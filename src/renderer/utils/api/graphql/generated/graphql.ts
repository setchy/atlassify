/* eslint-disable */
import { DocumentTypeDecoration } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** AppStoredEntityFieldValue */
  AppStoredCustomEntityFieldValue: { input: any; output: any; }
  /** AppStoredEntityFieldValue */
  AppStoredEntityFieldValue: { input: any; output: any; }
  /** A scalar that can represent arbitrary-precision signed decimal numbers based on the JVMs [BigDecimal](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html) */
  BigDecimal: { input: any; output: any; }
  /** Supported colors in the Palette */
  CardPaletteColor: { input: any; output: any; }
  /** CardTypeHierarchyLevelType */
  CardTypeHierarchyLevelType: { input: any; output: any; }
  /** A date scalar that accepts string values that are in yyyy-mm-dd format */
  Date: { input: any; output: any; }
  /** A scalar representing a specific point in time. */
  DateTime: { input: any; output: any; }
  /**
   * A scalar that enables us to spike [3D](https://relay.dev/docs/glossary/#3d) aka data-driven dependencies
   * This scalar is a requirement for using @match and @module directive supported by Relay GraphQL client
   * Please talk to #uip-app-framework before using this.
   * The definition of the scalar is yet to be decided based on spike insights.
   * To learn about current state see https://go.atlassian.com/JSDependency
   * DO NOT USE: Platform teams are iterating on the final shape of data returned
   */
  JSDependency: { input: any; output: any; }
  /**
   * The `JSON` scalar type represents JSON values as specified
   * by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
   *
   * Note to schema designers - use this scalar with caution as the resultant data becomes untyped
   * from a consumers point of view.  There are legitimate use cases for this scalar type
   * but it SHOULD not be a common scalar.
   */
  JSON: { input: any; output: any; }
  /** A scalar that is a 64-bit signed Java primitive data type. Its range is -2^63 to 2^63 â€“ 1 */
  Long: { input: any; output: any; }
  /** MercuryJSONString */
  MercuryJSONString: { input: any; output: any; }
  /** SoftwareBoardFeatureKey */
  SoftwareBoardFeatureKey: { input: any; output: any; }
  /** SoftwareBoardPermission */
  SoftwareBoardPermission: { input: any; output: any; }
  /** SprintScopeChangeEventType */
  SprintScopeChangeEventType: { input: any; output: any; }
  /**
   * A unique short string that can be used to fetch a board, card, etc. It's
   * usually used as a part of the entity URL. In some cases can be used as
   * as the ID.
   */
  TrelloShortLink: { input: any; output: any; }
  /** An URL scalar that accepts string values like [https://www.w3.org/Addressing/URL/url-spec.txt]( https://www.w3.org/Addressing/URL/url-spec.txt) */
  URL: { input: any; output: any; }
};

export enum AcceptableResponse {
  False = 'FALSE',
  NotApplicable = 'NOT_APPLICABLE',
  True = 'TRUE'
}

/**
 * "
 * The lifecycle status of the account
 */
export enum AccountStatus {
  /** The account is an active account */
  Active = 'active',
  /** The account has been closed */
  Closed = 'closed',
  /** The account is no longer an active account */
  Inactive = 'inactive'
}

export type ActionsActionableAppsFilter = {
  /** Types of actions to be returned. Any action that matches types in this list will be returned. */
  byActionType?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions for the given actionVerb will be returned. */
  byActionVerb?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions with the given capability will be returned. */
  byCapability?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions with the context entity will be returned. */
  byContextEntityType?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions acting on the entity property will be returned. */
  byEntityProperty?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions for the given entity types will be returned. */
  byEntityType?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions for the given forge environment ID will be returned. Actions without an extension ARI will not be returned */
  byEnvironmentId?: InputMaybe<Scalars['String']['input']>;
  /** Only actions for the given extensionAri will be returned. */
  byExtensionAri?: InputMaybe<Scalars['String']['input']>;
  /** Only actions for the specified integrations will be returned. */
  byIntegrationKey?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions for the given providers will be returned. */
  byProviderID?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum ActionsAuthType {
  /** actions that support THREE_LEGGED authentication can be executed with a user in context */
  ThreeLegged = 'THREE_LEGGED',
  /** actions that support TWO_LEGGED authentication can be executed without user in context */
  TwoLegged = 'TWO_LEGGED'
}

export type ActionsExecuteActionFilter = {
  /** Only execute action that matches the given ari */
  extensionAri?: InputMaybe<Scalars['String']['input']>;
  /** Only execute actions for the given first-party integration */
  integrationKey?: InputMaybe<Scalars['String']['input']>;
  /** Only execute actions for the given clients */
  oauthClientId?: InputMaybe<Scalars['String']['input']>;
  /** Only execute actions for the given providers */
  providerAri?: InputMaybe<Scalars['String']['input']>;
};

export type ActionsExecuteActionInput = {
  /** Cloud ID of the site to execute action on */
  cloudId?: InputMaybe<Scalars['String']['input']>;
  /** Inputs required to execute the action */
  inputs?: InputMaybe<Scalars['JSON']['input']>;
  /** Target inputs required to identify the resource */
  target?: InputMaybe<ActionsExecuteTargetInput>;
};

export type ActionsExecuteTargetInput = {
  ari?: InputMaybe<Scalars['String']['input']>;
  ids?: InputMaybe<Scalars['JSON']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type ActivitiesArguments = {
  /** set of Atlassian account IDs */
  accountIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** set of Cloud IDs */
  cloudIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** set of Container IDs */
  containerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The creation time of the earliest events to be included in the result */
  earliestStart?: InputMaybe<Scalars['DateTime']['input']>;
  /** set of Event Types */
  eventTypes?: InputMaybe<Array<ActivityEventType>>;
  /** The creation time of the latest events to be included in the result */
  latestStart?: InputMaybe<Scalars['DateTime']['input']>;
  /** set of Object Types */
  objectTypes?: InputMaybe<Array<ActivitiesObjectType>>;
  /** set of products */
  products?: InputMaybe<Array<ActivityProduct>>;
  /** arbitrary transition filters */
  transitions?: InputMaybe<Array<ActivityTransition>>;
};

export enum ActivitiesContainerType {
  Project = 'PROJECT',
  Site = 'SITE',
  Space = 'SPACE',
  Workspace = 'WORKSPACE'
}

export type ActivitiesFilter = {
  arguments?: InputMaybe<ActivitiesArguments>;
  /** Defines relationship in-between filter arguments (AND/OR) */
  type?: InputMaybe<ActivitiesFilterType>;
};

export enum ActivitiesFilterType {
  And = 'AND',
  Or = 'OR'
}

export enum ActivitiesObjectType {
  Blogpost = 'BLOGPOST',
  Database = 'DATABASE',
  Embed = 'EMBED',
  Goal = 'GOAL',
  Issue = 'ISSUE',
  Page = 'PAGE',
  /** Refers to a townsquare project (not to be confused with a jira project) */
  Project = 'PROJECT',
  Whiteboard = 'WHITEBOARD'
}

export enum ActivityEventType {
  Assigned = 'ASSIGNED',
  Commented = 'COMMENTED',
  Created = 'CREATED',
  Edited = 'EDITED',
  Liked = 'LIKED',
  Published = 'PUBLISHED',
  Transitioned = 'TRANSITIONED',
  Unassigned = 'UNASSIGNED',
  Updated = 'UPDATED',
  Viewed = 'VIEWED'
}

export type ActivityFilter = {
  /** Set of actor ARIs whose activity should be searched. A maximum of 5 values may be provided. (ex: AAIDs) */
  actors?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** These are always AND-ed with accountIds */
  arguments?: InputMaybe<ActivityFilterArgs>;
  /** set of top-level container ARIs (ex: Cloud ID, workspace ID) */
  rootContainerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Defines relationship between the filter arguments. Default: AND */
  type?: InputMaybe<ActivitiesFilterType>;
};

export type ActivityFilterArgs = {
  /** set of Container IDs (ex: Jira project ID, Space ID, etc) */
  containerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * set of Event Types ex:
   * assigned
   * unassigned
   * viewed
   * updated
   * created
   * liked
   * transitioned
   * published
   * edited
   */
  eventTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * set of Object Types (derived from the AVI) ex:
   * issue
   * page
   * blogpost
   * whiteboard
   * database
   * embed
   * project (townsquare)
   * goal
   */
  objectTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * set of products (derived from the AVI) ex:
   * jira
   * confluence
   * townsquare
   */
  products?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum ActivityObjectType {
  Blogpost = 'BLOGPOST',
  Comment = 'COMMENT',
  Database = 'DATABASE',
  Embed = 'EMBED',
  Goal = 'GOAL',
  Issue = 'ISSUE',
  Page = 'PAGE',
  Project = 'PROJECT',
  Site = 'SITE',
  Space = 'SPACE',
  Task = 'TASK',
  Whiteboard = 'WHITEBOARD'
}

export enum ActivityProduct {
  Confluence = 'CONFLUENCE',
  Jira = 'JIRA',
  JiraBusiness = 'JIRA_BUSINESS',
  JiraOps = 'JIRA_OPS',
  JiraServiceDesk = 'JIRA_SERVICE_DESK',
  JiraSoftware = 'JIRA_SOFTWARE',
  Townsquare = 'TOWNSQUARE'
}

/**
 *  Represents arbitrary transition,
 *  e.g. in case of TRANSITIONED event type it could be `from: "inprogress" to: "done"`.
 */
export type ActivityTransition = {
  from?: InputMaybe<Scalars['String']['input']>;
  to?: InputMaybe<Scalars['String']['input']>;
};

export type AddAppContributorInput = {
  appId: Scalars['ID']['input'];
  newContributorEmail: Scalars['String']['input'];
  role: AppContributorRole;
};

export type AddBetaUserAsSiteCreatorInput = {
  cloudID: Scalars['String']['input'];
};

/** Accepts input for adding labels to a component. */
export type AddCompassComponentLabelsInput = {
  /** The ID of the component to add the labels to. */
  componentId: Scalars['ID']['input'];
  /** The collection of labels to add to the component. */
  labelNames: Array<Scalars['String']['input']>;
};

export type AddMultipleAppContributorInput = {
  appId: Scalars['ID']['input'];
  newContributorEmails: Array<Scalars['String']['input']>;
  roles: Array<AppContributorRole>;
};

export type AddPolarisColumnInput = {
  /**
   * The column to insert this column before.  If not specified,
   * the new column is added to the right of all columns.
   */
  before?: InputMaybe<Scalars['ID']['input']>;
  /** The id of the field to add */
  field: Scalars['ID']['input'];
  /** The format to use for the rendering the field's data */
  format?: InputMaybe<Scalars['String']['input']>;
  /**
   * An override for the column heading; if not specified,
   * the field label should be used.
   */
  heading?: InputMaybe<Scalars['String']['input']>;
  /** The width to configure on the column */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * ###################################################################################################################
 *  COMPASS ALERT EVENT
 * ###################################################################################################################
 */
export enum AlertEventStatus {
  Acknowledged = 'ACKNOWLEDGED',
  Closed = 'CLOSED',
  Opened = 'OPENED',
  Snoozed = 'SNOOZED'
}

export enum AlertPriority {
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5'
}

/** Only used for inside the schema to mark the context for generic types */
export enum ApiContext {
  Devops = 'DEVOPS'
}

/**
 * This enum is the names of API groupings within the total Atlassian API.
 *
 * This is used by our documentation tooling to group together types and fields into logical groups
 */
export enum ApiGroup {
  Actions = 'ACTIONS',
  AppRecommendations = 'APP_RECOMMENDATIONS',
  Caas = 'CAAS',
  CloudAdmin = 'CLOUD_ADMIN',
  CollaborationGraph = 'COLLABORATION_GRAPH',
  CommerceCcp = 'COMMERCE_CCP',
  CommerceHams = 'COMMERCE_HAMS',
  CommerceSharedApi = 'COMMERCE_SHARED_API',
  Compass = 'COMPASS',
  Confluence = 'CONFLUENCE',
  ConfluenceAnalytics = 'CONFLUENCE_ANALYTICS',
  ConfluenceLegacy = 'CONFLUENCE_LEGACY',
  ConfluenceMutations = 'CONFLUENCE_MUTATIONS',
  ConfluencePages = 'CONFLUENCE_PAGES',
  ConfluencePageTree = 'CONFLUENCE_PAGE_TREE',
  ConfluenceSmarts = 'CONFLUENCE_SMARTS',
  ConfluenceTenant = 'CONFLUENCE_TENANT',
  ConfluenceUser = 'CONFLUENCE_USER',
  ConfluenceV2 = 'CONFLUENCE_V2',
  ContentPlatformApi = 'CONTENT_PLATFORM_API',
  CustomerService = 'CUSTOMER_SERVICE',
  DevopsAriGraph = 'DEVOPS_ARI_GRAPH',
  DevopsContainerRelationship = 'DEVOPS_CONTAINER_RELATIONSHIP',
  DevopsService = 'DEVOPS_SERVICE',
  DevopsThirdParty = 'DEVOPS_THIRD_PARTY',
  DevopsToolchain = 'DEVOPS_TOOLCHAIN',
  FeatureReleaseQuery = 'FEATURE_RELEASE_QUERY',
  Forge = 'FORGE',
  Help = 'HELP',
  Identity = 'IDENTITY',
  InsightsXperienceService = 'INSIGHTS_XPERIENCE_SERVICE',
  Jira = 'JIRA',
  Papi = 'PAPI',
  Polaris = 'POLARIS',
  SurfacePlatform = 'SURFACE_PLATFORM',
  Teams = 'TEAMS',
  VirtualAgent = 'VIRTUAL_AGENT',
  WebTriggers = 'WEB_TRIGGERS',
  XenInvocationService = 'XEN_INVOCATION_SERVICE',
  XenLogsApi = 'XEN_LOGS_API'
}

export enum AppContributorRole {
  Admin = 'ADMIN',
  Deployer = 'DEPLOYER',
  Developer = 'DEVELOPER',
  Viewer = 'VIEWER',
  ViewerAdvanced = 'VIEWER_ADVANCED'
}

export enum AppDeploymentEventLogLevel {
  Error = 'ERROR',
  Info = 'INFO',
  Warning = 'WARNING'
}

export enum AppDeploymentStatus {
  Done = 'DONE',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS'
}

export enum AppDeploymentStepStatus {
  Done = 'DONE',
  Failed = 'FAILED',
  Started = 'STARTED'
}

/** Used to uniquely identify an environment, when being used as an input. */
export type AppEnvironmentInput = {
  appId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
};

export enum AppEnvironmentType {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING'
}

/** The input needed to create or update an environment variable. */
export type AppEnvironmentVariableInput = {
  /** Whether or not to encrypt (default=false) */
  encrypt?: InputMaybe<Scalars['Boolean']['input']>;
  /** The key of the environment variable */
  key: Scalars['String']['input'];
  /** The value of the environment variable */
  value: Scalars['String']['input'];
};

/** Input payload for the app environment install mutation */
export type AppInstallationInput = {
  /** A unique Id representing the app */
  appId: Scalars['ID']['input'];
  /** Whether the installation will be done asynchronously */
  async?: InputMaybe<Scalars['Boolean']['input']>;
  /** The key of the app's environment to be used for installation */
  environmentKey: Scalars['String']['input'];
  /** A unique Id representing the context into which the app is being installed */
  installationContext: Scalars['ID']['input'];
  /** Bypass licensing flow if licenseOverride is set */
  licenseOverride?: InputMaybe<LicenseOverrideState>;
  /** An ID for checking whether an app license has been activated via POA, providing this will bypass the COFS activation flow */
  provisionRequestId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique Id representing a specific version of an app */
  versionId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input payload for the app environment upgrade mutation */
export type AppInstallationUpgradeInput = {
  /** A unique Id representing the app */
  appId: Scalars['ID']['input'];
  /** Whether the installation upgrade will be done asynchronously */
  async?: InputMaybe<Scalars['Boolean']['input']>;
  /** The key of the app's environment to be used for installation upgrade */
  environmentKey: Scalars['String']['input'];
  /** A unique Id representing the context into which the app is being upgraded */
  installationContext: Scalars['ID']['input'];
  /**
   * Determines whether the original billing type is HAMS or CCP. Will be treated as HAMS if not provided.
   * Providing CCP will skip deactivation via COFS
   */
  sourceBillingType?: InputMaybe<SourceBillingType>;
  /** A unique Id representing a specific major version of the app */
  versionId?: InputMaybe<Scalars['ID']['input']>;
};

export type AppInstallationsByAppFilter = {
  appEnvironments?: InputMaybe<InstallationsListFilterByAppEnvironments>;
  appInstallations?: InputMaybe<InstallationsListFilterByAppInstallations>;
  apps: InstallationsListFilterByApps;
  includeSystemApps?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AppInstallationsByContextFilter = {
  appInstallations: InstallationsListFilterByAppInstallationsWithCompulsoryContexts;
  apps?: InputMaybe<InstallationsListFilterByApps>;
};

export type AppInstallationsFilter = {
  appId: Scalars['ID']['input'];
  environmentType?: InputMaybe<AppEnvironmentType>;
};

export enum AppNetworkPermissionType {
  FetchBackendSide = 'FETCH_BACKEND_SIDE',
  FetchClientSide = 'FETCH_CLIENT_SIDE',
  Fonts = 'FONTS',
  Frames = 'FRAMES',
  Images = 'IMAGES',
  Media = 'MEDIA',
  Navigation = 'NAVIGATION',
  Scripts = 'SCRIPTS',
  Styles = 'STYLES'
}

export enum AppNetworkPermissionTypeExtension {
  FetchBackendSide = 'FETCH_BACKEND_SIDE',
  FetchClientSide = 'FETCH_CLIENT_SIDE',
  Fonts = 'FONTS',
  Frames = 'FRAMES',
  Images = 'IMAGES',
  Media = 'MEDIA',
  Navigation = 'NAVIGATION',
  Scripts = 'SCRIPTS',
  Styles = 'STYLES'
}

/**
 * The context object provides essential insights into the users' current experience and operations.
 *
 * The supported product and subproduct keys can be found at https://hello.atlassian.net/wiki/spaces/ECON/pages/2339030895/App+Identifiers
 */
export type AppRecContext = {
  anonymousId?: InputMaybe<Scalars['ID']['input']>;
  containers?: InputMaybe<Scalars['JSON']['input']>;
  /** Language-Sub language identifier format (ISO 639-1 and ISO 639-2) */
  locale?: InputMaybe<Scalars['String']['input']>;
  orgId?: InputMaybe<Scalars['ID']['input']>;
  product?: InputMaybe<Scalars['String']['input']>;
  /** This is an identifier for tagging analytics events, useful for correlating across frontend and backend */
  sessionId?: InputMaybe<Scalars['ID']['input']>;
  subproduct?: InputMaybe<Scalars['String']['input']>;
  /** The tenant id is also well known as the cloud id */
  tenantId?: InputMaybe<Scalars['ID']['input']>;
  useCase?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
  workspaceId?: InputMaybe<Scalars['ID']['input']>;
};

export type AppRecDismissRecommendationInput = {
  /** The context is temporarily optional. It will be enforced to be mandatory once consumers complete the migration. */
  context?: InputMaybe<AppRecContext>;
  /** A CCP identifier */
  productId: Scalars['ID']['input'];
};

export type AppRecUndoDismissalInput = {
  context: AppRecContext;
  /** A CCP identifier */
  productId: Scalars['ID']['input'];
};

export enum AppSecurityPoliciesPermissionType {
  Scripts = 'SCRIPTS',
  Styles = 'STYLES'
}

export enum AppSecurityPoliciesPermissionTypeExtension {
  Scripts = 'SCRIPTS',
  Styles = 'STYLES'
}

export type AppServicesFilter = {
  name: Scalars['String']['input'];
};

export type AppStoredCustomEntityFilter = {
  condition: AppStoredCustomEntityFilterCondition;
  property: Scalars['String']['input'];
  values: Array<Scalars['AppStoredCustomEntityFieldValue']['input']>;
};

export enum AppStoredCustomEntityFilterCondition {
  BeginsWith = 'BEGINS_WITH',
  Between = 'BETWEEN',
  Contains = 'CONTAINS',
  EqualTo = 'EQUAL_TO',
  Exists = 'EXISTS',
  GreaterThan = 'GREATER_THAN',
  GreaterThanEqualTo = 'GREATER_THAN_EQUAL_TO',
  LessThan = 'LESS_THAN',
  LessThanEqualTo = 'LESS_THAN_EQUAL_TO',
  NotContains = 'NOT_CONTAINS',
  NotEqualTo = 'NOT_EQUAL_TO',
  NotExists = 'NOT_EXISTS'
}

export type AppStoredCustomEntityFilters = {
  and?: InputMaybe<Array<AppStoredCustomEntityFilter>>;
  or?: InputMaybe<Array<AppStoredCustomEntityFilter>>;
};

export type AppStoredCustomEntityRange = {
  condition: AppStoredCustomEntityRangeCondition;
  values: Array<Scalars['AppStoredCustomEntityFieldValue']['input']>;
};

export enum AppStoredCustomEntityRangeCondition {
  BeginsWith = 'BEGINS_WITH',
  Between = 'BETWEEN',
  EqualTo = 'EQUAL_TO',
  GreaterThan = 'GREATER_THAN',
  GreaterThanEqualTo = 'GREATER_THAN_EQUAL_TO',
  LessThan = 'LESS_THAN',
  LessThanEqualTo = 'LESS_THAN_EQUAL_TO'
}

export enum AppStoredEntityCondition {
  In = 'IN',
  NotEqualTo = 'NOT_EQUAL_TO',
  StartsWith = 'STARTS_WITH'
}

/**
 * The identifier for this entity
 *
 * where condition to filter
 */
export type AppStoredEntityFilter = {
  condition: AppStoredEntityCondition;
  /** Condition filter to be provided when querying for Entities. */
  field: Scalars['String']['input'];
  value: Scalars['AppStoredEntityFieldValue']['input'];
};

export type AppSubscribeInput = {
  appId: Scalars['ID']['input'];
  envKey: Scalars['String']['input'];
  installationContext: Scalars['ID']['input'];
};

export enum AppTaskState {
  Complete = 'COMPLETE',
  Failed = 'FAILED',
  Pending = 'PENDING',
  Running = 'RUNNING'
}

/** App trust information state */
export enum AppTrustInformationState {
  Draft = 'DRAFT',
  Live = 'LIVE'
}

/** Input payload for the app environment uninstall mutation */
export type AppUninstallationInput = {
  /** A unique Id representing the app */
  appId: Scalars['ID']['input'];
  /** Whether the installation will be done asynchronously */
  async?: InputMaybe<Scalars['Boolean']['input']>;
  /** The key of the app's environment to be used for uninstallation */
  environmentKey: Scalars['String']['input'];
  /** A unique Id representing the context into which the app is being uninstalled */
  installationContext?: InputMaybe<Scalars['ID']['input']>;
  /** A unique Id representing the installationId */
  installationId?: InputMaybe<Scalars['ID']['input']>;
  /** Bypass licensing flow if licenseOverride is set */
  licenseOverride?: InputMaybe<LicenseOverrideState>;
  /**
   * Determines whether the original billing type is HAMS or CCP. Will be treated as HAMS if not provided.
   * Providing CCP will skip deactivation via COFS
   */
  sourceBillingType?: InputMaybe<SourceBillingType>;
};

export type AppUnsubscribeInput = {
  appId: Scalars['ID']['input'];
  envKey: Scalars['String']['input'];
  installationContext: Scalars['ID']['input'];
};

export type ApplyPolarisProjectTemplateInput = {
  ideaType: Scalars['ID']['input'];
  project: Scalars['ID']['input'];
  template: Scalars['ID']['input'];
};

export type AppsFilter = {
  isPublishable?: InputMaybe<Scalars['Boolean']['input']>;
  migrationKey?: InputMaybe<Scalars['String']['input']>;
};

export type AquaNotificationLogsFilter = {
  filterActionable?: InputMaybe<Scalars['Boolean']['input']>;
  selectedFilters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export enum ArchivedMode {
  ActiveOnly = 'ACTIVE_ONLY',
  All = 'ALL',
  ArchivedOnly = 'ARCHIVED_ONLY'
}

export type AriGraphCreateRelationshipsInput = {
  relationships: Array<AriGraphCreateRelationshipsInputRelationship>;
};

export type AriGraphCreateRelationshipsInputRelationship = {
  /** ARI of the subject */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. `updateTime` as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** ARI of the object */
  to: Scalars['ID']['input'];
  /** Type of the relationship */
  type: Scalars['ID']['input'];
  /** Time at which this relationship was last observed. `updateTime` at the request level will be used if this is omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

/**
 * At least 'from' or 'to' must be specified. If both are specified, then 'type' is required.
 *
 * If only one side of the relationship is provided, and no type is provided,
 * then every relationship (where that side of the relationship equals the provided ARI)
 * for every applicable relationship type will be deleted.
 */
export type AriGraphDeleteRelationshipsInput = {
  /** ARI of the subject */
  from?: InputMaybe<Scalars['ID']['input']>;
  /** ARI of the object */
  to?: InputMaybe<Scalars['ID']['input']>;
  /** Type of the relationship */
  type?: InputMaybe<Scalars['ID']['input']>;
};

/** At least one of `from` or `to` must be specified */
export type AriGraphRelationshipsFilter = {
  /**
   * @deprecated(reason: "Use variable [from] at the root of the query instead")
   * Kept for backwards compatibility only.
   */
  from?: InputMaybe<Scalars['ID']['input']>;
  /**
   * @deprecated(reason: "Use variable [to] at the root of the query instead")
   * Kept for backwards compatibility only.
   */
  to?: InputMaybe<Scalars['ID']['input']>;
  /**
   * @deprecated(reason: "Use variable [type] at the root of the query instead")
   * Kept for backwards compatibility only.
   */
  type?: InputMaybe<Scalars['ID']['input']>;
  /** Only include relationships updated after the given DateTime */
  updatedFrom?: InputMaybe<Scalars['DateTime']['input']>;
  /** Only include relationships updated before the given DateTime */
  updatedTo?: InputMaybe<Scalars['DateTime']['input']>;
};

export type AriGraphRelationshipsSort = {
  /** The direction of results based on the lastUpdated time of the relationships. Default is ascending (ASC). */
  lastUpdatedSortDirection?: InputMaybe<AriGraphRelationshipsSortDirection>;
};

export enum AriGraphRelationshipsSortDirection {
  /** Sort in ascending order */
  Asc = 'ASC',
  /** Sort in descending order */
  Desc = 'DESC'
}

export type AriGraphReplaceRelationshipsInput = {
  /** Relationships that replace any existing for the given type and from/to depending on cardinality. */
  relationships: Array<AriGraphReplaceRelationshipsInputRelationship>;
  /** Sequence number of this relationship, used for versioning. `updateTime` as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** Type of the relationship */
  type: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type AriGraphReplaceRelationshipsInputRelationship = {
  /** ARI of the subject */
  from: Scalars['ID']['input'];
  /** ARI of the object */
  to: Scalars['ID']['input'];
};

export type AssignIssueParentInput = {
  boardId: Scalars['ID']['input'];
  issueIds: Array<Scalars['ID']['input']>;
  issueParentId: Scalars['ID']['input'];
};

/** Hosting type where Atlassian product instance is installed. */
export enum AtlassianProductHostingType {
  Cloud = 'CLOUD',
  DataCenter = 'DATA_CENTER',
  Server = 'SERVER'
}

/** Accepts input to attach a data manager to a component. */
export type AttachCompassComponentDataManagerInput = {
  /** The ID of the component to attach a data manager to. */
  componentId: Scalars['ID']['input'];
  /** An URL of the external source of the component's data. */
  externalSourceURL?: InputMaybe<Scalars['URL']['input']>;
};

export type AttachEventSourceInput = {
  /** The ID of the component to attach the event source to. */
  componentId: Scalars['ID']['input'];
  /** The ID of the event source. */
  eventSourceId: Scalars['ID']['input'];
};

export type AutoSuggestionFilters = {
  contextType: Scalars['String']['input'];
  organizationId: Scalars['String']['input'];
  principalId: Scalars['String']['input'];
  productKey: Scalars['String']['input'];
  siteId: Scalars['String']['input'];
};

/** Payload to invoke an AUX Effect */
export type AuxEffectsInvocationPayload = {
  /** Configuration arguments for the instance of the AUX extension */
  config?: InputMaybe<Scalars['JSON']['input']>;
  /** Environment information about where the effects are dispatched from */
  context: Scalars['JSON']['input'];
  /** A signed token representing the context information of the extension */
  contextToken?: InputMaybe<Scalars['String']['input']>;
  /** The effects to action inside the function */
  effects: Array<Scalars['JSON']['input']>;
  /** Dynamic data from the extension point */
  extensionPayload?: InputMaybe<Scalars['JSON']['input']>;
  /** The current state of the AUX extension */
  state: Scalars['JSON']['input'];
};

/** The input for a Avatar for a Third Party Repository */
export type AvatarInput = {
  /** The description of the avatar. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the avatar. */
  webUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Bitbucket Permission Enum */
export enum BitbucketPermission {
  /** Bitbucket admin permission */
  Admin = 'ADMIN'
}

export type BoardCardMoveInput = {
  /** the ID of a board */
  boardId?: InputMaybe<Scalars['ID']['input']>;
  /** The IDs of cards to move */
  cardIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Card information on where card should be positioned */
  rank?: InputMaybe<CardRank>;
  /** The swimlane position, which might set additional fields */
  swimlaneId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the transition */
  transition?: InputMaybe<Scalars['ID']['input']>;
};

export enum BoardFeatureStatus {
  ComingSoon = 'COMING_SOON',
  Disabled = 'DISABLED',
  Enabled = 'ENABLED'
}

export enum BoardFeatureToggleStatus {
  Disabled = 'DISABLED',
  Enabled = 'ENABLED'
}

/** Available strategies for grouping issues into swimlanes for a classic board */
export enum BoardSwimlaneStrategy {
  AssigneeUnassignedFirst = 'ASSIGNEE_UNASSIGNED_FIRST',
  AssigneeUnassignedLast = 'ASSIGNEE_UNASSIGNED_LAST',
  Custom = 'CUSTOM',
  Epic = 'EPIC',
  IssueChildren = 'ISSUE_CHILDREN',
  IssueParent = 'ISSUE_PARENT',
  None = 'NONE',
  ParentChild = 'PARENT_CHILD',
  Project = 'PROJECT',
  RequestType = 'REQUEST_TYPE'
}

export enum BuiltinPolarisIdeaField {
  /**  Jira Product Discovery fields */
  Archived = 'ARCHIVED',
  ArchivedBy = 'ARCHIVED_BY',
  ArchivedOn = 'ARCHIVED_ON',
  /**  Jira fields */
  Assignee = 'ASSIGNEE',
  AtlasGoal = 'ATLAS_GOAL',
  AtlasProject = 'ATLAS_PROJECT',
  AtlasProjectStatus = 'ATLAS_PROJECT_STATUS',
  AtlasProjectTarget = 'ATLAS_PROJECT_TARGET',
  Created = 'CREATED',
  Creator = 'CREATOR',
  DeliveryProgress = 'DELIVERY_PROGRESS',
  DeliveryStatus = 'DELIVERY_STATUS',
  Description = 'DESCRIPTION',
  IssueComments = 'ISSUE_COMMENTS',
  IssueId = 'ISSUE_ID',
  IssueType = 'ISSUE_TYPE',
  Key = 'KEY',
  Labels = 'LABELS',
  LinkedIssues = 'LINKED_ISSUES',
  NumDataPoints = 'NUM_DATA_POINTS',
  Reporter = 'REPORTER',
  Status = 'STATUS',
  Summary = 'SUMMARY',
  Updated = 'UPDATED',
  Votes = 'VOTES'
}

/** Accepts input for deleting multiple existing components. */
export type BulkDeleteCompassComponentsInput = {
  /** A list of IDs of components being deleted. All IDs must belong in the same workspace. */
  ids: Array<Scalars['ID']['input']>;
};

/** Accepts input for updating multiple existing components. */
export type BulkUpdateCompassComponentsInput = {
  /** A list of IDs of components being updated. All IDs must belong in the same workspace. */
  ids: Array<Scalars['ID']['input']>;
  /** The updated state of the components. */
  state?: InputMaybe<Scalars['String']['input']>;
};

export enum CapabilitySet {
  CapabilityAdvanced = 'capabilityAdvanced',
  CapabilityStandard = 'capabilityStandard'
}

export enum CardHierarchyLevelEnumType {
  Base = 'BASE',
  Child = 'CHILD',
  Parent = 'PARENT'
}

export type CardParentCreateInput = {
  boardId: Scalars['ID']['input'];
  newIssueParents: Array<NewCardParent>;
};

export type CardParentRankInput = {
  boardId: Scalars['ID']['input'];
  issueParentIds: Array<Scalars['ID']['input']>;
  rankAfterIssueParentId?: InputMaybe<Scalars['Long']['input']>;
  rankBeforeIssueParentId?: InputMaybe<Scalars['Long']['input']>;
};

export type CardRank = {
  /** The card that is after this card */
  afterCardId?: InputMaybe<Scalars['ID']['input']>;
  /** The card that is before this card */
  beforeCardId?: InputMaybe<Scalars['ID']['input']>;
};

export enum CcpActivationReason {
  AdvantagePricing = 'ADVANTAGE_PRICING',
  DefaultPricing = 'DEFAULT_PRICING',
  ExperimentalPricing = 'EXPERIMENTAL_PRICING'
}

export enum CcpBillingInterval {
  Day = 'DAY',
  Month = 'MONTH',
  Week = 'WEEK',
  Year = 'YEAR'
}

export enum CcpChargeType {
  AutoScaling = 'AUTO_SCALING',
  Licensed = 'LICENSED',
  Metered = 'METERED'
}

export enum CcpCurrency {
  Jpy = 'JPY',
  Usd = 'USD'
}

export enum CcpDuration {
  Forever = 'FOREVER',
  Once = 'ONCE',
  Repeating = 'REPEATING'
}

export enum CcpEntitlementPreDunningStatus {
  InPreDunning = 'IN_PRE_DUNNING',
  NotInPreDunning = 'NOT_IN_PRE_DUNNING'
}

export enum CcpEntitlementStatus {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

export enum CcpOfferingHostingType {
  Cloud = 'CLOUD'
}

export enum CcpOfferingStatus {
  Active = 'ACTIVE',
  AtNotice = 'AT_NOTICE',
  Draft = 'DRAFT',
  Expired = 'EXPIRED'
}

export enum CcpOfferingType {
  Child = 'CHILD',
  Parent = 'PARENT'
}

export enum CcpOfferingUncollectibleActionType {
  Cancel = 'CANCEL',
  Downgrade = 'DOWNGRADE',
  NoAction = 'NO_ACTION'
}

/** Arguments for order-defaults */
export type CcpOrderDefaultsInput = {
  country?: InputMaybe<Scalars['String']['input']>;
  currentEntitlementId?: InputMaybe<Scalars['String']['input']>;
  offeringId?: InputMaybe<Scalars['String']['input']>;
};

export enum CcpPricingPlanStatus {
  Active = 'ACTIVE',
  AtNotice = 'AT_NOTICE',
  Draft = 'DRAFT',
  Expired = 'EXPIRED'
}

export enum CcpPricingType {
  External = 'EXTERNAL',
  Free = 'FREE',
  LimitedFree = 'LIMITED_FREE',
  Paid = 'PAID'
}

export enum CcpProrateOnUsageChange {
  AlwaysInvoice = 'ALWAYS_INVOICE',
  CreateProrations = 'CREATE_PRORATIONS',
  None = 'NONE'
}

export enum CcpRelationshipPricingType {
  AdvantagePricing = 'ADVANTAGE_PRICING',
  CurrencyGenerated = 'CURRENCY_GENERATED',
  NextPricing = 'NEXT_PRICING',
  SyntheticGenerated = 'SYNTHETIC_GENERATED'
}

export enum CcpSubscriptionScheduleAction {
  Cancel = 'CANCEL',
  Update = 'UPDATE'
}

export enum CcpSubscriptionStatus {
  Active = 'ACTIVE',
  Cancelled = 'CANCELLED',
  Processing = 'PROCESSING'
}

export enum CcpSupportedBillingSystems {
  Ccp = 'CCP',
  Hams = 'HAMS',
  Opsgenie = 'OPSGENIE'
}

export enum CcpTiersMode {
  Graduated = 'GRADUATED',
  Volume = 'VOLUME'
}

/** The input arguments for checking if a user can authorise an app by OauthID */
export type CheckConsentPermissionByOAuthClientIdInput = {
  /** Cloud id where app is trying to be installed */
  cloudId: Scalars['ID']['input'];
  /** App's oauthClientId which will be checked against the DB if it's valid */
  oauthClientId: Scalars['ID']['input'];
  /** The requested scopes of the app connection. */
  scopes: Array<Scalars['String']['input']>;
  /** The User's Atlassian account ID to verify their permissions on the target site */
  userId: Scalars['ID']['input'];
};

export enum Classification {
  Other = 'other',
  Pii = 'pii',
  Ugc = 'ugc'
}

/**
 * Entitlement filter returns entitlement only if filter conditions have been met
 *
 * There can be only one condition or operand present at the time (similar to @oneOf directive)
 */
export type CommerceEntitlementFilter = {
  AND?: InputMaybe<Array<InputMaybe<CommerceEntitlementFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<CommerceEntitlementFilter>>>;
  inPreDunning?: InputMaybe<Scalars['Boolean']['input']>;
  inTrialOrPreDunning?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Accepts input for acknowledging an announcement. */
export type CompassAcknowledgeAnnouncementInput = {
  /** The ID of the announcement being acknowledged. */
  announcementId: Scalars['ID']['input'];
  /** The ID of the component that is acknowledging the announcement. */
  componentId: Scalars['ID']['input'];
};

/** The user-provided input to add a new document */
export type CompassAddDocumentInput = {
  /** The ID of the component to add the document to. */
  componentId: Scalars['ID']['input'];
  /** The ID of the documentation category to add the document to. */
  documentationCategoryId: Scalars['ID']['input'];
  /** The (optional) display title of the document. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the document */
  url: Scalars['URL']['input'];
};

/** Accepts input for adding labels to a team. */
export type CompassAddTeamLabelsInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
  /** A list of labels that should be added to the team. */
  labels: Array<Scalars['String']['input']>;
  /** The unique identifier (ID) of the target team. */
  teamId: Scalars['ID']['input'];
};

/** The list of properties of the alert event. */
export type CompassAlertEventPropertiesInput = {
  /** The last time the alert status changed to ACKNOWLEDGED. */
  acknowledgedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The last time the alert status changed to CLOSED. */
  closedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Timestamp for when the alert was created, when status is set to OPENED. */
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The ID of the alert. */
  id: Scalars['ID']['input'];
  /** Priority of the alert. */
  priority?: InputMaybe<AlertPriority>;
  /** The last time the alert status changed to SNOOZED. */
  snoozedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Status of the alert. */
  status?: InputMaybe<AlertEventStatus>;
};

/** The query to get all managed components on a Compass site. */
export type CompassApplicationManagedComponentsQuery = {
  /** Returns results after the specified cursor. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The cloud ID of the site to query for managed components. */
  cloudId: Scalars['ID']['input'];
  /** The number of results to return in the query. The default is 10. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassAttentionItemQuery = {
  after?: InputMaybe<Scalars['String']['input']>;
  cloudId: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassBooleanFieldValueInput = {
  booleanValue: Scalars['Boolean']['input'];
};

/** The build event pipeline. */
export type CompassBuildEventPipelineInput = {
  /** The name of the build event pipeline. */
  displayName?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the build event pipeline. */
  pipelineId: Scalars['String']['input'];
  /** The URL to the build event pipeline. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The list of properties of the build event. */
export type CompassBuildEventPropertiesInput = {
  /** Time the build completed. */
  completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The build event pipeline. */
  pipeline: CompassBuildEventPipelineInput;
  /** Time the build started. */
  startedAt: Scalars['DateTime']['input'];
  /** The state of the build. */
  state: CompassBuildEventState;
};

/** Potential states for Build events */
export enum CompassBuildEventState {
  Cancelled = 'CANCELLED',
  Error = 'ERROR',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Successful = 'SUCCESSFUL',
  TimedOut = 'TIMED_OUT',
  Unknown = 'UNKNOWN'
}

export type CompassCampaignQuery = {
  /** Returns only campaigns whose attributes match those in the filters specified. */
  filter?: InputMaybe<CompassCampaignQueryFilter>;
  /** Returns campaigns according to the sorting scheme specified. */
  sort?: InputMaybe<CompassCampaignQuerySort>;
};

export type CompassCampaignQueryFilter = {
  /** Filter campaigns only by status */
  status?: InputMaybe<Scalars['String']['input']>;
};

export type CompassCampaignQuerySort = {
  /** The name of the field to sort by: due_date */
  name: Scalars['String']['input'];
  /** The order of the field to sort */
  order?: InputMaybe<CompassCampaignQuerySortOrder>;
};

export enum CompassCampaignQuerySortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type CompassComponentApiHistoricSpecTagsQuery = {
  tagName: Scalars['String']['input'];
};

export type CompassComponentApiRepoUpdate = {
  provider: Scalars['String']['input'];
  repoUrl: Scalars['String']['input'];
};

export type CompassComponentCreationTimeFilterInput = {
  /** The filter date of component creation. */
  createdAt: Scalars['DateTime']['input'];
  /** Filter before or after the time. */
  filter: CompassComponentCreationTimeFilterType;
};

export enum CompassComponentCreationTimeFilterType {
  After = 'AFTER',
  Before = 'BEFORE'
}

export type CompassComponentDescriptionDetailsInput = {
  /** The extended description details text body associated with a component. */
  content: Scalars['String']['input'];
};

/** The query to get the metric sources of a component. */
export type CompassComponentMetricSourcesQuery = {
  /** Returns results after the specified cursor. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The number of results to return in the query. The default is 10. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassComponentScorecardJiraIssuesQuery = {
  /** Returns the issues after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The first N number of issues to return in the query. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Scorecard score on a component for a scorecard. */
export type CompassComponentScorecardScoreQuery = {
  /** The unique identifier (ID) of the scorecard. */
  scorecardId: Scalars['ID']['input'];
};

/** Identifies the type of component. */
export enum CompassComponentType {
  /** A standalone software artifact that is directly consumable by an end-user. */
  Application = 'APPLICATION',
  /** A standalone software artifact that provides some functionality for other software via embedding. */
  Library = 'LIBRARY',
  /** A software artifact that does not fit into the pre-defined categories. */
  Other = 'OTHER',
  /** A software artifact that provides some functionality for other software over the network. */
  Service = 'SERVICE'
}

/** Input for querying Compass component types */
export type CompassComponentTypeQueryInput = {
  /** Returns results after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The number of results to return in the query.  The default number is 25. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** An alert event. */
export type CompassCreateAlertEventInput = {
  /** Alert Properties */
  alertProperties: CompassAlertEventPropertiesInput;
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

/** Accepts input for creating a component announcement. */
export type CompassCreateAnnouncementInput = {
  /** The ID of the component to create an announcement for. */
  componentId: Scalars['ID']['input'];
  /** The description of the announcement. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The date on which the changes in the announcement will take effect. */
  targetDate: Scalars['DateTime']['input'];
  /** The title of the announcement. */
  title: Scalars['String']['input'];
};

/** A build event. */
export type CompassCreateBuildEventInput = {
  /** Build Properties */
  buildProperties: CompassBuildEventPropertiesInput;
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

export type CompassCreateCampaignInput = {
  description: Scalars['String']['input'];
  dueDate: Scalars['DateTime']['input'];
  name: Scalars['String']['input'];
  scorecardId: Scalars['ID']['input'];
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Accepts input for creating a component scorecard Jira issue. */
export type CompassCreateComponentScorecardJiraIssueInput = {
  /** The ID of the component associated with the Jira issue. */
  componentId: Scalars['ID']['input'];
  /** The ID of the Jira issue. */
  issueId: Scalars['ID']['input'];
  /** The ID of the scorecard associated with the Jira issue. */
  scorecardId: Scalars['ID']['input'];
  /** The URL of the Jira issue. */
  url: Scalars['URL']['input'];
};

/** Input for creating a component subscription. */
export type CompassCreateComponentSubscriptionInput = {
  /** The ID of the component being subscribed. */
  componentId: Scalars['ID']['input'];
};

/** Accepts input for creating a custom boolean field definition. */
export type CompassCreateCustomBooleanFieldDefinitionInput = {
  /** The cloud ID of the site to create a custom boolean field definition for. */
  cloudId: Scalars['ID']['input'];
  /** The component types the custom boolean field appleis to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom boolean field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom boolean field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the custom boolean field. */
  name: Scalars['String']['input'];
};

/** A custom event. */
export type CompassCreateCustomEventInput = {
  /** Custom Event Properties */
  customEventProperties: CompassCustomEventPropertiesInput;
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

/** Accepts input for creating a custom field definition. You must provide exactly one of the fields in this input type. */
export type CompassCreateCustomFieldDefinitionInput = {
  /** Input for creating a custom boolean field definition. */
  booleanFieldDefinition?: InputMaybe<CompassCreateCustomBooleanFieldDefinitionInput>;
  /** Input for creating a custom multi-select field definition. */
  multiSelectFieldDefinition?: InputMaybe<CompassCreateCustomMultiSelectFieldDefinitionInput>;
  /** Input for creating a custom number field definition. */
  numberFieldDefinition?: InputMaybe<CompassCreateCustomNumberFieldDefinitionInput>;
  /** Input for creating a custom single-select field definition. */
  singleSelectFieldDefinition?: InputMaybe<CompassCreateCustomSingleSelectFieldDefinitionInput>;
  /** Input for creating a custom text field definition. */
  textFieldDefinition?: InputMaybe<CompassCreateCustomTextFieldDefinitionInput>;
  /** Input for creating a custom user field definition. */
  userFieldDefinition?: InputMaybe<CompassCreateCustomUserFieldDefinitionInput>;
};

/** Accepts input for creating a custom multi select field definition. */
export type CompassCreateCustomMultiSelectFieldDefinitionInput = {
  /** The cloud ID of the site to create a custom multi-select field definition for. */
  cloudId: Scalars['ID']['input'];
  /** The component types the custom multi-select field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The description of the custom multi-select field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the custom multi-select field. */
  name: Scalars['String']['input'];
  /** A list of options. */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Accepts input for creating a custom number field definition. */
export type CompassCreateCustomNumberFieldDefinitionInput = {
  /** The cloud ID of the site to create a custom number field definition for. */
  cloudId: Scalars['ID']['input'];
  /** The component types the custom number field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom number field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom number field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the custom number field. */
  name: Scalars['String']['input'];
};

/** Accepts input for creating a custom single select field definition. */
export type CompassCreateCustomSingleSelectFieldDefinitionInput = {
  /** The cloud ID of the site to create a custom single-select field definition for. */
  cloudId: Scalars['ID']['input'];
  /** The component types the custom single-select field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The description of the custom single-select field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the custom single-select field. */
  name: Scalars['String']['input'];
  /** A list of options. */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Accepts input for creating a custom text field definition. */
export type CompassCreateCustomTextFieldDefinitionInput = {
  /** The cloud ID of the site to create a custom text field definition for. */
  cloudId: Scalars['ID']['input'];
  /** The component types the custom text field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom text field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom text field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the custom text field. */
  name: Scalars['String']['input'];
};

/** Accepts input for creating a custom user field definition. */
export type CompassCreateCustomUserFieldDefinitionInput = {
  /** The cloud ID of the site to create a custom user field definition for. */
  cloudId: Scalars['ID']['input'];
  /** The component types the custom user field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom user field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom user field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the custom user field. */
  name: Scalars['String']['input'];
};

/** A deployment event. */
export type CompassCreateDeploymentEventInput = {
  /** Deployment Properties */
  deploymentProperties: CompassCreateDeploymentEventPropertiesInput;
  /** The description of the deployment event. */
  description: Scalars['String']['input'];
  /** The name of the deployment event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the deployment event. */
  url: Scalars['URL']['input'];
};

/** The list of properties of the deployment event. */
export type CompassCreateDeploymentEventPropertiesInput = {
  /** The time this deployment was completed at. */
  completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The environment where the deployment event has occurred. */
  environment: CompassDeploymentEventEnvironmentInput;
  /** The deployment event pipeline. */
  pipeline: CompassDeploymentEventPipelineInput;
  /** The sequence number for the deployment. */
  sequenceNumber: Scalars['Long']['input'];
  /** The time this deployment was started at. */
  startedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The state of the deployment. */
  state: CompassDeploymentEventState;
};

export type CompassCreateEventInput = {
  /** The cloud ID of the site to create the event for. */
  cloudId: Scalars['ID']['input'];
  event: CompassEventInput;
};

/** A flag event. */
export type CompassCreateFlagEventInput = {
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** Flag Properties */
  flagProperties: CompassCreateFlagEventPropertiesInput;
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

/** The list of properties of the flag event. */
export type CompassCreateFlagEventPropertiesInput = {
  /** The ID of the flag. */
  id: Scalars['ID']['input'];
  /** The flag's status. The recognized values (case-insensitive) are on, off, created, archived, deleted, and targeting_updated. Any other value, although acceptable, will be displayed as unknown on the activity feed. */
  status?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input to create a scorecard criterion checking the value of a specified custom boolean field. */
export type CompassCreateHasCustomBooleanFieldScorecardCriteriaInput = {
  /** The comparison operation to be performed. */
  booleanComparator: CompassCriteriaBooleanComparatorOptions;
  /** The value that the field is compared to. */
  booleanComparatorValue: Scalars['Boolean']['input'];
  /** The ID of the component custom boolean field to check the value of. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

export type CompassCreateHasCustomMultiSelectFieldScorecardCriteriaInput = {
  /** The comparison operation to be performed between the field and comparator value. */
  collectionComparator: CompassCriteriaCollectionComparatorOptions;
  /** The list of multi select options that the field is compared to. */
  collectionComparatorValue: Array<Scalars['ID']['input']>;
  /** The ID of the component custom multi select field to check the value of. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts input to create a scorecard criterion checking the value of a specified custom number field. */
export type CompassCreateHasCustomNumberFieldScorecardCriteriaInput = {
  /** The ID of the component custom number field to check the value of. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The comparison operation to be performed between the field and comparator value. */
  numberComparator: CompassCriteriaNumberComparatorOptions;
  /** The threshold value that the field is compared to. */
  numberComparatorValue: Scalars['Float']['input'];
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

export type CompassCreateHasCustomSingleSelectFieldScorecardCriteriaInput = {
  /** The ID of the component custom single select field to check the value of. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The comparison operation to be performed between the field and comparator value. */
  membershipComparator: CompassCriteriaMembershipComparatorOptions;
  /** The list of single select options that the field is compared to. */
  membershipComparatorValue: Array<Scalars['ID']['input']>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts input to create a scorecard criterion checking the value of a specified custom text field. */
export type CompassCreateHasCustomTextFieldScorecardCriteriaInput = {
  /** The ID of the component custom text field to check the value of. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** An incident event. */
export type CompassCreateIncidentEventInput = {
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The list of properties of the incident event. */
  incidentProperties: CompassCreateIncidentEventPropertiesInput;
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

/** The list of properties of the incident event. */
export type CompassCreateIncidentEventPropertiesInput = {
  /** The time when the incident ended */
  endTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** The ID of the incident. */
  id: Scalars['ID']['input'];
  /** The severity of the incident */
  severity?: InputMaybe<CompassIncidentEventSeverityInput>;
  /** The time when the incident started */
  startTime: Scalars['DateTime']['input'];
  /** The state of the incident. */
  state: CompassIncidentEventState;
};

/** The user-provided input to create an incoming webhook */
export type CompassCreateIncomingWebhookInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
  /** The description of the webhook. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the webhook. */
  name: Scalars['String']['input'];
  /** The source of the webhook. */
  source: Scalars['String']['input'];
};

export type CompassCreateIncomingWebhookTokenInput = {
  /** Name of auth token */
  name?: InputMaybe<Scalars['String']['input']>;
  /** ID of the webhook to associate the token with. */
  webhookId: Scalars['ID']['input'];
};

/** A lifecycle event. */
export type CompassCreateLifecycleEventInput = {
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** Lifecycle Properties */
  lifecycleProperties: CompassLifecycleEventInputProperties;
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

/** The input for creating a metric definition. */
export type CompassCreateMetricDefinitionInput = {
  /** The cloud ID of the Compass site to create a metric definition on. */
  cloudId: Scalars['ID']['input'];
  /** The description of the metric definition. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The format option for applying to the display of metric values. */
  format?: InputMaybe<CompassMetricDefinitionFormatInput>;
  /** The name of the metric definition. */
  name: Scalars['String']['input'];
};

/** The input to create a metric source. */
export type CompassCreateMetricSourceInput = {
  /** The ID of the component to create a metric source on. */
  componentId: Scalars['ID']['input'];
  /** Whether the metric source is derived from Compass events or not. */
  derived?: InputMaybe<Scalars['Boolean']['input']>;
  /** The external metric source configuration input */
  externalConfiguration?: InputMaybe<CompassExternalMetricSourceConfigurationInput>;
  /** The unique identifier (ID) of the metric source that is external to the Compass site, for example, a Bitbucket repository ID. */
  externalMetricSourceId: Scalars['ID']['input'];
  /** The ID of the Forge app that sends metric values. */
  forgeAppId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the metric definition which defines the metric source. */
  metricDefinitionId: Scalars['ID']['input'];
  /** The URL of the metric source. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** A pull request event. */
export type CompassCreatePullRequestEventInput = {
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** The list of properties of the pull request event. */
  pullRequestProperties: CompassPullRequestInputProperties;
};

export enum CompassCreatePullRequestStatus {
  Created = 'CREATED',
  InReview = 'IN_REVIEW',
  Merged = 'MERGED',
  Rejected = 'REJECTED'
}

/** A push event. */
export type CompassCreatePushEventInput = {
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** The list of properties of the push event. */
  pushEventProperties: CompassPushEventInputProperties;
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

export type CompassCreateScorecardCriteriaScoringStrategyRulesInput = {
  onFalse?: InputMaybe<CompassScorecardCriteriaScoringStrategyRuleAction>;
  onTrue?: InputMaybe<CompassScorecardCriteriaScoringStrategyRuleAction>;
};

/** Accepts input for creating team checkin's action item. */
export type CompassCreateTeamCheckinActionInput = {
  /** The text of the team checkin action item. */
  actionText: Scalars['String']['input'];
  /** Whether the action is completed or not. */
  completed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Accepts input for creating a checkin. */
export type CompassCreateTeamCheckinInput = {
  /** A list of action items to be created with the checkin. */
  actions?: InputMaybe<Array<CompassCreateTeamCheckinActionInput>>;
  /** The cloud ID of the site to update a checkin on. */
  cloudId: Scalars['ID']['input'];
  /** The mood of the checkin. */
  mood: Scalars['Int']['input'];
  /** The response to the question 1 of the team checkin. */
  response1?: InputMaybe<Scalars['String']['input']>;
  /** The response to the question 1 of the team checkin in a rich text format. */
  response1RichText?: InputMaybe<CompassCreateTeamCheckinResponseRichText>;
  /** The response to the question 2 of the team checkin. */
  response2?: InputMaybe<Scalars['String']['input']>;
  /** The response to the question 2 of the team checkin in a rich text format. */
  response2RichText?: InputMaybe<CompassCreateTeamCheckinResponseRichText>;
  /** The response to the question 3 of the team checkin. */
  response3?: InputMaybe<Scalars['String']['input']>;
  /** The response to the question 3 of the team checkin in a rich text format. */
  response3RichText?: InputMaybe<CompassCreateTeamCheckinResponseRichText>;
  /** The unique identifier (ID) of the team that did the checkin. */
  teamId: Scalars['ID']['input'];
};

/** Accepts input for creating team checkin responses with rich text. */
export type CompassCreateTeamCheckinResponseRichText = {
  /** Input for a team checkin response in Atlassian Document Format. */
  adf?: InputMaybe<Scalars['String']['input']>;
};

export type CompassCreateWebhookInput = {
  /** The template associated with this webhook. */
  componentId: Scalars['ID']['input'];
  /** The url of the webhook. */
  url: Scalars['String']['input'];
};

export enum CompassCriteriaBooleanComparatorOptions {
  Equals = 'EQUALS'
}

export enum CompassCriteriaCollectionComparatorOptions {
  AllOf = 'ALL_OF',
  AnyOf = 'ANY_OF',
  NoneOf = 'NONE_OF'
}

export enum CompassCriteriaMembershipComparatorOptions {
  In = 'IN',
  NotIn = 'NOT_IN'
}

export enum CompassCriteriaNumberComparatorOptions {
  Equals = 'EQUALS',
  GreaterThan = 'GREATER_THAN',
  GreaterThanOrEqualTo = 'GREATER_THAN_OR_EQUAL_TO',
  LessThan = 'LESS_THAN',
  LessThanOrEqualTo = 'LESS_THAN_OR_EQUAL_TO'
}

export enum CompassCriteriaTextComparatorOptions {
  IsPresent = 'IS_PRESENT',
  MatchesRegex = 'MATCHES_REGEX'
}

/** Accepts input for setting a boolean value on a custom field. */
export type CompassCustomBooleanFieldInput = {
  /** The annotations attached to a custom field. */
  annotations?: InputMaybe<Array<CompassCustomFieldAnnotationInput>>;
  /** The boolean value contained in the custom field on a component. */
  booleanValue: Scalars['Boolean']['input'];
  /** The ID of the custom boolean field definition. */
  definitionId: Scalars['ID']['input'];
};

export enum CompassCustomEventIcon {
  Checkpoint = 'CHECKPOINT',
  Info = 'INFO',
  Warning = 'WARNING'
}

/** The list of properties of the custom event. */
export type CompassCustomEventPropertiesInput = {
  /** The icon for the custom event. */
  icon: CompassCustomEventIcon;
  /** The ID of the custom event. */
  id: Scalars['ID']['input'];
};

/** Annotatation input for a custom field value */
export type CompassCustomFieldAnnotationInput = {
  /** Description of the annotation. */
  description: Scalars['String']['input'];
  /** The text to display for a given linkURI. */
  linkText: Scalars['String']['input'];
  /** Link to display alongside an annotations description. */
  linkUri: Scalars['URL']['input'];
};

/** The query for retrieving a custom field definition by id on a Compass site. */
export type CompassCustomFieldDefinitionQuery = {
  /** The cloud ID of the site to retrieve custom field definitions from. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the custom field definition to retrieve. */
  id: Scalars['ID']['input'];
};

/** The query for retrieving custom field definitions on a Compass site. */
export type CompassCustomFieldDefinitionsQuery = {
  /** The cloud ID of the site to retrieve custom field definitions from. */
  cloudId: Scalars['ID']['input'];
  /**
   * Optional filter to search for custom field definitions applied to any of the specific component types.
   * Returns all custom field definitions by default.
   */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * Optional filter to search for custom field definitions applied to any of the specified component types.
   * Returns all custom field definitions by default.
   */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
};

/** Accepts input for setting a custom field value. You must provide exactly one of the fields in this input type. */
export type CompassCustomFieldInput = {
  /** Input for setting a value on a custom field containing a boolean value. */
  booleanField?: InputMaybe<CompassCustomBooleanFieldInput>;
  /** Input for setting a value on a custom field containing multiple options */
  multiSelectField?: InputMaybe<CompassCustomMultiSelectFieldInput>;
  /** Input for setting a value on a custom field containing a number. */
  numberField?: InputMaybe<CompassCustomNumberFieldInput>;
  /** Input for setting a value on a custom field containing a single option */
  singleSelectField?: InputMaybe<CompassCustomSingleSelectFieldInput>;
  /** Input for setting a value on a custom field containing a text string. */
  textField?: InputMaybe<CompassCustomTextFieldInput>;
  /** Input for setting a value on a custom field containing a user. */
  userField?: InputMaybe<CompassCustomUserFieldInput>;
};

/** Accepts input for setting options for a multi-select field. */
export type CompassCustomMultiSelectFieldInput = {
  /** The annotations attached to a custom field. */
  annotations?: InputMaybe<Array<CompassCustomFieldAnnotationInput>>;
  /** The ID of the custom boolean field definition. */
  definitionId: Scalars['ID']['input'];
  /** The option IDs for the custom field on a component. */
  options?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Accepts input for setting a number on a custom field. */
export type CompassCustomNumberFieldInput = {
  /** The annotations attached to a custom field. */
  annotations?: InputMaybe<Array<CompassCustomFieldAnnotationInput>>;
  /** The ID of the custom number field definition. */
  definitionId: Scalars['ID']['input'];
  /** The number contained in the custom field on a component. */
  numberValue?: InputMaybe<Scalars['Float']['input']>;
};

/** Preset options to update custom permission configs, either open to all teams/roles or restricted to product admins and owners. */
export enum CompassCustomPermissionPreset {
  /** Restrictive option which only permits product admins and owners to create/edit/delete, which vary depending on entity, i.e. component */
  AdminsAndOwners = 'ADMINS_AND_OWNERS',
  /** Default option which permits the owner team, as well as all teams and roles. */
  Default = 'DEFAULT'
}

/** Accepts input for setting an option for single-select field. */
export type CompassCustomSingleSelectFieldInput = {
  /** The annotations attached to a custom field. */
  annotations?: InputMaybe<Array<CompassCustomFieldAnnotationInput>>;
  /** The ID of the custom boolean field definition. */
  definitionId: Scalars['ID']['input'];
  /** The option ID for the custom field on a component. */
  option?: InputMaybe<Scalars['ID']['input']>;
};

/** Accepts input for setting a text string on a custom field. */
export type CompassCustomTextFieldInput = {
  /** The annotations attached to a custom field. */
  annotations?: InputMaybe<Array<CompassCustomFieldAnnotationInput>>;
  /** The ID of the custom text field definition. */
  definitionId: Scalars['ID']['input'];
  /** The text string contained in the custom field on a component. */
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for setting a user on a custom field. */
export type CompassCustomUserFieldInput = {
  /** The annotations attached to a custom field. */
  annotations?: InputMaybe<Array<CompassCustomFieldAnnotationInput>>;
  /** The ID of the custom user field definition. */
  definitionId: Scalars['ID']['input'];
  /** The user contained in the custom field on a component. */
  userIdValue?: InputMaybe<Scalars['ID']['input']>;
};

/** Accepts input for deleting a component announcement. */
export type CompassDeleteAnnouncementInput = {
  /** The cloud ID of the site to delete an announcement from. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the announcement to delete. */
  id: Scalars['ID']['input'];
};

/** Accepts input for delete a subscription. */
export type CompassDeleteComponentSubscriptionInput = {
  /** The ID of the component to unsubscribe. */
  componentId: Scalars['ID']['input'];
};

/** Accepts input for deleting a custom field definition, along with all values associated with the definition. */
export type CompassDeleteCustomFieldDefinitionInput = {
  /** The ID of the custom field definition to be deleted. */
  id: Scalars['ID']['input'];
};

export type CompassDeleteDocumentInput = {
  /** The ARI of the document to delete */
  id: Scalars['ID']['input'];
};

export type CompassDeleteExternalAliasInput = {
  /** The ID of the component in the external source */
  externalId: Scalars['ID']['input'];
  /** The external system hosting the component */
  externalSource: Scalars['ID']['input'];
};

/** The user-provided input to delete an incoming webhook */
export type CompassDeleteIncomingWebhookInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
  /** The ARI of the webhook to delete */
  id: Scalars['ID']['input'];
};

/** The input to delete a metric definition. */
export type CompassDeleteMetricDefinitionInput = {
  /** The ID of the metric definition to be deleted. */
  id: Scalars['ID']['input'];
};

/** The input to delete a metric source. */
export type CompassDeleteMetricSourceInput = {
  /** The ID of the metric source to be deleted. */
  id: Scalars['ID']['input'];
};

/** Accepts input for deleting a team checkin. */
export type CompassDeleteTeamCheckinActionInput = {
  /** The ID of the team checkin item to delete. */
  id: Scalars['ID']['input'];
};

/** Accepts input for deleting a team checkin. */
export type CompassDeleteTeamCheckinInput = {
  /** The cloud ID of the site to update a checkin on. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the team checkin to delete. */
  id: Scalars['ID']['input'];
};

export enum CompassDeploymentEventEnvironmentCategory {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

/** The environment where the deployment event has occurred. */
export type CompassDeploymentEventEnvironmentInput = {
  /** The type of environment where the deployment event occurred. */
  category: CompassDeploymentEventEnvironmentCategory;
  /** The display name of the environment where the deployment event occurred. */
  displayName: Scalars['String']['input'];
  /** The ID of the environment where the deployment event occurred. */
  environmentId: Scalars['String']['input'];
};

/** Filters for deployment events. */
export type CompassDeploymentEventFilters = {
  /** A list of environments to filter deployment events by. */
  environments?: InputMaybe<Array<CompassDeploymentEventEnvironmentCategory>>;
};

/** The deployment event pipeline. */
export type CompassDeploymentEventPipelineInput = {
  /** The name of the deployment event pipeline. */
  displayName: Scalars['String']['input'];
  /** The ID of the deployment event pipeline. */
  pipelineId: Scalars['String']['input'];
  /** The URL of the deployment event pipeline. */
  url: Scalars['String']['input'];
};

/**  Compass Deployment Event */
export enum CompassDeploymentEventState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type CompassEnumFieldValueInput = {
  value?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Filters for events sent to Compass. */
export type CompassEventFilters = {
  /** Filters for deployment events. */
  deployments?: InputMaybe<CompassDeploymentEventFilters>;
};

/** The type of event. One and only one of the fields in this input type must be provided. */
export type CompassEventInput = {
  alert?: InputMaybe<CompassCreateAlertEventInput>;
  build?: InputMaybe<CompassCreateBuildEventInput>;
  custom?: InputMaybe<CompassCreateCustomEventInput>;
  deployment?: InputMaybe<CompassCreateDeploymentEventInput>;
  flag?: InputMaybe<CompassCreateFlagEventInput>;
  incident?: InputMaybe<CompassCreateIncidentEventInput>;
  lifecycle?: InputMaybe<CompassCreateLifecycleEventInput>;
  pullRequest?: InputMaybe<CompassCreatePullRequestEventInput>;
  push?: InputMaybe<CompassCreatePushEventInput>;
};

export type CompassEventTimeParameters = {
  /** The time to end querying for event data. */
  endAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The time to begin querying for event data. */
  startFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

export enum CompassEventType {
  Alert = 'ALERT',
  Build = 'BUILD',
  Custom = 'CUSTOM',
  Deployment = 'DEPLOYMENT',
  Flag = 'FLAG',
  Incident = 'INCIDENT',
  Lifecycle = 'LIFECYCLE',
  PullRequest = 'PULL_REQUEST',
  Push = 'PUSH'
}

export type CompassEventsInEventSourceQuery = {
  /** Returns the events after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Filter events based on CompassEventFilters. */
  eventFilters?: InputMaybe<CompassEventFilters>;
  /** The first N number of events to return in the query. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Returns the events after that match the CompassEventTimeParameters. */
  timeParameters?: InputMaybe<CompassEventTimeParameters>;
};

export type CompassEventsQuery = {
  /** Returns the events after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Filter events based on CompassEventFilters */
  eventFilters?: InputMaybe<CompassEventFilters>;
  /** The list of event types. */
  eventTypes?: InputMaybe<Array<CompassEventType>>;
  /** The first N number of events to return in the query. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Returns the events after that match the CompassEventTimeParameters. */
  timeParameters?: InputMaybe<CompassEventTimeParameters>;
};

export type CompassExternalAliasInput = {
  /** The ID of the component in the external source */
  externalId: Scalars['ID']['input'];
  /** The external system hosting the component */
  externalSource: Scalars['ID']['input'];
  /** The url of the component in an external system. */
  url?: InputMaybe<Scalars['String']['input']>;
};

export type CompassExternalMetricSourceConfigurationInput = {
  /** Plain external metric source configuration input */
  plain?: InputMaybe<CompassPlainMetricSourceConfigurationInput>;
  /** SLO external metric source configuration input */
  slo?: InputMaybe<CompassSloMetricSourceConfigurationInput>;
};

/** Specifies the type of value for a field. */
export enum CompassFieldType {
  Boolean = 'BOOLEAN',
  Date = 'DATE',
  Enum = 'ENUM',
  Number = 'NUMBER',
  Text = 'TEXT'
}

export type CompassFieldValueInput = {
  boolean?: InputMaybe<CompassBooleanFieldValueInput>;
  enum?: InputMaybe<CompassEnumFieldValueInput>;
};

/** Accepts input to find filtered components count */
export type CompassFilteredComponentsCountQuery = {
  fields?: InputMaybe<Array<CompassScorecardAppliedToComponentsFieldFilter>>;
  labels?: InputMaybe<CompassScorecardAppliedToComponentsLabelsFilter>;
  ownerIds?: InputMaybe<CompassScorecardAppliedToComponentsOwnerFilter>;
  types?: InputMaybe<CompassScorecardAppliedToComponentsTypesFilter>;
};

/** The severity of an incident */
export type CompassIncidentEventSeverityInput = {
  /** The label to use for displaying the severity of the incident */
  label?: InputMaybe<Scalars['String']['input']>;
  /** The severity level. A severity level of 'ONE' is the most severe, and a level of 'FIVE' is the least severe. */
  level?: InputMaybe<CompassIncidentEventSeverityLevel>;
};

export enum CompassIncidentEventSeverityLevel {
  Five = 'FIVE',
  Four = 'FOUR',
  One = 'ONE',
  Three = 'THREE',
  Two = 'TWO'
}

export enum CompassIncidentEventState {
  Deleted = 'DELETED',
  Open = 'OPEN',
  Resolved = 'RESOLVED'
}

/** The input to insert a metric value in all metric sources that match a specific combination of metricDefinitionId and externalMetricSourceId. */
export type CompassInsertMetricValueByExternalIdInput = {
  /** The cloud ID of the site to insert a metric value for. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the metric source that is external to the Compass site, for example, a Bitbucket repository ID. */
  externalMetricSourceId: Scalars['ID']['input'];
  /** The ID of the metric definition for which the value applies. */
  metricDefinitionId: Scalars['ID']['input'];
  /** The metric value to be inserted. */
  value: CompassMetricValueInput;
};

/** The input to insert a metric value into a metric source. */
export type CompassInsertMetricValueInput = {
  /** The ID of the metric source to insert the value into. */
  metricSourceId: Scalars['ID']['input'];
  /** The metric value to insert. */
  value: CompassMetricValueInput;
};

/** The list of properties of the lifecycle event. */
export type CompassLifecycleEventInputProperties = {
  /** The ID of the lifecycle. */
  id: Scalars['ID']['input'];
  /** The stage of the lifecycle event. */
  stage: CompassLifecycleEventStage;
};

export enum CompassLifecycleEventStage {
  Deprecation = 'DEPRECATION',
  EndOfLife = 'END_OF_LIFE',
  PreRelease = 'PRE_RELEASE',
  Production = 'PRODUCTION'
}

export type CompassLifecycleFilterInput = {
  /** logical operator to use for values in the list */
  operator: CompassLifecycleFilterOperator;
  /** stages to consider when filtering components for application of scorecards */
  values: Array<Scalars['String']['input']>;
};

/**  MUTATION INPUTS/PAYLOAD TYPES */
export enum CompassLifecycleFilterOperator {
  Nor = 'NOR',
  Or = 'OR'
}

/** The types used to identify the intent of the link. */
export enum CompassLinkType {
  /** Chat Channels for contacting the owners/support of the component */
  ChatChannel = 'CHAT_CHANNEL',
  /** A link to the dashboard of the component. */
  Dashboard = 'DASHBOARD',
  /**
   * A link to the documentation of the component.
   * @deprecated Documents should be created with the documentation API
   */
  Document = 'DOCUMENT',
  /** A link to the on-call schedule of the component. */
  OnCall = 'ON_CALL',
  /** Other link for a Component. */
  OtherLink = 'OTHER_LINK',
  /** A link to the Jira or third-party project of the component. */
  Project = 'PROJECT',
  /** A link to the source code repository of the component. */
  Repository = 'REPOSITORY'
}

export type CompassMetricDefinitionFormatInput = {
  /** A plain-text suffix appended to the metric value when displayed, for example, 'MB/s'. */
  suffix?: InputMaybe<CompassMetricDefinitionFormatSuffixInput>;
};

/** The format option to append a plain-text suffix to metric values. */
export type CompassMetricDefinitionFormatSuffixInput = {
  /** A plain-text suffix appended to the metric value when displayed, for example, 'MB/s'. */
  suffix: Scalars['String']['input'];
};

/** Used to identify the type for the metric */
export enum CompassMetricDefinitionType {
  /** Predefined metrics built in to Compass */
  BuiltIn = 'BUILT_IN',
  /** Metrics defined by the individual user */
  Custom = 'CUSTOM'
}

/** The query to get the metric definitions on a Compass site. */
export type CompassMetricDefinitionsQuery = {
  /** Returns results after the specified cursor. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The cloud ID of the site to query for metric definitions on. */
  cloudId: Scalars['ID']['input'];
  /** The number of results to return in the query. The default is 10. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassMetricSourceFilter = {
  metricDefinition?: InputMaybe<CompassMetricSourceMetricDefinitionFilter>;
};

export type CompassMetricSourceMetricDefinitionFilter = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type CompassMetricSourceQuery = {
  matchAnyFilter?: InputMaybe<Array<CompassMetricSourceFilter>>;
};

/** The query to get the metric values from a component's metric source. */
export type CompassMetricSourceValuesQuery = {
  /** Returns the values after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The number of results to return in the query. The default is 10. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassMetricSourcesQuery = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** A metric value to be inserted. */
export type CompassMetricValueInput = {
  /** The time the metric value was collected. */
  timestamp: Scalars['DateTime']['input'];
  /** The value of the metric. */
  value: Scalars['Float']['input'];
};

export type CompassMetricValuesFilter = {
  timeRange?: InputMaybe<CompassMetricValuesTimeRangeFilter>;
};

export type CompassMetricValuesQuery = {
  matchAnyFilter?: InputMaybe<Array<CompassMetricValuesFilter>>;
};

export type CompassMetricValuesTimeRangeFilter = {
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
};

export type CompassPlainMetricSourceConfigurationInput = {
  /** External configuration query */
  query: Scalars['String']['input'];
};

/** The list of properties of the pull event. */
export type CompassPullRequestInputProperties = {
  /** The ID of the pull request event. */
  id: Scalars['String']['input'];
  /** The URL of the pull request. */
  pullRequestUrl: Scalars['String']['input'];
  /** The URL of the repository of the pull request. */
  repoUrl: Scalars['String']['input'];
  /** The status of the pull request. */
  status: CompassCreatePullRequestStatus;
};

export enum CompassPullRequestQuerySortName {
  /** The time between a PR's created and merged or rejected state. */
  CycleTime = 'CYCLE_TIME',
  OpenToFirstReview = 'OPEN_TO_FIRST_REVIEW',
  PrClosedTime = 'PR_CLOSED_TIME',
  PrCreatedTime = 'PR_CREATED_TIME',
  /** The time between a PR's first reviewed and last reviewed timestamps. */
  ReviewTime = 'REVIEW_TIME'
}

export enum CompassPullRequestStatus {
  Created = 'CREATED',
  FirstReviewed = 'FIRST_REVIEWED',
  Merged = 'MERGED',
  Overdue = 'OVERDUE',
  Rejected = 'REJECTED'
}

/** The pull request status used in the StatusInTimeRangeFilter query. */
export enum CompassPullRequestStatusForStatusInTimeRangeFilter {
  Created = 'CREATED',
  FirstReviewed = 'FIRST_REVIEWED',
  Merged = 'MERGED',
  Rejected = 'REJECTED'
}

/** Accepts input to find pull requests. */
export type CompassPullRequestsQuery = {
  /** Returns the pull requests which matches one of the current status. */
  matchAnyCurrentStatus?: InputMaybe<Array<CompassPullRequestStatus>>;
  /** The filters used in the query. The relationship of filters is OR. */
  matchAnyFilters?: InputMaybe<Array<CompassPullRequestsQueryFilter>>;
  /** The sorting mechanism used in the query. */
  sort?: InputMaybe<CompassPullRequestsQuerySort>;
};

/** Accepts input for querying pull requests. */
export type CompassPullRequestsQueryFilter = {
  /** Input for querying pull request based on status and time range. */
  statusInTimeRange?: InputMaybe<PullRequestStatusInTimeRangeQueryFilter>;
};

export type CompassPullRequestsQuerySort = {
  /** The name of the field to sort by. */
  name: CompassPullRequestQuerySortName;
  /** The order to sort by. */
  order: CompassQuerySortOrder;
};

/** The author who made the push */
export type CompassPushEventAuthorInput = {
  /** The email of the author. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** The name of the author. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The list of properties of the push event. */
export type CompassPushEventInputProperties = {
  /** The author who made the push. */
  author?: InputMaybe<CompassPushEventAuthorInput>;
  /** The name of the branch being pushed to. */
  branchName: Scalars['String']['input'];
  /** The ID of the push to event. */
  id: Scalars['ID']['input'];
};

/** A filter to apply to the search results. */
export type CompassQueryFieldFilter = {
  filter?: InputMaybe<CompassQueryFilter>;
  /** The name of the field to apply the filter. The valid field names are compass:tier, labels, ownerId, score, type, links, linkTypes, state, and eventSourceCount. */
  name: Scalars['String']['input'];
};

export type CompassQueryFilter = {
  eq?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to */
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to */
  lte?: InputMaybe<Scalars['String']['input']>;
  neq?: InputMaybe<Scalars['String']['input']>;
};

export type CompassQuerySort = {
  name?: InputMaybe<Scalars['String']['input']>;
  /**  name of field to sort results by */
  order?: InputMaybe<CompassQuerySortOrder>;
};

export enum CompassQuerySortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type CompassQueryTimeRange = {
  /** End date for query, exclusive. */
  endDate: Scalars['DateTime']['input'];
  /** Start date for query, inclusive. */
  startDate: Scalars['DateTime']['input'];
};

/** Defines the possible relationship directions between components. */
export enum CompassRelationshipDirection {
  /** Going from the other component to this component. */
  Inward = 'INWARD',
  /** Going from this component to the other component. */
  Outward = 'OUTWARD'
}

/** Accepts input for finding component relationships. */
export type CompassRelationshipQuery = {
  /** The relationships to be returned after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The direction of relationships to be searched for. */
  direction?: CompassRelationshipDirection;
  /** The filters for the relationships to be searched for. */
  filters?: InputMaybe<CompassRelationshipQueryFilters>;
  /** The number of relationships to return in the query. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassRelationshipQueryFilters = {
  /** OR'd set of relationship types. */
  types?: InputMaybe<Array<CompassRelationshipType>>;
};

/** Defines the relationship types. A relationship must be one of these types. */
export enum CompassRelationshipType {
  DependsOn = 'DEPENDS_ON'
}

/** Accepts input for removing labels from a team. */
export type CompassRemoveTeamLabelsInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
  /** A list of labels that should be removed from the team. */
  labels: Array<Scalars['String']['input']>;
  /** The unique identifier (ID) of the target team. */
  teamId: Scalars['ID']['input'];
};

export type CompassRepositoryValueInput = {
  /** The repository link exists or not */
  exists: Scalars['Boolean']['input'];
};

export type CompassScoreStatisticsHistoryComponentTypesFilter = {
  /** The types of components to filter on, for example SERVICE. */
  in: Array<Scalars['ID']['input']>;
};

export type CompassScoreStatisticsHistoryDateFilter = {
  /** The date to start filtering score statistics history. */
  startFrom: Scalars['DateTime']['input'];
};

export type CompassScoreStatisticsHistoryOwnersFilter = {
  /** The team owners to filter on. */
  in: Array<Scalars['ID']['input']>;
};

export type CompassScorecardAppliedToComponentsCriteriaFilter = {
  /** The ID of the scorecard criterion. */
  id: Scalars['ID']['input'];
  /** The statuses of the criterion to filter on, for example FAILING. */
  statuses: Array<Scalars['ID']['input']>;
};

export type CompassScorecardAppliedToComponentsFieldFilter = {
  /** The ID of the field definition, for example 'compass:tier'. */
  definition: Scalars['ID']['input'];
  /** The values of the field to filter on. */
  in: Array<CompassFieldValueInput>;
};

export type CompassScorecardAppliedToComponentsLabelsFilter = {
  /** The labels of components to filter on. */
  in: Array<Scalars['String']['input']>;
};

export type CompassScorecardAppliedToComponentsOwnerFilter = {
  /** The team owners to filter on. */
  in: Array<Scalars['ID']['input']>;
};

/** Accepts input to find components a scorecard is applied to and their scores */
export type CompassScorecardAppliedToComponentsQuery = {
  /** Returns the components after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Returns only components whose attributes match those in the filters specified */
  filter?: InputMaybe<CompassScorecardAppliedToComponentsQueryFilter>;
  /** The first N number of components to return in the query. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Returns components according to the sorting scheme specified. */
  sort?: InputMaybe<CompassScorecardAppliedToComponentsQuerySort>;
};

export type CompassScorecardAppliedToComponentsQueryFilter = {
  fields?: InputMaybe<Array<CompassScorecardAppliedToComponentsFieldFilter>>;
  owners?: InputMaybe<CompassScorecardAppliedToComponentsOwnerFilter>;
  score?: InputMaybe<CompassScorecardAppliedToComponentsThresholdFilter>;
  scoreRanges?: InputMaybe<CompassScorecardAppliedToComponentsScoreRangeFilter>;
  scorecardCriteria?: InputMaybe<Array<CompassScorecardAppliedToComponentsCriteriaFilter>>;
  types?: InputMaybe<CompassScorecardAppliedToComponentsTypesFilter>;
};

/** Accepts input to sort the applied components by. */
export type CompassScorecardAppliedToComponentsQuerySort = {
  /** The name of the field to sort by. Supports `SCORE` for scorecard score. */
  name: Scalars['String']['input'];
  /** The order to sort the applied components by. */
  order: CompassScorecardQuerySortOrder;
};

export type CompassScorecardAppliedToComponentsScoreRange = {
  from: Scalars['Int']['input'];
  to: Scalars['Int']['input'];
};

export type CompassScorecardAppliedToComponentsScoreRangeFilter = {
  in: Array<CompassScorecardAppliedToComponentsScoreRange>;
};

export type CompassScorecardAppliedToComponentsThresholdFilter = {
  lt: Scalars['Int']['input'];
};

export type CompassScorecardAppliedToComponentsTypesFilter = {
  /** The types of components to filter on, for example SERVICE. */
  in: Array<Scalars['ID']['input']>;
};

/** Specifies the periodicity (regular repetition at fixed intervals) of the criteria score history data. */
export enum CompassScorecardCriteriaScoreHistoryPeriodicity {
  Daily = 'DAILY',
  Weekly = 'WEEKLY'
}

/** Accepts input for querying criteria score history. */
export type CompassScorecardCriteriaScoreHistoryQuery = {
  /** A filter which refines the criteria score history query. */
  filter?: InputMaybe<CompassScorecardCriteriaScoreHistoryQueryFilter>;
};

/** Accepts input for filtering when querying criteria score history. */
export type CompassScorecardCriteriaScoreHistoryQueryFilter = {
  /** The periodicity (regular repetition at fixed intervals) of the criteria score history data. */
  periodicity?: InputMaybe<CompassScorecardCriteriaScoreHistoryPeriodicity>;
  /** The date (midnight UTC) which the queried criteria score history data will start, which cannot be in the future. */
  startFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

export type CompassScorecardCriteriaScoreQuery = {
  /** The unique identifier (ID) of the component. */
  componentId: Scalars['ID']['input'];
};

export type CompassScorecardCriteriaScoreStatisticsHistoryQuery = {
  filter?: InputMaybe<CompassScorecardCriteriaScoreStatisticsHistoryQueryFilter>;
};

/** Accepts input to filter the scorecard criteria statistics history. */
export type CompassScorecardCriteriaScoreStatisticsHistoryQueryFilter = {
  /** The types of components to filter by. */
  componentTypes?: InputMaybe<CompassScoreStatisticsHistoryComponentTypesFilter>;
  /** The date at which to start filtering. */
  date?: InputMaybe<CompassScoreStatisticsHistoryDateFilter>;
  /** The team owners to filter by. */
  owners?: InputMaybe<CompassScoreStatisticsHistoryOwnersFilter>;
};

export enum CompassScorecardCriteriaScoringStrategyRuleAction {
  MarkAsFailed = 'MARK_AS_FAILED',
  MarkAsPassed = 'MARK_AS_PASSED',
  MarkAsSkipped = 'MARK_AS_SKIPPED'
}

/**  COMPASS SCORECARD DEACTIVATION TYPES */
export type CompassScorecardDeactivatedComponentsQuery = {
  filter?: InputMaybe<CompassScorecardDeactivatedComponentsQueryFilter>;
  sort?: InputMaybe<CompassScorecardDeactivatedComponentsQuerySort>;
};

export type CompassScorecardDeactivatedComponentsQueryFilter = {
  fields?: InputMaybe<Array<CompassScorecardAppliedToComponentsFieldFilter>>;
  owners?: InputMaybe<CompassScorecardAppliedToComponentsOwnerFilter>;
  types?: InputMaybe<CompassScorecardAppliedToComponentsTypesFilter>;
};

/** Accepts input to sort the deactivated components by. */
export type CompassScorecardDeactivatedComponentsQuerySort = {
  /** The name of the field to sort by. */
  name: Scalars['String']['input'];
  /** The order to sort the deactivated components by. */
  order: CompassScorecardQuerySortOrder;
};

/** The types used to identify the importance of the scorecard. */
export enum CompassScorecardImportance {
  /** Recommended to the component's owner when they select a scorecard to apply to their component. */
  Recommended = 'RECOMMENDED',
  /** Automatically applied to all components of the specified type or types and cannot be removed. */
  Required = 'REQUIRED',
  /** Custom scorecard, focused on specific use cases within teams or departments. */
  UserDefined = 'USER_DEFINED'
}

/** Accepts input to filter the scorecards by. */
export type CompassScorecardQueryFilter = {
  /** Filter by the collection of component types matching that of the scorecards. */
  componentTypeIds?: InputMaybe<CompassScorecardAppliedToComponentsTypesFilter>;
  /** Text input used to find matching scorecards by name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Filter by the type of scorecard */
  type?: InputMaybe<CompassScorecardTypesFilter>;
};

/** Accepts input to sort the scorecards by. */
export type CompassScorecardQuerySort = {
  /** Sort by the specified field. Supports `NAME` for scorecard name and `COMPONENT_COUNT` for associated component count. */
  name: Scalars['String']['input'];
  /** The order to sort the scorecards by. */
  order: CompassScorecardQuerySortOrder;
};

/** Sort scorecards in ascending or descending order of specified field. */
export enum CompassScorecardQuerySortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type CompassScorecardScoreDurationStatisticsQuery = {
  filter?: InputMaybe<CompassScorecardScoreDurationStatisticsQueryFilter>;
};

/** Accepts input to filter the scorecard score durations statistics. */
export type CompassScorecardScoreDurationStatisticsQueryFilter = {
  /** The types of components to filter by. */
  componentTypes?: InputMaybe<CompassScoreStatisticsHistoryComponentTypesFilter>;
  /** The team owners to filter by. */
  owners?: InputMaybe<CompassScoreStatisticsHistoryOwnersFilter>;
};

/** Specifies the periodicity (regular repetition at fixed intervals) of the scorecard score history data. */
export enum CompassScorecardScoreHistoryPeriodicity {
  Daily = 'DAILY',
  Weekly = 'WEEKLY'
}

/** Accepts input for querying scorecard score history. */
export type CompassScorecardScoreHistoryQuery = {
  /** A filter which refines the scorecard score history query. */
  filter?: InputMaybe<CompassScorecardScoreHistoryQueryFilter>;
};

/** Accepts input for filtering when querying scorecard score history. */
export type CompassScorecardScoreHistoryQueryFilter = {
  /** The periodicity (regular repetition at fixed intervals) of the scorecard score history data. */
  periodicity?: InputMaybe<CompassScorecardScoreHistoryPeriodicity>;
  /** The date (midnight UTC) which the queried scorecard score history data will start, which cannot be in the future. */
  startFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Scorecard score on a scorecard for a component. */
export type CompassScorecardScoreQuery = {
  /** The unique identifier (ID) of the component. */
  componentId: Scalars['ID']['input'];
};

export type CompassScorecardScoreStatisticsHistoryQuery = {
  filter?: InputMaybe<CompassScorecardScoreStatisticsHistoryQueryFilter>;
};

/** Accepts input to filter the scorecard score statistics history. */
export type CompassScorecardScoreStatisticsHistoryQueryFilter = {
  /** The types of components to filter by. */
  componentTypes?: InputMaybe<CompassScoreStatisticsHistoryComponentTypesFilter>;
  /** The date at which to start filtering. */
  date?: InputMaybe<CompassScoreStatisticsHistoryDateFilter>;
  /** The team owners to filter by. */
  owners?: InputMaybe<CompassScoreStatisticsHistoryOwnersFilter>;
};

export enum CompassScorecardScoringStrategyType {
  PointBased = 'POINT_BASED',
  WeightBased = 'WEIGHT_BASED'
}

export type CompassScorecardTypesFilter = {
  /** The types of scorecards to filter on, for example CUSTOM. */
  in: Array<Scalars['String']['input']>;
};

/** Accepts input to find available scorecards, optionally filtered and/or sorted. */
export type CompassScorecardsQuery = {
  /** Returns the scorecards after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Returns only scorecards whose attributes match those in the filters specified. */
  filter?: InputMaybe<CompassScorecardQueryFilter>;
  /** The first N number of scorecards to return in the query. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Returns scorecards according to the sorting scheme specified. */
  sort?: InputMaybe<CompassScorecardQuerySort>;
};

/** The query to find component labels within Compass. */
export type CompassSearchComponentLabelsQuery = {
  /** Returns results after the specified cursor. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Number of results to return in the query. The default is 25. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Text query to search against. */
  query?: InputMaybe<Scalars['String']['input']>;
  /** Sorting parameters for the results to be searched for. The default is by ranked results. */
  sort?: InputMaybe<Array<InputMaybe<CompassQuerySort>>>;
};

/** The query to find components. */
export type CompassSearchComponentQuery = {
  /** Returns results after the specified cursor. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Filters on component fields to be searched against. */
  fieldFilters?: InputMaybe<Array<InputMaybe<CompassQueryFieldFilter>>>;
  /** Number of results to return in the query. The default is 25. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Text query to search against. */
  query?: InputMaybe<Scalars['String']['input']>;
  /** How the query results will be sorted. This is essential for proper pagination of results. */
  sort?: InputMaybe<Array<InputMaybe<CompassQuerySort>>>;
};

/** Accepts input for searching team labels. */
export type CompassSearchTeamLabelsInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
};

export type CompassSearchTeamsInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
  /** A list of possible labels to filter by. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The possible term to search teams by. */
  term?: InputMaybe<Scalars['String']['input']>;
};

export type CompassSloMetricSourceConfigurationInput = {
  /** External configuration bad metrics query */
  badQuery: Scalars['String']['input'];
  /** External configuration good metrics query */
  goodQuery: Scalars['String']['input'];
};

export type CompassSynchronizeLinkAssociationsInput = {
  /** The cloud ID of the site to synchronize link associations on. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the Forge app to query for link association information */
  forgeAppId: Scalars['ID']['input'];
  /** The parameters to synchronize link associations on. */
  options?: InputMaybe<CompassSynchronizeLinkAssociationsOptions>;
};

export type CompassSynchronizeLinkAssociationsOptions = {
  /** The event types to synchronize link associations on. */
  eventTypes?: InputMaybe<Array<InputMaybe<CompassEventType>>>;
};

/** Accepts input for creating/updating/deleting team checkin's action item. */
export type CompassTeamCheckinActionInput = {
  create?: InputMaybe<CompassCreateTeamCheckinActionInput>;
  delete?: InputMaybe<CompassDeleteTeamCheckinActionInput>;
  update?: InputMaybe<CompassUpdateTeamCheckinActionInput>;
};

/** Accepts input for deleting a team checkin. */
export type CompassTeamCheckinsInput = {
  /** The cloud ID of the site to update a checkin on. */
  cloudId: Scalars['ID']['input'];
  /** The unique identifier (ID) of the team that did the checkin. */
  teamId: Scalars['ID']['input'];
};

/** Accepts input for viewing Compass-specific data about a team. */
export type CompassTeamDataInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
  /** The unique identifier (ID) of the target team. */
  teamId: Scalars['ID']['input'];
};

/** Accepts input for updating a component announcement. */
export type CompassUpdateAnnouncementInput = {
  /** Whether the existing acknowledgements should be reset or not. */
  clearAcknowledgements?: InputMaybe<Scalars['Boolean']['input']>;
  /** The cloud ID of the site to update an announcement on. */
  cloudId: Scalars['ID']['input'];
  /** The description of the announcement. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the announcement being updated. */
  id: Scalars['ID']['input'];
  /** The date on which the changes in the announcement will take effect. */
  targetDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** The title of the announcement. */
  title?: InputMaybe<Scalars['String']['input']>;
};

export type CompassUpdateCampaignInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  dueDate?: InputMaybe<Scalars['DateTime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for updating a Component Scorecard Jira issue. */
export type CompassUpdateComponentScorecardJiraIssueInput = {
  /** The ID of the component. */
  componentId: Scalars['ID']['input'];
  /** Whether a Component scorecard issue is active or not. */
  isActive: Scalars['Boolean']['input'];
  /** The ID of the Jira issue. */
  issueId: Scalars['ID']['input'];
  /** The ID of the scorecard. */
  scorecardId: Scalars['ID']['input'];
};

/** Accepts input for updating a custom boolean field definition. */
export type CompassUpdateCustomBooleanFieldDefinitionInput = {
  /** The component types the custom boolean field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom boolean field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom boolean field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom boolean field definition. */
  id: Scalars['ID']['input'];
  /** The name of the custom boolean field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for updating a custom field definition. You must provide exactly one of the fields in this input type. */
export type CompassUpdateCustomFieldDefinitionInput = {
  /** Input for updating a custom boolean field definition. */
  booleanFieldDefinition?: InputMaybe<CompassUpdateCustomBooleanFieldDefinitionInput>;
  /** Input for updating a custom multi-select field definition. */
  multiSelectFieldDefinition?: InputMaybe<CompassUpdateCustomMultiSelectFieldDefinitionInput>;
  /** Input for updating a custom number field definition. */
  numberFieldDefinition?: InputMaybe<CompassUpdateCustomNumberFieldDefinitionInput>;
  /** Input for updating a custom single-select field definition. */
  singleSelectFieldDefinition?: InputMaybe<CompassUpdateCustomSingleSelectFieldDefinitionInput>;
  /** Input for updating a custom text field definition. */
  textFieldDefinition?: InputMaybe<CompassUpdateCustomTextFieldDefinitionInput>;
  /** Input for updating a custom user field definition. */
  userFieldDefinition?: InputMaybe<CompassUpdateCustomUserFieldDefinitionInput>;
};

/** Accepts input for updating a custom multi select field definition. */
export type CompassUpdateCustomMultiSelectFieldDefinitionInput = {
  /** The component types the custom multi-select field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A list of options to create. */
  createOptions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of options to delete. */
  deleteOptions?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The description of the custom multi-select field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom multi-select field definition. */
  id: Scalars['ID']['input'];
  /** The name of the custom multi-select field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for updating a custom number field definition. */
export type CompassUpdateCustomNumberFieldDefinitionInput = {
  /** The component types the custom number field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom number field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom number field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom number field definition. */
  id: Scalars['ID']['input'];
  /** The name of the custom number field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type CompassUpdateCustomPermissionConfigsInput = {
  preset?: InputMaybe<CompassCustomPermissionPreset>;
};

/** Accepts input for updating a custom single select field definition. */
export type CompassUpdateCustomSingleSelectFieldDefinitionInput = {
  /** The component types the custom single-select field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A list of options to create. */
  createOptions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of options to delete. */
  deleteOptions?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The description of the custom single-select field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom single-select field definition. */
  id: Scalars['ID']['input'];
  /** The name of the custom single-select field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for updating a custom text field definition. */
export type CompassUpdateCustomTextFieldDefinitionInput = {
  /** The component types the custom text field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom text field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom text field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom text field definition. */
  id: Scalars['ID']['input'];
  /** The name of the custom text field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for updating a custom user field definition. */
export type CompassUpdateCustomUserFieldDefinitionInput = {
  /** The component types the custom user field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom user field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom user field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom user field definition. */
  id: Scalars['ID']['input'];
  /** The name of the custom user field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type CompassUpdateDocumentInput = {
  /** The ID of the documentation category the document was added to. */
  documentationCategoryId?: InputMaybe<Scalars['ID']['input']>;
  /** The ARI of the document to update. */
  id: Scalars['ID']['input'];
  /** The (optional) display title of the document. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the document. */
  url?: InputMaybe<Scalars['URL']['input']>;
};

/** Accepts input to update a scorecard criterion checking the value of a specified custom boolean field. */
export type CompassUpdateHasCustomBooleanFieldScorecardCriteriaInput = {
  /** The comparison operation to be performed. */
  booleanComparator?: InputMaybe<CompassCriteriaBooleanComparatorOptions>;
  /** The value that the field is compared to. */
  booleanComparatorValue?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the component custom boolean field to check the value of. */
  customFieldDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassUpdateHasCustomMultiSelectFieldScorecardCriteriaInput = {
  /** The comparison operation to be performed between the field and comparator value. */
  collectionComparator?: InputMaybe<CompassCriteriaCollectionComparatorOptions>;
  /** The list of multi select options that the field is compared to. */
  collectionComparatorValue?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The ID of the component custom multi select field to check the value of. */
  customFieldDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to update a scorecard criterion checking the value of a specified custom number field. */
export type CompassUpdateHasCustomNumberFieldScorecardCriteriaInput = {
  /** The ID of the component custom number field to check the value of. */
  customFieldDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The comparison operation to be performed between the field and comparator value. */
  numberComparator?: InputMaybe<CompassCriteriaNumberComparatorOptions>;
  /** The threshold value that the field is compared to. */
  numberComparatorValue?: InputMaybe<Scalars['Float']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassUpdateHasCustomSingleSelectFieldScorecardCriteriaInput = {
  /** The ID of the component custom single select field to check the value of. */
  customFieldDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The comparison operation to be performed between the field and comparator value. */
  membershipComparator?: InputMaybe<CompassCriteriaMembershipComparatorOptions>;
  /** The list of single select options that the field is compared to. */
  membershipComparatorValue?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to update a scorecard criterion checking the value of a specified custom text field. */
export type CompassUpdateHasCustomTextFieldScorecardCriteriaInput = {
  /** The ID of the component custom text field to check the value of. */
  customFieldDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** The input to update a metric definition. */
export type CompassUpdateMetricDefinitionInput = {
  /** The cloud ID of the built in metric definition being updated */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The updated description of the metric definition. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The updated format option of the metric definition. */
  format?: InputMaybe<CompassMetricDefinitionFormatInput>;
  /** The ID of the metric definition being updated. */
  id: Scalars['ID']['input'];
  isPinned?: InputMaybe<Scalars['Boolean']['input']>;
  /** The updated name of the metric definition. */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type CompassUpdateScorecardCriteriaScoringStrategyRulesInput = {
  onFalse?: InputMaybe<CompassScorecardCriteriaScoringStrategyRuleAction>;
  onTrue?: InputMaybe<CompassScorecardCriteriaScoringStrategyRuleAction>;
};

/** Accepts input for updating a team checkin action. */
export type CompassUpdateTeamCheckinActionInput = {
  /** The text of the team checkin action item. */
  actionText?: InputMaybe<Scalars['String']['input']>;
  /** Whether the action is completed or not. */
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the team checkin action item. */
  id: Scalars['ID']['input'];
};

/** Accepts input for updating a team checkin. */
export type CompassUpdateTeamCheckinInput = {
  /** A list of action items belong to the checkin. */
  actions?: InputMaybe<Array<CompassTeamCheckinActionInput>>;
  /** The cloud ID of the site to update a checkin on. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the team checkin being updated. */
  id: Scalars['ID']['input'];
  /** The mood of the team checkin. */
  mood: Scalars['Int']['input'];
  /** The response to the question 1 of the team checkin. */
  response1?: InputMaybe<Scalars['String']['input']>;
  /** The response to the question 1 of the team checkin in a rich text format. */
  response1RichText?: InputMaybe<CompassUpdateTeamCheckinResponseRichText>;
  /** The response to the question 2 of the team checkin. */
  response2?: InputMaybe<Scalars['String']['input']>;
  /** The response to the question 2 of the team checkin in a rich text format. */
  response2RichText?: InputMaybe<CompassUpdateTeamCheckinResponseRichText>;
  /** The response to the question 3 of the team checkin. */
  response3?: InputMaybe<Scalars['String']['input']>;
  /** The response to the question 3 of the team checkin in a rich text format. */
  response3RichText?: InputMaybe<CompassUpdateTeamCheckinResponseRichText>;
};

/** Accepts input for updating team checkin responses with rich text. */
export type CompassUpdateTeamCheckinResponseRichText = {
  /** Input for a team checkin response in Atlassian Document Format. */
  adf?: InputMaybe<Scalars['String']['input']>;
};

/** Complete sprint */
export type CompleteSprintInput = {
  boardId: Scalars['ID']['input'];
  incompleteCardsDestination: SoftwareCardsDestination;
  sprintId: Scalars['ID']['input'];
};

/** Details on the result of the last component sync. */
export type ComponentSyncEventInput = {
  /** Error messages explaining why last sync event failed. */
  lastSyncErrors?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Status of the last sync event. */
  status: ComponentSyncEventStatus;
};

/** Status types of a data manager sync event. */
export enum ComponentSyncEventStatus {
  /** A Compass internal server issue prevented the sync from occurring. */
  ServerError = 'SERVER_ERROR',
  /** The component updates were successfully synced to Compass. */
  Success = 'SUCCESS',
  /** An issue with the calling app or user input prevented the component from syncing to Compass. */
  UserError = 'USER_ERROR'
}

export type ConfigurePolarisRefreshInput = {
  autoRefreshTimeSeconds?: InputMaybe<Scalars['Int']['input']>;
  clearError?: InputMaybe<Scalars['Boolean']['input']>;
  /**  either an issue, an insight, or a snippet */
  disable?: InputMaybe<Scalars['Boolean']['input']>;
  project: Scalars['ID']['input'];
  setError?: InputMaybe<PolarisRefreshError>;
  subject?: InputMaybe<Scalars['ID']['input']>;
  timeToLiveSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export enum ConfluenceBlogPostStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Deleted = 'DELETED',
  Draft = 'DRAFT',
  Historical = 'HISTORICAL',
  Trashed = 'TRASHED'
}

export enum ConfluenceBodyRepresentation {
  AnonymousExportView = 'ANONYMOUS_EXPORT_VIEW',
  AtlasDocFormat = 'ATLAS_DOC_FORMAT',
  Dynamic = 'DYNAMIC',
  Editor = 'EDITOR',
  Editor2 = 'EDITOR2',
  ExportView = 'EXPORT_VIEW',
  Storage = 'STORAGE',
  StyledView = 'STYLED_VIEW',
  View = 'VIEW'
}

export enum ConfluenceCollaborativeEditingService {
  Ncs = 'NCS',
  Synchrony = 'SYNCHRONY'
}

export enum ConfluenceCommentStatus {
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export enum ConfluenceCommentType {
  Footer = 'FOOTER',
  Inline = 'INLINE'
}

export type ConfluenceContentBodyInput = {
  representation: ConfluenceContentRepresentation;
  value: Scalars['String']['input'];
};

export enum ConfluenceContentRepresentation {
  AtlasDocFormat = 'ATLAS_DOC_FORMAT',
  Editor = 'EDITOR',
  Editor2 = 'EDITOR2',
  ExportView = 'EXPORT_VIEW',
  Plain = 'PLAIN',
  Raw = 'RAW',
  Storage = 'STORAGE',
  StyledView = 'STYLED_VIEW',
  View = 'VIEW',
  Wiki = 'WIKI'
}

export enum ConfluenceContentType {
  Attachment = 'ATTACHMENT',
  BlogPost = 'BLOG_POST',
  Comment = 'COMMENT',
  Page = 'PAGE',
  Whiteboard = 'WHITEBOARD'
}

export enum ConfluenceContributionStatus {
  Current = 'CURRENT',
  Draft = 'DRAFT',
  Unknown = 'UNKNOWN',
  Unpublished = 'UNPUBLISHED'
}

export type ConfluenceCreateBlogPostInput = {
  body?: InputMaybe<ConfluenceContentBodyInput>;
  spaceId: Scalars['ID']['input'];
  /** Status with which the BlogPost will be created. Defaults to CURRENT status. */
  status?: InputMaybe<ConfluenceMutationContentStatus>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceCreateBlogPostPropertyInput = {
  blogPostId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ConfluenceCreateFooterCommentOnBlogPostInput = {
  blogPostId: Scalars['ID']['input'];
  body: ConfluenceContentBodyInput;
};

export type ConfluenceCreateFooterCommentOnPageInput = {
  body: ConfluenceContentBodyInput;
  pageId: Scalars['ID']['input'];
};

export type ConfluenceCreatePageInput = {
  body?: InputMaybe<ConfluenceContentBodyInput>;
  spaceId: Scalars['ID']['input'];
  /** Status with which the Page will be created. Defaults to CURRENT status. */
  status?: InputMaybe<ConfluenceMutationContentStatus>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceCreatePagePropertyInput = {
  key: Scalars['String']['input'];
  pageId: Scalars['ID']['input'];
  value: Scalars['String']['input'];
};

export type ConfluenceCreateSpaceInput = {
  key: Scalars['String']['input'];
  name: Scalars['String']['input'];
  type?: InputMaybe<ConfluenceSpaceType>;
};

export type ConfluenceDeleteBlogPostPropertyInput = {
  blogPostId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
};

export type ConfluenceDeleteCommentInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceDeleteDraftBlogPostInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceDeleteDraftPageInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceDeletePagePropertyInput = {
  key: Scalars['String']['input'];
  pageId: Scalars['ID']['input'];
};

export enum ConfluenceInlineCommentResolutionStatus {
  Resolved = 'RESOLVED',
  Unresolved = 'UNRESOLVED'
}

export enum ConfluenceInlineTaskStatus {
  Complete = 'COMPLETE',
  Incomplete = 'INCOMPLETE'
}

/**  --------------------------------------------------------------------------------------------- */
export enum ConfluenceLegacyAccessStatus {
  AnonymousAccess = 'ANONYMOUS_ACCESS',
  ExternalCollaboratorAccess = 'EXTERNAL_COLLABORATOR_ACCESS',
  ExternalShareAccess = 'EXTERNAL_SHARE_ACCESS',
  LicensedAdminAccess = 'LICENSED_ADMIN_ACCESS',
  LicensedUseAccess = 'LICENSED_USE_ACCESS',
  NotPermitted = 'NOT_PERMITTED',
  UnlicensedAuthenticatedAccess = 'UNLICENSED_AUTHENTICATED_ACCESS'
}

export enum ConfluenceLegacyAccessType {
  Edit = 'EDIT',
  View = 'VIEW'
}

export enum ConfluenceLegacyAccountType {
  App = 'APP',
  Atlassian = 'ATLASSIAN',
  Customer = 'CUSTOMER',
  Unknown = 'UNKNOWN'
}

export type ConfluenceLegacyActivatePaywallContentInput = {
  contentIdToActivate: Scalars['ID']['input'];
  deactivationIdentifier?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceLegacyAddDefaultExCoSpacePermissionsInput = {
  accountIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  groupIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  groupNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  spaceKeys: Array<InputMaybe<Scalars['String']['input']>>;
};

/**  --------------------------------------------------------------------------------------------- */
export type ConfluenceLegacyAddLabelsInput = {
  contentId: Scalars['ID']['input'];
  labels: Array<ConfluenceLegacyLabelInput>;
};

export type ConfluenceLegacyAddPublicLinkPermissionsInput = {
  objectId: Scalars['ID']['input'];
  objectType: ConfluenceLegacyPublicLinkPermissionsObjectType;
  permissions: Array<ConfluenceLegacyPublicLinkPermissionsType>;
};

export enum ConfluenceLegacyAdminAnnouncementBannerSettingsByCriteriaOrder {
  Default = 'DEFAULT',
  ScheduledEndDate = 'SCHEDULED_END_DATE',
  ScheduledStartDate = 'SCHEDULED_START_DATE',
  Visibility = 'VISIBILITY'
}

export enum ConfluenceLegacyAdminAnnouncementBannerStatusType {
  Published = 'PUBLISHED',
  Saved = 'SAVED',
  Scheduled = 'SCHEDULED'
}

export enum ConfluenceLegacyAdminAnnouncementBannerVisibilityType {
  All = 'ALL',
  Authorized = 'AUTHORIZED'
}

export enum ConfluenceLegacyAllUpdatesFeedEventType {
  Comment = 'COMMENT',
  Create = 'CREATE',
  Edit = 'EDIT'
}

export enum ConfluenceLegacyAnalyticsCommentType {
  Inline = 'inline',
  Page = 'page'
}

export enum ConfluenceLegacyAnalyticsContentType {
  Blogpost = 'blogpost',
  Page = 'page'
}

/** Events to gather analytics for */
export enum ConfluenceLegacyAnalyticsEventName {
  AnalyticsPageModalViewed = 'analyticsPageModal_viewed',
  AutomationRuleTrackCreated = 'automationRuleTrack_created',
  CalendarCreated = 'calendar_created',
  CommentCreated = 'comment_created',
  DatabaseCreated = 'database_created',
  DatabaseViewed = 'database_viewed',
  InspectPermissionsDialogViewed = 'inspectPermissionsDialog_viewed',
  InstanceAnalyticsViewed = 'instanceAnalytics_viewed',
  PageAnalyticsViewed = 'pageAnalytics_viewed',
  PageCreated = 'page_created',
  PageUpdated = 'page_updated',
  PageViewed = 'page_viewed',
  PubliclinkPageViewed = 'publiclink_page_viewed',
  SpaceAnalyticsViewed = 'spaceAnalytics_viewed',
  TeamCalendarsViewed = 'teamCalendars_viewed',
  WhiteboardCreated = 'whiteboard_created',
  WhiteboardViewed = 'whiteboard_viewed'
}

/** Events to gather measure analytics for */
export enum ConfluenceLegacyAnalyticsMeasuresEventName {
  CurrentBlogpostCountSitestateMeasured = 'currentBlogpostCount_sitestate_measured',
  CurrentBlogpostCountSpacestateMeasured = 'currentBlogpostCount_spacestate_measured',
  CurrentDatabaseCountSitestateMeasured = 'currentDatabaseCount_sitestate_measured',
  CurrentDatabaseCountSpacestateMeasured = 'currentDatabaseCount_spacestate_measured',
  CurrentPageCountSitestateMeasured = 'currentPageCount_sitestate_measured',
  CurrentPageCountSpacestateMeasured = 'currentPageCount_spacestate_measured',
  CurrentWhiteboardCountSitestateMeasured = 'currentWhiteboardCount_sitestate_measured',
  CurrentWhiteboardCountSpacestateMeasured = 'currentWhiteboardCount_spacestate_measured',
  InactivePageCountSitestateMeasured = 'inactivePageCount_sitestate_measured',
  InactivePageCountSpacestateMeasured = 'inactivePageCount_spacestate_measured',
  TotalActiveCommunalSpacesSitestateMeasured = 'totalActiveCommunalSpaces_sitestate_measured',
  TotalActivePersonalSpacesSitestateMeasured = 'totalActivePersonalSpaces_sitestate_measured',
  TotalActivePublicLinksSitestateMeasured = 'totalActivePublicLinks_sitestate_measured',
  TotalActivePublicLinksSpacestateMeasured = 'totalActivePublicLinks_spacestate_measured',
  TotalActiveSpacesSitestateMeasured = 'totalActiveSpaces_sitestate_measured',
  TotalCurrentBlogpostCountSitestateMeasured = 'totalCurrentBlogpostCount_sitestate_measured',
  TotalCurrentDatabaseCountSitestateMeasured = 'totalCurrentDatabaseCount_sitestate_measured',
  TotalCurrentPageCountSitestateMeasured = 'totalCurrentPageCount_sitestate_measured',
  TotalCurrentWhiteboardCountSitestateMeasured = 'totalCurrentWhiteboardCount_sitestate_measured',
  TotalPagesDeactivatedOwnerSitestateMeasured = 'totalPagesDeactivatedOwner_sitestate_measured',
  TotalPagesDeactivatedOwnerSpacestateMeasured = 'totalPagesDeactivatedOwner_spacestate_measured'
}

/** Events to gather measure analytics space state */
export enum ConfluenceLegacyAnalyticsMeasuresSpaceEventName {
  CurrentBlogpostCountSpacestateMeasured = 'currentBlogpostCount_spacestate_measured',
  CurrentDatabaseCountSpacestateMeasured = 'currentDatabaseCount_spacestate_measured',
  CurrentPageCountSpacestateMeasured = 'currentPageCount_spacestate_measured',
  CurrentWhiteboardCountSpacestateMeasured = 'currentWhiteboardCount_spacestate_measured',
  InactivePageCountSpacestateMeasured = 'inactivePageCount_spacestate_measured',
  TotalActivePublicLinksSpacestateMeasured = 'totalActivePublicLinks_spacestate_measured',
  TotalPagesDeactivatedOwnerSpacestateMeasured = 'totalPagesDeactivatedOwner_spacestate_measured'
}

/** Events to gather search analytics for */
export enum ConfluenceLegacyAnalyticsSearchEventName {
  AdvancedSearchResultLinkClicked = 'advancedSearchResultLink_clicked',
  AdvancedSearchResultsShown = 'advancedSearchResults_shown',
  QuickSearchRequestCompleted = 'quickSearchRequest_completed',
  QuickSearchResultSelected = 'quickSearchResult_selected'
}

/** Granularity to group events by */
export enum ConfluenceLegacyAnalyticsTimeseriesGranularity {
  Day = 'DAY',
  Hour = 'HOUR',
  Month = 'MONTH',
  Week = 'WEEK'
}

export type ConfluenceLegacyAnonymousWithPermissionsInput = {
  operations: Array<InputMaybe<ConfluenceLegacyOperationCheckResultInput>>;
};

export enum ConfluenceLegacyBackendExperiment {
  Einstein = 'EINSTEIN'
}

export type ConfluenceLegacyBatchedInlineTasksInput = {
  contentId: Scalars['ID']['input'];
  tasks: Array<InputMaybe<ConfluenceLegacyInlineTaskInput>>;
  trigger?: InputMaybe<ConfluenceLegacyPageUpdateTrigger>;
};

export enum ConfluenceLegacyBillingSourceSystem {
  Ccp = 'CCP',
  Hams = 'HAMS'
}

export enum ConfluenceLegacyBodyFormatType {
  AnonymousExportView = 'ANONYMOUS_EXPORT_VIEW',
  AtlasDocFormat = 'ATLAS_DOC_FORMAT',
  Editor = 'EDITOR',
  Editor2 = 'EDITOR2',
  ExportView = 'EXPORT_VIEW',
  Storage = 'STORAGE',
  StyledView = 'STYLED_VIEW',
  View = 'VIEW'
}

export type ConfluenceLegacyBulkArchivePagesInput = {
  archiveNote?: InputMaybe<Scalars['String']['input']>;
  areChildrenIncluded?: InputMaybe<Scalars['Boolean']['input']>;
  descendantsNoteApplicationOption?: InputMaybe<ConfluenceLegacyDescendantsNoteApplicationOption>;
  excludedBranchRootPageIDs?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  isSelected?: InputMaybe<Scalars['Boolean']['input']>;
  pageID: Scalars['Long']['input'];
};

export type ConfluenceLegacyBulkDeleteContentDataClassificationLevelInput = {
  contentStatuses: Array<InputMaybe<ConfluenceLegacyContentDataClassificationMutationContentStatus>>;
  id: Scalars['Long']['input'];
};

export type ConfluenceLegacyBulkSetSpacePermissionInput = {
  spacePermissions: Array<InputMaybe<ConfluenceLegacySpacePermissionType>>;
  spaceTypes: Array<InputMaybe<ConfluenceLegacyBulkSetSpacePermissionSpaceType>>;
  subjectId: Scalars['ID']['input'];
  subjectType: ConfluenceLegacyBulkSetSpacePermissionSubjectType;
};

export enum ConfluenceLegacyBulkSetSpacePermissionSpaceType {
  Collaboration = 'COLLABORATION',
  Global = 'GLOBAL',
  KnowledgeBase = 'KNOWLEDGE_BASE',
  Personal = 'PERSONAL'
}

export enum ConfluenceLegacyBulkSetSpacePermissionSubjectType {
  Group = 'GROUP',
  User = 'USER'
}

export type ConfluenceLegacyBulkUpdateContentDataClassificationLevelInput = {
  classificationLevelId: Scalars['ID']['input'];
  contentStatuses: Array<InputMaybe<ConfluenceLegacyContentDataClassificationMutationContentStatus>>;
  id: Scalars['Long']['input'];
};

export type ConfluenceLegacyBulkUpdateMainSpaceSidebarLinksInput = {
  hidden: Scalars['Boolean']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  linkIdentifier?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ConfluenceLegacySpaceSidebarLinkType>;
};

export enum ConfluenceLegacyCatchupContentType {
  Blogpost = 'BLOGPOST',
  Page = 'PAGE'
}

export enum ConfluenceLegacyCatchupUpdateType {
  TopN = 'TOP_N'
}

export type ConfluenceLegacyCommentBody = {
  representationFormat: ConfluenceLegacyContentRepresentation;
  value: Scalars['String']['input'];
};

export enum ConfluenceLegacyCommentCreationLocation {
  Editor = 'EDITOR',
  Live = 'LIVE',
  Renderer = 'RENDERER',
  Whiteboard = 'WHITEBOARD'
}

export enum ConfluenceLegacyCommentDeletionLocation {
  Live = 'LIVE'
}

export enum ConfluenceLegacyCommentReplyType {
  Emoji = 'EMOJI',
  Prompt = 'PROMPT',
  QuickReply = 'QUICK_REPLY'
}

export enum ConfluenceLegacyCommentType {
  Footer = 'FOOTER',
  Inline = 'INLINE',
  Resolved = 'RESOLVED',
  Unresolved = 'UNRESOLVED'
}

export enum ConfluenceLegacyCommentsType {
  Footer = 'FOOTER',
  Inline = 'INLINE'
}

export type ConfluenceLegacyContactAdminMutationInput = {
  content: ConfluenceLegacyContactAdminMutationInputContent;
  recaptchaResponseToken?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceLegacyContactAdminMutationInputContent = {
  from: Scalars['String']['input'];
  requestDetails: Scalars['String']['input'];
  subject: Scalars['String']['input'];
};

export enum ConfluenceLegacyContactAdminPageDisabledReason {
  ConfigOff = 'CONFIG_OFF',
  NoAdminEmails = 'NO_ADMIN_EMAILS',
  NoMailServer = 'NO_MAIL_SERVER',
  NoRecaptcha = 'NO_RECAPTCHA'
}

/**  --------------------------------------------------------------------------------------------- */
export enum ConfluenceLegacyContainerType {
  Blogpost = 'BLOGPOST',
  Page = 'PAGE',
  Space = 'SPACE',
  Whiteboard = 'WHITEBOARD'
}

export enum ConfluenceLegacyContentAccessInputType {
  EveryoneCanEdit = 'EVERYONE_CAN_EDIT',
  EveryoneCanView = 'EVERYONE_CAN_VIEW',
  EveryoneNoAccess = 'EVERYONE_NO_ACCESS',
  Private = 'PRIVATE'
}

export enum ConfluenceLegacyContentAccessType {
  EveryoneCanEdit = 'EVERYONE_CAN_EDIT',
  EveryoneCanView = 'EVERYONE_CAN_VIEW',
  EveryoneNoAccess = 'EVERYONE_NO_ACCESS'
}

export enum ConfluenceLegacyContentAction {
  Created = 'created',
  Updated = 'updated',
  Viewed = 'viewed'
}

export type ConfluenceLegacyContentBodyInput = {
  representation: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export enum ConfluenceLegacyContentDataClassificationMutationContentStatus {
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export enum ConfluenceLegacyContentDataClassificationQueryContentStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export enum ConfluenceLegacyContentDeleteActionType {
  DeleteDraft = 'DELETE_DRAFT',
  DeleteDraftIfBlank = 'DELETE_DRAFT_IF_BLANK',
  MoveToTrash = 'MOVE_TO_TRASH',
  PurgeFromTrash = 'PURGE_FROM_TRASH'
}

export enum ConfluenceLegacyContentPermissionType {
  Edit = 'EDIT',
  View = 'VIEW'
}

export enum ConfluenceLegacyContentRendererMode {
  Editor = 'EDITOR',
  Pdf = 'PDF',
  Renderer = 'RENDERER'
}

export enum ConfluenceLegacyContentRepresentation {
  AtlasDocFormat = 'ATLAS_DOC_FORMAT',
  Editor = 'EDITOR',
  Editor2 = 'EDITOR2',
  ExportView = 'EXPORT_VIEW',
  Plain = 'PLAIN',
  Raw = 'RAW',
  Storage = 'STORAGE',
  StyledView = 'STYLED_VIEW',
  View = 'VIEW',
  Wiki = 'WIKI'
}

export enum ConfluenceLegacyContentRole {
  Default = 'DEFAULT',
  Editor = 'EDITOR',
  Viewer = 'VIEWER'
}

export type ConfluenceLegacyContentSpecificCreateInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ConfluenceLegacyContentStateInput = {
  color?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Long']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
};

export enum ConfluenceLegacyContentStateRestrictionLevel {
  None = 'NONE',
  PageOwner = 'PAGE_OWNER'
}

export enum ConfluenceLegacyContentStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Deleted = 'DELETED',
  Draft = 'DRAFT'
}

export type ConfluenceLegacyContentTemplateBodyInput = {
  atlasDocFormat: ConfluenceLegacyContentBodyInput;
};

export type ConfluenceLegacyContentTemplateLabelInput = {
  id: Scalars['ID']['input'];
  label?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  prefix?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceLegacyContentTemplateSpaceInput = {
  key: Scalars['String']['input'];
};

export enum ConfluenceLegacyContentTemplateType {
  Blueprint = 'BLUEPRINT',
  Page = 'PAGE'
}

export type ConfluenceLegacyConvertPageToLiveEditActionInput = {
  contentId: Scalars['ID']['input'];
};

export type ConfluenceLegacyCreateAdminAnnouncementBannerInput = {
  appearance: Scalars['String']['input'];
  content: Scalars['String']['input'];
  isDismissible: Scalars['Boolean']['input'];
  scheduledEndTime?: InputMaybe<Scalars['String']['input']>;
  scheduledStartTime?: InputMaybe<Scalars['String']['input']>;
  scheduledTimeZone?: InputMaybe<Scalars['String']['input']>;
  status: ConfluenceLegacyAdminAnnouncementBannerStatusType;
  title?: InputMaybe<Scalars['String']['input']>;
  visibility: ConfluenceLegacyAdminAnnouncementBannerVisibilityType;
};

export type ConfluenceLegacyCreateCommentInput = {
  commentBody: ConfluenceLegacyCommentBody;
  commentSource?: InputMaybe<ConfluenceLegacyPlatform>;
  containerId: Scalars['ID']['input'];
  parentCommentId?: InputMaybe<Scalars['ID']['input']>;
};

export type ConfluenceLegacyCreateContentInput = {
  contentSpecificCreateInput?: InputMaybe<Array<ConfluenceLegacyContentSpecificCreateInput>>;
  parentId?: InputMaybe<Scalars['ID']['input']>;
  spaceId?: InputMaybe<Scalars['String']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
  status: ConfluenceLegacyContentStatus;
  title?: InputMaybe<Scalars['String']['input']>;
  type: Scalars['String']['input'];
};

export type ConfluenceLegacyCreateContentTemplateInput = {
  body: ConfluenceLegacyContentTemplateBodyInput;
  description?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<InputMaybe<ConfluenceLegacyContentTemplateLabelInput>>>;
  name: Scalars['String']['input'];
  space?: InputMaybe<ConfluenceLegacyContentTemplateSpaceInput>;
  templateType: ConfluenceLegacyContentTemplateType;
};

export type ConfluenceLegacyCreateContentTemplateLabelsInput = {
  contentTemplateId: Scalars['ID']['input'];
  labels: Array<InputMaybe<ConfluenceLegacyContentTemplateLabelInput>>;
};

export type ConfluenceLegacyCreateFaviconFilesInput = {
  fileStoreId: Scalars['ID']['input'];
};

export type ConfluenceLegacyCreateInlineCommentInput = {
  commentBody: ConfluenceLegacyCommentBody;
  commentSource?: InputMaybe<ConfluenceLegacyPlatform>;
  containerId: Scalars['ID']['input'];
  createdFrom: ConfluenceLegacyCommentCreationLocation;
  lastFetchTimeMillis: Scalars['Long']['input'];
  /** matchIndex must be greater than or equal to 0. */
  matchIndex: Scalars['Int']['input'];
  /** numMatches must be positive and greater than matchIndex. */
  numMatches: Scalars['Int']['input'];
  originalSelection: Scalars['String']['input'];
  parentCommentId?: InputMaybe<Scalars['ID']['input']>;
  publishedVersion?: InputMaybe<Scalars['Int']['input']>;
  step?: InputMaybe<ConfluenceLegacyStep>;
};

export type ConfluenceLegacyCreateInlineContentInput = {
  contentSpecificCreateInput?: InputMaybe<Array<ConfluenceLegacyContentSpecificCreateInput>>;
  createdInContentId: Scalars['ID']['input'];
  spaceId?: InputMaybe<Scalars['String']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  type: Scalars['String']['input'];
};

export type ConfluenceLegacyCreateInlineTaskNotificationInput = {
  contentId: Scalars['ID']['input'];
  tasks: Array<InputMaybe<ConfluenceLegacyIndividualInlineTaskNotificationInput>>;
};

export type ConfluenceLegacyCreateLivePageInput = {
  parentId?: InputMaybe<Scalars['ID']['input']>;
  spaceKey: Scalars['String']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceLegacyCreateMentionNotificationInput = {
  contentId: Scalars['ID']['input'];
  mentionLocalId?: InputMaybe<Scalars['ID']['input']>;
  mentionedUserAccountId: Scalars['ID']['input'];
};

export type ConfluenceLegacyCreateMentionReminderNotificationInput = {
  contentId: Scalars['ID']['input'];
  mentionData: Array<ConfluenceLegacyMentionData>;
};

export type ConfluenceLegacyCreatePersonalSpaceInput = {
  /** Fetches the Space Permissions from the given space key and copies them to the new space. If this field is set, it must be accompanied with field initialPermissionOption: COPY_FROM_SPACE. */
  copySpacePermissionsFromSpaceKey?: InputMaybe<Scalars['String']['input']>;
  /** if this enum is set to PRIVATE, it will take precedence over copySpacePermissionsFromSpaceKey. */
  initialPermissionOption?: InputMaybe<ConfluenceLegacyInitialPermissionOptions>;
  spaceName: Scalars['String']['input'];
};

export type ConfluenceLegacyCreateSpaceAdditionalSettingsInput = {
  jiraProject?: InputMaybe<ConfluenceLegacyCreateSpaceJiraProjectInput>;
  spaceTypeSettings?: InputMaybe<ConfluenceLegacySpaceTypeSettingsInput>;
};

export type ConfluenceLegacyCreateSpaceInput = {
  additionalSettings?: InputMaybe<ConfluenceLegacyCreateSpaceAdditionalSettingsInput>;
  /** if this field is set, it must be accompanied with field initialPermissionOption: COPY_FROM_SPACE. */
  copySpacePermissionsFromSpaceKey?: InputMaybe<Scalars['String']['input']>;
  /** if this enum is set to PRIVATE, it will take precedence over copySpacePermissionsFromSpaceKey. */
  initialPermissionOption?: InputMaybe<ConfluenceLegacyInitialPermissionOptions>;
  spaceKey: Scalars['String']['input'];
  spaceLogoDataURI?: InputMaybe<Scalars['String']['input']>;
  spaceName: Scalars['String']['input'];
  spaceTemplateKey?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceLegacyCreateSpaceJiraProjectInput = {
  jiraProjectKey: Scalars['String']['input'];
  jiraProjectName?: InputMaybe<Scalars['String']['input']>;
  jiraServerId: Scalars['String']['input'];
};

export enum ConfluenceLegacyDataSecurityPolicyAction {
  AppAccess = 'APP_ACCESS',
  PageExport = 'PAGE_EXPORT',
  PublicLinks = 'PUBLIC_LINKS'
}

export enum ConfluenceLegacyDataSecurityPolicyCoverageType {
  ClassificationLevel = 'CLASSIFICATION_LEVEL',
  Container = 'CONTAINER',
  None = 'NONE',
  Workspace = 'WORKSPACE'
}

export enum ConfluenceLegacyDataSecurityPolicyDecidableContentStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export enum ConfluenceLegacyDateFormat {
  Global = 'GLOBAL',
  Millis = 'MILLIS',
  User = 'USER',
  UserFriendly = 'USER_FRIENDLY'
}

export type ConfluenceLegacyDeactivatePaywallContentInput = {
  deactivationIdentifier: Scalars['ID']['input'];
};

export enum ConfluenceLegacyDeactivatedPageOwnerUserType {
  FormerUsers = 'FORMER_USERS',
  NonFormerUsers = 'NON_FORMER_USERS'
}

export type ConfluenceLegacyDeleteContentDataClassificationLevelInput = {
  contentStatus: ConfluenceLegacyContentDataClassificationMutationContentStatus;
  id: Scalars['Long']['input'];
};

export type ConfluenceLegacyDeleteContentTemplateLabelInput = {
  contentTemplateId: Scalars['ID']['input'];
  labelId: Scalars['ID']['input'];
};

export type ConfluenceLegacyDeleteDefaultSpaceRolesInput = {
  principalsList: Array<ConfluenceLegacyRoleAssignmentPrincipalInput>;
};

export type ConfluenceLegacyDeleteExCoSpacePermissionsInput = {
  accountId: Scalars['String']['input'];
};

export type ConfluenceLegacyDeleteInlineCommentInput = {
  commentId: Scalars['ID']['input'];
  step?: InputMaybe<ConfluenceLegacyStep>;
};

export type ConfluenceLegacyDeleteLabelInput = {
  contentId: Scalars['ID']['input'];
  label: Scalars['String']['input'];
};

export type ConfluenceLegacyDeletePagesInput = {
  areChildrenIncluded?: InputMaybe<Scalars['Boolean']['input']>;
  excludedBranchRootPageIDs?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  isSelected?: InputMaybe<Scalars['Boolean']['input']>;
  pageID: Scalars['Long']['input'];
};

export type ConfluenceLegacyDeleteRelationInput = {
  relationName: ConfluenceLegacyRelationType;
  sourceKey: Scalars['String']['input'];
  sourceType: ConfluenceLegacyRelationSourceType;
  targetKey: Scalars['String']['input'];
  targetType: ConfluenceLegacyRelationTargetType;
};

export type ConfluenceLegacyDeleteSpaceDefaultClassificationLevelInput = {
  id: Scalars['Long']['input'];
};

export type ConfluenceLegacyDeleteSpaceRolesInput = {
  principalList: Array<ConfluenceLegacyRoleAssignmentPrincipalInput>;
  spaceId: Scalars['Long']['input'];
};

export enum ConfluenceLegacyDepth {
  All = 'ALL',
  Root = 'ROOT'
}

export enum ConfluenceLegacyDescendantsNoteApplicationOption {
  All = 'ALL',
  None = 'NONE',
  Roots = 'ROOTS'
}

export enum ConfluenceLegacyDocumentRepresentation {
  AtlasDocFormat = 'ATLAS_DOC_FORMAT',
  Html = 'HTML',
  Storage = 'STORAGE',
  View = 'VIEW'
}

export enum ConfluenceLegacyEdition {
  Free = 'FREE',
  Premium = 'PREMIUM',
  Standard = 'STANDARD'
}

export enum ConfluenceLegacyEditorConversionSetting {
  None = 'NONE',
  Supported = 'SUPPORTED'
}

export type ConfluenceLegacyEnabledContentTypesInput = {
  isBlogsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isDatabasesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isEmbedsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isFoldersEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isLivePagesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isWhiteboardsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConfluenceLegacyEnabledFeaturesInput = {
  isAnalyticsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isAppsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isAutomationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isCalendarsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isContentManagerEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isQuestionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isShortcutsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/**  --------------------------------------------------------------------------------------------- */
export enum ConfluenceLegacyEnvironment {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING'
}

export enum ConfluenceLegacyExternalCollaboratorsSortField {
  Name = 'NAME'
}

export type ConfluenceLegacyExternalCollaboratorsSortType = {
  field?: InputMaybe<ConfluenceLegacyExternalCollaboratorsSortField>;
  isAscending?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConfluenceLegacyFaviconFileInput = {
  fileStoreId: Scalars['ID']['input'];
  filename: Scalars['String']['input'];
};

export type ConfluenceLegacyFavouritePageInput = {
  pageId: Scalars['ID']['input'];
};

export enum ConfluenceLegacyFeedEventType {
  Comment = 'COMMENT',
  Create = 'CREATE',
  Edit = 'EDIT'
}

export enum ConfluenceLegacyFeedItemSourceType {
  Person = 'PERSON',
  Space = 'SPACE'
}

export enum ConfluenceLegacyFeedType {
  Direct = 'DIRECT',
  Following = 'FOLLOWING',
  Popular = 'POPULAR'
}

export type ConfluenceLegacyFollowUserInput = {
  accountId: Scalars['String']['input'];
};

export enum ConfluenceLegacyFrontCoverState {
  Hidden = 'HIDDEN',
  Shown = 'SHOWN',
  Transition = 'TRANSITION',
  Unset = 'UNSET'
}

export type ConfluenceLegacyGrantContentAccessInput = {
  accessType: ConfluenceLegacyAccessType;
  accountIdOrUsername: Scalars['String']['input'];
  contentId: Scalars['String']['input'];
};

export type ConfluenceLegacyGroupWithPermissionsInput = {
  id: Scalars['ID']['input'];
  operations: Array<InputMaybe<ConfluenceLegacyOperationCheckResultInput>>;
};

export type ConfluenceLegacyHomeUserSettingsInput = {
  shouldShowActivityFeed?: InputMaybe<Scalars['Boolean']['input']>;
  shouldShowSpaces?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConfluenceLegacyHomeWidgetInput = {
  id: Scalars['ID']['input'];
  state: ConfluenceLegacyHomeWidgetState;
};

export enum ConfluenceLegacyHomeWidgetState {
  Collapsed = 'COLLAPSED',
  Expanded = 'EXPANDED'
}

export type ConfluenceLegacyIndividualInlineTaskNotificationInput = {
  operation: ConfluenceLegacyOperation;
  recipientAccountId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};

export enum ConfluenceLegacyInitialPermissionOptions {
  CopyFromSpace = 'COPY_FROM_SPACE',
  Default = 'DEFAULT',
  Private = 'PRIVATE'
}

export type ConfluenceLegacyInlineTaskInput = {
  status: ConfluenceLegacyTaskStatus;
  taskId: Scalars['ID']['input'];
};

export type ConfluenceLegacyInlineTasksByMetadata = {
  accountIds?: InputMaybe<ConfluenceLegacyInlineTasksQueryAccountIds>;
  after?: InputMaybe<Scalars['String']['input']>;
  /** The date range for an Inline Tasks' Completed Date. Start dates and end dates can be null-able to represent no specified start or end boundary. */
  completedDateRange?: InputMaybe<ConfluenceLegacyInlineTasksQueryDateRange>;
  /** The date range for an Inline Tasks' Created Date. Start dates and end dates can be null-able to represent no specified start or end boundary. */
  createdDateRange?: InputMaybe<ConfluenceLegacyInlineTasksQueryDateRange>;
  /** The date range for an Inline Tasks' Due Date. Start dates and end dates can be null-able to represent no specified start or end boundary. */
  dueDate?: InputMaybe<ConfluenceLegacyInlineTasksQueryDateRange>;
  first: Scalars['Int']['input'];
  /** A boolean value representing whether to return task on current page or on child pages as well */
  forCurrentPageOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** A boolean value representing whether or not a Task has a set due date. False indicates no due date set for a given task. */
  isNoDueDate?: InputMaybe<Scalars['Boolean']['input']>;
  pageIds?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  /** Supported sort columns for a Task query are: `due date`, `assignee`, and `page title`. Supported sort columns are `ASC` or `DESC`. */
  sortParameters?: InputMaybe<ConfluenceLegacyInlineTasksQuerySortParameters>;
  spaceIds?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  status?: InputMaybe<ConfluenceLegacyTaskStatus>;
};

export type ConfluenceLegacyInlineTasksInput = {
  cid: Scalars['ID']['input'];
  status: ConfluenceLegacyTaskStatus;
  taskId: Scalars['ID']['input'];
  trigger?: InputMaybe<ConfluenceLegacyPageUpdateTrigger>;
};

export type ConfluenceLegacyInlineTasksQueryAccountIds = {
  assigneeAccountIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  completedByAccountIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  creatorAccountIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** The date range for an Inline Tasks Query Date. Start dates and end dates can be null-able to represent no specified boundary. */
export type ConfluenceLegacyInlineTasksQueryDateRange = {
  endDate?: InputMaybe<Scalars['Long']['input']>;
  startDate?: InputMaybe<Scalars['Long']['input']>;
};

export enum ConfluenceLegacyInlineTasksQuerySortColumn {
  Assignee = 'ASSIGNEE',
  DueDate = 'DUE_DATE',
  PageTitle = 'PAGE_TITLE'
}

export enum ConfluenceLegacyInlineTasksQuerySortOrder {
  Ascending = 'ASCENDING',
  Descending = 'DESCENDING'
}

export type ConfluenceLegacyInlineTasksQuerySortParameters = {
  sortColumn: ConfluenceLegacyInlineTasksQuerySortColumn;
  sortOrder: ConfluenceLegacyInlineTasksQuerySortOrder;
};

export enum ConfluenceLegacyInspectPermissions {
  Comment = 'COMMENT',
  Edit = 'EDIT',
  View = 'VIEW'
}

export type ConfluenceLegacyLabelInput = {
  name: Scalars['String']['input'];
  prefix: Scalars['String']['input'];
};

export type ConfluenceLegacyLabelSort = {
  direction: ConfluenceLegacyLabelSortDirection;
  sortField: ConfluenceLegacyLabelSortField;
};

export enum ConfluenceLegacyLabelSortDirection {
  Ascending = 'ASCENDING',
  Descending = 'DESCENDING'
}

export enum ConfluenceLegacyLabelSortField {
  LabellingCreationdate = 'LABELLING_CREATIONDATE',
  LabellingId = 'LABELLING_ID'
}

export enum ConfluenceLegacyLicenseStatus {
  Active = 'ACTIVE',
  Suspended = 'SUSPENDED',
  Unlicensed = 'UNLICENSED'
}

export type ConfluenceLegacyLikeContentInput = {
  contentId: Scalars['ID']['input'];
};

export type ConfluenceLegacyLocalStorageBooleanPairInput = {
  key: Scalars['String']['input'];
  value?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConfluenceLegacyLocalStorageInput = {
  booleanValues?: InputMaybe<Array<InputMaybe<ConfluenceLegacyLocalStorageBooleanPairInput>>>;
  stringValues?: InputMaybe<Array<InputMaybe<ConfluenceLegacyLocalStorageStringPairInput>>>;
};

export type ConfluenceLegacyLocalStorageStringPairInput = {
  key: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export enum ConfluenceLegacyLoomUserStatus {
  Linked = 'LINKED',
  Mastered = 'MASTERED',
  NotFound = 'NOT_FOUND'
}

export type ConfluenceLegacyMark = {
  attrs?: InputMaybe<ConfluenceLegacyMarkAttribute>;
  type: Scalars['String']['input'];
};

export type ConfluenceLegacyMarkAttribute = {
  annotationType: Scalars['String']['input'];
  id: Scalars['String']['input'];
};

export type ConfluenceLegacyMarkCommentsAsReadInput = {
  commentIds: Array<Scalars['ID']['input']>;
};

export type ConfluenceLegacyMediaAttachmentInput = {
  file: ConfluenceLegacyMediaFile;
  minorEdit?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConfluenceLegacyMediaFile = {
  /**  this is the media store ID */
  id: Scalars['ID']['input'];
  /**  optional mime type of the file */
  mimeType?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /**  size of the file in bytes */
  size: Scalars['Int']['input'];
};

export type ConfluenceLegacyMentionData = {
  mentionLocalIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  mentionedUserAccountId: Scalars['ID']['input'];
};

export type ConfluenceLegacyMissionControlOverview = {
  metricOrder: Array<InputMaybe<Scalars['String']['input']>>;
  spaceId?: InputMaybe<Scalars['Long']['input']>;
};

export enum ConfluenceLegacyMobilePlatform {
  Android = 'ANDROID',
  Ios = 'IOS'
}

export type ConfluenceLegacyMoveBlogInput = {
  blogPostId: Scalars['Long']['input'];
  targetSpaceId: Scalars['Long']['input'];
};

export type ConfluenceLegacyMovePageAsChildInput = {
  pageId: Scalars['ID']['input'];
  parentId: Scalars['ID']['input'];
};

export type ConfluenceLegacyMovePageAsSiblingInput = {
  pageId: Scalars['ID']['input'];
  siblingId: Scalars['ID']['input'];
};

export type ConfluenceLegacyMovePageTopLevelInput = {
  pageId: Scalars['ID']['input'];
  targetSpaceKey: Scalars['String']['input'];
};

export type ConfluenceLegacyNestedPageInput = {
  areChildrenIncluded?: InputMaybe<Scalars['Boolean']['input']>;
  excludedBranchRootPageIDs?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  isSelected?: InputMaybe<Scalars['Boolean']['input']>;
  pageID: Scalars['Long']['input'];
};

export type ConfluenceLegacyNewPageInput = {
  page: ConfluenceLegacyPageInput;
  space: ConfluenceLegacySpaceInput;
};

export type ConfluenceLegacyOnboardingStateInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export enum ConfluenceLegacyOperation {
  Assigned = 'ASSIGNED',
  Complete = 'COMPLETE',
  Deleted = 'DELETED',
  InComplete = 'IN_COMPLETE',
  Reworded = 'REWORDED',
  Unassigned = 'UNASSIGNED'
}

export type ConfluenceLegacyOperationCheckResultInput = {
  operation: Scalars['String']['input'];
  targetType: Scalars['String']['input'];
};

export enum ConfluenceLegacyOutputDeviceType {
  Desktop = 'DESKTOP',
  Email = 'EMAIL',
  Mobile = 'MOBILE'
}

/**  --------------------------------------------------------------------------------------------- */
export enum ConfluenceLegacyPtGraphQlPageStatus {
  Current = 'CURRENT',
  Draft = 'DRAFT',
  Historical = 'HISTORICAL',
  Trashed = 'TRASHED'
}

export enum ConfluenceLegacyPageActivityAction {
  Created = 'created',
  Updated = 'updated'
}

export enum ConfluenceLegacyPageActivityActionSubject {
  Comment = 'comment',
  Page = 'page'
}

/** Type of metric to group by */
export enum ConfluenceLegacyPageAnalyticsCountType {
  All = 'ALL',
  User = 'USER'
}

/** Type of metric to group by */
export enum ConfluenceLegacyPageAnalyticsTimeseriesCountType {
  All = 'ALL'
}

export type ConfluenceLegacyPageBodyInput = {
  representation?: InputMaybe<ConfluenceLegacyBodyFormatType>;
  value: Scalars['String']['input'];
};

export enum ConfluenceLegacyPageCardInPageTreeHoverPreference {
  NoOptionSelected = 'NO_OPTION_SELECTED',
  NoShowPagecard = 'NO_SHOW_PAGECARD',
  ShowPagecard = 'SHOW_PAGECARD'
}

export enum ConfluenceLegacyPageCopyRestrictionValidationStatus {
  InvalidMultiple = 'INVALID_MULTIPLE',
  InvalidSingle = 'INVALID_SINGLE',
  Valid = 'VALID'
}

export type ConfluenceLegacyPageGroupRestrictionInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
};

export type ConfluenceLegacyPageInput = {
  /**  the parent page ID, default is no parent page (i.e. root page in the space) */
  body?: InputMaybe<ConfluenceLegacyPageBodyInput>;
  parentId?: InputMaybe<Scalars['ID']['input']>;
  restrictions?: InputMaybe<ConfluenceLegacyPageRestrictionsInput>;
  status?: InputMaybe<ConfluenceLegacyPageStatusInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceLegacyPageRestrictionInput = {
  group?: InputMaybe<Array<ConfluenceLegacyPageGroupRestrictionInput>>;
  user?: InputMaybe<Array<ConfluenceLegacyPageUserRestrictionInput>>;
};

export type ConfluenceLegacyPageRestrictionsInput = {
  read?: InputMaybe<ConfluenceLegacyPageRestrictionInput>;
  update?: InputMaybe<ConfluenceLegacyPageRestrictionInput>;
};

export enum ConfluenceLegacyPageStatus {
  Current = 'CURRENT',
  Draft = 'DRAFT',
  Historical = 'HISTORICAL',
  Trashed = 'TRASHED'
}

export enum ConfluenceLegacyPageStatusInput {
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export enum ConfluenceLegacyPageUpdateTrigger {
  CreatePage = 'CREATE_PAGE',
  DiscardChanges = 'DISCARD_CHANGES',
  EditPage = 'EDIT_PAGE',
  LinkRefactoring = 'LINK_REFACTORING',
  MigratePageCollab = 'MIGRATE_PAGE_COLLAB',
  OwnerChange = 'OWNER_CHANGE',
  PageRename = 'PAGE_RENAME',
  PersonalTasklist = 'PERSONAL_TASKLIST',
  Revert = 'REVERT',
  SpaceCreate = 'SPACE_CREATE',
  Unknown = 'UNKNOWN',
  ViewPage = 'VIEW_PAGE'
}

export type ConfluenceLegacyPageUserRestrictionInput = {
  id: Scalars['ID']['input'];
};

export enum ConfluenceLegacyPagesDisplayPersistenceOption {
  Cards = 'CARDS',
  CompactList = 'COMPACT_LIST',
  List = 'LIST'
}

export enum ConfluenceLegacyPagesSortField {
  LastModifiedDate = 'LAST_MODIFIED_DATE',
  Relevant = 'RELEVANT',
  Title = 'TITLE'
}

export enum ConfluenceLegacyPagesSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type ConfluenceLegacyPagesSortPersistenceOptionInput = {
  field: ConfluenceLegacyPagesSortField;
  order: ConfluenceLegacyPagesSortOrder;
};

export type ConfluenceLegacyPatchCommentsSummaryInput = {
  commentsType: ConfluenceLegacyCommentsType;
  contentId: Scalars['ID']['input'];
  contentType: ConfluenceLegacySummaryType;
  language?: InputMaybe<Scalars['String']['input']>;
};

export enum ConfluenceLegacyPathType {
  Absolute = 'ABSOLUTE',
  Relative = 'RELATIVE',
  RelativeNoContext = 'RELATIVE_NO_CONTEXT'
}

export enum ConfluenceLegacyPaywallStatus {
  Active = 'ACTIVE',
  Deactivated = 'DEACTIVATED',
  Unset = 'UNSET'
}

export enum ConfluenceLegacyPermissionDisplayType {
  Anonymous = 'ANONYMOUS',
  Group = 'GROUP',
  GuestUser = 'GUEST_USER',
  LicensedUser = 'LICENSED_USER'
}

export enum ConfluenceLegacyPlatform {
  Android = 'ANDROID',
  Ios = 'IOS',
  Web = 'WEB'
}

export type ConfluenceLegacyPremiumToolsDropdownPersistence = {
  premiumToolsDropdownStatus: ConfluenceLegacyPremiumToolsDropdownStatus;
  spaceKey: Scalars['String']['input'];
};

export enum ConfluenceLegacyPremiumToolsDropdownStatus {
  Collapsed = 'COLLAPSED',
  Expanded = 'EXPANDED',
  Unset = 'UNSET'
}

export enum ConfluenceLegacyPrincipalType {
  Group = 'GROUP',
  User = 'USER'
}

export enum ConfluenceLegacyProduct {
  Confluence = 'CONFLUENCE'
}

export enum ConfluenceLegacyPublicLinkAdminAction {
  Block = 'BLOCK',
  Off = 'OFF',
  On = 'ON',
  Unblock = 'UNBLOCK'
}

export enum ConfluenceLegacyPublicLinkDefaultSpaceStatus {
  Off = 'OFF',
  On = 'ON'
}

export enum ConfluenceLegacyPublicLinkPageStatus {
  BlockedByClassificationLevel = 'BLOCKED_BY_CLASSIFICATION_LEVEL',
  BlockedByOrg = 'BLOCKED_BY_ORG',
  BlockedByProduct = 'BLOCKED_BY_PRODUCT',
  BlockedBySpace = 'BLOCKED_BY_SPACE',
  Off = 'OFF',
  On = 'ON',
  SiteBlocked = 'SITE_BLOCKED',
  SiteDisabled = 'SITE_DISABLED',
  SpaceBlocked = 'SPACE_BLOCKED',
  SpaceDisabled = 'SPACE_DISABLED'
}

export enum ConfluenceLegacyPublicLinkPageStatusFilter {
  BlockedByProduct = 'BLOCKED_BY_PRODUCT',
  BlockedBySpace = 'BLOCKED_BY_SPACE',
  Off = 'OFF',
  On = 'ON'
}

export enum ConfluenceLegacyPublicLinkPagesByCriteriaOrder {
  DateEnabled = 'DATE_ENABLED',
  Status = 'STATUS',
  Title = 'TITLE'
}

export enum ConfluenceLegacyPublicLinkPermissionsObjectType {
  Content = 'CONTENT'
}

export enum ConfluenceLegacyPublicLinkPermissionsType {
  Edit = 'EDIT'
}

export enum ConfluenceLegacyPublicLinkSiteStatus {
  BlockedByOrg = 'BLOCKED_BY_ORG',
  Off = 'OFF',
  On = 'ON'
}

export enum ConfluenceLegacyPublicLinkSpaceStatus {
  BlockedByOrg = 'BLOCKED_BY_ORG',
  BlockedByProduct = 'BLOCKED_BY_PRODUCT',
  Off = 'OFF',
  On = 'ON'
}

export enum ConfluenceLegacyPublicLinkSpacesByCriteriaOrder {
  ActiveLinks = 'ACTIVE_LINKS',
  Name = 'NAME',
  Status = 'STATUS'
}

export enum ConfluenceLegacyPublicLinkStatus {
  BlockedByClassificationLevel = 'BLOCKED_BY_CLASSIFICATION_LEVEL',
  BlockedByOrg = 'BLOCKED_BY_ORG',
  BlockedByProduct = 'BLOCKED_BY_PRODUCT',
  BlockedBySpace = 'BLOCKED_BY_SPACE',
  Off = 'OFF',
  On = 'ON',
  SiteBlocked = 'SITE_BLOCKED',
  SiteDisabled = 'SITE_DISABLED',
  SpaceBlocked = 'SPACE_BLOCKED',
  SpaceDisabled = 'SPACE_DISABLED'
}

export enum ConfluenceLegacyPublicLinksByCriteriaOrder {
  DateEnabled = 'DATE_ENABLED',
  Status = 'STATUS',
  Title = 'TITLE'
}

export type ConfluenceLegacyPushNotificationCustomSettingsInput = {
  comment: Scalars['Boolean']['input'];
  commentContentCreator: Scalars['Boolean']['input'];
  commentReply: Scalars['Boolean']['input'];
  createBlogPost: Scalars['Boolean']['input'];
  createPage: Scalars['Boolean']['input'];
  editBlogPost: Scalars['Boolean']['input'];
  editPage: Scalars['Boolean']['input'];
  grantContentAccessEdit?: InputMaybe<Scalars['Boolean']['input']>;
  grantContentAccessView?: InputMaybe<Scalars['Boolean']['input']>;
  likeBlogPost: Scalars['Boolean']['input'];
  likeComment: Scalars['Boolean']['input'];
  likePage: Scalars['Boolean']['input'];
  mentionBlogPost: Scalars['Boolean']['input'];
  mentionComment: Scalars['Boolean']['input'];
  mentionPage: Scalars['Boolean']['input'];
  reactionBlogPost?: InputMaybe<Scalars['Boolean']['input']>;
  reactionComment?: InputMaybe<Scalars['Boolean']['input']>;
  reactionPage?: InputMaybe<Scalars['Boolean']['input']>;
  requestContentAccess?: InputMaybe<Scalars['Boolean']['input']>;
  share: Scalars['Boolean']['input'];
  shareGroup: Scalars['Boolean']['input'];
  taskAssign: Scalars['Boolean']['input'];
};

export enum ConfluenceLegacyPushNotificationGroupInputType {
  None = 'NONE',
  Quiet = 'QUIET',
  Standard = 'STANDARD'
}

export enum ConfluenceLegacyPushNotificationSettingGroup {
  Custom = 'CUSTOM',
  None = 'NONE',
  Quiet = 'QUIET',
  Standard = 'STANDARD'
}

export enum ConfluenceLegacyReactionContentType {
  Blogpost = 'BLOGPOST',
  Comment = 'COMMENT',
  Page = 'PAGE'
}

export type ConfluenceLegacyReactionsId = {
  containerId: Scalars['ID']['input'];
  containerType: Scalars['String']['input'];
  contentId: Scalars['ID']['input'];
  contentType: Scalars['String']['input'];
};

export type ConfluenceLegacyReattachInlineCommentInput = {
  commentId: Scalars['ID']['input'];
  containerId: Scalars['ID']['input'];
  lastFetchTimeMillis: Scalars['Long']['input'];
  /** matchIndex must be greater than or equal to 0. */
  matchIndex: Scalars['Int']['input'];
  /** numMatches must be positive and greater than matchIndex. */
  numMatches: Scalars['Int']['input'];
  originalSelection: Scalars['String']['input'];
  publishedVersion?: InputMaybe<Scalars['Int']['input']>;
  step?: InputMaybe<ConfluenceLegacyStep>;
};

export enum ConfluenceLegacyRecentFilter {
  All = 'ALL',
  Created = 'CREATED',
  WorkedOn = 'WORKED_ON'
}

export enum ConfluenceLegacyRecommendedPagesSpaceBehavior {
  Hidden = 'HIDDEN',
  Shown = 'SHOWN'
}

export enum ConfluenceLegacyRelationSourceType {
  User = 'user'
}

export enum ConfluenceLegacyRelationTargetType {
  Content = 'content',
  Space = 'space'
}

export enum ConfluenceLegacyRelationType {
  Collaborator = 'collaborator',
  Favourite = 'favourite',
  Touched = 'touched'
}

export enum ConfluenceLegacyRelevantUserFilter {
  Collaborators = 'collaborators'
}

export enum ConfluenceLegacyRelevantUsersSortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type ConfluenceLegacyRemoveGroupSpacePermissionsInput = {
  groupIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  groupNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  spaceKey: Scalars['String']['input'];
};

export type ConfluenceLegacyRemovePublicLinkPermissionsInput = {
  objectId: Scalars['ID']['input'];
  objectType: ConfluenceLegacyPublicLinkPermissionsObjectType;
  permissions: Array<ConfluenceLegacyPublicLinkPermissionsType>;
};

export type ConfluenceLegacyRemoveUserSpacePermissionsInput = {
  accountId: Scalars['String']['input'];
  spaceKey: Scalars['String']['input'];
};

export type ConfluenceLegacyReplyInlineCommentInput = {
  commentBody: ConfluenceLegacyCommentBody;
  commentSource?: InputMaybe<ConfluenceLegacyPlatform>;
  containerId: Scalars['ID']['input'];
  createdFrom?: InputMaybe<ConfluenceLegacyCommentCreationLocation>;
  parentCommentId: Scalars['ID']['input'];
};

export type ConfluenceLegacyRequestPageAccessInput = {
  accessType: ConfluenceLegacyAccessType;
  pageId: Scalars['String']['input'];
};

export type ConfluenceLegacyResetExCoSpacePermissionsInput = {
  accountId: Scalars['String']['input'];
  spaceKey?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceLegacyResetSpaceRolesFromAnotherSpaceInput = {
  sourceSpaceId: Scalars['Long']['input'];
  targetSpaceId: Scalars['Long']['input'];
};

export enum ConfluenceLegacyResponseType {
  BulletListAdf = 'BULLET_LIST_ADF',
  BulletListMarkdown = 'BULLET_LIST_MARKDOWN',
  ParagraphPlaintext = 'PARAGRAPH_PLAINTEXT'
}

export enum ConfluenceLegacyReverseTrialCohort {
  Control = 'CONTROL',
  Enrolled = 'ENROLLED',
  NotEnrolled = 'NOT_ENROLLED',
  Unassigned = 'UNASSIGNED',
  Unknown = 'UNKNOWN',
  Variant = 'VARIANT'
}

export enum ConfluenceLegacyRevertToLegacyEditorResult {
  NotReverted = 'NOT_REVERTED',
  Reverted = 'REVERTED'
}

export type ConfluenceLegacyRoleAssignment = {
  principal: ConfluenceLegacyRoleAssignmentPrincipalInput;
  roleId: Scalars['ID']['input'];
};

export type ConfluenceLegacyRoleAssignmentPrincipalInput = {
  principalId: Scalars['ID']['input'];
  principalType: ConfluenceLegacyRoleAssignmentPrincipalType;
};

export enum ConfluenceLegacyRoleAssignmentPrincipalType {
  AccessClass = 'ACCESS_CLASS',
  Group = 'GROUP',
  Team = 'TEAM',
  User = 'USER'
}

export enum ConfluenceLegacySearchesByTermColumns {
  PageViewedPercentage = 'pageViewedPercentage',
  SearchClickCount = 'searchClickCount',
  SearchSessionCount = 'searchSessionCount',
  SearchTerm = 'searchTerm',
  Total = 'total',
  UniqueUsers = 'uniqueUsers'
}

export enum ConfluenceLegacySearchesByTermPeriod {
  Day = 'day',
  Month = 'month',
  Week = 'week'
}

export type ConfluenceLegacySetDefaultSpaceRolesInput = {
  spaceRoleAssignmentList: Array<ConfluenceLegacyRoleAssignment>;
};

export type ConfluenceLegacySetFeedUserConfigInput = {
  followSpaces?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  followUsers?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  unfollowSpaces?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  unfollowUsers?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type ConfluenceLegacySetRecommendedPagesSpaceStatusInput = {
  defaultBehavior?: InputMaybe<ConfluenceLegacyRecommendedPagesSpaceBehavior>;
  enableRecommendedPages?: InputMaybe<Scalars['Boolean']['input']>;
  entityId: Scalars['ID']['input'];
};

export type ConfluenceLegacySetRecommendedPagesStatusInput = {
  enableRecommendedPages: Scalars['Boolean']['input'];
  entityId: Scalars['ID']['input'];
  entityType: Scalars['String']['input'];
};

export type ConfluenceLegacySetSpaceRolesInput = {
  spaceId: Scalars['Long']['input'];
  spaceRoleAssignmentList: Array<ConfluenceLegacyRoleAssignment>;
};

export type ConfluenceLegacyShareResourceInput = {
  atlOrigin: Scalars['String']['input'];
  contextualPageId: Scalars['String']['input'];
  emails: Array<InputMaybe<Scalars['String']['input']>>;
  entityId: Scalars['String']['input'];
  entityType: Scalars['String']['input'];
  groupIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  groups: Array<InputMaybe<Scalars['String']['input']>>;
  isShareEmailExperiment: Scalars['Boolean']['input'];
  note: Scalars['String']['input'];
  shareType: ConfluenceLegacyShareType;
  users: Array<InputMaybe<Scalars['String']['input']>>;
};

export enum ConfluenceLegacyShareType {
  InviteToEdit = 'INVITE_TO_EDIT',
  SharePage = 'SHARE_PAGE'
}

export type ConfluenceLegacySitePermissionInput = {
  permissionsToAdd?: InputMaybe<ConfluenceLegacyUpdateSitePermissionInput>;
  permissionsToRemove?: InputMaybe<ConfluenceLegacyUpdateSitePermissionInput>;
};

export enum ConfluenceLegacySitePermissionOperationType {
  AdministerConfluence = 'ADMINISTER_CONFLUENCE',
  AdministerSystem = 'ADMINISTER_SYSTEM',
  CreateProfileattachment = 'CREATE_PROFILEATTACHMENT',
  CreateSpace = 'CREATE_SPACE',
  ExternalCollaborator = 'EXTERNAL_COLLABORATOR',
  LimitedUseConfluence = 'LIMITED_USE_CONFLUENCE',
  ReadUserprofile = 'READ_USERPROFILE',
  UpdateUserstatus = 'UPDATE_USERSTATUS',
  UseConfluence = 'USE_CONFLUENCE',
  UsePersonalspace = 'USE_PERSONALSPACE'
}

export enum ConfluenceLegacySitePermissionType {
  Anonymous = 'ANONYMOUS',
  App = 'APP',
  External = 'EXTERNAL',
  Internal = 'INTERNAL',
  Jsd = 'JSD'
}

export enum ConfluenceLegacySitePermissionTypeFilter {
  All = 'ALL',
  Externalcollaborator = 'EXTERNALCOLLABORATOR',
  None = 'NONE'
}

export type ConfluenceLegacySmartFeaturesInput = {
  entityIds: Array<Scalars['String']['input']>;
  entityType: Scalars['String']['input'];
  features?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export enum ConfluenceLegacySpaceAssignmentType {
  Assigned = 'ASSIGNED',
  Unassigned = 'UNASSIGNED'
}

export type ConfluenceLegacySpaceInput = {
  key: Scalars['ID']['input'];
};

export type ConfluenceLegacySpacePagesDisplayView = {
  spaceKey: Scalars['String']['input'];
  spacePagesPersistenceOption: ConfluenceLegacyPagesDisplayPersistenceOption;
};

export type ConfluenceLegacySpacePagesSortView = {
  spaceKey: Scalars['String']['input'];
  spacePagesSortPersistenceOption: ConfluenceLegacyPagesSortPersistenceOptionInput;
};

export enum ConfluenceLegacySpacePermissionType {
  AdministerSpace = 'ADMINISTER_SPACE',
  ArchivePage = 'ARCHIVE_PAGE',
  Comment = 'COMMENT',
  CreateAttachment = 'CREATE_ATTACHMENT',
  CreateEditPage = 'CREATE_EDIT_PAGE',
  EditBlog = 'EDIT_BLOG',
  ExportPage = 'EXPORT_PAGE',
  ExportSpace = 'EXPORT_SPACE',
  RemoveAttachment = 'REMOVE_ATTACHMENT',
  RemoveBlog = 'REMOVE_BLOG',
  RemoveComment = 'REMOVE_COMMENT',
  RemoveMail = 'REMOVE_MAIL',
  RemoveOwnContent = 'REMOVE_OWN_CONTENT',
  RemovePage = 'REMOVE_PAGE',
  SetPagePermissions = 'SET_PAGE_PERMISSIONS',
  ViewSpace = 'VIEW_SPACE'
}

export enum ConfluenceLegacySpaceRoleType {
  Custom = 'CUSTOM',
  System = 'SYSTEM'
}

export type ConfluenceLegacySpaceShortcutsInput = {
  iconUrl?: InputMaybe<Scalars['String']['input']>;
  isPinnedPage: Scalars['Boolean']['input'];
  shortcutId: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export enum ConfluenceLegacySpaceSidebarLinkType {
  ExternalLink = 'EXTERNAL_LINK',
  Forge = 'FORGE',
  PinnedAttachment = 'PINNED_ATTACHMENT',
  PinnedBlogPost = 'PINNED_BLOG_POST',
  PinnedPage = 'PINNED_PAGE',
  PinnedSpace = 'PINNED_SPACE',
  PinnedUserInfo = 'PINNED_USER_INFO',
  WebItem = 'WEB_ITEM'
}

export type ConfluenceLegacySpaceTypeSettingsInput = {
  enabledContentTypes?: InputMaybe<ConfluenceLegacyEnabledContentTypesInput>;
  enabledFeatures?: InputMaybe<ConfluenceLegacyEnabledFeaturesInput>;
};

export type ConfluenceLegacySpaceViewsPersistence = {
  persistenceOption: ConfluenceLegacySpaceViewsPersistenceOption;
  spaceKey: Scalars['String']['input'];
};

export enum ConfluenceLegacySpaceViewsPersistenceOption {
  Popularity = 'POPULARITY',
  RecentlyModified = 'RECENTLY_MODIFIED',
  RecentlyViewed = 'RECENTLY_VIEWED',
  TitleAz = 'TITLE_AZ',
  Tree = 'TREE'
}

export enum ConfluenceLegacyStalePageStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export enum ConfluenceLegacyStalePagesSortingType {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type ConfluenceLegacyStep = {
  from?: InputMaybe<Scalars['Long']['input']>;
  mark: ConfluenceLegacyMark;
  pos?: InputMaybe<Scalars['Long']['input']>;
  to?: InputMaybe<Scalars['Long']['input']>;
};

export type ConfluenceLegacySubjectPermissionDeltas = {
  permissionsToAdd: Array<InputMaybe<ConfluenceLegacySpacePermissionType>>;
  permissionsToRemove: Array<InputMaybe<ConfluenceLegacySpacePermissionType>>;
  subjectKeyInput: ConfluenceLegacyUpdatePermissionSubjectKeyInput;
};

export enum ConfluenceLegacySummaryType {
  Blogpost = 'BLOGPOST',
  Page = 'PAGE'
}

export type ConfluenceLegacySystemSpaceHomepageInput = {
  systemSpaceHomepageTemplate: ConfluenceLegacySystemSpaceHomepageTemplate;
};

export enum ConfluenceLegacySystemSpaceHomepageTemplate {
  Eap = 'EAP',
  Minimal = 'MINIMAL',
  Visual = 'VISUAL'
}

export enum ConfluenceLegacyTaskStatus {
  Checked = 'CHECKED',
  Unchecked = 'UNCHECKED'
}

export enum ConfluenceLegacyTeamCalendarDayOfWeek {
  Friday = 'FRIDAY',
  Monday = 'MONDAY',
  Saturday = 'SATURDAY',
  Sunday = 'SUNDAY',
  Thursday = 'THURSDAY',
  Tuesday = 'TUESDAY',
  Wednesday = 'WEDNESDAY'
}

export enum ConfluenceLegacyTemplateContentAppearance {
  Default = 'DEFAULT',
  FullWidth = 'FULL_WIDTH'
}

export type ConfluenceLegacyTemplateEntityFavouriteStatus = {
  isFavourite: Scalars['Boolean']['input'];
  templateEntityId: Scalars['String']['input'];
};

export type ConfluenceLegacyTemplatePropertySetInput = {
  /** appearance of the template */
  contentAppearance?: InputMaybe<ConfluenceLegacyTemplateContentAppearance>;
};

export type ConfluenceLegacyTemplatizeInput = {
  contentId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceLegacyUnlicensedUserWithPermissionsInput = {
  operations: Array<InputMaybe<ConfluenceLegacyOperationCheckResultInput>>;
};

export type ConfluenceLegacyUpdateAdminAnnouncementBannerInput = {
  appearance?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  isDismissible?: InputMaybe<Scalars['Boolean']['input']>;
  scheduledEndTime?: InputMaybe<Scalars['String']['input']>;
  scheduledStartTime?: InputMaybe<Scalars['String']['input']>;
  scheduledTimeZone?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ConfluenceLegacyAdminAnnouncementBannerStatusType>;
  title?: InputMaybe<Scalars['String']['input']>;
  visibility?: InputMaybe<ConfluenceLegacyAdminAnnouncementBannerVisibilityType>;
};

export type ConfluenceLegacyUpdateArchiveNotesInput = {
  archiveNote?: InputMaybe<Scalars['String']['input']>;
  areChildrenIncluded?: InputMaybe<Scalars['Boolean']['input']>;
  excludedBranchRootPageIDs?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  isSelected?: InputMaybe<Scalars['Boolean']['input']>;
  pageID: Scalars['Long']['input'];
};

export type ConfluenceLegacyUpdateCommentInput = {
  commentBody: ConfluenceLegacyCommentBody;
  commentId: Scalars['ID']['input'];
  /** This field is being deprecated, you do not need to provide this value if the update.comment.mutations.optional.version FF is on */
  version?: InputMaybe<Scalars['Int']['input']>;
};

export type ConfluenceLegacyUpdateContentDataClassificationLevelInput = {
  classificationLevelId: Scalars['ID']['input'];
  contentStatus: ConfluenceLegacyContentDataClassificationMutationContentStatus;
  id: Scalars['Long']['input'];
};

export type ConfluenceLegacyUpdateContentPermissionsInput = {
  contentRole: ConfluenceLegacyContentRole;
  principalId: Scalars['ID']['input'];
  principalType: ConfluenceLegacyPrincipalType;
};

export type ConfluenceLegacyUpdateContentTemplateInput = {
  body: ConfluenceLegacyContentTemplateBodyInput;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  labels?: InputMaybe<Array<InputMaybe<ConfluenceLegacyContentTemplateLabelInput>>>;
  name: Scalars['String']['input'];
  space?: InputMaybe<ConfluenceLegacyContentTemplateSpaceInput>;
  templateId: Scalars['ID']['input'];
  templateType: ConfluenceLegacyContentTemplateType;
};

export type ConfluenceLegacyUpdateDefaultSpacePermissionsInput = {
  permissionsToAdd: Array<InputMaybe<ConfluenceLegacySpacePermissionType>>;
  permissionsToRemove: Array<InputMaybe<ConfluenceLegacySpacePermissionType>>;
  subjectKeyInput: ConfluenceLegacyUpdatePermissionSubjectKeyInput;
};

export type ConfluenceLegacyUpdateEmbedInput = {
  embedIconUrl?: InputMaybe<Scalars['String']['input']>;
  embedUrl?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  product?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceLegacyUpdateExCoSpacePermissionsInput = {
  accountId: Scalars['String']['input'];
  spaceId: Scalars['Long']['input'];
};

export type ConfluenceLegacyUpdateExternalCollaboratorDefaultSpaceInput = {
  enabled: Scalars['Boolean']['input'];
  spaceId: Scalars['Long']['input'];
};

export type ConfluenceLegacyUpdateOwnerInput = {
  contentId: Scalars['ID']['input'];
  ownerId: Scalars['String']['input'];
};

export type ConfluenceLegacyUpdatePageExtensionInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ConfluenceLegacyUpdatePageInput = {
  body?: InputMaybe<ConfluenceLegacyPageBodyInput>;
  extensions?: InputMaybe<Array<InputMaybe<ConfluenceLegacyUpdatePageExtensionInput>>>;
  mediaAttachments?: InputMaybe<Array<ConfluenceLegacyMediaAttachmentInput>>;
  minorEdit?: InputMaybe<Scalars['Boolean']['input']>;
  pageId: Scalars['ID']['input'];
  restrictions?: InputMaybe<ConfluenceLegacyPageRestrictionsInput>;
  status?: InputMaybe<ConfluenceLegacyPageStatusInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceLegacyUpdatePageOwnersInput = {
  ownerId: Scalars['ID']['input'];
  pageIDs: Array<InputMaybe<Scalars['Long']['input']>>;
};

export type ConfluenceLegacyUpdatePageStatusesInput = {
  pages: Array<InputMaybe<ConfluenceLegacyNestedPageInput>>;
  spaceKey: Scalars['String']['input'];
  targetContentState: ConfluenceLegacyContentStateInput;
};

export type ConfluenceLegacyUpdatePermissionSubjectKeyInput = {
  permissionDisplayType: ConfluenceLegacyPermissionDisplayType;
  subjectId: Scalars['String']['input'];
};

export type ConfluenceLegacyUpdateRelationInput = {
  relationName: ConfluenceLegacyRelationType;
  sourceKey: Scalars['String']['input'];
  sourceStatus?: InputMaybe<Scalars['String']['input']>;
  sourceType: ConfluenceLegacyRelationSourceType;
  sourceVersion?: InputMaybe<Scalars['Int']['input']>;
  targetKey: Scalars['String']['input'];
  targetStatus?: InputMaybe<Scalars['String']['input']>;
  targetType: ConfluenceLegacyRelationTargetType;
  targetVersion?: InputMaybe<Scalars['Int']['input']>;
};

export type ConfluenceLegacyUpdateSiteLookAndFeelInput = {
  backgroundColor?: InputMaybe<Scalars['String']['input']>;
  faviconFiles: Array<ConfluenceLegacyFaviconFileInput>;
  frontCoverState?: InputMaybe<ConfluenceLegacyFrontCoverState>;
  highlightColor?: InputMaybe<Scalars['String']['input']>;
  resetFavicon?: InputMaybe<Scalars['Boolean']['input']>;
  resetSiteLogo?: InputMaybe<Scalars['Boolean']['input']>;
  showFrontCover?: InputMaybe<Scalars['Boolean']['input']>;
  showSiteName?: InputMaybe<Scalars['Boolean']['input']>;
  siteLogoFileStoreId?: InputMaybe<Scalars['ID']['input']>;
  siteName?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceLegacyUpdateSitePermissionInput = {
  anonymous?: InputMaybe<ConfluenceLegacyAnonymousWithPermissionsInput>;
  groups?: InputMaybe<Array<InputMaybe<ConfluenceLegacyGroupWithPermissionsInput>>>;
  unlicensedUser?: InputMaybe<ConfluenceLegacyUnlicensedUserWithPermissionsInput>;
  users?: InputMaybe<Array<InputMaybe<ConfluenceLegacyUserWithPermissionsInput>>>;
};

export type ConfluenceLegacyUpdateSpaceDefaultClassificationLevelInput = {
  classificationLevelId: Scalars['ID']['input'];
  id: Scalars['Long']['input'];
};

export type ConfluenceLegacyUpdateSpacePermissionsInput = {
  spaceKey: Scalars['String']['input'];
  subjectPermissionDeltasList: Array<ConfluenceLegacySubjectPermissionDeltas>;
};

export type ConfluenceLegacyUpdateSpaceTypeSettingsInput = {
  spaceKey?: InputMaybe<Scalars['String']['input']>;
  spaceTypeSettings?: InputMaybe<ConfluenceLegacySpaceTypeSettingsInput>;
};

export type ConfluenceLegacyUpdateTemplatePropertySetInput = {
  /** ID of template to create property for */
  templateId: Scalars['Long']['input'];
  /** Template properties */
  templatePropertySet: ConfluenceLegacyTemplatePropertySetInput;
};

export type ConfluenceLegacyUpdatedNestedPageOwnersInput = {
  ownerId: Scalars['ID']['input'];
  pages: Array<InputMaybe<ConfluenceLegacyNestedPageInput>>;
};

export type ConfluenceLegacyUserPreferencesInput = {
  addUserSpaceNotifiedChangeBoardingOfExternalCollab?: InputMaybe<Scalars['String']['input']>;
  addUserSpaceNotifiedOfExternalCollab?: InputMaybe<Scalars['String']['input']>;
  endOfPageRecommendationsOptInStatus?: InputMaybe<Scalars['String']['input']>;
  feedRecommendedUserSettingsDismissTimestamp?: InputMaybe<Scalars['String']['input']>;
  feedTab?: InputMaybe<Scalars['String']['input']>;
  feedType?: InputMaybe<ConfluenceLegacyFeedType>;
  globalPageCardAppearancePreference?: InputMaybe<ConfluenceLegacyPagesDisplayPersistenceOption>;
  homePagesDisplayView?: InputMaybe<ConfluenceLegacyPagesDisplayPersistenceOption>;
  homeWidget?: InputMaybe<ConfluenceLegacyHomeWidgetInput>;
  isHomeOnboardingDismissed?: InputMaybe<Scalars['Boolean']['input']>;
  keyboardShortcutDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  missionControlOverview?: InputMaybe<ConfluenceLegacyMissionControlOverview>;
  nextGenFeedOptInStatus?: InputMaybe<Scalars['String']['input']>;
  premiumToolsDropdownPersistence?: InputMaybe<ConfluenceLegacyPremiumToolsDropdownPersistence>;
  recentFilter?: InputMaybe<ConfluenceLegacyRecentFilter>;
  searchExperimentOptInStatus?: InputMaybe<Scalars['String']['input']>;
  shouldShowCardOnPageTreeHover?: InputMaybe<ConfluenceLegacyPageCardInPageTreeHoverPreference>;
  spacePagesDisplayView?: InputMaybe<ConfluenceLegacySpacePagesDisplayView>;
  spacePagesSortView?: InputMaybe<ConfluenceLegacySpacePagesSortView>;
  spaceViewsPersistence?: InputMaybe<ConfluenceLegacySpaceViewsPersistence>;
  templateEntityFavouriteStatus?: InputMaybe<ConfluenceLegacyTemplateEntityFavouriteStatus>;
  theme?: InputMaybe<Scalars['String']['input']>;
  topNavigationOptedOut?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConfluenceLegacyUserWithPermissionsInput = {
  accountId: Scalars['ID']['input'];
  operations: Array<InputMaybe<ConfluenceLegacyOperationCheckResultInput>>;
};

export type ConfluenceLegacyValidateConvertPageToLiveEditInput = {
  adf: Scalars['String']['input'];
  contentId: Scalars['ID']['input'];
};

export type ConfluenceLegacyValidatePageCopyInput = {
  /** ID of destination space */
  destinationSpaceId: Scalars['ID']['input'];
  /** ID of page being copied */
  pageId: Scalars['ID']['input'];
  /** Input params for validation of copying page restrictions */
  validatePageRestrictionsCopyInput?: InputMaybe<ConfluenceLegacyValidatePageRestrictionsCopyInput>;
};

export type ConfluenceLegacyValidatePageRestrictionsCopyInput = {
  includeChildren: Scalars['Boolean']['input'];
};

export type ConfluenceLegacyWatchContentInput = {
  accountId?: InputMaybe<Scalars['String']['input']>;
  contentId: Scalars['ID']['input'];
  currentUser?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConfluenceLegacyWatchSpaceInput = {
  accountId?: InputMaybe<Scalars['String']['input']>;
  currentUser?: InputMaybe<Scalars['Boolean']['input']>;
  spaceId?: InputMaybe<Scalars['ID']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
};

export enum ConfluenceMutationContentStatus {
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export enum ConfluenceOperationName {
  Administer = 'ADMINISTER',
  Archive = 'ARCHIVE',
  Copy = 'COPY',
  Create = 'CREATE',
  CreateSpace = 'CREATE_SPACE',
  Delete = 'DELETE',
  Export = 'EXPORT',
  Move = 'MOVE',
  Purge = 'PURGE',
  PurgeVersion = 'PURGE_VERSION',
  Read = 'READ',
  Restore = 'RESTORE',
  RestrictContent = 'RESTRICT_CONTENT',
  Update = 'UPDATE',
  Use = 'USE'
}

export enum ConfluenceOperationTarget {
  Application = 'APPLICATION',
  Attachment = 'ATTACHMENT',
  BlogPost = 'BLOG_POST',
  Comment = 'COMMENT',
  Page = 'PAGE',
  Space = 'SPACE',
  UserProfile = 'USER_PROFILE'
}

export enum ConfluencePageStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Deleted = 'DELETED',
  Draft = 'DRAFT',
  Historical = 'HISTORICAL',
  Trashed = 'TRASHED'
}

export enum ConfluencePageSubType {
  Live = 'LIVE'
}

export type ConfluencePublishBlogPostInput = {
  /** ID of draft BlogPost. */
  id: Scalars['ID']['input'];
  /** Title of the published BlogPost. If it is EMPTY, it will be same as draft BlogPost title. */
  publishTitle?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluencePublishPageInput = {
  /** ID of draft Page. */
  id: Scalars['ID']['input'];
  /** Title of the published Page. If it is EMPTY, it will be same as draft Page title. */
  publishTitle?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluencePurgeBlogPostInput = {
  /** ID of TRASHED BlogPost. */
  id: Scalars['ID']['input'];
};

export type ConfluencePurgePageInput = {
  /** ID of TRASHED Page. */
  id: Scalars['ID']['input'];
};

export type ConfluenceReopenInlineCommentInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceReplyToCommentInput = {
  body: ConfluenceContentBodyInput;
  parentCommentId: Scalars['ID']['input'];
};

export type ConfluenceResolveInlineCommentInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceSpaceFilters = {
  /** It is used to filter Space by it type. */
  type?: InputMaybe<ConfluenceSpaceType>;
};

export enum ConfluenceSpaceSettingEditorVersion {
  V1 = 'V1',
  V2 = 'V2'
}

export enum ConfluenceSpaceStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT'
}

export enum ConfluenceSpaceType {
  Global = 'GLOBAL',
  Personal = 'PERSONAL'
}

export type ConfluenceTrashBlogPostInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceTrashPageInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceUpdateCommentInput = {
  body: ConfluenceContentBodyInput;
  id: Scalars['ID']['input'];
};

export type ConfluenceUpdateCurrentBlogPostInput = {
  body?: InputMaybe<ConfluenceContentBodyInput>;
  id: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateCurrentPageInput = {
  body?: InputMaybe<ConfluenceContentBodyInput>;
  id: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateDraftBlogPostInput = {
  body?: InputMaybe<ConfluenceContentBodyInput>;
  id: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateDraftPageInput = {
  body?: InputMaybe<ConfluenceContentBodyInput>;
  id: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateSpaceInput = {
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateSpaceSettingsInput = {
  /** ARI for the Space. */
  id: Scalars['String']['input'];
  /** Defines whether an override for the space home should be used. This is used in conjunction with a space theme provided by an app. For example, if this property is set to true, a theme can display a page other than the space homepage when users visit the root URL for a space. This property allows apps to provide content-only theming without overriding the space home. */
  routeOverrideEnabled: Scalars['Boolean']['input'];
};

export type ConfluenceUpdateValueBlogPostPropertyInput = {
  blogPostId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ConfluenceUpdateValuePagePropertyInput = {
  key: Scalars['String']['input'];
  pageId: Scalars['ID']['input'];
  value: Scalars['String']['input'];
};

export enum ConfluenceUserType {
  Anonymous = 'ANONYMOUS',
  Known = 'KNOWN'
}

export enum ContentPlatformBooleanOperators {
  And = 'AND',
  Or = 'OR'
}

export type ContentPlatformContentClause = {
  /** Logical AND operator that expects all expressions within operator to be true */
  and?: InputMaybe<Array<ContentPlatformContentClause>>;
  /** Field name selector */
  fieldNamed?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to operator, currently used for date comparisons */
  gte?: InputMaybe<ContentPlatformDateCondition>;
  /** Existence selector */
  hasAnyValue?: InputMaybe<Scalars['Boolean']['input']>;
  /** Values selector */
  havingValues?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Less than or equal to operator, currently used for date comparisons */
  lte?: InputMaybe<ContentPlatformDateCondition>;
  /** Logical OR operator that expects at least one expression within operator to be true */
  or?: InputMaybe<Array<ContentPlatformContentClause>>;
  /** Object that allows users to search content for text snippets */
  searchText?: InputMaybe<ContentPlatformSearchTextClause>;
};

export type ContentPlatformContentQueryInput = {
  /** This is a cursor after which (exclusive) the data should be fetched */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Number of content results to fetch */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** This is how the entries returned will be sorted */
  sortBy?: InputMaybe<ContentPlatformSortClause>;
  /** Object used to filter and search text */
  where?: InputMaybe<ContentPlatformContentClause>;
  /** Locales to return content in */
  withLocales?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Object containing the product Feature Flags associated with the Atlassian Product Instance */
  withProductFeatureFlags?: InputMaybe<Scalars['JSON']['input']>;
};

export type ContentPlatformDateCondition = {
  /**
   * Determines which date field to compare this operation to. One of:
   * * "createdAt"
   * * "publishDate"
   * * "updatedAt"
   * * "featureRolloutDate"
   * * "featureRolloutEndDate"
   */
  dateFieldNamed?: Scalars['String']['input'];
  /** An ISO date string that is used to filter items before or after a given date */
  havingDate: Scalars['DateTime']['input'];
};

export type ContentPlatformDateRangeFilter = {
  /** An ISO date string that is used to filter items after given date */
  after: Scalars['DateTime']['input'];
  /** An ISO date string that is used to filter items before given date */
  before: Scalars['DateTime']['input'];
};

export type ContentPlatformField = {
  /** Name of field to be searched. One of TITLE or DESCRIPTION */
  field: ContentPlatformFieldNames;
};

export enum ContentPlatformFieldNames {
  Description = 'DESCRIPTION',
  Title = 'TITLE'
}

export enum ContentPlatformOperators {
  All = 'ALL',
  Any = 'ANY'
}

export type ContentPlatformReleaseNoteFilterOptions = {
  /**
   * A list of change statuses on which to match release notes. Options:
   *   * "Coming soon"
   *   * "Generally available"
   *   * "Planned"
   *   * "Rolled back"
   *   * "Rolling out"
   */
  changeStatus?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * A list of Change Types on which to match release notes. Options:
   *   * "Experiment"
   *   * "Improvement"
   *   * "Removed"
   *   * "Announcement"
   *   * "Fix"
   */
  changeTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The Contentful ID of a product on which to match release notes */
  contextId?: InputMaybe<Scalars['String']['input']>;
  /** A list of Feature Delivery Jira issue keys on which to match release notes */
  fdIssueKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of Feature Delivery Jira ticket urls on which to match release notes */
  fdIssueLinks?: InputMaybe<Array<Scalars['String']['input']>>;
  /** This field will be removed in the next version of the service. Please use the `featureFlagEnvironment` filter at the parent level. */
  featureFlagEnvironment?: InputMaybe<Scalars['String']['input']>;
  /** This field will be removed in the next version of the service. Please use the `featureFlagProject` filter at the parent level. */
  featureFlagProject?: InputMaybe<Scalars['String']['input']>;
  /** Rollout dates on which to match release notes */
  featureRolloutDates?: InputMaybe<Array<Scalars['String']['input']>>;
  /** JSON passed in as a query variable corresponding to product feature flags defined in LaunchDarkly. The API will filter Release Notes based on the feature flag OFF value. */
  productFeatureFlags?: InputMaybe<Scalars['JSON']['input']>;
  /**
   * A list of product/app names on which to match release notes. Options:
   *   * "Advanced Roadmaps for Jira"
   *   * "Atlas"
   *   * "Atlassian Analytics"
   *   * "Atlassian Cloud"
   *   * "Bitbucket"
   *   * "Compass"
   *   * "Confluence"
   *   * "Halp"
   *   * "Jira Align"
   *   * "Jira Product Discovery"
   *   * "Jira Service Management"
   *   * "Jira Software"
   *   * "Jira Work Management"
   *   * "Opsgenie"
   *   * "Questions for Confluence"
   *   * "Statuspage"
   *   * "Team Calendars for Confluence"
   *   * "Trello"
   *   * "Cloud automation"
   *   * "Jira cloud app for Android"
   *   * "Jira cloud app for iOS"
   *   * "Jira cloud app for macOS"
   *   * "Opsgenie app for Android"
   *   * "Opsgenie app for BlackBerry Dynamics"
   *   * "Opsgenie app for iOS"
   */
  productNames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of feature flag off values on which to match release notes */
  releaseNoteFlagOffValues?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of feature flags on which to match release notes */
  releaseNoteFlags?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A date range where you can filter release notes within a specific date range on the updatedAt field */
  updatedAt?: InputMaybe<ContentPlatformDateRangeFilter>;
};

export type ContentPlatformSearchApIv2Query = {
  /** Queries to be sent to the search API */
  queries: Array<ContentPlatformContentQueryInput>;
};

export type ContentPlatformSearchOptions = {
  /** Boolean AND/OR for combining search queries in the query list */
  operator?: InputMaybe<ContentPlatformBooleanOperators>;
  /** Search query defining the search type, terms, term operators, fields, and field operators */
  queries: Array<ContentPlatformSearchQuery>;
};

export type ContentPlatformSearchQuery = {
  /** One of ANY or ALL. Defines whether search needs to match any of the fields queried (boolean OR) or of all of them (boolean AND) */
  fieldOperator?: InputMaybe<ContentPlatformOperators>;
  /** Fields to be searched */
  fields?: InputMaybe<Array<ContentPlatformField>>;
  /** Type of search to be executed. One of CONTAINS or EXACT_MATCH */
  searchType: ContentPlatformSearchTypes;
  /** One of ANY or ALL. Defines whether search needs to match any of the terms queried (boolean OR) or of all of them (boolean AND) */
  termOperator?: InputMaybe<ContentPlatformOperators>;
  /** The terms to be searched within fields of the Release Notes */
  terms: Array<Scalars['String']['input']>;
};

export type ContentPlatformSearchTextClause = {
  /** Logical AND operator that expects all expressions within operator to be true */
  and?: InputMaybe<Array<ContentPlatformSearchTextClause>>;
  /** Object used to search text using fuzzy matching */
  exactlyMatching?: InputMaybe<ContentPlatformSearchTextMatchingClause>;
  /** Logical OR operator that expects at least one expression within operator to be true */
  or?: InputMaybe<Array<ContentPlatformSearchTextClause>>;
  /** Object used to search text using exact matching */
  partiallyMatching?: InputMaybe<ContentPlatformSearchTextMatchingClause>;
};

export type ContentPlatformSearchTextMatchingClause = {
  /** Logical AND operator that expects all expressions within operator to be true */
  and?: InputMaybe<Array<ContentPlatformSearchTextMatchingClause>>;
  /** Field name selector */
  fieldNamed?: InputMaybe<Scalars['String']['input']>;
  /** Values selector */
  havingValues?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Values selector */
  matchingAllValues?: InputMaybe<Scalars['Boolean']['input']>;
  /** Logical OR operator that expects at least one expression within operator to be true */
  or?: InputMaybe<Array<ContentPlatformSearchTextMatchingClause>>;
};

export enum ContentPlatformSearchTypes {
  Contains = 'CONTAINS',
  ExactMatch = 'EXACT_MATCH'
}

export type ContentPlatformSortClause = {
  /**
   * This is how the data returned will be sorted, one of
   * * "relevancy" <- if searchText is used, this is the default, and no other sort order is specified
   * * "createdAt" <- DEFAULT
   * * "updatedAt"
   * * "featureRolloutDate"
   * * "featureRolloutEndDate"
   */
  fieldNamed?: Scalars['String']['input'];
  /** Options are DESC (DEFAULT) or ASC */
  havingOrder?: Scalars['String']['input'];
};

export type CopyPolarisInsightsContainerInput = {
  /** The container ARI which contains insights */
  container?: InputMaybe<Scalars['ID']['input']>;
  /** The project ARI which contains container */
  project: Scalars['ID']['input'];
};

export type CopyPolarisInsightsInput = {
  /** Destination container to copy insgihts */
  destination: CopyPolarisInsightsContainerInput;
  /** Insight ARI's list that should be copied. Leave it empty to copy all insights from source to destination */
  insights?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Source container to copy insgihts */
  source: CopyPolarisInsightsContainerInput;
};

export type CreateAppDeploymentInput = {
  appId: Scalars['ID']['input'];
  artifactUrl: Scalars['URL']['input'];
  environmentKey: Scalars['String']['input'];
  hostedResourceUploadId?: InputMaybe<Scalars['ID']['input']>;
  majorVersion?: InputMaybe<Scalars['Int']['input']>;
};

export type CreateAppDeploymentUrlInput = {
  appId: Scalars['ID']['input'];
};

export type CreateAppEnvironmentInput = {
  appAri: Scalars['String']['input'];
  environmentKey: Scalars['String']['input'];
  environmentType: AppEnvironmentType;
};

export type CreateAppInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/**
 * Establish tunnels for a specific environment of an app.
 *
 * This will redirect all function calls to the provided faas url. This URL must implement the same
 * invocation contract that is used elsewhere in Xen.
 *
 * This will also be used to redirect Custom UI product rendering to the custom ui urls. We separate
 * them by extension key.
 */
export type CreateAppTunnelsInput = {
  /** The app to setup a tunnel for */
  appId: Scalars['ID']['input'];
  /** The environment key */
  environmentKey: Scalars['String']['input'];
  /** Should existing tunnels be overwritten */
  force?: InputMaybe<Scalars['Boolean']['input']>;
  /** The tunnel definitions */
  tunnelDefinitions: TunnelDefinitionsInput;
};

/**
 * ## Mutations
 * ## Column Mutations ###
 */
export type CreateColumnInput = {
  boardId: Scalars['ID']['input'];
  columnName: Scalars['String']['input'];
};

/** The user-provided input to eventually get an answer to a given question */
export type CreateCompassAssistantAnswerInput = {
  /** User-provided prompt with the question to be answered */
  question: Scalars['String']['input'];
};

/** Accepts input to create an external alias of a component. */
export type CreateCompassComponentExternalAliasInput = {
  /** The ID of the component to which you add the alias. */
  componentId: Scalars['ID']['input'];
  /** An alias of the component identifier in external sources. */
  externalAlias: CompassExternalAliasInput;
};

export type CreateCompassComponentFromTemplateArgumentInput = {
  key: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

/**
 * ###################################################################################################################
 *  COMPASS COMPONENT TEMPLATE
 * ###################################################################################################################
 */
export type CreateCompassComponentFromTemplateInput = {
  /** The details of the component to create. */
  createComponentDetails: CreateCompassComponentInput;
  /** The optional parameter indicating the key of the project to fork into. Currently only implemented for Bitbucket repositories. */
  projectKey?: InputMaybe<Scalars['String']['input']>;
  /** Arguments to pass into your template as parameters. Note: This field is not in use currently. */
  templateArguments?: InputMaybe<Array<CreateCompassComponentFromTemplateArgumentInput>>;
  /** The unique identifier (ID) of the template component. */
  templateComponentId: Scalars['ID']['input'];
};

/** Accepts input for creating a new component. */
export type CreateCompassComponentInput = {
  /** A collection of custom fields for storing data about the component. */
  customFields?: InputMaybe<Array<CompassCustomFieldInput>>;
  /** The description of the component. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** A collection of fields for storing data about the component. */
  fields?: InputMaybe<Array<CreateCompassFieldInput>>;
  /** A list of labels to add to the component */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of links to associate with the component */
  links?: InputMaybe<Array<CreateCompassLinkInput>>;
  /** The name of the component. */
  name: Scalars['String']['input'];
  /** The unique identifier (ID) of the team that owns the component. */
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  /** The state of the component. */
  state?: InputMaybe<Scalars['String']['input']>;
  /** The type of the component. */
  type?: InputMaybe<CompassComponentType>;
  /** The type of the component. */
  typeId?: InputMaybe<Scalars['ID']['input']>;
};

/** Accepts input to add links for a component. */
export type CreateCompassComponentLinkInput = {
  /** The ID of the component to add the link. */
  componentId: Scalars['ID']['input'];
  /** The link to be added for the component. */
  link: CreateCompassLinkInput;
};

export type CreateCompassComponentTypeInput = {
  /** The description of the component type. */
  description: Scalars['String']['input'];
  /** The icon key of the component type. */
  iconKey: Scalars['String']['input'];
  /** The name of the component type. */
  name: Scalars['String']['input'];
};

/** Accepts input to create a field. */
export type CreateCompassFieldInput = {
  /** The ID of the field definition. */
  definition: Scalars['ID']['input'];
  /** The value of the field. */
  value: CompassFieldValueInput;
};

/** Input to create a freeform user defined parameter. */
export type CreateCompassFreeformUserDefinedParameterInput = {
  /** The value that will be used if the user does not provide a value. */
  defaultValue?: InputMaybe<Scalars['String']['input']>;
  /** The description of the parameter. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the parameter. */
  name: Scalars['String']['input'];
};

/** Accepts input to a create a scorecard criterion representing the presence of a description. */
export type CreateCompassHasDescriptionScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts input to create a scorecard criterion representing the presence of a field, for example, 'Has Tier'. */
export type CreateCompassHasFieldScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID for the field definition that is the target of a relationship. */
  fieldDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts input to create a scorecard criterion representing the presence of a link, for example, 'Has Repository' or 'Has Documentation'. */
export type CreateCompassHasLinkScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The type of link, for example, 'Repository' if 'Has Repository'. */
  linkType: CompassLinkType;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The comparison operation to be performed. */
  textComparator?: InputMaybe<CompassCriteriaTextComparatorOptions>;
  /** The value that the field is compared to. */
  textComparatorValue?: InputMaybe<Scalars['String']['input']>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts input to create a scorecard criterion checking the value of a specified metric ID. */
export type CreateCompassHasMetricValueCriteriaInput = {
  /** Automatically create metric sources for the custom metric definition associated with this criterion */
  automaticallyCreateMetricSources?: InputMaybe<Scalars['Boolean']['input']>;
  /** The comparison operation to be performed between the metric and comparator value. */
  comparator: CompassCriteriaNumberComparatorOptions;
  /** The threshold value that the metric is compared to. */
  comparatorValue: Scalars['Float']['input'];
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the component metric to check the value of. */
  metricDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts input to a create a scorecard criterion representing the presence of an owner. */
export type CreateCompassHasOwnerScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts details of the link to add to a component. */
export type CreateCompassLinkInput = {
  /** The name of the link. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The type of the link. */
  type: CompassLinkType;
  /** The URL of the link. */
  url: Scalars['URL']['input'];
};

/** Accepts input for creating a new relationship. */
export type CreateCompassRelationshipInput = {
  /** The unique identifier (ID) of the component at the ending node. */
  endNodeId: Scalars['ID']['input'];
  /** The unique identifier (ID) of the component at the starting node. */
  startNodeId: Scalars['ID']['input'];
  /** The type of the relationship. */
  type: CompassRelationshipType;
};

/** Accepts input to create a scorecard criterion. */
export type CreateCompassScorecardCriteriaInput = {
  hasCustomBooleanValue?: InputMaybe<CompassCreateHasCustomBooleanFieldScorecardCriteriaInput>;
  hasCustomMultiSelectValue?: InputMaybe<CompassCreateHasCustomMultiSelectFieldScorecardCriteriaInput>;
  hasCustomNumberValue?: InputMaybe<CompassCreateHasCustomNumberFieldScorecardCriteriaInput>;
  hasCustomSingleSelectValue?: InputMaybe<CompassCreateHasCustomSingleSelectFieldScorecardCriteriaInput>;
  hasCustomTextValue?: InputMaybe<CompassCreateHasCustomTextFieldScorecardCriteriaInput>;
  hasDescription?: InputMaybe<CreateCompassHasDescriptionScorecardCriteriaInput>;
  hasField?: InputMaybe<CreateCompassHasFieldScorecardCriteriaInput>;
  hasLink?: InputMaybe<CreateCompassHasLinkScorecardCriteriaInput>;
  hasMetricValue?: InputMaybe<CreateCompassHasMetricValueCriteriaInput>;
  hasOwner?: InputMaybe<CreateCompassHasOwnerScorecardCriteriaInput>;
};

export type CreateCompassScorecardInput = {
  componentCreationTimeFilter?: InputMaybe<CompassComponentCreationTimeFilterInput>;
  componentLabelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  componentLifecycleStages?: InputMaybe<CompassLifecycleFilterInput>;
  componentOwnerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  componentTierValues?: InputMaybe<Array<Scalars['String']['input']>>;
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  criterias?: InputMaybe<Array<CreateCompassScorecardCriteriaInput>>;
  description?: InputMaybe<Scalars['String']['input']>;
  importance: CompassScorecardImportance;
  isDeactivationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  repositoryValues?: InputMaybe<CompassRepositoryValueInput>;
  scoringStrategyType?: InputMaybe<CompassScorecardScoringStrategyType>;
};

/** Accepts input for creating a starred component. */
export type CreateCompassStarredComponentInput = {
  /** The ID of the component to be starred. */
  componentId: Scalars['ID']['input'];
};

export type CreateCompassUserDefinedParameterInput = {
  freeformField?: InputMaybe<CreateCompassFreeformUserDefinedParameterInput>;
};

export type CreateComponentApiUploadInput = {
  componentId: Scalars['ID']['input'];
};

/** CustomFilters Mutation */
export type CreateCustomFilterInput = {
  boardId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  jql: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

/** The request input for creating a relationship between a DevOps Service and an Jira Project. */
export type CreateDevOpsServiceAndJiraProjectRelationshipInput = {
  /** The ID of the site of the service and the Jira project. */
  cloudId: Scalars['ID']['input'];
  /** An optional description of the relationship. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The Jira project ARI */
  jiraProjectId: Scalars['ID']['input'];
  /** Optional properties of the relationship. */
  properties?: InputMaybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
  /** The type of the relationship. */
  relationshipType: DevOpsServiceAndJiraProjectRelationshipType;
  /** The ARI of the DevOps Service. */
  serviceId: Scalars['ID']['input'];
};

/** The request input for creating a relationship between a DevOps Service and an Opsgenie Team */
export type CreateDevOpsServiceAndOpsgenieTeamRelationshipInput = {
  /**
   * We can't infer this from the service ARI since the container association registry doesn't own the service ARI -
   * therefore we have to treat it as opaque.
   */
  cloudId: Scalars['ID']['input'];
  /** An optional description of the relationship. */
  description?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ARI of the Opsgenie Team
   *
   * The Opsgenie team must exist on the same site as the service. If it doesn't, the create will fail
   * with a OPSGENIE_TEAM_ID_INVALID error.
   */
  opsgenieTeamId: Scalars['ID']['input'];
  /** Optional properties of the relationship. */
  properties?: InputMaybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
  /** The ARI of the DevOps Service. */
  serviceId: Scalars['ID']['input'];
};

/** The request input for creating a relationship between a DevOps Service and a Repository */
export type CreateDevOpsServiceAndRepositoryRelationshipInput = {
  /** The Bitbucket Repository ARI */
  bitbucketRepositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** An optional description of the relationship. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Optional properties of the relationship. */
  properties?: InputMaybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
  /** The ARI of the DevOps Service. */
  serviceId: Scalars['ID']['input'];
  /** The Third Party Repository. It should be null when repositoryId is a Bitbucket Repository ARI */
  thirdPartyRepository?: InputMaybe<ThirdPartyRepositoryInput>;
};

/** The request input for creating a new DevOps Service */
export type CreateDevOpsServiceInput = {
  cloudId: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  properties?: InputMaybe<Array<DevOpsServiceEntityPropertyInput>>;
  /** Tier assigned to the DevOps Service */
  serviceTier: DevOpsServiceTierInput;
  /** Service Type asigned to the DevOps Service */
  serviceType?: InputMaybe<DevOpsServiceTypeInput>;
};

/** The request input for creating a new DevOps Service Relationship */
export type CreateDevOpsServiceRelationshipInput = {
  /** The description of the relationship */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The Service ARI of the end node of the relationship */
  endId: Scalars['ID']['input'];
  /** The properties of the relationship */
  properties?: InputMaybe<Array<DevOpsServiceEntityPropertyInput>>;
  /** The Service ARI of the start node of the relationship */
  startId: Scalars['ID']['input'];
  /** The inter-service relationship type */
  type: DevOpsServiceRelationshipType;
};

export type CreateEventSourceInput = {
  /** The cloud ID of the site to create an event source for. */
  cloudId: Scalars['ID']['input'];
  /** The type of the event that the event source can accept. */
  eventType: CompassEventType;
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
};

export type CreateHostedResourceUploadUrlInput = {
  appId: Scalars['ID']['input'];
  environmentKey: Scalars['String']['input'];
  resourceKeys: Array<Scalars['String']['input']>;
};

/** #################### Mutation Input - Jira Project and Opsgenie Team Relationship ##################### */
export type CreateJiraProjectAndOpsgenieTeamRelationshipInput = {
  /** An optional description of the relationship. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ARI of the Jira project. */
  jiraProjectId: Scalars['ID']['input'];
  /** The type of Jira. */
  jiraProjectType?: InputMaybe<DevOpsJiraProjectType>;
  /**
   * The Opsgenie team must exist on the same site as the service. If it doesn't, the create will fail
   * with a OPSGENIE_TEAM_ID_INVALID error.
   */
  opsgenieTeamId: Scalars['ID']['input'];
  /** Optional properties of the relationship. */
  properties?: InputMaybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
};

/** The request input for creating a relationship between a Jira project and a repository */
export type CreateJiraProjectAndRepositoryRelationshipInput = {
  /**
   * The Bitbucket repository ARI.
   * This parameter should be null when the third party repository is not null, and vice versa.
   */
  bitbucketRepositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** An optional description of the relationship */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The project ARI */
  jiraProjectId: Scalars['ID']['input'];
  /** Optional properties of the relationship */
  properties?: InputMaybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
  /**
   * The third party repository details.
   * This parameter should be null when the Bitbucket repository ARI is not null, and vice versa.
   */
  thirdPartyRepository?: InputMaybe<ThirdPartyRepositoryInput>;
};

export type CreatePolarisCommentInput = {
  content?: InputMaybe<Scalars['JSON']['input']>;
  kind?: InputMaybe<PolarisCommentKind>;
  subject?: InputMaybe<Scalars['ID']['input']>;
};

export type CreatePolarisIdeaTemplateInput = {
  color?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  emoji?: InputMaybe<Scalars['String']['input']>;
  project: Scalars['ID']['input'];
  /**
   * Template in ADF format.  See
   * https://developer.atlassian.com/platform/atlassian-document-format/
   */
  template?: InputMaybe<Scalars['JSON']['input']>;
  title: Scalars['String']['input'];
};

export type CreatePolarisInsightInput = {
  /** The cloudID in which we are adding insight */
  cloudID: Scalars['String']['input'];
  /**
   * DEPRECATED, DO NOT USE
   * Array of datas in JSON format. It will be validated with JSON schema of Polaris Insights Data format.
   */
  data?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Description in ADF format https://developer.atlassian.com/platform/atlassian-document-format/ */
  description?: InputMaybe<Scalars['JSON']['input']>;
  /** The issueID in which we are adding insight, cloud be empty for adding insight on project level */
  issueID?: InputMaybe<Scalars['Int']['input']>;
  /** The projectID in which we are adding insight */
  projectID: Scalars['Int']['input'];
  /** Array of snippets */
  snippets?: InputMaybe<Array<CreatePolarisSnippetInput>>;
};

export type CreatePolarisPlayContribution = {
  /**  the issue (idea) to which this contribution is being made */
  amount?: InputMaybe<Scalars['Int']['input']>;
  /**  the extent of the contribution (null=drop value) */
  comment?: InputMaybe<Scalars['JSON']['input']>;
  play: Scalars['ID']['input'];
  /**  the play being contributed to */
  subject: Scalars['ID']['input'];
};

export type CreatePolarisPlayInput = {
  /**  the view from which the play is created */
  description?: InputMaybe<Scalars['JSON']['input']>;
  fromView?: InputMaybe<Scalars['ID']['input']>;
  kind: PolarisPlayKind;
  label: Scalars['String']['input'];
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  project: Scalars['ID']['input'];
  /**  the label for the play field, and the "short" name of the play */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** # Types */
export type CreatePolarisProjectInput = {
  key: Scalars['String']['input'];
  name: Scalars['String']['input'];
  tenant: Scalars['ID']['input'];
};

export type CreatePolarisSnippetInput = {
  /** Data in JSON format. It will be validated with JSON schema of Polaris Insights Data format. */
  data?: InputMaybe<Scalars['JSON']['input']>;
  /** OauthClientId of CaaS app */
  oauthClientId: Scalars['String']['input'];
  /**
   * DEPRECATED, DO NOT USE
   * Snippet-level properties in JSON format.
   */
  properties?: InputMaybe<Scalars['JSON']['input']>;
  /** Snippet url that is source of data */
  url?: InputMaybe<Scalars['String']['input']>;
};

export type CreatePolarisViewInput = {
  container: Scalars['ID']['input'];
  /**  the type of viz to create */
  copyView?: InputMaybe<Scalars['ID']['input']>;
  /**  view to copy configuration from */
  update?: InputMaybe<UpdatePolarisViewInput>;
  visualizationType?: InputMaybe<PolarisVisualizationType>;
};

export type CreatePolarisViewSetInput = {
  container: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

/**  Types */
export type CreateRankingListInput = {
  items?: InputMaybe<Array<Scalars['String']['input']>>;
  listId: Scalars['ID']['input'];
};

/** Create sprint */
export type CreateSprintInput = {
  boardId: Scalars['ID']['input'];
};

export type CustomEntity = {
  attributes: Array<CustomEntityAttribute>;
  indexes?: InputMaybe<Array<CustomEntityIndex>>;
  name: Scalars['String']['input'];
};

export type CustomEntityAttribute = {
  name: Scalars['String']['input'];
  required?: InputMaybe<Scalars['Boolean']['input']>;
  type: CustomEntityAttributeType;
};

export enum CustomEntityAttributeType {
  Any = 'any',
  Boolean = 'boolean',
  Float = 'float',
  Integer = 'integer',
  String = 'string'
}

export type CustomEntityIndex = {
  name: Scalars['String']['input'];
  partition?: InputMaybe<Array<Scalars['String']['input']>>;
  range: Array<Scalars['String']['input']>;
};

export enum CustomEntityIndexStatus {
  Active = 'ACTIVE',
  Creating = 'CREATING',
  Inactive = 'INACTIVE',
  Pending = 'PENDING'
}

export type CustomEntityMutationInput = {
  entities: Array<CustomEntity>;
  oauthClientId: Scalars['String']['input'];
};

export enum CustomEntityStatus {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

export type CustomUiTunnelDefinitionInput = {
  resourceKey?: InputMaybe<Scalars['String']['input']>;
  tunnelUrl?: InputMaybe<Scalars['URL']['input']>;
};

/** DEPRECATED: Use CustomerServiceCustomDetailConfigMetadataUpdateInput instead. */
export type CustomerServiceAttributeConfigMetadataUpdateInput = {
  /** Context configuration */
  contextConfigurations?: InputMaybe<Array<InputMaybe<CustomerServiceContextConfigurationInput>>>;
  /** ID of the custom attribute */
  id: Scalars['ID']['input'];
  /** position of the attribute */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** Styles configuration */
  styleConfiguration?: InputMaybe<CustomerServiceCustomAttributeStyleConfigurationInput>;
};

/** DEPRECATED: use CustomerServiceCustomDetailCreateInput instead. */
export type CustomerServiceAttributeCreateInput = {
  /** Context configuration */
  contextConfigurations?: InputMaybe<Array<InputMaybe<CustomerServiceContextConfigurationInput>>>;
  /** The name of the attribute to create */
  name: Scalars['String']['input'];
  /** The type of the attribute to create */
  type?: InputMaybe<CustomerServiceAttributeCreateTypeInput>;
};

/** DEPRECATED: use CustomerServiceCustomDetailCreateTypeInput instead. */
export type CustomerServiceAttributeCreateTypeInput = {
  /** The type of the attribute to be created */
  name?: InputMaybe<CustomerServiceAttributeTypeName>;
  /** Options for this type, only valid if the provided type is SELECT/MULTI-SELECT. Empty otherwise. */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** DEPRECATED: Use CustomerServiceCustomDetailDeleteInput instead. */
export type CustomerServiceAttributeDeleteInput = {
  /** ID of the custom attribute */
  id: Scalars['ID']['input'];
};

/**
 * The types of attributes that can exist
 * DEPRECATED: use CustomerServiceCustomDetailTypeName instead.
 * NOTE: Please do not modify enums without first notifying the FE team.
 */
export enum CustomerServiceAttributeTypeName {
  Boolean = 'BOOLEAN',
  Date = 'DATE',
  Email = 'EMAIL',
  Multiselect = 'MULTISELECT',
  Number = 'NUMBER',
  Phone = 'PHONE',
  Select = 'SELECT',
  Text = 'TEXT',
  Url = 'URL',
  User = 'USER'
}

/** DEPRECATED: use CustomerServiceCustomDetailUpdateInput instead. */
export type CustomerServiceAttributeUpdateInput = {
  /** ID of the custom attribute */
  id: Scalars['ID']['input'];
  /** The updated name for the attribute to update */
  name: Scalars['String']['input'];
  /** The type of the attribute to update */
  type?: InputMaybe<CustomerServiceAttributeUpdateTypeInput>;
};

/** DEPRECATED: use CustomerServiceCustomDetailUpdateTypeInput instead. */
export type CustomerServiceAttributeUpdateTypeInput = {
  /** The type of the attribute to be updated */
  name?: InputMaybe<CustomerServiceAttributeTypeName>;
  /** Options for this type, only valid if the provided type is SELECT/MULTI-SELECT. Empty Otherwise. */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type CustomerServiceContext = {
  issueId?: InputMaybe<Scalars['String']['input']>;
  type: CustomerServiceContextType;
};

export type CustomerServiceContextConfigurationInput = {
  context: CustomerServiceContextType;
  enabled: Scalars['Boolean']['input'];
};

/** Context is the place where detail fields are being requested. The Context determines which configurations to use. Configurations determines settings like: the max number of fields allowed and if a field is enabled for displayed or not */
export enum CustomerServiceContextType {
  /** Organization/Customer Details View */
  Default = 'DEFAULT',
  /** Jira Issue View */
  Issue = 'ISSUE'
}

export type CustomerServiceCustomAttributeOptionStyleInput = {
  backgroundColour: Scalars['String']['input'];
};

export type CustomerServiceCustomAttributeOptionsStyleConfigurationInput = {
  optionValue: Scalars['String']['input'];
  style: CustomerServiceCustomAttributeOptionStyleInput;
};

export type CustomerServiceCustomAttributeStyleConfigurationInput = {
  options?: InputMaybe<Array<CustomerServiceCustomAttributeOptionsStyleConfigurationInput>>;
};

export type CustomerServiceCustomDetailConfigMetadataUpdateInput = {
  /** Context configuration */
  contextConfigurations?: InputMaybe<Array<CustomerServiceContextConfigurationInput>>;
  /** The ID of the custom detail */
  id: Scalars['ID']['input'];
  /** The position of the custom detail */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** Styles configuration */
  styleConfiguration?: InputMaybe<CustomerServiceCustomAttributeStyleConfigurationInput>;
};

export type CustomerServiceCustomDetailContextInput = {
  /** Context configuration */
  contextConfigurations?: InputMaybe<Array<CustomerServiceContextConfigurationInput>>;
  /** The ID of the custom detail */
  id: Scalars['ID']['input'];
};

export enum CustomerServiceCustomDetailCreateErrorCode {
  ColorNotSaved = 'COLOR_NOT_SAVED',
  PermissionsNotSaved = 'PERMISSIONS_NOT_SAVED'
}

export type CustomerServiceCustomDetailCreateInput = {
  /** Context configuration */
  contextConfigurations?: InputMaybe<Array<CustomerServiceContextConfigurationInput>>;
  /** The entity type to create a custom detail for */
  customDetailEntityType: CustomerServiceCustomDetailsEntityType;
  /** The PermissionGroup IDs of the user roles that are able to edit this detail */
  editPermissions?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The name of the custom detail to create */
  name: Scalars['String']['input'];
  /** The PermissionGroup IDs of the user roles that are able to view this detail */
  readPermissions?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Styles configuration */
  styleConfiguration?: InputMaybe<CustomerServiceCustomAttributeStyleConfigurationInput>;
  /** The type of the custom detail to create */
  type?: InputMaybe<CustomerServiceCustomDetailCreateTypeInput>;
};

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceCustomDetailCreateTypeInput = {
  /** The type of the custom detail to be created */
  name?: InputMaybe<CustomerServiceCustomDetailTypeName>;
  /** Options for this type, only valid if the provided type is SELECT/MULTI-SELECT. Empty otherwise. */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type CustomerServiceCustomDetailDeleteInput = {
  /** ID of the custom detail */
  id: Scalars['ID']['input'];
};

export type CustomerServiceCustomDetailEntityTypeId = {
  /** The ID of the individual that the custom detail is for */
  accountId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the entitlement that the custom detail is for */
  entitlementId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the organization that the custom detail is for */
  organizationId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceCustomDetailPermissionsUpdateInput = {
  /** The CustomerServicePermissionGroup IDs that are able to edit this detail. */
  editPermissions?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The ID of the detail */
  id: Scalars['ID']['input'];
  /** The CustomerServicePermissionGroup IDs that are able to view this detail */
  readPermissions?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * The types of custom details that can exist
 * NOTE: Please do not modify enums without first notifying the FE team.
 */
export enum CustomerServiceCustomDetailTypeName {
  Boolean = 'BOOLEAN',
  Date = 'DATE',
  Email = 'EMAIL',
  Multiselect = 'MULTISELECT',
  Number = 'NUMBER',
  Phone = 'PHONE',
  Select = 'SELECT',
  Text = 'TEXT',
  Url = 'URL',
  User = 'USER'
}

export type CustomerServiceCustomDetailUpdateInput = {
  /** ID of the custom detail */
  id: Scalars['ID']['input'];
  /** The updated name for the custom detail to update */
  name: Scalars['String']['input'];
  /** The type of the custom detail to update */
  type?: InputMaybe<CustomerServiceCustomDetailUpdateTypeInput>;
};

export type CustomerServiceCustomDetailUpdateTypeInput = {
  /** The type of the custom detail to be updated */
  name?: InputMaybe<CustomerServiceCustomDetailTypeName>;
  /** Options for this type, only valid if the provided type is SELECT/MULTI-SELECT. Empty Otherwise. */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** The available entities */
export enum CustomerServiceCustomDetailsEntityType {
  Customer = 'CUSTOMER',
  Entitlement = 'ENTITLEMENT',
  Organization = 'ORGANIZATION'
}

/**
 * #########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceEntitlementAddInput = {
  /** The ID of the entity that the entitlement is for (customer or organization) */
  entitlementEntityId: CustomerServiceEntitlementEntityId;
  /** The ID of the product that the entitlement is for */
  productId: Scalars['ID']['input'];
};

export type CustomerServiceEntitlementEntityId = {
  /** The ID of the customer that the entitlement is for */
  accountId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the organization that the entitlement is for */
  organizationId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * ###############################
 *  Base objects for entitlements
 * ###############################
 */
export type CustomerServiceEntitlementFilterInput = {
  /** The product ID to filter entitlements results by */
  productId?: InputMaybe<Scalars['ID']['input']>;
};

export type CustomerServiceEntitlementRemoveInput = {
  /** The ID of the entitlement */
  entitlementId: Scalars['ID']['input'];
};

export type CustomerServiceFilterInput = {
  context: CustomerServiceContext;
};

export type CustomerServiceIndividualUpdateAttributeByNameInput = {
  /**  Account ID of the individual whose attribute you wish to update */
  accountId: Scalars['String']['input'];
  /**  The name of the attribute whose value should be updated  */
  attributeName: Scalars['String']['input'];
  /**  The new value for the attribute  */
  attributeValue: Scalars['String']['input'];
};

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceIndividualUpdateAttributeInput = {
  /**  Account ID of the individual whose attribute you wish to update */
  accountId: Scalars['String']['input'];
  /**  The ID of the attribute whose value should be updated  */
  attributeId: Scalars['String']['input'];
  /**  The new value for the attribute  */
  attributeValue: Scalars['String']['input'];
};

export type CustomerServiceIndividualUpdateAttributeMultiValueByNameInput = {
  /**  Account ID of the individual whose attribute you wish to update */
  accountId: Scalars['String']['input'];
  /**  The name of the attribute whose value should be updated  */
  attributeName: Scalars['String']['input'];
  /**  The new value for the attribute  */
  attributeValues: Array<Scalars['String']['input']>;
};

export type CustomerServiceLinkCreateInput = {
  /** Display name for the link */
  displayName?: InputMaybe<Scalars['String']['input']>;
  /** ID of the entity */
  entityId: Scalars['ID']['input'];
  /** The type of the entity that will be associated with the new link */
  type: CustomerServiceLinkEntityType;
  /** The url that the link will point to */
  url: Scalars['URL']['input'];
};

export type CustomerServiceLinkDeleteInput = {
  /** ID of the entity */
  entityId: Scalars['ID']['input'];
  /** The ID of the link being deleted */
  linkId: Scalars['ID']['input'];
  /** The type of the entity that will be associated with the new link */
  type: CustomerServiceLinkEntityType;
};

/**
 * #########################
 *  Mutation Inputs
 * #########################
 */
export enum CustomerServiceLinkEntityType {
  Customer = 'CUSTOMER',
  Organization = 'ORGANIZATION'
}

export type CustomerServiceNoteCreateInput = {
  body: Scalars['String']['input'];
  entityId: Scalars['ID']['input'];
  entityType: CustomerServiceNoteEntity;
};

export type CustomerServiceNoteDeleteInput = {
  entityId: Scalars['ID']['input'];
  entityType: CustomerServiceNoteEntity;
  noteId: Scalars['ID']['input'];
};

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export enum CustomerServiceNoteEntity {
  Customer = 'CUSTOMER',
  Organization = 'ORGANIZATION'
}

export type CustomerServiceNoteUpdateInput = {
  body: Scalars['String']['input'];
  entityId: Scalars['ID']['input'];
  entityType: CustomerServiceNoteEntity;
  noteId: Scalars['ID']['input'];
};

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceOrganizationCreateInput = {
  /** The ID of the organization to create */
  id: Scalars['ID']['input'];
  /** Organization name to be created */
  name: Scalars['String']['input'];
};

export type CustomerServiceOrganizationDeleteInput = {
  /**  The ID of the organization to delete */
  id: Scalars['ID']['input'];
};

export type CustomerServiceOrganizationUpdateAttributeByNameInput = {
  /**  The name of the attribute whose value should be updated  */
  attributeName: Scalars['String']['input'];
  /**  The new value for the attribute  */
  attributeValue: Scalars['String']['input'];
  /**  ID of the organisation whose attribute you wish to update */
  organizationId: Scalars['String']['input'];
};

export type CustomerServiceOrganizationUpdateAttributeInput = {
  /**  The ID of the attribute whose value should be updated  */
  attributeId: Scalars['String']['input'];
  /**  The new value for the attribute  */
  attributeValue: Scalars['String']['input'];
  /**  ID of the organisation whose attribute you wish to update */
  organizationId: Scalars['String']['input'];
};

export type CustomerServiceOrganizationUpdateAttributeMultiValueByNameInput = {
  /**  The name of the attribute whose value should be updated  */
  attributeName: Scalars['String']['input'];
  /**  The new values for the attribute  */
  attributeValues: Array<Scalars['String']['input']>;
  /**  ID of the organisation whose attribute you wish to update */
  organizationId: Scalars['String']['input'];
};

export type CustomerServiceOrganizationUpdateInput = {
  /** The ID of the organization to update */
  id: Scalars['ID']['input'];
  /** Organization name to be updated */
  name?: InputMaybe<Scalars['String']['input']>;
};

export enum CustomerServicePermissionGroupType {
  Admins = 'ADMINS',
  AdminsAgents = 'ADMINS_AGENTS',
  AdminsAgentsSiteAccess = 'ADMINS_AGENTS_SITE_ACCESS'
}

/**
 * #########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceProductCreateInput = {
  /** The name of the new product */
  name: Scalars['String']['input'];
};

export type CustomerServiceProductDeleteInput = {
  /** The ID of the product to be deleted */
  id: Scalars['ID']['input'];
};

export type CustomerServiceProductFilterInput = {
  /** Case insensitive string to filter products by names they begin with */
  nameBeginsWith?: InputMaybe<Scalars['String']['input']>;
  /** Case insensitive string to filter product names with */
  nameContains?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerServiceProductUpdateInput = {
  /** The ID of the product to be updated */
  id: Scalars['ID']['input'];
  /** The updated name of the product */
  name: Scalars['String']['input'];
};

export type CustomerServiceUpdateCustomDetailValueInput = {
  /** ID of the entity whose custom detail you wish to update */
  id: CustomerServiceCustomDetailEntityTypeId;
  /** The name of the custom detail whose value should be updated */
  name: Scalars['String']['input'];
  /** The new value for the custom detail, for a single value field */
  value?: InputMaybe<Scalars['String']['input']>;
  /** The new value for the custom detail, for a multi-value field */
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type DataClassificationPolicyDecisionInput = {
  dataClassificationTags: Array<Scalars['ID']['input']>;
};

export enum DataClassificationPolicyDecisionStatus {
  Allowed = 'ALLOWED',
  Blocked = 'BLOCKED'
}

export enum DataResidencyResponse {
  AppDoesNotSupportDr = 'APP_DOES_NOT_SUPPORT_DR',
  NotApplicable = 'NOT_APPLICABLE',
  StoredExternalToAtlassian = 'STORED_EXTERNAL_TO_ATLASSIAN',
  StoredInAtlassianAndDrNotSupported = 'STORED_IN_ATLASSIAN_AND_DR_NOT_SUPPORTED',
  StoredInAtlassianAndDrSupported = 'STORED_IN_ATLASSIAN_AND_DR_SUPPORTED'
}

/** Time ranges of invocation date. */
export type DateSearchInput = {
  /**
   * The start time of the earliest invocation to include in the results.
   * If null, search results will only be limited by retention limits.
   *
   * RFC-3339 formatted timestamp.
   */
  earliestStart?: InputMaybe<Scalars['String']['input']>;
  /**
   * The start time of the latest invocation to include in the results.
   * If null, will include most recent invocations.
   *
   * RFC-3339 formatted timestamp.
   */
  latestStart?: InputMaybe<Scalars['String']['input']>;
};

export type DeleteAppEnvironmentInput = {
  appAri: Scalars['ID']['input'];
  environmentKey: Scalars['String']['input'];
};

export type DeleteAppEnvironmentVariableInput = {
  environment: AppEnvironmentInput;
  /** The key of the environment variable to delete */
  key: Scalars['String']['input'];
};

export type DeleteAppInput = {
  appId: Scalars['ID']['input'];
};

export type DeleteAppStoredCustomEntityMutationInput = {
  /** The ARI to store this entity within */
  contextAri: Scalars['ID']['input'];
  /** Specify entity name for custom schema */
  entityName: Scalars['String']['input'];
  /** The identifier for the entity */
  key: Scalars['ID']['input'];
};

export type DeleteAppStoredEntityMutationInput = {
  /** The ARI to store this entity within */
  contextAri: Scalars['ID']['input'];
  /** Specify whether the encrypted value should be deleted */
  encrypted?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The identifier for the entity
   *
   * Keys must be between 1-100 characters long and must match the following pattern /^[a-zA-Z0-9:._\s-]+$/
   */
  key: Scalars['ID']['input'];
};

export type DeleteAppTunnelInput = {
  /** The app to setup a tunnel for */
  appId: Scalars['ID']['input'];
  /** The environment key */
  environmentKey: Scalars['String']['input'];
};

export type DeleteCardInput = {
  cardId: Scalars['ID']['input'];
};

export type DeleteColumnInput = {
  boardId: Scalars['ID']['input'];
  columnId: Scalars['ID']['input'];
};

/** Accepts input to delete an external alias. */
export type DeleteCompassComponentExternalAliasInput = {
  /** The ID of the component to which you add the external alias. */
  componentId: Scalars['ID']['input'];
  /** The alias of the component identifier in external sources. */
  externalAlias: CompassDeleteExternalAliasInput;
};

/** Accepts input for deleting an existing component. */
export type DeleteCompassComponentInput = {
  /** The ID of the component to be deleted. */
  id: Scalars['ID']['input'];
};

/** Accepts input to delete a component link. */
export type DeleteCompassComponentLinkInput = {
  /** The ID for the component to delete a link. */
  componentId: Scalars['ID']['input'];
  /** The component link to be deleted. */
  link: Scalars['ID']['input'];
};

/** Input to delete a component type. */
export type DeleteCompassComponentTypeInput = {
  /** The ARI of the component type to be deleted. */
  id: Scalars['ID']['input'];
};

/** Accepts input for deleting an existing relationship between two components. */
export type DeleteCompassRelationshipInput = {
  /** The unique identifier (ID) of the component at the ending node. */
  endNodeId: Scalars['ID']['input'];
  /** The unique identifier (ID) of the component at the starting node. */
  startNodeId: Scalars['ID']['input'];
  /** The type of the relationship. */
  type: CompassRelationshipType;
};

export type DeleteCompassScorecardCriteriaInput = {
  /** ID of the scorecard criterion for deletion. The criteria is already applied to a scorecard. */
  id: Scalars['ID']['input'];
};

/** Accepts input for deleting a starred component. */
export type DeleteCompassStarredComponentInput = {
  /** The ID of the component to be un-starred. */
  componentId: Scalars['ID']['input'];
};

/** Input to delete an individual user defined parameter. */
export type DeleteCompassUserDefinedParameterInput = {
  /** The id of the parameter to delete */
  id: Scalars['ID']['input'];
};

export type DeleteCustomFilterInput = {
  boardId: Scalars['ID']['input'];
  customFilterId: Scalars['String']['input'];
};

/** The request input for deleting relationship properties */
export type DeleteDevOpsContainerRelationshipEntityPropertiesInput = {
  /** The ARI of the any of the relationship entity */
  id: Scalars['ID']['input'];
  /** The properties with the given keys in the list will be removed from the relationship */
  keys: Array<Scalars['String']['input']>;
};

/** The request input for deleting a relationship between a DevOps Service and a Jira Project */
export type DeleteDevOpsServiceAndJiraProjectRelationshipInput = {
  /** The DevOps Graph Service_And_Jira_Project relationship ARI */
  id: Scalars['ID']['input'];
};

/** The request input for deleting a relationship between a DevOps Service and an Opsgenie Team */
export type DeleteDevOpsServiceAndOpsgenieTeamRelationshipInput = {
  id: Scalars['ID']['input'];
};

/** The request input for deleting a relationship between a DevOps Service and a Repository */
export type DeleteDevOpsServiceAndRepositoryRelationshipInput = {
  /** The ARI of the relationship */
  id: Scalars['ID']['input'];
};

/** The request input for deleting DevOps Service Entity Properties */
export type DeleteDevOpsServiceEntityPropertiesInput = {
  /** The ARI of the DevOps Service */
  id: Scalars['ID']['input'];
  /** The properties with the given keys in the list will be removed from the DevOps Service */
  keys: Array<Scalars['String']['input']>;
};

/** The request input for deleting a DevOps Service */
export type DeleteDevOpsServiceInput = {
  id: Scalars['ID']['input'];
};

/** The request input for deleting a DevOps Service Relationship */
export type DeleteDevOpsServiceRelationshipInput = {
  /** The ARI of the DevOps Service Relationship */
  id: Scalars['ID']['input'];
};

export type DeleteEventSourceInput = {
  /** The cloud ID of the site to delete an event source for. */
  cloudId: Scalars['ID']['input'];
  /** The type of event to be deleted. */
  eventType: CompassEventType;
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
};

export type DeleteJiraProjectAndOpsgenieTeamRelationshipInput = {
  id: Scalars['ID']['input'];
};

/** The request input for deleting a relationship between a Jira project and a repository */
export type DeleteJiraProjectAndRepositoryRelationshipInput = {
  /** The relationship ARI */
  id: Scalars['ID']['input'];
};

export type DeletePolarisIdeaTemplateInput = {
  id: Scalars['ID']['input'];
  project: Scalars['ID']['input'];
};

/** Delete sprint */
export type DeleteSprintInput = {
  boardId: Scalars['ID']['input'];
  sprintId: Scalars['ID']['input'];
};

export type DeleteUserGrantInput = {
  oauthClientId: Scalars['ID']['input'];
};

/** The state that a code deployment can be in (think of a deployment in Bitbucket Pipelines, CircleCI, etc). */
export enum DeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

/** Accepts input to detach a data manager from a component. */
export type DetachCompassComponentDataManagerInput = {
  /** The ID of the component to detach a data manager from. */
  componentId: Scalars['ID']['input'];
};

export type DetachEventSourceInput = {
  /** The ID of the component to detach the event source from. */
  componentId: Scalars['ID']['input'];
  /** The ID of the event source. */
  eventSourceId: Scalars['ID']['input'];
};

/** The "phase" of the job the group of logs is associated with. Coding, planning, etc. */
export enum DevAiAutodevLogGroupPhase {
  CodeGenerating = 'CODE_GENERATING',
  CodeReview = 'CODE_REVIEW',
  CodeReGenerating = 'CODE_RE_GENERATING',
  PlanGenerating = 'PLAN_GENERATING',
  PlanReview = 'PLAN_REVIEW',
  PlanReGenerating = 'PLAN_RE_GENERATING'
}

/** Overall status of the group of logs. */
export enum DevAiAutodevLogGroupStatus {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS'
}

/** Status of the log item. */
export enum DevAiAutodevLogStatus {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS'
}

export type DevAiAutofixScanOrderInput = {
  order: SortDirection;
  sortByField: DevAiAutofixScanSortField;
};

export enum DevAiAutofixScanSortField {
  StartDate = 'START_DATE'
}

export enum DevAiAutofixScanStatus {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS'
}

export type DevAiAutofixTaskFilterInput = {
  primaryLanguage?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<DevAiAutofixTaskStatus>>;
};

export type DevAiAutofixTaskOrderInput = {
  order: SortDirection;
  sortByField: DevAiAutofixTaskSortField;
};

export enum DevAiAutofixTaskSortField {
  CreatedAt = 'CREATED_AT',
  Filename = 'FILENAME',
  NewCoveragePercentage = 'NEW_COVERAGE_PERCENTAGE',
  PreviousCoveragePercentage = 'PREVIOUS_COVERAGE_PERCENTAGE',
  PrimaryLanguage = 'PRIMARY_LANGUAGE',
  Status = 'STATUS',
  UpdatedAt = 'UPDATED_AT'
}

export enum DevAiAutofixTaskStatus {
  PrDeclined = 'PR_DECLINED',
  PrMerged = 'PR_MERGED',
  PrOpened = 'PR_OPENED',
  WorkflowCancelled = 'WORKFLOW_CANCELLED',
  WorkflowCompleted = 'WORKFLOW_COMPLETED',
  WorkflowInprogress = 'WORKFLOW_INPROGRESS',
  WorkflowPending = 'WORKFLOW_PENDING'
}

export type DevAiCancelRunningAutofixScanInput = {
  repoUrl: Scalars['URL']['input'];
  workspaceId: Scalars['ID']['input'];
};

export type DevAiRunAutofixScanInput = {
  repoUrl: Scalars['URL']['input'];
  /**
   * If a scan is currently running, this determines whether the mutation (a) does nothing
   * or (b) cancels the current scan and initiates another.
   */
  restartIfCurrentlyRunning?: InputMaybe<Scalars['Boolean']['input']>;
  workspaceId: Scalars['ID']['input'];
};

export enum DevAiScanIntervalUnit {
  Days = 'DAYS',
  Months = 'MONTHS',
  Weeks = 'WEEKS'
}

export type DevAiSetAutofixConfigurationForRepositoryInput = {
  codeCoverageCommand: Scalars['String']['input'];
  codeCoverageReportPath: Scalars['String']['input'];
  coveragePercentage: Scalars['Int']['input'];
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  maxPrOpenCount?: InputMaybe<Scalars['Int']['input']>;
  primaryLanguage: Scalars['String']['input'];
  repoUrl: Scalars['URL']['input'];
  runInitialScan?: InputMaybe<Scalars['Boolean']['input']>;
  scanIntervalFrequency?: InputMaybe<Scalars['Int']['input']>;
  scanIntervalUnit?: InputMaybe<DevAiScanIntervalUnit>;
  scanStartDate?: InputMaybe<Scalars['Date']['input']>;
  workspaceId: Scalars['ID']['input'];
};

/** Input to enable/disable Autofix for a repository. */
export type DevAiSetAutofixEnabledStateForRepositoryInput = {
  isEnabled: Scalars['Boolean']['input'];
  repoUrl: Scalars['URL']['input'];
  workspaceId: Scalars['ID']['input'];
};

export enum DevAiSupportedRepoFilterOption {
  All = 'ALL',
  DisabledOnly = 'DISABLED_ONLY',
  EnabledOnly = 'ENABLED_ONLY'
}

/** Input to trigger an autofix scan of a repository */
export type DevAiTriggerAutofixScanInput = {
  /** Command to run code coverage tool in this repository */
  codeCoverageCommand: Scalars['String']['input'];
  /** Directory where code coverage report is generated */
  codeCoverageReportPath: Scalars['String']['input'];
  /** Target code coverage percentage for the scan */
  coveragePercentage: Scalars['Int']['input'];
  /** Primary language */
  primaryLanguage: Scalars['String']['input'];
  repoUrl: Scalars['URL']['input'];
  /** User to add as a PR reviewer */
  reviewerUserId?: InputMaybe<Scalars['ID']['input']>;
  workspaceId: Scalars['ID']['input'];
};

/** The state of a build. */
export enum DevOpsBuildState {
  /** The build has been cancelled or stopped. */
  Cancelled = 'CANCELLED',
  /** The build failed. */
  Failed = 'FAILED',
  /** The build is currently running. */
  InProgress = 'IN_PROGRESS',
  /** The build is queued, or some manual action is required. */
  Pending = 'PENDING',
  /** The build completed successfully. */
  Successful = 'SUCCESSFUL',
  /** The build is in an unknown state. */
  Unknown = 'UNKNOWN'
}

export enum DevOpsComponentTier {
  Tier_1 = 'TIER_1',
  Tier_2 = 'TIER_2',
  Tier_3 = 'TIER_3',
  Tier_4 = 'TIER_4'
}

export enum DevOpsComponentType {
  Application = 'APPLICATION',
  Capability = 'CAPABILITY',
  CloudResource = 'CLOUD_RESOURCE',
  DataPipeline = 'DATA_PIPELINE',
  Library = 'LIBRARY',
  MachineLearningModel = 'MACHINE_LEARNING_MODEL',
  Other = 'OTHER',
  Service = 'SERVICE',
  UiElement = 'UI_ELEMENT',
  Website = 'WEBSITE'
}

export type DevOpsContainerRelationshipEntityPropertyInput = {
  /**
   * Keys must:
   * * Contain only the characters a-z, A-Z, 0-9, _ and -.
   * * Be no greater than 80 characters long.
   * * Not begin with an underscore.
   */
  key: Scalars['String']['input'];
  /**
   * * Can be no larger than 5KB for all properties for an entity.
   * * Can not be `null`.
   */
  value: Scalars['JSON']['input'];
};

export enum DevOpsDesignStatus {
  None = 'NONE',
  ReadyForDevelopment = 'READY_FOR_DEVELOPMENT',
  Unknown = 'UNKNOWN'
}

export enum DevOpsDesignType {
  Canvas = 'CANVAS',
  File = 'FILE',
  Group = 'GROUP',
  Node = 'NODE',
  Other = 'OTHER',
  Prototype = 'PROTOTYPE'
}

/**  Document Category  */
export enum DevOpsDocumentCategory {
  Archive = 'ARCHIVE',
  Audio = 'AUDIO',
  Code = 'CODE',
  Document = 'DOCUMENT',
  Folder = 'FOLDER',
  Form = 'FORM',
  Image = 'IMAGE',
  Other = 'OTHER',
  Pdf = 'PDF',
  Presentation = 'PRESENTATION',
  Shortcut = 'SHORTCUT',
  Spreadsheet = 'SPREADSHEET',
  Video = 'VIDEO'
}

/**
 * The types of environments that a code change can be released to.
 *
 * The release may be via a code deployment or via a feature flag change.
 */
export enum DevOpsEnvironmentCategory {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum DevOpsJiraProjectType {
  JiraCore = 'JIRA_CORE',
  JiraServicedesk = 'JIRA_SERVICEDESK',
  JiraSoftware = 'JIRA_SOFTWARE'
}

export enum DevOpsMetricsCycleTimePhase {
  /** Development phase from initial code commit to deployed code. */
  CommitToDeployment = 'COMMIT_TO_DEPLOYMENT',
  /** Development phase from initial code commit to opened pull request. */
  CommitToPr = 'COMMIT_TO_PR'
}

/** No results will be returned unless an association type is specified. Currently only 'jiraProjectIds' association type is supported. */
export type DevOpsMetricsFilterInput = {
  /** The identifier that indicates which cloud instance this data is to be fetched for. */
  cloudId: Scalars['ID']['input'];
  /** The end dateTime for overall time interval to return results for. The interval is exclusive of this value. */
  endAtExclusive: Scalars['DateTime']['input'];
  /** Issue level filters. Currently, in order to apply this filter, jiraProjectIds must also be provided */
  issueFilters?: InputMaybe<DevOpsMetricsIssueFilters>;
  /** List of Jira projectIds in the given 'cloudId' to fetch metrics for. Max limit of 10. */
  jiraProjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The size of time interval in which to rollup data points in. Default is 1 day.
   * E.g. Count of data over 2 weeks with 1 day resolution means rollup is number of datapoints per day over 2 weeks.
   */
  resolution?: InputMaybe<DevOpsMetricsResolutionInput>;
  /** The start dateTime for overall time interval to return results for. The interval is inclusive of this value. */
  startFromInclusive: Scalars['DateTime']['input'];
  /**
   * The Olson Timezone ID. E.g. 'Australia/Sydney'.
   * Specifies which timezone to aggregate data in so that daylight savings is taken into account if it occurred between request time range.
   */
  timezoneId?: InputMaybe<Scalars['String']['input']>;
};

export type DevOpsMetricsIssueFilters = {
  /**
   * Only issues in these epics will be returned.
   *
   * Note:
   * * If a null ID is included in the list, issues not in epics will be included in the results.
   * * If a subtask's parent issue is in one of the epics, the subtask will also be returned.
   */
  epicIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Only issues of these types will be returned. */
  issueTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** No results will be returned unless an association type is specified. Currently only 'jiraProjectIds' association type is supported. */
export type DevOpsMetricsPerDeploymentMetricsFilter = {
  /** The identifier that indicates which cloud instance this data is to be fetched for. */
  cloudId: Scalars['ID']['input'];
  /** The end dateTime for overall time interval to return results for. The interval is exclusive of this value. */
  endAtExclusive: Scalars['DateTime']['input'];
  /** List of environment categories to filter for - only deployments in these categories will be returned. */
  environmentCategories?: Array<DevOpsEnvironmentCategory>;
  /** List of Jira projectIds in the given 'cloudId' to fetch metrics for. Max limit of 10. */
  jiraProjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The start dateTime for overall time interval to return results for. The interval is inclusive of this value. */
  startFromInclusive: Scalars['DateTime']['input'];
};

/** No results will be returned unless an association type is specified. Currently only 'jiraProjectIds' association type is supported. */
export type DevOpsMetricsPerIssueMetricsFilter = {
  /** The identifier that indicates which cloud instance this data is to be fetched for. */
  cloudId: Scalars['ID']['input'];
  /** The end dateTime for overall time interval to return results for. The interval is exclusive of this value. */
  endAtExclusive: Scalars['DateTime']['input'];
  /** Issue level filters. Currently, in order to apply this filter, jiraProjectIds must also be provided */
  issueFilters?: InputMaybe<DevOpsMetricsIssueFilters>;
  /** List of Jira projectIds in the given 'cloudId' to fetch metrics for. Max limit of 10. */
  jiraProjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The start dateTime for overall time interval to return results for. The interval is inclusive of this value. */
  startFromInclusive: Scalars['DateTime']['input'];
};

export type DevOpsMetricsResolutionInput = {
  /** Input unit for specified resolution value. */
  unit: DevOpsMetricsResolutionUnit;
  /** Input value for resolution specified. */
  value: Scalars['Int']['input'];
};

/** Unit for specified resolution value. */
export enum DevOpsMetricsResolutionUnit {
  Day = 'DAY',
  Hour = 'HOUR',
  Week = 'WEEK'
}

export enum DevOpsMetricsRollupOption {
  Mean = 'MEAN',
  Percentile = 'PERCENTILE'
}

export type DevOpsMetricsRollupType = {
  /** Must only be specified if the rollup kind is PERCENTILE */
  percentile?: InputMaybe<Scalars['Int']['input']>;
  type: DevOpsMetricsRollupOption;
};

export enum DevOpsOperationsIncidentSeverity {
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export enum DevOpsOperationsIncidentStatus {
  Open = 'OPEN',
  Resolved = 'RESOLVED',
  Unknown = 'UNKNOWN'
}

export enum DevOpsPostIncidentReviewStatus {
  Completed = 'COMPLETED',
  InProgress = 'IN_PROGRESS',
  Todo = 'TODO'
}

export enum DevOpsProjectStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  InProgress = 'IN_PROGRESS',
  Paused = 'PAUSED',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export enum DevOpsProjectTargetDateType {
  Day = 'DAY',
  Month = 'MONTH',
  Quarter = 'QUARTER',
  Unknown = 'UNKNOWN'
}

export enum DevOpsProviderNamespace {
  Asap = 'ASAP',
  Classic = 'CLASSIC',
  Forge = 'FORGE',
  Oauth = 'OAUTH'
}

/**
 * Type of a data-depot provider.
 * A provider may belongs to multiple types (e.g an connect-app can send both build and deployment info).
 */
export enum DevOpsProviderType {
  Build = 'BUILD',
  Deployment = 'DEPLOYMENT',
  Design = 'DESIGN',
  DevopsComponents = 'DEVOPS_COMPONENTS',
  DevInfo = 'DEV_INFO',
  Documentation = 'DOCUMENTATION',
  FeatureFlag = 'FEATURE_FLAG',
  Operations = 'OPERATIONS',
  Project = 'PROJECT',
  RemoteLinks = 'REMOTE_LINKS',
  Security = 'SECURITY'
}

export enum DevOpsPullRequestApprovalStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  Unapproved = 'UNAPPROVED'
}

export enum DevOpsPullRequestStatus {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum DevOpsRelationshipCertainty {
  /** The relationship was created by a user. */
  Explicit = 'EXPLICIT',
  /** The relationship was inferred by a system. */
  Implicit = 'IMPLICIT'
}

export enum DevOpsRelationshipCertaintyFilter {
  /** Return all relationships. */
  All = 'ALL',
  /** Return only relationships created by a user. */
  Explicit = 'EXPLICIT',
  /** Return only relationships inferred by a system. */
  Implicit = 'IMPLICIT'
}

export enum DevOpsRepositoryHostingProviderFilter {
  All = 'ALL',
  BitbucketCloud = 'BITBUCKET_CLOUD',
  ThirdParty = 'THIRD_PARTY'
}

export enum DevOpsSecurityVulnerabilitySeverity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  Unknown = 'UNKNOWN'
}

export enum DevOpsSecurityVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type DevOpsServiceAndJiraProjectRelationshipFilter = {
  /** Include only relationships with the specified certainty */
  certainty?: InputMaybe<DevOpsRelationshipCertaintyFilter>;
  /** Include only relationships with the specified relationship type */
  relationshipTypeIn?: InputMaybe<Array<DevOpsServiceAndJiraProjectRelationshipType>>;
};

export enum DevOpsServiceAndJiraProjectRelationshipType {
  /** A relationship created for the change management feature */
  ChangeManagement = 'CHANGE_MANAGEMENT',
  /** A standard relationship */
  Default = 'DEFAULT'
}

export type DevOpsServiceAndRepositoryRelationshipFilter = {
  /** Include only relationships with the specified certainty */
  certainty?: InputMaybe<DevOpsRelationshipCertaintyFilter>;
  /** Include only relationships with the specified repository hosting provider type */
  hostingProvider?: InputMaybe<DevOpsRepositoryHostingProviderFilter>;
  /**
   * Include only relationships with all of the specified property keys.
   * If this is omitted, no filtering by 'all property keys' is applied.
   */
  withAllPropertyKeys?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type DevOpsServiceAndRepositoryRelationshipSort = {
  /** The field to apply sorting on */
  by: DevOpsServiceAndRepositoryRelationshipSortBy;
  /** The direction of sorting */
  order?: SortDirection;
};

export enum DevOpsServiceAndRepositoryRelationshipSortBy {
  LastInferredAt = 'LAST_INFERRED_AT'
}

/** The request input for DevOps Service Entity Property */
export type DevOpsServiceEntityPropertyInput = {
  /**
   * Keys must:
   * * Contain only the characters a-z, A-Z, 0-9, _ and -
   * * Be no greater than 80 characters long
   * * Not begin with an underscore
   */
  key: Scalars['String']['input'];
  /**
   * * Can be no larger than 5KB for all properties for an entity
   * * Can not be `null`
   */
  value: Scalars['JSON']['input'];
};

/** #################### Enums ##################### */
export enum DevOpsServiceRelationshipType {
  Contains = 'CONTAINS',
  DependsOn = 'DEPENDS_ON'
}

export type DevOpsServiceTierInput = {
  level: Scalars['Int']['input'];
};

export type DevOpsServiceTypeInput = {
  key: Scalars['String']['input'];
};

/** The filtering input for retrieving services. tierLevelIn must not be empty if provided. */
export type DevOpsServicesFilterInput = {
  /** Case insensitive string to filter service names with */
  nameContains?: InputMaybe<Scalars['String']['input']>;
  /** Integer numbers to filter service tier levels with */
  tierLevelIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export enum DevOpsToolIntegrationType {
  Any = 'ANY',
  App = 'APP',
  Exists = 'EXISTS',
  None = 'NONE',
  Product = 'PRODUCT'
}

export type DevOpsToolSort = {
  integration?: InputMaybe<DevOpsToolSortOrder>;
  name?: InputMaybe<DevOpsToolSortOrder>;
  recommended?: InputMaybe<DevOpsToolSortOrder>;
  supportsContainers?: InputMaybe<DevOpsToolSortOrder>;
};

export enum DevOpsToolSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export enum DevStatusActivity {
  BranchOpen = 'BRANCH_OPEN',
  Commit = 'COMMIT',
  Deployment = 'DEPLOYMENT',
  Design = 'DESIGN',
  PrDeclined = 'PR_DECLINED',
  PrMerged = 'PR_MERGED',
  PrOpen = 'PR_OPEN'
}

export enum EcosystemAppNetworkPermissionType {
  Connect = 'CONNECT'
}

export type EcosystemAppsInstalledInContextsFilter = {
  type: EcosystemAppsInstalledInContextsFilterType;
  values: Array<Scalars['String']['input']>;
};

export enum EcosystemAppsInstalledInContextsFilterType {
  /**
   * Only supports one name in the values list for now, otherwise will fail
   * validation.
   */
  Name = 'NAME',
  /**
   * Returns apps filtered by the ARIs passed in the values list, as an exact match with its id
   * or the ARI generated from its latest migration keys for harmonised apps
   */
  OnlyAppIds = 'ONLY_APP_IDS'
}

export type EcosystemAppsInstalledInContextsOptions = {
  groupByBaseApp?: InputMaybe<Scalars['Boolean']['input']>;
  shouldExcludeFirstPartyApps?: InputMaybe<Scalars['Boolean']['input']>;
  shouldIncludePrivateApps?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EcosystemAppsInstalledInContextsOrderBy = {
  direction: SortDirection;
  sortKey: EcosystemAppsInstalledInContextsSortKey;
};

export enum EcosystemAppsInstalledInContextsSortKey {
  Name = 'NAME',
  RelatedApps = 'RELATED_APPS'
}

/** Edit sprint */
export type EditSprintInput = {
  boardId: Scalars['ID']['input'];
  endDate?: InputMaybe<Scalars['String']['input']>;
  goal?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  sprintId: Scalars['ID']['input'];
  startDate?: InputMaybe<Scalars['String']['input']>;
};

export enum EstimationType {
  CustomNumberField = 'CUSTOM_NUMBER_FIELD',
  IssueCount = 'ISSUE_COUNT',
  OriginalEstimate = 'ORIGINAL_ESTIMATE',
  StoryPoints = 'STORY_POINTS'
}

export type ExtensionContextsFilter = {
  type: ExtensionContextsFilterType;
  value: Array<Scalars['String']['input']>;
};

export enum ExtensionContextsFilterType {
  /** Filters extensions by App ID and Environment ID. Format is 'appId:environmentId'. */
  AppIdEnvironmentId = 'APP_ID_ENVIRONMENT_ID',
  DataClassificationTag = 'DATA_CLASSIFICATION_TAG',
  /**  Filters extensions by Definition ID.  */
  DefinitionId = 'DEFINITION_ID',
  ExtensionType = 'EXTENSION_TYPE',
  /** Filters extensions by principal type. Supported values are: 'unlicensed', 'customer', 'anonymous'. */
  PrincipalType = 'PRINCIPAL_TYPE'
}

/**
 * Details about an extension.
 *
 * This information is used to look up the extension within CaaS so that the
 * correct function can be resolved.
 *
 * This will eventually be superseded by an Id.
 */
export type ExtensionDetailsInput = {
  /** The definition identifier as provided by CaaS */
  definitionId: Scalars['ID']['input'];
  /** The extension key as provided by CaaS */
  extensionKey: Scalars['String']['input'];
};

export enum ExternalApprovalStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  Unapproved = 'UNAPPROVED'
}

export type ExternalAuthCredentialsInput = {
  /** The oAuth Client Id */
  clientId?: InputMaybe<Scalars['ID']['input']>;
  /** The shared secret */
  clientSecret?: InputMaybe<Scalars['String']['input']>;
};

export enum ExternalBuildState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum ExternalChangeType {
  Added = 'ADDED',
  Copied = 'COPIED',
  Deleted = 'DELETED',
  Modified = 'MODIFIED',
  Moved = 'MOVED',
  Unknown = 'UNKNOWN'
}

export enum ExternalCommitFlags {
  MergeCommit = 'MERGE_COMMIT'
}

export enum ExternalConversationType {
  Channel = 'CHANNEL',
  DirectMessage = 'DIRECT_MESSAGE',
  GroupDirectMessage = 'GROUP_DIRECT_MESSAGE'
}

export enum ExternalDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum ExternalDesignStatus {
  None = 'NONE',
  ReadyForDevelopment = 'READY_FOR_DEVELOPMENT',
  Unknown = 'UNKNOWN'
}

export enum ExternalDesignType {
  Canvas = 'CANVAS',
  File = 'FILE',
  Group = 'GROUP',
  Node = 'NODE',
  Other = 'OTHER',
  Prototype = 'PROTOTYPE'
}

export enum ExternalDocumentCategory {
  Archive = 'ARCHIVE',
  Audio = 'AUDIO',
  Code = 'CODE',
  Document = 'DOCUMENT',
  Folder = 'FOLDER',
  Form = 'FORM',
  Image = 'IMAGE',
  Other = 'OTHER',
  Pdf = 'PDF',
  Presentation = 'PRESENTATION',
  Shortcut = 'SHORTCUT',
  Spreadsheet = 'SPREADSHEET',
  Video = 'VIDEO',
  WebPage = 'WEB_PAGE'
}

export enum ExternalEnvironmentType {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum ExternalMembershipType {
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  Shared = 'SHARED'
}

export enum ExternalPullRequestStatus {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum ExternalVulnerabilitySeverityLevel {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  Unknown = 'UNKNOWN'
}

export enum ExternalVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum ExternalVulnerabilityType {
  Dast = 'DAST',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type ForgeAlertsActivitiesQueryInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  endTime: Scalars['String']['input'];
  environment: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  onlyOpenResolvedActivityType?: InputMaybe<Scalars['Boolean']['input']>;
  startTime: Scalars['String']['input'];
};

export type ForgeAlertsActivityLogsInput = {
  alertId: Scalars['Int']['input'];
};

export enum ForgeAlertsActivityType {
  AlertCreated = 'ALERT_CREATED',
  AlertMuted = 'ALERT_MUTED',
  AlertOpened = 'ALERT_OPENED',
  AlertResolved = 'ALERT_RESOLVED',
  AlertSentFiring = 'ALERT_SENT_FIRING',
  AlertSentResolved = 'ALERT_SENT_RESOLVED',
  AlertUnmuted = 'ALERT_UNMUTED',
  AlertUpdated = 'ALERT_UPDATED'
}

export enum ForgeAlertsAlertActivityType {
  AlertClosed = 'ALERT_CLOSED',
  AlertOpen = 'ALERT_OPEN',
  EmailSent = 'EMAIL_SENT',
  SeverityUpdated = 'SEVERITY_UPDATED'
}

export type ForgeAlertsChartDetailsInput = {
  environment: Scalars['String']['input'];
  filters?: InputMaybe<Array<ForgeAlertsRuleFilters>>;
  interval?: InputMaybe<ForgeAlertsQueryIntervalInput>;
  metric: ForgeAlertsRuleMetricType;
  period?: InputMaybe<Scalars['Int']['input']>;
};

export type ForgeAlertsConfigQueryInput = {
  environment: Scalars['String']['input'];
};

export type ForgeAlertsCreateConfigInput = {
  alertId?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  environment: Scalars['String']['input'];
  isMuted?: InputMaybe<Scalars['Boolean']['input']>;
  metricName?: InputMaybe<Scalars['String']['input']>;
  triggerValue?: InputMaybe<Scalars['Float']['input']>;
};

export type ForgeAlertsCreateRuleInput = {
  conditions: Array<ForgeAlertsRuleConditions>;
  description?: InputMaybe<Scalars['String']['input']>;
  envId: Scalars['String']['input'];
  filters?: InputMaybe<Array<ForgeAlertsRuleFilters>>;
  metric: ForgeAlertsRuleMetricType;
  name: Scalars['String']['input'];
  period: Scalars['Int']['input'];
  responders: Array<Scalars['String']['input']>;
  runbook?: InputMaybe<Scalars['String']['input']>;
  tolerance?: InputMaybe<Scalars['Int']['input']>;
};

export type ForgeAlertsDeleteAlertConfigsInput = {
  appIds: Array<Scalars['ID']['input']>;
};

export type ForgeAlertsDeleteRuleInput = {
  ruleId: Scalars['ID']['input'];
};

export enum ForgeAlertsListOrderByColumns {
  AlertId = 'alertId',
  ClosedAt = 'closedAt',
  CreatedAt = 'createdAt',
  Duration = 'duration',
  Severity = 'severity'
}

export enum ForgeAlertsListOrderOptions {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type ForgeAlertsListQueryInput = {
  closedAtEndDate?: InputMaybe<Scalars['String']['input']>;
  closedAtStartDate?: InputMaybe<Scalars['String']['input']>;
  createdAtEndDate?: InputMaybe<Scalars['String']['input']>;
  createdAtStartDate?: InputMaybe<Scalars['String']['input']>;
  limit: Scalars['Int']['input'];
  order: ForgeAlertsListOrderOptions;
  orderBy: ForgeAlertsListOrderByColumns;
  page: Scalars['Int']['input'];
  responders?: InputMaybe<Array<Scalars['String']['input']>>;
  ruleId?: InputMaybe<Scalars['ID']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  severities?: InputMaybe<Array<ForgeAlertsRuleSeverity>>;
  status?: InputMaybe<ForgeAlertsStatus>;
};

export enum ForgeAlertsMetricsDataType {
  DateTime = 'DATE_TIME'
}

export enum ForgeAlertsMetricsResolutionUnit {
  Day = 'DAY',
  Hours = 'HOURS',
  Minutes = 'MINUTES'
}

export type ForgeAlertsQueryIntervalInput = {
  end: Scalars['String']['input'];
  start: Scalars['String']['input'];
};

export enum ForgeAlertsRuleActivityAction {
  Created = 'CREATED',
  Deleted = 'DELETED',
  Disabled = 'DISABLED',
  Enabled = 'ENABLED',
  Updated = 'UPDATED'
}

export type ForgeAlertsRuleActivityLogsInput = {
  action?: InputMaybe<Array<InputMaybe<ForgeAlertsRuleActivityAction>>>;
  actor?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  endTime: Scalars['String']['input'];
  limit: Scalars['Int']['input'];
  page: Scalars['Int']['input'];
  ruleIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  startTime: Scalars['String']['input'];
};

export type ForgeAlertsRuleConditions = {
  severity: ForgeAlertsRuleSeverity;
  threshold: Scalars['String']['input'];
  when: ForgeAlertsRuleWhenConditions;
};

export enum ForgeAlertsRuleFilterActions {
  Exclude = 'EXCLUDE',
  Include = 'INCLUDE'
}

export enum ForgeAlertsRuleFilterDimensions {
  ErrorTypes = 'ERROR_TYPES',
  Functions = 'FUNCTIONS',
  Sites = 'SITES',
  Versions = 'VERSIONS'
}

export type ForgeAlertsRuleFilters = {
  action: ForgeAlertsRuleFilterActions;
  dimension: ForgeAlertsRuleFilterDimensions;
  value: Array<Scalars['String']['input']>;
};

export type ForgeAlertsRuleFiltersInput = {
  environment: Scalars['String']['input'];
};

export enum ForgeAlertsRuleMetricType {
  InvocationCount = 'INVOCATION_COUNT',
  InvocationErrors = 'INVOCATION_ERRORS',
  InvocationLatency = 'INVOCATION_LATENCY',
  InvocationSuccessRate = 'INVOCATION_SUCCESS_RATE'
}

export enum ForgeAlertsRuleSeverity {
  Critical = 'CRITICAL',
  Major = 'MAJOR',
  Minor = 'MINOR'
}

export enum ForgeAlertsRuleWhenConditions {
  Above = 'ABOVE',
  AboveOrEqualTo = 'ABOVE_OR_EQUAL_TO',
  Below = 'BELOW',
  BelowOrEqualTo = 'BELOW_OR_EQUAL_TO'
}

export enum ForgeAlertsStatus {
  Closed = 'CLOSED',
  Firing = 'FIRING',
  Open = 'OPEN',
  Resolved = 'RESOLVED'
}

export type ForgeAlertsUpdateConfigInput = {
  alertName?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  environment: Scalars['String']['input'];
  isMuted?: InputMaybe<Scalars['Boolean']['input']>;
  triggerValue?: InputMaybe<Scalars['Float']['input']>;
};

export type ForgeAlertsUpdateRuleInput = {
  input: ForgeAlertsUpdateRuleInputType;
  ruleId: Scalars['ID']['input'];
};

export type ForgeAlertsUpdateRuleInputType = {
  conditions?: InputMaybe<Array<ForgeAlertsRuleConditions>>;
  description?: InputMaybe<Scalars['String']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  filters?: InputMaybe<Array<ForgeAlertsRuleFilters>>;
  metric?: InputMaybe<ForgeAlertsRuleMetricType>;
  name?: InputMaybe<Scalars['String']['input']>;
  period?: InputMaybe<Scalars['Int']['input']>;
  responders?: InputMaybe<Array<Scalars['String']['input']>>;
  runbook?: InputMaybe<Scalars['String']['input']>;
  tolerance?: InputMaybe<Scalars['Int']['input']>;
};

export enum ForgeAuditLogsActionType {
  ContributorAdded = 'CONTRIBUTOR_ADDED',
  ContributorRemoved = 'CONTRIBUTOR_REMOVED',
  ContributorRoleUpdated = 'CONTRIBUTOR_ROLE_UPDATED',
  OwnershipTransferred = 'OWNERSHIP_TRANSFERRED'
}

export type ForgeAuditLogsDaResQueryInput = {
  endTime?: InputMaybe<Scalars['String']['input']>;
  startTime?: InputMaybe<Scalars['String']['input']>;
};

export type ForgeAuditLogsQueryInput = {
  actions?: InputMaybe<Array<ForgeAuditLogsActionType>>;
  after?: InputMaybe<Scalars['String']['input']>;
  contributorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  endTime?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  startTime?: InputMaybe<Scalars['String']['input']>;
};

export enum ForgeMetricsApiRequestGroupByDimensions {
  ContextAri = 'CONTEXT_ARI',
  Status = 'STATUS',
  Url = 'URL'
}

export type ForgeMetricsApiRequestQueryFilters = {
  apiRequestType?: InputMaybe<ForgeMetricsApiRequestType>;
  contextAris?: InputMaybe<Array<Scalars['ID']['input']>>;
  environment: Scalars['ID']['input'];
  interval: ForgeMetricsIntervalInput;
  status?: InputMaybe<ForgeMetricsApiRequestStatus>;
  urls?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type ForgeMetricsApiRequestQueryInput = {
  filters: ForgeMetricsApiRequestQueryFilters;
  groupBy?: InputMaybe<Array<ForgeMetricsApiRequestGroupByDimensions>>;
};

export enum ForgeMetricsApiRequestStatus {
  '2Xx' = '_2XX',
  '4Xx' = '_4XX',
  '5Xx' = '_5XX'
}

export enum ForgeMetricsApiRequestType {
  Cache = 'CACHE',
  External = 'EXTERNAL',
  Product = 'PRODUCT',
  Sql = 'SQL'
}

export type ForgeMetricsChartInsightQueryInput = {
  apiRequestChartFilters?: InputMaybe<ForgeMetricsApiRequestQueryFilters>;
  apiRequestGroupBy?: InputMaybe<Array<ForgeMetricsApiRequestGroupByDimensions>>;
  chartName?: InputMaybe<ForgeMetricsChartName>;
  invocationChartFilters?: InputMaybe<ForgeMetricsQueryFilters>;
  invocationGroupBy?: InputMaybe<Array<ForgeMetricsGroupByDimensions>>;
  latencyBucketsChartFilters?: InputMaybe<ForgeMetricsLatencyBucketsQueryFilters>;
};

export enum ForgeMetricsChartName {
  ApiRequestCount_2Xx = 'API_REQUEST_COUNT_2XX',
  ApiRequestCount_4Xx = 'API_REQUEST_COUNT_4XX',
  ApiRequestCount_5Xx = 'API_REQUEST_COUNT_5XX',
  ApiRequestLatency = 'API_REQUEST_LATENCY',
  InvocationCount = 'INVOCATION_COUNT',
  InvocationError = 'INVOCATION_ERROR',
  InvocationLatency = 'INVOCATION_LATENCY',
  InvocationSuccessRate = 'INVOCATION_SUCCESS_RATE'
}

export enum ForgeMetricsDataType {
  Category = 'CATEGORY',
  DateTime = 'DATE_TIME',
  Numeric = 'NUMERIC'
}

export enum ForgeMetricsGroupByDimensions {
  ContextAri = 'CONTEXT_ARI',
  EnvironmentId = 'ENVIRONMENT_ID',
  ErrorType = 'ERROR_TYPE',
  Function = 'FUNCTION',
  UserTier = 'USER_TIER',
  Version = 'VERSION'
}

export type ForgeMetricsIntervalInput = {
  end: Scalars['DateTime']['input'];
  /** "start" and "end" are ISO-8601 formatted timestamps */
  start: Scalars['DateTime']['input'];
};

export enum ForgeMetricsLabels {
  ForgeApiRequestCount = 'FORGE_API_REQUEST_COUNT',
  ForgeApiRequestLatency = 'FORGE_API_REQUEST_LATENCY',
  ForgeBackendInvocationCount = 'FORGE_BACKEND_INVOCATION_COUNT',
  ForgeBackendInvocationErrors = 'FORGE_BACKEND_INVOCATION_ERRORS',
  ForgeBackendInvocationLatency = 'FORGE_BACKEND_INVOCATION_LATENCY'
}

export type ForgeMetricsLatencyBucketsQueryFilters = {
  /**
   * List of ARIs to filter metrics by
   * E.g.: ["ari:cloud:jira::site/{siteId}", ...]
   */
  contextAris?: InputMaybe<Array<Scalars['ID']['input']>>;
  environment?: InputMaybe<Scalars['ID']['input']>;
  /**
   * List of function names to be filtered by.
   * E.g.: ["functionA", "functionB"]
   * If the functionNames is omitted or provided as an empty list, no filtering on function names will be applied.
   */
  functionNames?: InputMaybe<Array<Scalars['String']['input']>>;
  interval: ForgeMetricsIntervalInput;
};

export type ForgeMetricsLatencyBucketsQueryInput = {
  filters: ForgeMetricsLatencyBucketsQueryFilters;
  groupBy?: InputMaybe<Array<ForgeMetricsGroupByDimensions>>;
};

export type ForgeMetricsOtlpQueryFilters = {
  environments: Array<Scalars['ID']['input']>;
  interval: ForgeMetricsIntervalInput;
  metrics: Array<ForgeMetricsLabels>;
};

export type ForgeMetricsOtlpQueryInput = {
  filters: ForgeMetricsOtlpQueryFilters;
};

export type ForgeMetricsQueryFilters = {
  /**
   * List of ARIs to filter metrics by
   * E.g.: ["ari:cloud:jira::site/{siteId}", ...]
   */
  contextAris?: InputMaybe<Array<Scalars['ID']['input']>>;
  environment?: InputMaybe<Scalars['ID']['input']>;
  interval: ForgeMetricsIntervalInput;
};

export type ForgeMetricsQueryInput = {
  filters: ForgeMetricsQueryFilters;
  groupBy?: InputMaybe<Array<ForgeMetricsGroupByDimensions>>;
};

export enum ForgeMetricsResolutionUnit {
  Hours = 'HOURS',
  Minutes = 'MINUTES'
}

export enum ForgeMetricsSiteFilterCategory {
  All = 'ALL',
  HighestInvocationCount = 'HIGHEST_INVOCATION_COUNT',
  HighestNumberOfErrors = 'HIGHEST_NUMBER_OF_ERRORS',
  HighestNumberOfUsers = 'HIGHEST_NUMBER_OF_USERS',
  LowestSuccessRate = 'LOWEST_SUCCESS_RATE'
}

export enum FormStatus {
  Approved = 'APPROVED',
  Rejected = 'REJECTED',
  Saved = 'SAVED',
  Submitted = 'SUBMITTED'
}

export type FortifiedMetricsIntervalInput = {
  /** The end of the interval. Inclusive. */
  end: Scalars['DateTime']['input'];
  /** The start of the interval. Inclusive. */
  start: Scalars['DateTime']['input'];
};

export type FortifiedMetricsQueryFilters = {
  /** The interval to query metrics for. */
  interval: FortifiedMetricsIntervalInput;
};

export type FortifiedMetricsQueryInput = {
  filters: FortifiedMetricsQueryFilters;
};

export enum FortifiedMetricsResolutionUnit {
  Hours = 'HOURS',
  Minutes = 'MINUTES'
}

/** Which type of trigger */
export enum FunctionTriggerType {
  Frontend = 'FRONTEND',
  Manual = 'MANUAL',
  Product = 'PRODUCT',
  Web = 'WEB'
}

export enum GrantCheckProduct {
  Compass = 'COMPASS',
  Confluence = 'CONFLUENCE',
  Jira = 'JIRA',
  JiraServicedesk = 'JIRA_SERVICEDESK',
  Mercury = 'MERCURY',
  /** Don't check whether a user has been granted access to a specific site(cloudId) */
  NoGrantChecks = 'NO_GRANT_CHECKS',
  Townsquare = 'TOWNSQUARE'
}

export type GraphCreateIncidentAssociatedPostIncidentReviewLinkInput = {
  /** An ARI of any of the following: [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following: [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphCreateIncidentHasActionItemInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphCreateIncidentLinkedJswIssueInput = {
  /** An ARI of any of the following: [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphCreateIssueAssociatedDesignInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:design */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphCreateIssueAssociatedPrInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:pull-request */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export enum GraphCreateMetadataProjectAssociatedBuildJiraBuildOutputBuildStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataProjectAssociatedDeploymentJiraDeploymentOutputDeploymentStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataProjectAssociatedDeploymentJiraDeploymentOutputEnvironmentTypeEnum {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum GraphCreateMetadataProjectAssociatedPrJiraPullRequestOutputPullRequestStatusEnum {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataProjectAssociatedPrJiraPullRequestOutputReviewerReviewerStatusEnum {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphCreateMetadataProjectAssociatedVulnerabilityJiraVulnerabilityOutputVulnerabilitySeverityEnum {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataProjectAssociatedVulnerabilityJiraVulnerabilityOutputVulnerabilityStatusEnum {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataProjectAssociatedVulnerabilityJiraVulnerabilityOutputVulnerabilityTypeEnum {
  Dast = 'DAST',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataSprintAssociatedBuildJiraBuildOutputBuildStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataSprintAssociatedDeploymentJiraDeploymentOutputDeploymentStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataSprintAssociatedPrJiraPullRequestOutputPullRequestStatusEnum {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataSprintAssociatedPrJiraPullRequestOutputReviewerReviewerStatusEnum {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphCreateMetadataSprintAssociatedVulnerabilityJiraVulnerabilityOutputVulnerabilitySeverityEnum {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataSprintAssociatedVulnerabilityJiraVulnerabilityOutputVulnerabilityStatusEnum {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataSprintAssociatedVulnerabilityOutputStatusCategoryEnum {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphCreateMetadataSprintContainsIssueInput = {
  issueLastUpdatedOn?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphCreateMetadataSprintContainsIssueJiraIssueInput = {
  assigneeAri?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInputAri>;
  creatorAri?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInputAri>;
  issueAri?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInputAri>;
  reporterAri?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInputAri>;
  statusAri?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInputAri>;
  statusCategory?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInputStatusCategoryEnum>;
};

export type GraphCreateMetadataSprintContainsIssueJiraIssueInputAri = {
  value?: InputMaybe<Scalars['String']['input']>;
};

export enum GraphCreateMetadataSprintContainsIssueJiraIssueInputStatusCategoryEnum {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export enum GraphCreateMetadataSprintContainsIssueJiraIssueOutputStatusCategoryEnum {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphCreateParentDocumentHasChildDocumentInput = {
  /** An ARI of type ati:cloud:jira:document */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:document */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphCreateSprintContainsIssueInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  relationshipMetadata?: InputMaybe<GraphCreateMetadataSprintContainsIssueInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  toMetadata?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInput>;
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphCreateSprintRetrospectivePageInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInput = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedBuildInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedBuildInputOr>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedBuildInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToState>;
  to_testInfo?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfo>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToState>;
  to_testInfo?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfo>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputCreatedAt = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputCreatedAtMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputLastUpdated = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputLastUpdatedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedBuildInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToState>;
  to_testInfo?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfo>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToState>;
  to_testInfo?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfo>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAriValue>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataProjectAssociatedBuildInputToBuildStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataProjectAssociatedBuildInputToState = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedBuildInputToBuildStateEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToStateMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedBuildInputToBuildStateEnum>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToStateMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfo = {
  numberFailed?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberFailed>;
  numberPassed?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberPassed>;
  numberSkipped?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberSkipped>;
  totalNumber?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoTotalNumber>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberFailed = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberFailedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberFailedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberFailedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberFailedRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberPassed = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberPassedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberPassedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberPassedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberPassedRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberSkipped = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberSkippedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberSkippedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberSkippedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberSkippedRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoTotalNumber = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoTotalNumberRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoTotalNumberMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoTotalNumberMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoTotalNumberRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInput = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputOr>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIds>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIds>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAt = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAtMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdated = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdatedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIds>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIds>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAriValue>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIds = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIdsRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIdsMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIdsMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIdsRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToAuthor = {
  authorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthorAri>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToAuthorAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthorAriValue>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToAuthorAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthorAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToAuthorAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataProjectAssociatedDeploymentInputToDeploymentStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentType = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentTypeEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentTypeMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentTypeEnum>>;
};

export enum GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentTypeEnum {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentTypeMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToState = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputToDeploymentStateEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToStateMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputToDeploymentStateEnum>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToStateMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInput = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedIncidentInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedIncidentInputOr>>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedIncidentInputOrInner>>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputLastUpdated>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedIncidentInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputLastUpdated>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputLastUpdated>;
};

export type GraphQueryMetadataProjectAssociatedPrInput = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputOr>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataProjectAssociatedPrInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataProjectAssociatedPrInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataProjectAssociatedPrInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataProjectAssociatedPrInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataProjectAssociatedPrInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataProjectAssociatedPrInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAriValue>;
};

export type GraphQueryMetadataProjectAssociatedPrInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToAuthor = {
  authorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthorAri>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToAuthorAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthorAriValue>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToAuthorAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthorAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToAuthorAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataProjectAssociatedPrInputToPullRequestStatusEnum {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataProjectAssociatedPrInputToReviewer = {
  approvalStatus?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewerApprovalStatus>;
  matchType?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewermatchTypeEnum>;
  reviewerAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewerAri>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToReviewerApprovalStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputToReviewerReviewerStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewerApprovalStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputToReviewerReviewerStatusEnum>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToReviewerApprovalStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToReviewerAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewerAriValue>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToReviewerAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewerAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToReviewerAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataProjectAssociatedPrInputToReviewerReviewerStatusEnum {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphQueryMetadataProjectAssociatedPrInputToReviewermatchTypeEnum {
  All = 'ALL',
  Any = 'ANY',
  None = 'NONE'
}

export type GraphQueryMetadataProjectAssociatedPrInputToStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputToPullRequestStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputToPullRequestStatusEnum>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToTaskCount = {
  notValues?: InputMaybe<Array<Scalars['Int']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToTaskCountRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToTaskCountMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToTaskCountMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToTaskCountRangeField = {
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInput = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputOr>>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputOrInner>>;
  to_container?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToType>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdated>;
  to_container?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToType>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdated>;
  to_container?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToType>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdated>;
  to_container?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToType>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainer = {
  containerAri?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainerAri>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainerAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainerAriValue>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainerAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainerAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainerAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverity = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilitySeverityEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverityMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilitySeverityEnum>>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverityMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilityStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilityStatusEnum>>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToType = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilityTypeEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToTypeMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilityTypeEnum>>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToTypeMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilitySeverityEnum {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  Unknown = 'UNKNOWN'
}

export enum GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilityStatusEnum {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilityTypeEnum {
  Dast = 'DAST',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataProjectHasIssueInput = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectHasIssueInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectHasIssueInputOr>>;
};

export type GraphQueryMetadataProjectHasIssueInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectHasIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectHasIssueInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectHasIssueInputOrInner>>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOn>;
  relationship_sprintAris?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipAri>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToFixVersionIds>;
  to_issueAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
};

export type GraphQueryMetadataProjectHasIssueInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectHasIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectHasIssueInputLastUpdated>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOn>;
  relationship_sprintAris?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipAri>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToFixVersionIds>;
  to_issueAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
};

export type GraphQueryMetadataProjectHasIssueInputCreatedAt = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectHasIssueInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectHasIssueInputCreatedAtMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataProjectHasIssueInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputLastUpdated = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectHasIssueInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectHasIssueInputLastUpdatedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataProjectHasIssueInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectHasIssueInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataProjectHasIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectHasIssueInputLastUpdated>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOn>;
  relationship_sprintAris?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipAri>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToFixVersionIds>;
  to_issueAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
};

export type GraphQueryMetadataProjectHasIssueInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectHasIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectHasIssueInputLastUpdated>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOn>;
  relationship_sprintAris?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipAri>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToFixVersionIds>;
  to_issueAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
};

export type GraphQueryMetadataProjectHasIssueInputRelationshipAri = {
  matchType?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipArimatchTypeEnum>;
  value?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipAriValue>;
};

export type GraphQueryMetadataProjectHasIssueInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectHasIssueInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataProjectHasIssueInputRelationshipArimatchTypeEnum {
  All = 'ALL',
  Any = 'ANY',
  None = 'NONE'
}

export type GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputToAri = {
  value?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAriValue>;
};

export type GraphQueryMetadataProjectHasIssueInputToAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectHasIssueInputToAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputToFixVersionIds = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToFixVersionIdsRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToFixVersionIdsMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectHasIssueInputToFixVersionIdsMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputToFixVersionIdsRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInput = {
  and?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputOr>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAt>;
  fromAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAti>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputOrInner>>;
  toAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAti>;
  to_container?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToType>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAt>;
  fromAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAti>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdated>;
  toAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAti>;
  to_container?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToType>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAt = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAtMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdated = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdatedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAt>;
  fromAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAti>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdated>;
  toAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAti>;
  to_container?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToType>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAt>;
  fromAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAti>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdated>;
  toAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAti>;
  to_container?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToType>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainer = {
  containerAri?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainerAri>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainerAri = {
  value?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainerAriValue>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainerAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainerAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainerAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverity = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilitySeverityEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverityMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilitySeverityEnum>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverityMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilityStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilityStatusEnum>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToType = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilityTypeEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToTypeMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilityTypeEnum>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToTypeMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilitySeverityEnum {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilityStatusEnum {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilityTypeEnum {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataServiceLinkedIncidentInput = {
  and?: InputMaybe<Array<GraphQueryMetadataServiceLinkedIncidentInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataServiceLinkedIncidentInputOr>>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataServiceLinkedIncidentInputOrInner>>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputLastUpdated>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataServiceLinkedIncidentInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputLastUpdated>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputLastUpdated>;
};

export enum GraphQueryMetadataServiceLinkedIncidentInputToJiraServiceManagementIncidentPriorityEnum {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5'
}

export enum GraphQueryMetadataSortEnum {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type GraphQueryMetadataSprintAssociatedBuildInput = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedBuildInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedBuildInputOr>>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedBuildInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToState>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToState>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedBuildInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToState>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToState>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAriValue>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataSprintAssociatedBuildInputToBuildStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataSprintAssociatedBuildInputToState = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedBuildInputToBuildStateEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToStateMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedBuildInputToBuildStateEnum>>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputToStateMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInput = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputOr>>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAriValue>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToAuthor = {
  authorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthorAri>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToAuthorAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthorAriValue>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToAuthorAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthorAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToAuthorAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataSprintAssociatedDeploymentInputToDeploymentStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentType = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentTypeEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentTypeMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentTypeEnum>>;
};

export enum GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentTypeEnum {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentTypeMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToState = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputToDeploymentStateEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToStateMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputToDeploymentStateEnum>>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToStateMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInput = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputOr>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataSprintAssociatedPrInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataSprintAssociatedPrInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataSprintAssociatedPrInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataSprintAssociatedPrInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataSprintAssociatedPrInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataSprintAssociatedPrInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAriValue>;
};

export type GraphQueryMetadataSprintAssociatedPrInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToAuthor = {
  authorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthorAri>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToAuthorAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthorAriValue>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToAuthorAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthorAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToAuthorAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataSprintAssociatedPrInputToPullRequestStatusEnum {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataSprintAssociatedPrInputToReviewer = {
  approvalStatus?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewerApprovalStatus>;
  matchType?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewermatchTypeEnum>;
  reviewerAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewerAri>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToReviewerApprovalStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputToReviewerReviewerStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewerApprovalStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputToReviewerReviewerStatusEnum>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToReviewerApprovalStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToReviewerAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewerAriValue>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToReviewerAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewerAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToReviewerAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataSprintAssociatedPrInputToReviewerReviewerStatusEnum {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphQueryMetadataSprintAssociatedPrInputToReviewermatchTypeEnum {
  All = 'ALL',
  Any = 'ANY',
  None = 'NONE'
}

export type GraphQueryMetadataSprintAssociatedPrInputToStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputToPullRequestStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputToPullRequestStatusEnum>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToTaskCount = {
  notValues?: InputMaybe<Array<Scalars['Int']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToTaskCountRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToTaskCountMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToTaskCountMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToTaskCountRangeField = {
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInput = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputOr>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusCategory?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategory>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToAti>;
  to_introducedDate?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDate>;
  to_severity?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatus>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusCategory?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategory>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToAti>;
  to_introducedDate?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDate>;
  to_severity?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatus>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAt = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAtMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdated = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdatedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusCategory?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategory>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToAti>;
  to_introducedDate?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDate>;
  to_severity?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatus>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusCategory?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategory>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToAti>;
  to_introducedDate?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDate>;
  to_severity?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatus>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAriValue>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategory = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategoryEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategoryMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategoryEnum>>;
};

export enum GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategoryEnum {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategoryMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDate = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDateRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDateMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDateMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDateRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverity = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputToVulnerabilitySeverityEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverityMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputToVulnerabilitySeverityEnum>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverityMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputToVulnerabilityStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputToVulnerabilityStatusEnum>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataSprintAssociatedVulnerabilityInputToVulnerabilitySeverityEnum {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphQueryMetadataSprintAssociatedVulnerabilityInputToVulnerabilityStatusEnum {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataSprintContainsIssueInput = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintContainsIssueInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintContainsIssueInputOr>>;
};

export type GraphQueryMetadataSprintContainsIssueInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintContainsIssueInputOrInner>>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOn>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_issueAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusCategory?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToStatusCategory>;
};

export type GraphQueryMetadataSprintContainsIssueInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputLastUpdated>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOn>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_issueAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusCategory?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToStatusCategory>;
};

export type GraphQueryMetadataSprintContainsIssueInputCreatedAt = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputCreatedAtMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataSprintContainsIssueInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputLastUpdated = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputLastUpdatedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataSprintContainsIssueInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintContainsIssueInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputLastUpdated>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOn>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_issueAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusCategory?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToStatusCategory>;
};

export type GraphQueryMetadataSprintContainsIssueInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputLastUpdated>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOn>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_issueAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusCategory?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToStatusCategory>;
};

export type GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputToAri = {
  value?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAriValue>;
};

export type GraphQueryMetadataSprintContainsIssueInputToAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintContainsIssueInputToAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputToStatusCategory = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintContainsIssueInputToStatusCategoryEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToStatusCategoryMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintContainsIssueInputToStatusCategoryEnum>>;
};

export enum GraphQueryMetadataSprintContainsIssueInputToStatusCategoryEnum {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphQueryMetadataSprintContainsIssueInputToStatusCategoryMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphStoreAriFilterInput = {
  is?: InputMaybe<Array<Scalars['String']['input']>>;
  isNot?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphStoreAtiFilterInput = {
  is?: InputMaybe<Array<Scalars['String']['input']>>;
  isNot?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphStoreAtlasGoalHasSubAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasProjectContributesToAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasProjectIsTrackedOnJiraEpicSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreBooleanFilterInput = {
  is?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreComponentImpactedByIncidentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreComponentLinkIsJiraProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreComponentLinkedJswIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreContentReferencedEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreCreateComponentImpactedByIncidentInput = {
  /** The list of relationships of type component-impacted-by-incident to persist */
  relationships: Array<GraphStoreCreateComponentImpactedByIncidentRelationshipInput>;
};

export enum GraphStoreCreateComponentImpactedByIncidentJiraIncidentPriorityInput {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreCreateComponentImpactedByIncidentJiraIncidentStatusInput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export type GraphStoreCreateComponentImpactedByIncidentRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** Object metadata for this relationship */
  objectMetadata?: InputMaybe<GraphStoreCreateComponentImpactedByIncidentRelationshipObjectMetadataInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateComponentImpactedByIncidentRelationshipObjectMetadataInput = {
  affectedServiceAris?: InputMaybe<Scalars['String']['input']>;
  assigneeAri?: InputMaybe<Scalars['String']['input']>;
  majorIncident?: InputMaybe<Scalars['Boolean']['input']>;
  priority?: InputMaybe<GraphStoreCreateComponentImpactedByIncidentJiraIncidentPriorityInput>;
  reporterAri?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<GraphStoreCreateComponentImpactedByIncidentJiraIncidentStatusInput>;
};

export type GraphStoreCreateFocusAreaHasAtlasGoalInput = {
  /** The list of relationships of type focus-area-has-atlas-goal to persist */
  relationships: Array<GraphStoreCreateFocusAreaHasAtlasGoalRelationshipInput>;
};

export type GraphStoreCreateFocusAreaHasAtlasGoalRelationshipInput = {
  /** An ARI of type ati:cloud:townsquare:goal */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:townsquare:goal */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateIncidentAssociatedPostIncidentReviewLinkInput = {
  /** The list of relationships of type incident-associated-post-incident-review-link to persist */
  relationships: Array<GraphStoreCreateIncidentAssociatedPostIncidentReviewLinkRelationshipInput>;
};

export type GraphStoreCreateIncidentAssociatedPostIncidentReviewLinkRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link, ati:cloud:jira:post-incident-review, ati:cloud:graph:post-incident-review] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link, ati:cloud:jira:post-incident-review, ati:cloud:graph:post-incident-review] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateIncidentHasActionItemInput = {
  /** The list of relationships of type incident-has-action-item to persist */
  relationships: Array<GraphStoreCreateIncidentHasActionItemRelationshipInput>;
};

export type GraphStoreCreateIncidentHasActionItemRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateIncidentLinkedJswIssueInput = {
  /** The list of relationships of type incident-linked-jsw-issue to persist */
  relationships: Array<GraphStoreCreateIncidentLinkedJswIssueRelationshipInput>;
};

export type GraphStoreCreateIncidentLinkedJswIssueRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateIssueToWhiteboardInput = {
  /** The list of relationships of type issue-to-whiteboard to persist */
  relationships: Array<GraphStoreCreateIssueToWhiteboardRelationshipInput>;
};

export type GraphStoreCreateIssueToWhiteboardRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:whiteboard */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateJswProjectAssociatedComponentInput = {
  /** The list of relationships of type jsw-project-associated-component to persist */
  relationships: Array<GraphStoreCreateJswProjectAssociatedComponentRelationshipInput>;
};

export type GraphStoreCreateJswProjectAssociatedComponentRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:graph:service, ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:graph:service, ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectAssociatedOpsgenieTeamInput = {
  /** The list of relationships of type project-associated-opsgenie-team to persist */
  relationships: Array<GraphStoreCreateProjectAssociatedOpsgenieTeamRelationshipInput>;
};

export type GraphStoreCreateProjectAssociatedOpsgenieTeamRelationshipInput = {
  /** An ARI of type ati:cloud:opsgenie:team */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:opsgenie:team */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectAssociatedToSecurityContainerInput = {
  /** The list of relationships of type project-associated-to-security-container to persist */
  relationships: Array<GraphStoreCreateProjectAssociatedToSecurityContainerRelationshipInput>;
};

export type GraphStoreCreateProjectAssociatedToSecurityContainerRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:security-container, ati:cloud:graph:security-container] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:security-container, ati:cloud:graph:security-container] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectDisassociatedRepoInput = {
  /** The list of relationships of type project-disassociated-repo to persist */
  relationships: Array<GraphStoreCreateProjectDisassociatedRepoRelationshipInput>;
};

export type GraphStoreCreateProjectDisassociatedRepoRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:repository, ati:cloud:graph:repository] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:repository, ati:cloud:graph:repository] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectDocumentationEntityInput = {
  /** The list of relationships of type project-documentation-entity to persist */
  relationships: Array<GraphStoreCreateProjectDocumentationEntityRelationshipInput>;
};

export type GraphStoreCreateProjectDocumentationEntityRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:confluence:space, ati:cloud:confluence:page, ati:cloud:jira:document, ati:cloud:graph:document] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:confluence:space, ati:cloud:confluence:page, ati:cloud:jira:document, ati:cloud:graph:document] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectDocumentationPageInput = {
  /** The list of relationships of type project-documentation-page to persist */
  relationships: Array<GraphStoreCreateProjectDocumentationPageRelationshipInput>;
};

export type GraphStoreCreateProjectDocumentationPageRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:page */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectDocumentationSpaceInput = {
  /** The list of relationships of type project-documentation-space to persist */
  relationships: Array<GraphStoreCreateProjectDocumentationSpaceRelationshipInput>;
};

export type GraphStoreCreateProjectDocumentationSpaceRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:space */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:space */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectHasRelatedWorkWithProjectInput = {
  /** The list of relationships of type project-has-related-work-with-project to persist */
  relationships: Array<GraphStoreCreateProjectHasRelatedWorkWithProjectRelationshipInput>;
};

export type GraphStoreCreateProjectHasRelatedWorkWithProjectRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectHasSharedVersionWithInput = {
  /** The list of relationships of type project-has-shared-version-with to persist */
  relationships: Array<GraphStoreCreateProjectHasSharedVersionWithRelationshipInput>;
};

export type GraphStoreCreateProjectHasSharedVersionWithRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectHasVersionInput = {
  /** The list of relationships of type project-has-version to persist */
  relationships: Array<GraphStoreCreateProjectHasVersionRelationshipInput>;
};

export type GraphStoreCreateProjectHasVersionRelationshipInput = {
  /** An ARI of type ati:cloud:jira:version */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:version */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateSprintRetrospectivePageInput = {
  /** The list of relationships of type sprint-retrospective-page to persist */
  relationships: Array<GraphStoreCreateSprintRetrospectivePageRelationshipInput>;
};

export type GraphStoreCreateSprintRetrospectivePageRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:page */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateSprintRetrospectiveWhiteboardInput = {
  /** The list of relationships of type sprint-retrospective-whiteboard to persist */
  relationships: Array<GraphStoreCreateSprintRetrospectiveWhiteboardRelationshipInput>;
};

export type GraphStoreCreateSprintRetrospectiveWhiteboardRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:whiteboard */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateTownsquareTagIsAliasOfTownsquareTagInput = {
  /** The list of relationships of type townsquare-tag-is-alias-of-townsquare-tag to persist */
  relationships: Array<GraphStoreCreateTownsquareTagIsAliasOfTownsquareTagRelationshipInput>;
};

export type GraphStoreCreateTownsquareTagIsAliasOfTownsquareTagRelationshipInput = {
  /** An ARI of type ati:cloud:townsquare:tag */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:townsquare:tag */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateVersionUserAssociatedFeatureFlagInput = {
  /** The list of relationships of type version-user-associated-feature-flag to persist */
  relationships: Array<GraphStoreCreateVersionUserAssociatedFeatureFlagRelationshipInput>;
};

export type GraphStoreCreateVersionUserAssociatedFeatureFlagRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:feature-flag, ati:cloud:graph:feature-flag] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:feature-flag, ati:cloud:graph:feature-flag] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateVulnerabilityAssociatedIssueContainerInput = {
  containerAri?: InputMaybe<Scalars['String']['input']>;
};

export type GraphStoreCreateVulnerabilityAssociatedIssueInput = {
  /** The list of relationships of type vulnerability-associated-issue to persist */
  relationships: Array<GraphStoreCreateVulnerabilityAssociatedIssueRelationshipInput>;
};

export type GraphStoreCreateVulnerabilityAssociatedIssueRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** Subject metadata for this relationship */
  subjectMetadata?: InputMaybe<GraphStoreCreateVulnerabilityAssociatedIssueRelationshipSubjectMetadataInput>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateVulnerabilityAssociatedIssueRelationshipSubjectMetadataInput = {
  container?: InputMaybe<GraphStoreCreateVulnerabilityAssociatedIssueContainerInput>;
  introducedDate?: InputMaybe<Scalars['DateTime']['input']>;
  severity?: InputMaybe<GraphStoreCreateVulnerabilityAssociatedIssueVulnerabilitySeverityInput>;
  status?: InputMaybe<GraphStoreCreateVulnerabilityAssociatedIssueVulnerabilityStatusInput>;
  type?: InputMaybe<GraphStoreCreateVulnerabilityAssociatedIssueVulnerabilityTypeInput>;
};

export enum GraphStoreCreateVulnerabilityAssociatedIssueVulnerabilitySeverityInput {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreCreateVulnerabilityAssociatedIssueVulnerabilityStatusInput {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreCreateVulnerabilityAssociatedIssueVulnerabilityTypeInput {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type GraphStoreDateFilterInput = {
  after?: InputMaybe<Scalars['DateTime']['input']>;
  before?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreDeleteComponentImpactedByIncidentInput = {
  /** The list of relationships of type component-impacted-by-incident to delete */
  relationships: Array<GraphStoreDeleteComponentImpactedByIncidentRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteComponentImpactedByIncidentRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteFocusAreaHasAtlasGoalInput = {
  /** The list of relationships of type focus-area-has-atlas-goal to delete */
  relationships: Array<GraphStoreDeleteFocusAreaHasAtlasGoalRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteFocusAreaHasAtlasGoalRelationshipInput = {
  /** An ARI of type ati:cloud:mercury:focus-area */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:townsquare:goal */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteIncidentAssociatedPostIncidentReviewLinkInput = {
  /** The list of relationships of type incident-associated-post-incident-review-link to delete */
  relationships: Array<GraphStoreDeleteIncidentAssociatedPostIncidentReviewLinkRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteIncidentAssociatedPostIncidentReviewLinkRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link, ati:cloud:jira:post-incident-review, ati:cloud:graph:post-incident-review] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteIncidentHasActionItemInput = {
  /** The list of relationships of type incident-has-action-item to delete */
  relationships: Array<GraphStoreDeleteIncidentHasActionItemRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteIncidentHasActionItemRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteIncidentLinkedJswIssueInput = {
  /** The list of relationships of type incident-linked-jsw-issue to delete */
  relationships: Array<GraphStoreDeleteIncidentLinkedJswIssueRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteIncidentLinkedJswIssueRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteIssueToWhiteboardInput = {
  /** The list of relationships of type issue-to-whiteboard to delete */
  relationships: Array<GraphStoreDeleteIssueToWhiteboardRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteIssueToWhiteboardRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteJswProjectAssociatedComponentInput = {
  /** The list of relationships of type jsw-project-associated-component to delete */
  relationships: Array<GraphStoreDeleteJswProjectAssociatedComponentRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteJswProjectAssociatedComponentRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:graph:service, ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectAssociatedOpsgenieTeamInput = {
  /** The list of relationships of type project-associated-opsgenie-team to delete */
  relationships: Array<GraphStoreDeleteProjectAssociatedOpsgenieTeamRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectAssociatedOpsgenieTeamRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:opsgenie:team */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectAssociatedToSecurityContainerInput = {
  /** The list of relationships of type project-associated-to-security-container to delete */
  relationships: Array<GraphStoreDeleteProjectAssociatedToSecurityContainerRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectAssociatedToSecurityContainerRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:security-container, ati:cloud:graph:security-container] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectDisassociatedRepoInput = {
  /** The list of relationships of type project-disassociated-repo to delete */
  relationships: Array<GraphStoreDeleteProjectDisassociatedRepoRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectDisassociatedRepoRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:repository, ati:cloud:graph:repository] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectDocumentationEntityInput = {
  /** The list of relationships of type project-documentation-entity to delete */
  relationships: Array<GraphStoreDeleteProjectDocumentationEntityRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectDocumentationEntityRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:confluence:space, ati:cloud:confluence:page, ati:cloud:jira:document, ati:cloud:graph:document] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectDocumentationPageInput = {
  /** The list of relationships of type project-documentation-page to delete */
  relationships: Array<GraphStoreDeleteProjectDocumentationPageRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectDocumentationPageRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectDocumentationSpaceInput = {
  /** The list of relationships of type project-documentation-space to delete */
  relationships: Array<GraphStoreDeleteProjectDocumentationSpaceRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectDocumentationSpaceRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:space */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectHasRelatedWorkWithProjectInput = {
  /** The list of relationships of type project-has-related-work-with-project to delete */
  relationships: Array<GraphStoreDeleteProjectHasRelatedWorkWithProjectRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectHasRelatedWorkWithProjectRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectHasSharedVersionWithInput = {
  /** The list of relationships of type project-has-shared-version-with to delete */
  relationships: Array<GraphStoreDeleteProjectHasSharedVersionWithRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectHasSharedVersionWithRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectHasVersionInput = {
  /** The list of relationships of type project-has-version to delete */
  relationships: Array<GraphStoreDeleteProjectHasVersionRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectHasVersionRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:version */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteSprintRetrospectivePageInput = {
  /** The list of relationships of type sprint-retrospective-page to delete */
  relationships: Array<GraphStoreDeleteSprintRetrospectivePageRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteSprintRetrospectivePageRelationshipInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteSprintRetrospectiveWhiteboardInput = {
  /** The list of relationships of type sprint-retrospective-whiteboard to delete */
  relationships: Array<GraphStoreDeleteSprintRetrospectiveWhiteboardRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteSprintRetrospectiveWhiteboardRelationshipInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteTownsquareTagIsAliasOfTownsquareTagInput = {
  /** The list of relationships of type townsquare-tag-is-alias-of-townsquare-tag to delete */
  relationships: Array<GraphStoreDeleteTownsquareTagIsAliasOfTownsquareTagRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteTownsquareTagIsAliasOfTownsquareTagRelationshipInput = {
  /** An ARI of type ati:cloud:townsquare:tag */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:townsquare:tag */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteVersionUserAssociatedFeatureFlagInput = {
  /** The list of relationships of type version-user-associated-feature-flag to delete */
  relationships: Array<GraphStoreDeleteVersionUserAssociatedFeatureFlagRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteVersionUserAssociatedFeatureFlagRelationshipInput = {
  /** An ARI of type ati:cloud:jira:version */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:feature-flag, ati:cloud:graph:feature-flag] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteVulnerabilityAssociatedIssueInput = {
  /** The list of relationships of type vulnerability-associated-issue to delete */
  relationships: Array<GraphStoreDeleteVulnerabilityAssociatedIssueRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteVulnerabilityAssociatedIssueRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:vulnerability, ati:cloud:graph:vulnerability] */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
};

export type GraphStoreFloatFilterInput = {
  greaterThan?: InputMaybe<Scalars['Float']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['Float']['input']>;
  is?: InputMaybe<Array<Scalars['Float']['input']>>;
  isNot?: InputMaybe<Array<Scalars['Float']['input']>>;
  lessThan?: InputMaybe<Scalars['Float']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['Float']['input']>;
};

export type GraphStoreFocusAreaAssociatedToProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreFocusAreaHasAtlasGoalSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreFocusAreaHasFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreFocusAreaHasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreFullComponentImpactedByIncidentJiraIncidentPriorityOutput {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullComponentImpactedByIncidentJiraIncidentStatusOutput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export enum GraphStoreFullIssueAssociatedBuildBuildStateOutput {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullIssueAssociatedDeploymentDeploymentStateOutput {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullIssueAssociatedDeploymentEnvironmentTypeOutput {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum GraphStoreFullIssueAssociatedDesignDesignStatusOutput {
  None = 'NONE',
  NotSet = 'NOT_SET',
  ReadyForDevelopment = 'READY_FOR_DEVELOPMENT',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullIssueAssociatedDesignDesignTypeOutput {
  Canvas = 'CANVAS',
  File = 'FILE',
  Group = 'GROUP',
  Node = 'NODE',
  NotSet = 'NOT_SET',
  Other = 'OTHER',
  Prototype = 'PROTOTYPE'
}

export enum GraphStoreFullIssueAssociatedIssueRemoteLinkLinkApplicationTypeOutput {
  Bamboo = 'BAMBOO',
  BbPrComment = 'BB_PR_COMMENT',
  ConfluencePage = 'CONFLUENCE_PAGE',
  Jira = 'JIRA',
  NotSet = 'NOT_SET',
  Snyk = 'SNYK',
  Trello = 'TRELLO',
  WebLink = 'WEB_LINK'
}

export enum GraphStoreFullIssueAssociatedIssueRemoteLinkLinkRelationshipOutput {
  AddedToIdea = 'ADDED_TO_IDEA',
  Blocks = 'BLOCKS',
  Causes = 'CAUSES',
  Clones = 'CLONES',
  CreatedFrom = 'CREATED_FROM',
  Duplicates = 'DUPLICATES',
  Implements = 'IMPLEMENTS',
  IsBlockedBy = 'IS_BLOCKED_BY',
  IsCausedBy = 'IS_CAUSED_BY',
  IsClonedBy = 'IS_CLONED_BY',
  IsDuplicatedBy = 'IS_DUPLICATED_BY',
  IsIdeaFor = 'IS_IDEA_FOR',
  IsImplementedBy = 'IS_IMPLEMENTED_BY',
  IsReviewedBy = 'IS_REVIEWED_BY',
  MentionedIn = 'MENTIONED_IN',
  MergedFrom = 'MERGED_FROM',
  MergedInto = 'MERGED_INTO',
  NotSet = 'NOT_SET',
  RelatesTo = 'RELATES_TO',
  Reviews = 'REVIEWS',
  SplitFrom = 'SPLIT_FROM',
  SplitTo = 'SPLIT_TO',
  WikiPage = 'WIKI_PAGE'
}

export enum GraphStoreFullIssueAssociatedPrPullRequestStatusOutput {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullIssueAssociatedPrReviewerReviewerStatusOutput {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphStoreFullJswProjectAssociatedIncidentJiraIncidentPriorityOutput {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullJswProjectAssociatedIncidentJiraIncidentStatusOutput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export enum GraphStoreFullParentDocumentHasChildDocumentCategoryOutput {
  Archive = 'ARCHIVE',
  Audio = 'AUDIO',
  Code = 'CODE',
  Document = 'DOCUMENT',
  Folder = 'FOLDER',
  Form = 'FORM',
  Image = 'IMAGE',
  NotSet = 'NOT_SET',
  Other = 'OTHER',
  Pdf = 'PDF',
  Presentation = 'PRESENTATION',
  Shortcut = 'SHORTCUT',
  Spreadsheet = 'SPREADSHEET',
  Video = 'VIDEO'
}

export enum GraphStoreFullProjectAssociatedBuildBuildStateOutput {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullProjectAssociatedDeploymentDeploymentStateOutput {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullProjectAssociatedDeploymentEnvironmentTypeOutput {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum GraphStoreFullProjectAssociatedPrPullRequestStatusOutput {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullProjectAssociatedPrReviewerReviewerStatusOutput {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphStoreFullProjectAssociatedVulnerabilityVulnerabilitySeverityOutput {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullProjectAssociatedVulnerabilityVulnerabilityStatusOutput {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullProjectAssociatedVulnerabilityVulnerabilityTypeOutput {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSecurityContainerAssociatedToVulnerabilityVulnerabilitySeverityOutput {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSecurityContainerAssociatedToVulnerabilityVulnerabilityStatusOutput {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSecurityContainerAssociatedToVulnerabilityVulnerabilityTypeOutput {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullServiceLinkedIncidentJiraServiceManagementIncidentPriorityOutput {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5'
}

export enum GraphStoreFullServiceLinkedIncidentJiraServiceManagementIncidentStatusOutput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export enum GraphStoreFullSprintAssociatedBuildBuildStateOutput {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSprintAssociatedDeploymentDeploymentStateOutput {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSprintAssociatedDeploymentEnvironmentTypeOutput {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum GraphStoreFullSprintAssociatedPrPullRequestStatusOutput {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSprintAssociatedPrReviewerReviewerStatusOutput {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphStoreFullSprintAssociatedVulnerabilityStatusCategoryOutput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export enum GraphStoreFullSprintAssociatedVulnerabilityVulnerabilitySeverityOutput {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSprintAssociatedVulnerabilityVulnerabilityStatusOutput {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSprintContainsIssueStatusCategoryOutput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export enum GraphStoreFullVersionAssociatedDesignDesignStatusOutput {
  None = 'NONE',
  NotSet = 'NOT_SET',
  ReadyForDevelopment = 'READY_FOR_DEVELOPMENT',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullVersionAssociatedDesignDesignTypeOutput {
  Canvas = 'CANVAS',
  File = 'FILE',
  Group = 'GROUP',
  Node = 'NODE',
  NotSet = 'NOT_SET',
  Other = 'OTHER',
  Prototype = 'PROTOTYPE'
}

export enum GraphStoreFullVulnerabilityAssociatedIssueVulnerabilitySeverityOutput {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullVulnerabilityAssociatedIssueVulnerabilityStatusOutput {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullVulnerabilityAssociatedIssueVulnerabilityTypeOutput {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type GraphStoreIncidentAssociatedPostIncidentReviewLinkSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIncidentAssociatedPostIncidentReviewSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIncidentHasActionItemSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIncidentLinkedJswIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIntFilterInput = {
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['Int']['input']>;
  is?: InputMaybe<Array<Scalars['Int']['input']>>;
  isNot?: InputMaybe<Array<Scalars['Int']['input']>>;
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphStoreIssueAssociatedBranchSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedBuildSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedCommitSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedDeploymentAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreIssueAssociatedDeploymentAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreIssueAssociatedDeploymentAuthorFilterInput>>>;
};

export type GraphStoreIssueAssociatedDeploymentAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreIssueAssociatedDeploymentAuthorFilterInput>;
  to_environmentType?: InputMaybe<GraphStoreIssueAssociatedDeploymentEnvironmentTypeFilterInput>;
  to_state?: InputMaybe<GraphStoreIssueAssociatedDeploymentDeploymentStateFilterInput>;
};

export enum GraphStoreIssueAssociatedDeploymentDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreIssueAssociatedDeploymentDeploymentStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreIssueAssociatedDeploymentDeploymentState>>;
  isNot?: InputMaybe<Array<GraphStoreIssueAssociatedDeploymentDeploymentState>>;
};

export enum GraphStoreIssueAssociatedDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphStoreIssueAssociatedDeploymentEnvironmentTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreIssueAssociatedDeploymentEnvironmentType>>;
  isNot?: InputMaybe<Array<GraphStoreIssueAssociatedDeploymentEnvironmentType>>;
};

/** Conditional selection for filter field of issue-associated-deployment relationship queries */
export type GraphStoreIssueAssociatedDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreIssueAssociatedDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreIssueAssociatedDeploymentConditionalFilterInput>>>;
};

export type GraphStoreIssueAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreIssueAssociatedDeploymentAuthorSortInput>;
  to_environmentType?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedDesignSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedFeatureFlagSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedIssueRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedPrSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueChangesComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueRecursiveAssociatedPrSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueToWhiteboardSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJiraEpicContributesToAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJiraProjectAssociatedAtlasGoalSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJsmProjectAssociatedServiceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJswProjectAssociatedComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJswProjectAssociatedIncidentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_affectedServiceAris?: InputMaybe<GraphStoreAriFilterInput>;
  to_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_majorIncident?: InputMaybe<GraphStoreBooleanFilterInput>;
  to_priority?: InputMaybe<GraphStoreJswProjectAssociatedIncidentJiraIncidentPriorityFilterInput>;
  to_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_status?: InputMaybe<GraphStoreJswProjectAssociatedIncidentJiraIncidentStatusFilterInput>;
};

/** Conditional selection for filter field of jsw-project-associated-incident relationship queries */
export type GraphStoreJswProjectAssociatedIncidentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreJswProjectAssociatedIncidentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreJswProjectAssociatedIncidentConditionalFilterInput>>>;
};

export enum GraphStoreJswProjectAssociatedIncidentJiraIncidentPriority {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export type GraphStoreJswProjectAssociatedIncidentJiraIncidentPriorityFilterInput = {
  is?: InputMaybe<Array<GraphStoreJswProjectAssociatedIncidentJiraIncidentPriority>>;
  isNot?: InputMaybe<Array<GraphStoreJswProjectAssociatedIncidentJiraIncidentPriority>>;
};

export enum GraphStoreJswProjectAssociatedIncidentJiraIncidentStatus {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export type GraphStoreJswProjectAssociatedIncidentJiraIncidentStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreJswProjectAssociatedIncidentJiraIncidentStatus>>;
  isNot?: InputMaybe<Array<GraphStoreJswProjectAssociatedIncidentJiraIncidentStatus>>;
};

export type GraphStoreJswProjectAssociatedIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_affectedServiceAris?: InputMaybe<GraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  to_majorIncident?: InputMaybe<GraphStoreSortInput>;
  to_priority?: InputMaybe<GraphStoreSortInput>;
  to_reporterAri?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJswProjectSharesComponentWithJsmProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreLinkedProjectHasVersionSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreLongFilterInput = {
  greaterThan?: InputMaybe<Scalars['Long']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['Long']['input']>;
  is?: InputMaybe<Array<Scalars['Long']['input']>>;
  isNot?: InputMaybe<Array<Scalars['Long']['input']>>;
  lessThan?: InputMaybe<Scalars['Long']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphStoreMediaAttachedToContentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreOperationsContainerImpactedByIncidentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreOperationsContainerImprovedByActionItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreParentDocumentHasChildDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreParentIssueHasChildIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStorePrInRepoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedBranchSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreProjectAssociatedBuildBuildState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedBuildBuildStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedBuildBuildState>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedBuildBuildState>>;
};

export type GraphStoreProjectAssociatedBuildConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_state?: InputMaybe<GraphStoreProjectAssociatedBuildBuildStateFilterInput>;
  to_testInfo?: InputMaybe<GraphStoreProjectAssociatedBuildTestInfoFilterInput>;
};

/** Conditional selection for filter field of project-associated-build relationship queries */
export type GraphStoreProjectAssociatedBuildFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedBuildConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedBuildConditionalFilterInput>>>;
};

export type GraphStoreProjectAssociatedBuildSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
  to_testInfo?: InputMaybe<GraphStoreProjectAssociatedBuildTestInfoSortInput>;
};

export type GraphStoreProjectAssociatedBuildTestInfoFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedBuildTestInfoFilterInput>>>;
  numberFailed?: InputMaybe<GraphStoreLongFilterInput>;
  numberPassed?: InputMaybe<GraphStoreLongFilterInput>;
  numberSkipped?: InputMaybe<GraphStoreLongFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedBuildTestInfoFilterInput>>>;
  totalNumber?: InputMaybe<GraphStoreLongFilterInput>;
};

export type GraphStoreProjectAssociatedBuildTestInfoSortInput = {
  numberFailed?: InputMaybe<GraphStoreSortInput>;
  numberPassed?: InputMaybe<GraphStoreSortInput>;
  numberSkipped?: InputMaybe<GraphStoreSortInput>;
  totalNumber?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedDeploymentAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedDeploymentAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedDeploymentAuthorFilterInput>>>;
};

export type GraphStoreProjectAssociatedDeploymentAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_fixVersionIds?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_issueTypeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreProjectAssociatedDeploymentAuthorFilterInput>;
  to_deploymentLastUpdated?: InputMaybe<GraphStoreLongFilterInput>;
  to_environmentType?: InputMaybe<GraphStoreProjectAssociatedDeploymentEnvironmentTypeFilterInput>;
  to_state?: InputMaybe<GraphStoreProjectAssociatedDeploymentDeploymentStateFilterInput>;
};

export enum GraphStoreProjectAssociatedDeploymentDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedDeploymentDeploymentStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedDeploymentDeploymentState>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedDeploymentDeploymentState>>;
};

export enum GraphStoreProjectAssociatedDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphStoreProjectAssociatedDeploymentEnvironmentTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedDeploymentEnvironmentType>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedDeploymentEnvironmentType>>;
};

/** Conditional selection for filter field of project-associated-deployment relationship queries */
export type GraphStoreProjectAssociatedDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedDeploymentConditionalFilterInput>>>;
};

export type GraphStoreProjectAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_fixVersionIds?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_issueTypeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreProjectAssociatedDeploymentAuthorSortInput>;
  to_deploymentLastUpdated?: InputMaybe<GraphStoreSortInput>;
  to_environmentType?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedOpsgenieTeamSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedPrAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedPrAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedPrAuthorFilterInput>>>;
};

export type GraphStoreProjectAssociatedPrAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedPrConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreProjectAssociatedPrAuthorFilterInput>;
  to_reviewers?: InputMaybe<GraphStoreProjectAssociatedPrReviewerFilterInput>;
  to_status?: InputMaybe<GraphStoreProjectAssociatedPrPullRequestStatusFilterInput>;
  to_taskCount?: InputMaybe<GraphStoreFloatFilterInput>;
};

/** Conditional selection for filter field of project-associated-pr relationship queries */
export type GraphStoreProjectAssociatedPrFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedPrConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedPrConditionalFilterInput>>>;
};

export enum GraphStoreProjectAssociatedPrPullRequestStatus {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedPrPullRequestStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedPrPullRequestStatus>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedPrPullRequestStatus>>;
};

export type GraphStoreProjectAssociatedPrReviewerFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedPrReviewerFilterInput>>>;
  approvalStatus?: InputMaybe<GraphStoreProjectAssociatedPrReviewerReviewerStatusFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedPrReviewerFilterInput>>>;
  reviewerAri?: InputMaybe<GraphStoreAriFilterInput>;
};

export enum GraphStoreProjectAssociatedPrReviewerReviewerStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export type GraphStoreProjectAssociatedPrReviewerReviewerStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedPrReviewerReviewerStatus>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedPrReviewerReviewerStatus>>;
};

export type GraphStoreProjectAssociatedPrReviewerSortInput = {
  approvalStatus?: InputMaybe<GraphStoreSortInput>;
  reviewerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedPrSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreProjectAssociatedPrAuthorSortInput>;
  to_reviewers?: InputMaybe<GraphStoreProjectAssociatedPrReviewerSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_taskCount?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedRepoConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_providerAri?: InputMaybe<GraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of project-associated-repo relationship queries */
export type GraphStoreProjectAssociatedRepoFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedRepoConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedRepoConditionalFilterInput>>>;
};

export type GraphStoreProjectAssociatedRepoSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_providerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedServiceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedToIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedToOperationsContainerSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedToSecurityContainerSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedVulnerabilityConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_container?: InputMaybe<GraphStoreProjectAssociatedVulnerabilityContainerFilterInput>;
  to_severity?: InputMaybe<GraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverityFilterInput>;
  to_status?: InputMaybe<GraphStoreProjectAssociatedVulnerabilityVulnerabilityStatusFilterInput>;
  to_type?: InputMaybe<GraphStoreProjectAssociatedVulnerabilityVulnerabilityTypeFilterInput>;
};

export type GraphStoreProjectAssociatedVulnerabilityContainerFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedVulnerabilityContainerFilterInput>>>;
  containerAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedVulnerabilityContainerFilterInput>>>;
};

export type GraphStoreProjectAssociatedVulnerabilityContainerSortInput = {
  containerAri?: InputMaybe<GraphStoreSortInput>;
};

/** Conditional selection for filter field of project-associated-vulnerability relationship queries */
export type GraphStoreProjectAssociatedVulnerabilityFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedVulnerabilityConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedVulnerabilityConditionalFilterInput>>>;
};

export type GraphStoreProjectAssociatedVulnerabilitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_container?: InputMaybe<GraphStoreProjectAssociatedVulnerabilityContainerSortInput>;
  to_severity?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_type?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverityFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverity>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverity>>;
};

export enum GraphStoreProjectAssociatedVulnerabilityVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedVulnerabilityVulnerabilityStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedVulnerabilityVulnerabilityStatus>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedVulnerabilityVulnerabilityStatus>>;
};

export enum GraphStoreProjectAssociatedVulnerabilityVulnerabilityType {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedVulnerabilityVulnerabilityTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedVulnerabilityVulnerabilityType>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedVulnerabilityVulnerabilityType>>;
};

export type GraphStoreProjectDisassociatedRepoSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectDocumentationEntitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectDocumentationPageSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectDocumentationSpaceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectExplicitlyAssociatedRepoSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_providerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectHasIssueConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_fixVersionIds?: InputMaybe<GraphStoreLongFilterInput>;
  to_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_issueTypeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of project-has-issue relationship queries */
export type GraphStoreProjectHasIssueFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectHasIssueConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectHasIssueConditionalFilterInput>>>;
};

export type GraphStoreProjectHasIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  to_creatorAri?: InputMaybe<GraphStoreSortInput>;
  to_fixVersionIds?: InputMaybe<GraphStoreSortInput>;
  to_issueAri?: InputMaybe<GraphStoreSortInput>;
  to_issueTypeAri?: InputMaybe<GraphStoreSortInput>;
  to_reporterAri?: InputMaybe<GraphStoreSortInput>;
  to_statusAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectHasRelatedWorkWithProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectHasSharedVersionWithSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectHasVersionSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectLinkedToCompassComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSecurityContainerAssociatedToVulnerabilitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreServiceAssociatedDeploymentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreServiceLinkedIncidentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_affectedServiceAris?: InputMaybe<GraphStoreAriFilterInput>;
  to_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_majorIncident?: InputMaybe<GraphStoreBooleanFilterInput>;
  to_priority?: InputMaybe<GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriorityFilterInput>;
  to_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_status?: InputMaybe<GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatusFilterInput>;
};

/** Conditional selection for filter field of service-linked-incident relationship queries */
export type GraphStoreServiceLinkedIncidentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreServiceLinkedIncidentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreServiceLinkedIncidentConditionalFilterInput>>>;
};

export enum GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriority {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5'
}

export type GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriorityFilterInput = {
  is?: InputMaybe<Array<GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriority>>;
  isNot?: InputMaybe<Array<GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriority>>;
};

export enum GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatus {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export type GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatus>>;
  isNot?: InputMaybe<Array<GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatus>>;
};

export type GraphStoreServiceLinkedIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_affectedServiceAris?: InputMaybe<GraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  to_majorIncident?: InputMaybe<GraphStoreSortInput>;
  to_priority?: InputMaybe<GraphStoreSortInput>;
  to_reporterAri?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSortInput = {
  /** The direction of the sort. For enums the order is determined by the order of enum values in the protobuf schema. */
  direction: SortDirection;
  /** The priority of the field. Higher keys are used to resolve ties when lower keys have the same value. If there is only one sorting option, the priority value becomes irrelevant. */
  priority: Scalars['Int']['input'];
};

export type GraphStoreSpaceAssociatedWithProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreSprintAssociatedBuildBuildState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreSprintAssociatedBuildBuildStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedBuildBuildState>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedBuildBuildState>>;
};

export type GraphStoreSprintAssociatedBuildConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_state?: InputMaybe<GraphStoreSprintAssociatedBuildBuildStateFilterInput>;
  to_testInfo?: InputMaybe<GraphStoreSprintAssociatedBuildTestInfoFilterInput>;
};

/** Conditional selection for filter field of sprint-associated-build relationship queries */
export type GraphStoreSprintAssociatedBuildFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedBuildConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedBuildConditionalFilterInput>>>;
};

export type GraphStoreSprintAssociatedBuildSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
  to_testInfo?: InputMaybe<GraphStoreSprintAssociatedBuildTestInfoSortInput>;
};

export type GraphStoreSprintAssociatedBuildTestInfoFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedBuildTestInfoFilterInput>>>;
  numberFailed?: InputMaybe<GraphStoreLongFilterInput>;
  numberPassed?: InputMaybe<GraphStoreLongFilterInput>;
  numberSkipped?: InputMaybe<GraphStoreLongFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedBuildTestInfoFilterInput>>>;
  totalNumber?: InputMaybe<GraphStoreLongFilterInput>;
};

export type GraphStoreSprintAssociatedBuildTestInfoSortInput = {
  numberFailed?: InputMaybe<GraphStoreSortInput>;
  numberPassed?: InputMaybe<GraphStoreSortInput>;
  numberSkipped?: InputMaybe<GraphStoreSortInput>;
  totalNumber?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintAssociatedDeploymentAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedDeploymentAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedDeploymentAuthorFilterInput>>>;
};

export type GraphStoreSprintAssociatedDeploymentAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintAssociatedDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreSprintAssociatedDeploymentAuthorFilterInput>;
  to_environmentType?: InputMaybe<GraphStoreSprintAssociatedDeploymentEnvironmentTypeFilterInput>;
  to_state?: InputMaybe<GraphStoreSprintAssociatedDeploymentDeploymentStateFilterInput>;
};

export enum GraphStoreSprintAssociatedDeploymentDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreSprintAssociatedDeploymentDeploymentStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedDeploymentDeploymentState>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedDeploymentDeploymentState>>;
};

export enum GraphStoreSprintAssociatedDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphStoreSprintAssociatedDeploymentEnvironmentTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedDeploymentEnvironmentType>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedDeploymentEnvironmentType>>;
};

/** Conditional selection for filter field of sprint-associated-deployment relationship queries */
export type GraphStoreSprintAssociatedDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedDeploymentConditionalFilterInput>>>;
};

export type GraphStoreSprintAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreSprintAssociatedDeploymentAuthorSortInput>;
  to_environmentType?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintAssociatedPrAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedPrAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedPrAuthorFilterInput>>>;
};

export type GraphStoreSprintAssociatedPrAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintAssociatedPrConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreSprintAssociatedPrAuthorFilterInput>;
  to_reviewers?: InputMaybe<GraphStoreSprintAssociatedPrReviewerFilterInput>;
  to_status?: InputMaybe<GraphStoreSprintAssociatedPrPullRequestStatusFilterInput>;
  to_taskCount?: InputMaybe<GraphStoreFloatFilterInput>;
};

/** Conditional selection for filter field of sprint-associated-pr relationship queries */
export type GraphStoreSprintAssociatedPrFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedPrConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedPrConditionalFilterInput>>>;
};

export enum GraphStoreSprintAssociatedPrPullRequestStatus {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphStoreSprintAssociatedPrPullRequestStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedPrPullRequestStatus>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedPrPullRequestStatus>>;
};

export type GraphStoreSprintAssociatedPrReviewerFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedPrReviewerFilterInput>>>;
  approvalStatus?: InputMaybe<GraphStoreSprintAssociatedPrReviewerReviewerStatusFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedPrReviewerFilterInput>>>;
  reviewerAri?: InputMaybe<GraphStoreAriFilterInput>;
};

export enum GraphStoreSprintAssociatedPrReviewerReviewerStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export type GraphStoreSprintAssociatedPrReviewerReviewerStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedPrReviewerReviewerStatus>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedPrReviewerReviewerStatus>>;
};

export type GraphStoreSprintAssociatedPrReviewerSortInput = {
  approvalStatus?: InputMaybe<GraphStoreSortInput>;
  reviewerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintAssociatedPrSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreSprintAssociatedPrAuthorSortInput>;
  to_reviewers?: InputMaybe<GraphStoreSprintAssociatedPrReviewerSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_taskCount?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintAssociatedVulnerabilityConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusCategory?: InputMaybe<GraphStoreSprintAssociatedVulnerabilityStatusCategoryFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_introducedDate?: InputMaybe<GraphStoreLongFilterInput>;
  to_severity?: InputMaybe<GraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverityFilterInput>;
  to_status?: InputMaybe<GraphStoreSprintAssociatedVulnerabilityVulnerabilityStatusFilterInput>;
};

/** Conditional selection for filter field of sprint-associated-vulnerability relationship queries */
export type GraphStoreSprintAssociatedVulnerabilityFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedVulnerabilityConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedVulnerabilityConditionalFilterInput>>>;
};

export type GraphStoreSprintAssociatedVulnerabilitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusCategory?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_introducedDate?: InputMaybe<GraphStoreSortInput>;
  to_severity?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreSprintAssociatedVulnerabilityStatusCategory {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphStoreSprintAssociatedVulnerabilityStatusCategoryFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedVulnerabilityStatusCategory>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedVulnerabilityStatusCategory>>;
};

export enum GraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export type GraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverityFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverity>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverity>>;
};

export enum GraphStoreSprintAssociatedVulnerabilityVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphStoreSprintAssociatedVulnerabilityVulnerabilityStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedVulnerabilityVulnerabilityStatus>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedVulnerabilityVulnerabilityStatus>>;
};

export type GraphStoreSprintContainsIssueConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_statusCategory?: InputMaybe<GraphStoreSprintContainsIssueStatusCategoryFilterInput>;
};

/** Conditional selection for filter field of sprint-contains-issue relationship queries */
export type GraphStoreSprintContainsIssueFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintContainsIssueConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintContainsIssueConditionalFilterInput>>>;
};

export type GraphStoreSprintContainsIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  to_creatorAri?: InputMaybe<GraphStoreSortInput>;
  to_issueAri?: InputMaybe<GraphStoreSortInput>;
  to_reporterAri?: InputMaybe<GraphStoreSortInput>;
  to_statusAri?: InputMaybe<GraphStoreSortInput>;
  to_statusCategory?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreSprintContainsIssueStatusCategory {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphStoreSprintContainsIssueStatusCategoryFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintContainsIssueStatusCategory>>;
  isNot?: InputMaybe<Array<GraphStoreSprintContainsIssueStatusCategory>>;
};

export type GraphStoreSprintRetrospectivePageSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintRetrospectiveWhiteboardSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreTeamOwnsComponentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreTeamWorksOnProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnsComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedBranchSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedBuildSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedCommitSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedDesignConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_designLastUpdated?: InputMaybe<GraphStoreLongFilterInput>;
  to_status?: InputMaybe<GraphStoreVersionAssociatedDesignDesignStatusFilterInput>;
  to_type?: InputMaybe<GraphStoreVersionAssociatedDesignDesignTypeFilterInput>;
};

export enum GraphStoreVersionAssociatedDesignDesignStatus {
  None = 'NONE',
  NotSet = 'NOT_SET',
  ReadyForDevelopment = 'READY_FOR_DEVELOPMENT',
  Unknown = 'UNKNOWN'
}

export type GraphStoreVersionAssociatedDesignDesignStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreVersionAssociatedDesignDesignStatus>>;
  isNot?: InputMaybe<Array<GraphStoreVersionAssociatedDesignDesignStatus>>;
};

export enum GraphStoreVersionAssociatedDesignDesignType {
  Canvas = 'CANVAS',
  File = 'FILE',
  Group = 'GROUP',
  Node = 'NODE',
  NotSet = 'NOT_SET',
  Other = 'OTHER',
  Prototype = 'PROTOTYPE'
}

export type GraphStoreVersionAssociatedDesignDesignTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreVersionAssociatedDesignDesignType>>;
  isNot?: InputMaybe<Array<GraphStoreVersionAssociatedDesignDesignType>>;
};

/** Conditional selection for filter field of version-associated-design relationship queries */
export type GraphStoreVersionAssociatedDesignFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreVersionAssociatedDesignConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreVersionAssociatedDesignConditionalFilterInput>>>;
};

export type GraphStoreVersionAssociatedDesignSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_designLastUpdated?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_type?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedPullRequestSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionUserAssociatedFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVulnerabilityAssociatedIssueContainerSortInput = {
  containerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVulnerabilityAssociatedIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  from_container?: InputMaybe<GraphStoreVulnerabilityAssociatedIssueContainerSortInput>;
  from_introducedDate?: InputMaybe<GraphStoreSortInput>;
  from_severity?: InputMaybe<GraphStoreSortInput>;
  from_status?: InputMaybe<GraphStoreSortInput>;
  from_type?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

/**
 * The context object provides essential insights into the users' current experience and operations.
 *
 * The supported product and subproduct keys can be found at https://hello.atlassian.net/wiki/spaces/ECON/pages/2339030895/App+Identifiers
 */
export type GrowthRecContext = {
  anonymousId?: InputMaybe<Scalars['ID']['input']>;
  containers?: InputMaybe<Scalars['JSON']['input']>;
  /** Any custom context associated with this request */
  custom?: InputMaybe<Scalars['JSON']['input']>;
  /** Language-Sub language identifier format (ISO 639-1 and ISO 639-2) */
  locale?: InputMaybe<Scalars['String']['input']>;
  orgId?: InputMaybe<Scalars['ID']['input']>;
  product?: InputMaybe<Scalars['String']['input']>;
  /** This is an identifier for tagging analytics events, useful for correlating across frontend and backend */
  sessionId?: InputMaybe<Scalars['ID']['input']>;
  subproduct?: InputMaybe<Scalars['String']['input']>;
  /** The tenant id is also well known as the cloud id */
  tenantId?: InputMaybe<Scalars['ID']['input']>;
  useCase?: InputMaybe<Scalars['String']['input']>;
  workspaceId?: InputMaybe<Scalars['ID']['input']>;
};

export type GrowthRecRerankCandidate = {
  context?: InputMaybe<Scalars['JSON']['input']>;
  entityId: Scalars['String']['input'];
};

export enum GrowthUnifiedProfileAnchorType {
  Pfm = 'PFM',
  Seo = 'SEO'
}

export enum GrowthUnifiedProfileChannelName {
  Comarketing = 'COMARKETING',
  Direct = 'DIRECT',
  Email = 'EMAIL',
  EngagementEngine = 'ENGAGEMENT_ENGINE',
  InProductReferral = 'IN_PRODUCT_REFERRAL',
  Organic = 'ORGANIC',
  Other = 'OTHER',
  PaidAffiliate = 'PAID_AFFILIATE',
  PaidDisplay = 'PAID_DISPLAY',
  PaidReviewSites = 'PAID_REVIEW_SITES',
  PaidSearchBranded = 'PAID_SEARCH_BRANDED',
  PaidSearchNonBranded = 'PAID_SEARCH_NON_BRANDED',
  PaidSocial = 'PAID_SOCIAL',
  ReferralExternal = 'REFERRAL_EXTERNAL',
  ReferralInternal = 'REFERRAL_INTERNAL',
  SelfReferral = 'SELF_REFERRAL',
  SlackAppDirectory = 'SLACK_APP_DIRECTORY',
  Suppress = 'SUPPRESS',
  UnpaidSocial = 'UNPAID_SOCIAL',
  UnpaidVideo = 'UNPAID_VIDEO'
}

export enum GrowthUnifiedProfileCompanySize {
  Large = 'LARGE',
  Medium = 'MEDIUM',
  Small = 'SMALL',
  Unknown = 'UNKNOWN'
}

export enum GrowthUnifiedProfileCompanyType {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

export type GrowthUnifiedProfileConfluenceOnboardingContextInput = {
  jobsToBeDone?: InputMaybe<Array<InputMaybe<GrowthUnifiedProfileJtbd>>>;
  template?: InputMaybe<Scalars['String']['input']>;
};

export type GrowthUnifiedProfileCreateProfileInput = {
  /** The account ID for the user. */
  accountId?: InputMaybe<Scalars['ID']['input']>;
  /** The anonymous ID for the user. */
  anonymousId?: InputMaybe<Scalars['ID']['input']>;
  /** The tenant ID for the user. */
  tenantId?: InputMaybe<Scalars['ID']['input']>;
  /** Unified profile which needs to be created for the user. */
  unifiedProfile: GrowthUnifiedProfileInput;
};

export enum GrowthUnifiedProfileEnrichmentStatus {
  Complete = 'COMPLETE',
  Error = 'ERROR',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING'
}

export enum GrowthUnifiedProfileEnterpriseAccountStatus {
  Bronze = 'BRONZE',
  Gam = 'GAM',
  Gold = 'GOLD',
  Platimun = 'PLATIMUN',
  Silver = 'SILVER'
}

export enum GrowthUnifiedProfileEntityType {
  /** anonymous entity type */
  AjsAnonymousUser = 'AJS_ANONYMOUS_USER',
  /** atlassian account entity type */
  AtlassianAccount = 'ATLASSIAN_ACCOUNT',
  /** organization entity type */
  Org = 'ORG',
  /** site of tenant entity type */
  Site = 'SITE'
}

export type GrowthUnifiedProfileInput = {
  /** onboardingContext for jira or confluence */
  onboardingContext?: InputMaybe<GrowthUnifiedProfileOnboardingContextInput>;
};

export enum GrowthUnifiedProfileJtbd {
  AdHocTaskAndIncidentManagement = 'AD_HOC_TASK_AND_INCIDENT_MANAGEMENT',
  Budgets = 'BUDGETS',
  CdWrtng = 'CD_WRTNG',
  CentralizedDocumentation = 'CENTRALIZED_DOCUMENTATION',
  ComplianceAndRiskManagement = 'COMPLIANCE_AND_RISK_MANAGEMENT',
  EstimateTimeAndEffort = 'ESTIMATE_TIME_AND_EFFORT',
  ImproveTeamProcesses = 'IMPROVE_TEAM_PROCESSES',
  ImproveWorkflow = 'IMPROVE_WORKFLOW',
  LaunchCampaigns = 'LAUNCH_CAMPAIGNS',
  ManageTasks = 'MANAGE_TASKS',
  ManagingClientAndVendorRelationships = 'MANAGING_CLIENT_AND_VENDOR_RELATIONSHIPS',
  MapWorkDependencies = 'MAP_WORK_DEPENDENCIES',
  MarketingContent = 'MARKETING_CONTENT',
  PlanAndManage = 'PLAN_AND_MANAGE',
  PrioritizeWork = 'PRIORITIZE_WORK',
  ProjectPlanning = 'PROJECT_PLANNING',
  ProjectPlanningAndCoordination = 'PROJECT_PLANNING_AND_COORDINATION',
  ProjectProgress = 'PROJECT_PROGRESS',
  Stakeholders = 'STAKEHOLDERS',
  StrategiesAndGoals = 'STRATEGIES_AND_GOALS',
  SystemAndToolEvaluations = 'SYSTEM_AND_TOOL_EVALUATIONS',
  TrackingRprtng = 'TRACKING_RPRTNG',
  TrackBugs = 'TRACK_BUGS',
  UseKanbanBoard = 'USE_KANBAN_BOARD'
}

export enum GrowthUnifiedProfileJiraFamiliarity {
  Experience = 'EXPERIENCE',
  Middle = 'MIDDLE',
  New = 'NEW'
}

/** onboarding context input for jira */
export type GrowthUnifiedProfileJiraOnboardingContextInput = {
  experienceLevel?: InputMaybe<Scalars['String']['input']>;
  jiraFamiliarity?: InputMaybe<GrowthUnifiedProfileJiraFamiliarity>;
  /** jobs to be done */
  jobsToBeDone?: InputMaybe<Array<InputMaybe<GrowthUnifiedProfileJtbd>>>;
  persona?: InputMaybe<Scalars['String']['input']>;
  /** name of the jira project */
  projectName?: InputMaybe<Scalars['String']['input']>;
  /** team type of the team */
  teamType?: InputMaybe<GrowthUnifiedProfileTeamType>;
  template?: InputMaybe<Scalars['String']['input']>;
};

/** onboarding context input for jira or confluence */
export type GrowthUnifiedProfileOnboardingContextInput = {
  confluence?: InputMaybe<GrowthUnifiedProfileConfluenceOnboardingContextInput>;
  jira?: InputMaybe<GrowthUnifiedProfileJiraOnboardingContextInput>;
};

export enum GrowthUnifiedProfileProductType {
  Confluence = 'CONFLUENCE',
  JiraSoftware = 'JIRA_SOFTWARE',
  Jsm = 'JSM',
  Trello = 'TRELLO'
}

export enum GrowthUnifiedProfileTeamType {
  CustomerService = 'CUSTOMER_SERVICE',
  Design = 'DESIGN',
  Finance = 'FINANCE',
  HumanResources = 'HUMAN_RESOURCES',
  ItSupport = 'IT_SUPPORT',
  Legal = 'LEGAL',
  Marketing = 'MARKETING',
  Operations = 'OPERATIONS',
  Other = 'OTHER',
  Sales = 'SALES',
  SoftwareDevelopment = 'SOFTWARE_DEVELOPMENT'
}

export enum HelpCenterAccessControlType {
  /** Help center is accessible to external customers  */
  External = 'EXTERNAL',
  /** Help center is accessible to specific groups */
  GroupBased = 'GROUP_BASED',
  /** Help center is accessible to internal customers */
  Internal = 'INTERNAL',
  /** Help center is accessible to all */
  Public = 'PUBLIC'
}

export type HelpCenterAnnouncementInput = {
  /**  Description and its all translations in raw format */
  descriptionTranslations?: InputMaybe<Array<HelpCenterTranslationInput>>;
  /**  Type in which announcements are stored */
  descriptionType: HelpCenterDescriptionType;
  /**  HelpCenterARI can be used to get the correct help center node  */
  helpCenterAri: Scalars['String']['input'];
  /**  Name and its all translations in raw format */
  nameTranslations?: InputMaybe<Array<HelpCenterTranslationInput>>;
};

export type HelpCenterBannerInput = {
  filedId?: InputMaybe<Scalars['String']['input']>;
  useDefaultBanner?: InputMaybe<Scalars['Boolean']['input']>;
};

export type HelpCenterBrandingColorsInput = {
  /** Banner text color of the Help Center */
  bannerTextColor?: InputMaybe<Scalars['String']['input']>;
  /** primary brand color of the Help Center */
  primary?: InputMaybe<Scalars['String']['input']>;
};

export type HelpCenterBrandingInput = {
  banner?: InputMaybe<HelpCenterBannerInput>;
  /**  Brand colors of the Help Center  */
  colors?: InputMaybe<HelpCenterBrandingColorsInput>;
  /** Title of the Help Center */
  homePageTitle?: InputMaybe<HelpCenterHomePageTitleInput>;
  /** Logo of Help Center */
  logo?: InputMaybe<HelpCenterLogoInput>;
};

export type HelpCenterBulkCreateTopicsInput = {
  /** Actual set of topics to be created in the given help center */
  helpCenterCreateTopicInputItem: Array<HelpCenterCreateTopicInput>;
};

export type HelpCenterBulkDeleteTopicInput = {
  helpCenterTopicDeleteInput: Array<HelpCenterTopicDeleteInput>;
};

export type HelpCenterBulkUpdateTopicInput = {
  /** The new updated topic for the given help center */
  helpCenterUpdateTopicInputItem: Array<HelpCenterUpdateTopicInput>;
};

/**
 * #########################
 *  Mutation Inputs
 * #########################
 */
export type HelpCenterCreateInput = {
  /**  Name of the help center.  */
  name: HelpCenterNameInput;
  /**  Slug of the help center.  */
  slug: Scalars['String']['input'];
  /**  workspaceARI can be used to get the correct help center node  */
  workspaceARI: Scalars['String']['input'];
};

export type HelpCenterCreateTopicInput = {
  /**  Description about the topic as visible on help center page */
  description?: InputMaybe<Scalars['String']['input']>;
  /**  HelpCenterARI can be used to retrieve helpCenterId  */
  helpCenterAri?: InputMaybe<Scalars['String']['input']>;
  /**  The help objects ARI which this topic contains */
  items: Array<HelpCenterTopicItemInput>;
  /**  Name about the topic as visible on the help center page */
  name: Scalars['String']['input'];
  /** The id of help center where the topics needs to be created */
  productName?: InputMaybe<Scalars['String']['input']>;
  /**
   *  This includes additional properties to the topics.
   * Such as whether the topic is visible to the helpseekers on help center or not etc.
   */
  properties?: InputMaybe<Scalars['JSON']['input']>;
};

export type HelpCenterDeleteInput = {
  /**  HelpCenterARI can be used to get the correct help center node  */
  helpCenterAri: Scalars['String']['input'];
};

export enum HelpCenterDescriptionType {
  PlainText = 'PLAIN_TEXT',
  RichText = 'RICH_TEXT',
  WikiMarkup = 'WIKI_MARKUP'
}

export type HelpCenterHomePageTitleInput = {
  /**  Default name of the helpcenter. */
  default: Scalars['String']['input'];
  /**  Translations of title the helpcenter. */
  translations?: InputMaybe<Array<InputMaybe<HelpCenterTranslationInput>>>;
};

export type HelpCenterLogoInput = {
  fileId?: InputMaybe<Scalars['String']['input']>;
};

/**  This describes the type of operation for which mediaConfig needs to be generated */
export enum HelpCenterMediaConfigOperationType {
  /**  indicates banner upload */
  BannerUpload = 'BANNER_UPLOAD',
  /**  indicates logo upload  */
  LogoUpload = 'LOGO_UPLOAD'
}

export type HelpCenterNameInput = {
  /**  Default name of the helpcenter to be updated */
  default: Scalars['String']['input'];
  /**  Translations of description the helpcenter. */
  translations?: InputMaybe<Array<InputMaybe<HelpCenterTranslationInput>>>;
};

export type HelpCenterPermissionsInput = {
  /** Type of access control for Help Center */
  accessControlType: HelpCenterAccessControlType;
  /** List of groups that needs to be added for Help Center access */
  addedAllowedAccessGroups?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List of groups whose access to Help Center needs to be deleted */
  deletedAllowedAccessGroups?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  HelpCenterARI can be used to get the correct help center node  */
  helpCenterAri: Scalars['String']['input'];
};

export type HelpCenterPortalFilter = {
  /** Give a list of type of portals to be given */
  typeFilter?: InputMaybe<Array<HelpCenterPortalsType>>;
};

export type HelpCenterPortalsConfigurationUpdateInput = {
  /** List of final featured portals. Max limit is 15 */
  featuredPortals: Array<Scalars['String']['input']>;
  /**  HelpCenterARI can be used to get the correct help center node  */
  helpCenterAri: Scalars['String']['input'];
  /** List of hidden portals. */
  hiddenPortals: Array<Scalars['String']['input']>;
  /** Sorting order of portals */
  sortOrder: HelpCenterPortalsSortOrder;
};

export enum HelpCenterPortalsSortOrder {
  NameAscending = 'NAME_ASCENDING',
  Popularity = 'POPULARITY'
}

export enum HelpCenterPortalsType {
  /** Featured Portals */
  Featured = 'FEATURED',
  /** Hidden Portals */
  Hidden = 'HIDDEN',
  /** Visible Portals */
  Visible = 'VISIBLE'
}

export enum HelpCenterProjectMappingOperationType {
  /**  Indicates the mapping of projects to Help Center  */
  MapProjects = 'MAP_PROJECTS',
  /**  Indicates the un-mapping of projects to a Help Center  */
  UnmapProjects = 'UNMAP_PROJECTS'
}

export type HelpCenterProjectMappingUpdateInput = {
  /**  HelpCenterARI can be used to get the correct help center node  */
  helpCenterAri: Scalars['String']['input'];
  /**  Operation to be performed on provided projectsIds  */
  operationType?: InputMaybe<HelpCenterProjectMappingOperationType>;
  /**  List of project Ids to be linked or un-linked based on the operationType  */
  projectIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  Automatically map newly created projects to this Help center  */
  syncNewProjects?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum HelpCenterProjectType {
  CustomerService = 'CUSTOMER_SERVICE',
  ServiceDesk = 'SERVICE_DESK'
}

export enum HelpCenterSortOrder {
  CreatedDateAscending = 'CREATED_DATE_ASCENDING',
  CreatedDateDescending = 'CREATED_DATE_DESCENDING'
}

export type HelpCenterTopicDeleteInput = {
  /**  HelpCenterARI can be used to retrieve helpCenterId  */
  helpCenterAri?: InputMaybe<Scalars['String']['input']>;
  /** The id of help center where the topic that needs to be deleted is part of */
  productName?: InputMaybe<Scalars['String']['input']>;
  /** The id of the topic which needs to be deleted */
  topicId: Scalars['ID']['input'];
};

export type HelpCenterTopicItemInput = {
  /** ARI of the help object which is included in this topic */
  ari: Scalars['ID']['input'];
};

export type HelpCenterTranslationInput = {
  locale: Scalars['String']['input'];
  localeDisplayName?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

export enum HelpCenterType {
  /**  indicates Advanced help center  */
  Advanced = 'ADVANCED',
  /**  indicates Basic help center  */
  Basic = 'BASIC',
  /**  indicates Customer Service help center  */
  CustomerService = 'CUSTOMER_SERVICE',
  /**  indicates Unified help center  */
  Unified = 'UNIFIED'
}

export type HelpCenterUpdateInput = {
  /**  HelpCenterARI can be used to get the correct helpCenter node  */
  helpCenterAri: Scalars['String']['input'];
  /**  Branding of the help center  */
  helpCenterBranding?: InputMaybe<HelpCenterBrandingInput>;
  /**  Name of the helpcenter */
  name?: InputMaybe<HelpCenterNameInput>;
  /**  Slug(identifier in the url) of the helpcenter. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** whether Virtual Agent is enabled for HelpCenter */
  virtualAgentEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type HelpCenterUpdateTopicInput = {
  /** Description of the topic */
  description?: InputMaybe<Scalars['String']['input']>;
  /**  HelpCenterARI can be used to retrieve helpCenterId  */
  helpCenterAri?: InputMaybe<Scalars['String']['input']>;
  /** The set of ARIs which this topic contains. */
  items: Array<HelpCenterTopicItemInput>;
  /** Name of the topic */
  name: Scalars['String']['input'];
  /** The id of help center where the topic that needs to be update is part of */
  productName?: InputMaybe<Scalars['String']['input']>;
  /** Additional properties of topics. Such as whether the topic is visible to the helpseekers on help center or not etc. */
  properties?: InputMaybe<Scalars['JSON']['input']>;
  /** The id of the already created topic */
  topicId: Scalars['ID']['input'];
};

export type HelpCenterUpdateTopicsOrderInput = {
  /**  HelpCenterARI can be used to retrieve helpCenterId  */
  helpCenterAri?: InputMaybe<Scalars['String']['input']>;
  /** The id of help center where the topic that needs to be reordered is part of */
  productName?: InputMaybe<Scalars['String']['input']>;
  /** The set of ids in the order you want them to be sorted */
  topicIds: Array<Scalars['ID']['input']>;
};

export type HelpExternalResourceCreateInput = {
  /**  The container ATI  */
  containerAti: Scalars['String']['input'];
  /**  The containerId  */
  containerId: Scalars['String']['input'];
  /**  The description  */
  description: Scalars['String']['input'];
  /**  The external resource link  */
  link: Scalars['String']['input'];
  /**  The resource type of the external resource  */
  resourceType: HelpExternalResourceLinkResourceType;
  /**  The external resource title  */
  title: Scalars['String']['input'];
};

export enum HelpExternalResourceLinkResourceType {
  Channel = 'CHANNEL',
  Knowledge = 'KNOWLEDGE',
  RequestForm = 'REQUEST_FORM'
}

export type HelpExternalResourceUpdateInput = {
  /**  The description  */
  description: Scalars['String']['input'];
  /**  The external resource id  */
  id: Scalars['ID']['input'];
  /**  The external resource link  */
  link: Scalars['String']['input'];
  /**  The external resource title  */
  title: Scalars['String']['input'];
};

export type HelpLayoutAlignmentSettingsInput = {
  horizontalAlignment?: InputMaybe<HelpLayoutHorizontalAlignment>;
  verticalAlignment?: InputMaybe<HelpLayoutVerticalAlignment>;
};

/** Portals List Input */
export type HelpLayoutAnnouncementInput = {
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/**
 * This input type will be used to mutate Atomic Elements inside Composite Elements.
 * This type is used only inside a Composite Element
 */
export type HelpLayoutAtomicElementInput = {
  announcementInput?: InputMaybe<HelpLayoutAnnouncementInput>;
  connectInput?: InputMaybe<HelpLayoutConnectInput>;
  editorInput?: InputMaybe<HelpLayoutEditorInput>;
  elementTypeKey: HelpLayoutAtomicElementKey;
  forgeInput?: InputMaybe<HelpLayoutForgeInput>;
  headingConfigInput?: InputMaybe<HelpLayoutHeadingConfigInput>;
  heroElementInput?: InputMaybe<HelpLayoutHeroElementInput>;
  imageConfigInput?: InputMaybe<HelpLayoutImageConfigInput>;
  noContentElementInput?: InputMaybe<HelpLayoutNoContentElementInput>;
  paragraphConfigInput?: InputMaybe<HelpLayoutParagraphConfigInput>;
  portalsListInput?: InputMaybe<HelpLayoutPortalsListInput>;
  searchConfigInput?: InputMaybe<HelpLayoutSearchConfigInput>;
  suggestedRequestFormsListInput?: InputMaybe<HelpLayoutSuggestedRequestFormsListInput>;
  topicListInput?: InputMaybe<HelpLayoutTopicsListInput>;
};

/** This enum represents all the atomic element keys. */
export enum HelpLayoutAtomicElementKey {
  Announcement = 'ANNOUNCEMENT',
  Connect = 'CONNECT',
  Editor = 'EDITOR',
  Forge = 'FORGE',
  Heading = 'HEADING',
  Hero = 'HERO',
  Image = 'IMAGE',
  NoContent = 'NO_CONTENT',
  Paragraph = 'PARAGRAPH',
  PortalsList = 'PORTALS_LIST',
  Search = 'SEARCH',
  SuggestedRequestFormsList = 'SUGGESTED_REQUEST_FORMS_LIST',
  TopicsList = 'TOPICS_LIST'
}

export type HelpLayoutBackgroundImageInput = {
  fileId?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** This enum represents all the composite element keys. */
export enum HelpLayoutCompositeElementKey {
  LinkCard = 'LINK_CARD'
}

/** Connect App Element */
export enum HelpLayoutConnectElementPages {
  Approvals = 'APPROVALS',
  CreateRequest = 'CREATE_REQUEST',
  HelpCenter = 'HELP_CENTER',
  MyRequest = 'MY_REQUEST',
  Portal = 'PORTAL',
  Profile = 'PROFILE',
  ViewRequest = 'VIEW_REQUEST'
}

export enum HelpLayoutConnectElementType {
  DetailsPanels = 'detailsPanels',
  FooterPanels = 'footerPanels',
  HeaderAndSubheaderPanels = 'headerAndSubheaderPanels',
  HeaderPanels = 'headerPanels',
  OptionPanels = 'optionPanels',
  ProfilePagePanel = 'profilePagePanel',
  PropertyPanels = 'propertyPanels',
  RequestCreatePanel = 'requestCreatePanel',
  SubheaderPanels = 'subheaderPanels'
}

/** Connect App Input */
export type HelpLayoutConnectInput = {
  pages: HelpLayoutConnectElementPages;
  type: HelpLayoutConnectElementType;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export type HelpLayoutCreationInput = {
  parentAri: Scalars['ID']['input'];
  sections: Array<HelpLayoutSectionInput>;
};

/** Editor Input */
export type HelpLayoutEditorInput = {
  adf: Scalars['String']['input'];
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** This enum represents all the element category. */
export enum HelpLayoutElementCategory {
  Basic = 'BASIC',
  Navigation = 'NAVIGATION'
}

/**
 * This input type can mutate both atomic and composite elements. Since there is no polymorphism in input types in graphql.
 * Client will have to send the Key to the element they are mutating and respective config.
 * Only one of the config fields will be specified. "elementTypeKey" should match the config provided.
 */
export type HelpLayoutElementInput = {
  announcementInput?: InputMaybe<HelpLayoutAnnouncementInput>;
  connectInput?: InputMaybe<HelpLayoutConnectInput>;
  editorInput?: InputMaybe<HelpLayoutEditorInput>;
  elementTypeKey: HelpLayoutElementKey;
  forgeInput?: InputMaybe<HelpLayoutForgeInput>;
  headingConfigInput?: InputMaybe<HelpLayoutHeadingConfigInput>;
  heroElementInput?: InputMaybe<HelpLayoutHeroElementInput>;
  imageConfigInput?: InputMaybe<HelpLayoutImageConfigInput>;
  linkCardInput?: InputMaybe<HelpLayoutLinkCardInput>;
  noContentElementInput?: InputMaybe<HelpLayoutNoContentElementInput>;
  paragraphConfigInput?: InputMaybe<HelpLayoutParagraphConfigInput>;
  portalsListInput?: InputMaybe<HelpLayoutPortalsListInput>;
  searchConfigInput?: InputMaybe<HelpLayoutSearchConfigInput>;
  suggestedRequestFormsListInput?: InputMaybe<HelpLayoutSuggestedRequestFormsListInput>;
  topicListInput?: InputMaybe<HelpLayoutTopicsListInput>;
};

/** Enum of all the supported element types, atomic and composite. */
export enum HelpLayoutElementKey {
  Announcement = 'ANNOUNCEMENT',
  Connect = 'CONNECT',
  Editor = 'EDITOR',
  Forge = 'FORGE',
  Heading = 'HEADING',
  Hero = 'HERO',
  Image = 'IMAGE',
  LinkCard = 'LINK_CARD',
  NoContent = 'NO_CONTENT',
  Paragraph = 'PARAGRAPH',
  PortalsList = 'PORTALS_LIST',
  Search = 'SEARCH',
  SuggestedRequestFormsList = 'SUGGESTED_REQUEST_FORMS_LIST',
  TopicsList = 'TOPICS_LIST'
}

export type HelpLayoutFilter = {
  isEditMode?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Forge App Element */
export enum HelpLayoutForgeElementPages {
  Approvals = 'approvals',
  CreateRequest = 'create_request',
  HelpCenter = 'help_center',
  MyRequests = 'my_requests',
  Portal = 'portal',
  Profile = 'profile',
  ViewRequest = 'view_request'
}

export enum HelpLayoutForgeElementType {
  Footer = 'FOOTER',
  HeaderAndSubheader = 'HEADER_AND_SUBHEADER'
}

/** Forge App Input */
export type HelpLayoutForgeInput = {
  pages: HelpLayoutForgeElementPages;
  type: HelpLayoutForgeElementType;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** Heading Input */
export type HelpLayoutHeadingConfigInput = {
  headingType: HelpLayoutHeadingType;
  text: Scalars['String']['input'];
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export enum HelpLayoutHeadingType {
  H1 = 'h1',
  H2 = 'h2',
  H3 = 'h3',
  H4 = 'h4',
  H5 = 'h5',
  H6 = 'h6'
}

/** Hero Element Input */
export type HelpLayoutHeroElementInput = {
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export enum HelpLayoutHorizontalAlignment {
  Center = 'CENTER',
  Left = 'LEFT',
  Right = 'RIGHT'
}

/** Image Input */
export type HelpLayoutImageConfigInput = {
  altText?: InputMaybe<Scalars['String']['input']>;
  fileId?: InputMaybe<Scalars['String']['input']>;
  fit?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['String']['input']>;
  scale?: InputMaybe<Scalars['Int']['input']>;
  size?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** Link card input */
export type HelpLayoutLinkCardInput = {
  children: Array<HelpLayoutAtomicElementInput>;
  config: Scalars['String']['input'];
  type: HelpLayoutCompositeElementKey;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** No Content Element Input */
export type HelpLayoutNoContentElementInput = {
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** Paragraph Input */
export type HelpLayoutParagraphConfigInput = {
  adf: Scalars['String']['input'];
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** Announcement Input */
export type HelpLayoutPortalsListInput = {
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export enum HelpLayoutProjectType {
  CustomerService = 'CUSTOMER_SERVICE',
  ServiceDesk = 'SERVICE_DESK'
}

/** Search Input */
export type HelpLayoutSearchConfigInput = {
  placeHolderText: Scalars['String']['input'];
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export type HelpLayoutSectionInput = {
  subsections: Array<HelpLayoutSubsectionInput>;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export type HelpLayoutSubsectionConfigInput = {
  span: Scalars['Int']['input'];
};

export type HelpLayoutSubsectionInput = {
  config: HelpLayoutSubsectionConfigInput;
  elements: Array<HelpLayoutElementInput>;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** Suggested Request Forms List Input */
export type HelpLayoutSuggestedRequestFormsListInput = {
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** Topics List Input */
export type HelpLayoutTopicsListInput = {
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export type HelpLayoutUpdateInput = {
  layoutId: Scalars['ID']['input'];
  sections: Array<HelpLayoutSectionInput>;
};

export enum HelpLayoutVerticalAlignment {
  Bottom = 'BOTTOM',
  Middle = 'MIDDLE',
  Top = 'TOP'
}

/** This represents the visual config input required during mutation */
export type HelpLayoutVisualConfigInput = {
  alignment?: InputMaybe<HelpLayoutAlignmentSettingsInput>;
  backgroundColor?: InputMaybe<Scalars['String']['input']>;
  backgroundImage?: InputMaybe<HelpLayoutBackgroundImageInput>;
  foregroundColor?: InputMaybe<Scalars['String']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  themeTemplateId?: InputMaybe<Scalars['String']['input']>;
};

export type HelpObjectStoreBulkCreateEntityMappingInput = {
  helpObjectStoreCreateEntityMappingInputItems: Array<HelpObjectStoreCreateEntityMappingInput>;
};

export type HelpObjectStoreCreateEntityMappingInput = {
  /**  Id of the container through which help object is associated. Could be projectId / Help Center Id etc.  */
  containerId?: InputMaybe<Scalars['String']['input']>;
  /**  Container Key which identifies the type of the container. ex- jira:project / external:forge  */
  containerKey?: InputMaybe<Scalars['String']['input']>;
  /**  Id of the Request Type / Article / Channel / External Link in jira  */
  entityId: Scalars['String']['input'];
  /**  Namespace of the entity in product. Like jira:request-form, notion:article, jira:external-resource  */
  entityKey?: InputMaybe<Scalars['String']['input']>;
  /**  Type of entity  */
  type: HelpObjectStoreJsmEntityType;
};

export enum HelpObjectStoreHelpObjectType {
  Article = 'ARTICLE',
  Channel = 'CHANNEL',
  Portal = 'PORTAL',
  RequestForm = 'REQUEST_FORM'
}

export enum HelpObjectStoreJsmEntityType {
  Article = 'ARTICLE',
  Channel = 'CHANNEL',
  Portal = 'PORTAL',
  RequestForm = 'REQUEST_FORM'
}

export enum HelpObjectStoreSearchAlgorithm {
  KeywordSearchOnIssues = 'KEYWORD_SEARCH_ON_ISSUES',
  KeywordSearchOnPortalsBm25 = 'KEYWORD_SEARCH_ON_PORTALS_BM25',
  KeywordSearchOnPortalsExactMatch = 'KEYWORD_SEARCH_ON_PORTALS_EXACT_MATCH',
  KeywordSearchOnRequestTypesBm25 = 'KEYWORD_SEARCH_ON_REQUEST_TYPES_BM25',
  KeywordSearchOnRequestTypesExactMatch = 'KEYWORD_SEARCH_ON_REQUEST_TYPES_EXACT_MATCH'
}

export enum HelpObjectStoreSearchBackend {
  Jira = 'JIRA',
  SearchPlatform = 'SEARCH_PLATFORM'
}

export enum HelpObjectStoreSearchEntityType {
  Article = 'ARTICLE',
  Channel = 'CHANNEL',
  Portal = 'PORTAL',
  RequestForm = 'REQUEST_FORM'
}

export type HelpObjectStoreSearchInput = {
  categoryIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  cloudId: Scalars['ID']['input'];
  entityType: HelpObjectStoreSearchEntityType;
  helpCenterAri?: InputMaybe<Scalars['String']['input']>;
  highlightArticles?: InputMaybe<Scalars['Boolean']['input']>;
  portalIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  queryTerm: Scalars['String']['input'];
  resultLimit?: InputMaybe<Scalars['Int']['input']>;
  skipSearchingRestrictedPages?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum HelpObjectStoreSearchableEntityType {
  Article = 'ARTICLE',
  RequestForm = 'REQUEST_FORM'
}

export enum InfluentsNotificationAppearance {
  Danger = 'DANGER',
  Default = 'DEFAULT',
  Link = 'LINK',
  Primary = 'PRIMARY',
  Subtle = 'SUBTLE',
  Warning = 'WARNING'
}

export enum InfluentsNotificationCategory {
  Direct = 'direct',
  Watching = 'watching'
}

export type InfluentsNotificationFilter = {
  categoryFilter?: InputMaybe<InfluentsNotificationCategory>;
  productFilter?: InputMaybe<Scalars['String']['input']>;
  readStateFilter?: InputMaybe<InfluentsNotificationReadState>;
  workspaceId?: InputMaybe<Scalars['String']['input']>;
};

export enum InfluentsNotificationReadState {
  Read = 'read',
  Unread = 'unread'
}

/** Input for the mutation operations (snooze and remove). */
export type InsightsActionNextBestTaskInput = {
  /** Next best task id */
  taskId: Scalars['String']['input'];
};

export enum InsightsApprovalStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  Unapproved = 'UNAPPROVED',
  Unknown = 'UNKNOWN'
}

/** A context of either sprint or project Ari */
export type InsightsContextAri = {
  /** A projectAri that sets the context for Kanban board */
  projectAri?: InputMaybe<Scalars['ID']['input']>;
  /** A sprintAri that sets the context for SCRUM board */
  sprintAri?: InputMaybe<Scalars['ID']['input']>;
};

export enum InsightsEnvironmentType {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

/** Input for the onboarding mutation operations (purge / snooze / remove). */
export type InsightsGithubOnboardingActionInput = {
  /** Cloud id */
  cloudId: Scalars['ID']['input'];
};

export enum InsightsNextBestTaskAction {
  Remove = 'REMOVE',
  Snooze = 'SNOOZE'
}

/**
 * Defines whether we show the github onboarding UX
 * VISIBLE means JFE should render the onboarding UX
 * HIDDEN means user is already onboarded, do not show UX
 * SNOOZED means user snoozed the recommendation
 * REMOVED means user explicitly hid the recommendation
 */
export enum InsightsRecommendationVisibility {
  Hidden = 'HIDDEN',
  Removed = 'REMOVED',
  Snoozed = 'SNOOZED',
  Visible = 'VISIBLE'
}

export enum InsightsTaskType {
  /** Surface to the current user the blocking issues assigned to them */
  BlockingIssue = 'BLOCKING_ISSUE',
  /** Surface to the current user that a Build in a certain pipeline has failed */
  BuildFailed = 'BUILD_FAILED',
  /** Surface to the current user that a issue linked critical vulnerability */
  CritVuln = 'CRIT_VULN',
  /** Surface to the current user that a Deployment in an environment has failed */
  DeploymentFailed = 'DEPLOYMENT_FAILED',
  /**
   * Surface to the current user that a Pull Request (which they are the author of) has been marked as "Needs Work" or
   * "Changes Requested"
   */
  PrNeedsWork = 'PR_NEEDS_WORK',
  /** Surface to the current user that a Pull Request (which they are a reviewer of) needs review */
  PrReview = 'PR_REVIEW'
}

export enum InsightsVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type InstallationsListFilterByAppEnvironments = {
  types: Array<AppEnvironmentType>;
};

export type InstallationsListFilterByAppInstallations = {
  /** An array of unique ARI's representing app installation contexts */
  contexts?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** An array of unique ARI's representing apps */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type InstallationsListFilterByAppInstallationsWithCompulsoryContexts = {
  /** An array of unique ARI's representing app installation contexts */
  contexts: Array<Scalars['ID']['input']>;
  /** An array of unique ARI's representing apps */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type InstallationsListFilterByApps = {
  /** An array of unique ARI's representing apps */
  ids: Array<Scalars['ID']['input']>;
};

export type IntervalFilter = {
  /**
   * Query end time as an ISO-8601 timestamp e.g. "2022-11-24T15:00:00.000Z"
   * See https://date-fns.org/v2.29.3/docs/parseISO
   */
  end: Scalars['String']['input'];
  /**
   * Query start time as an ISO-8601 timestamp e.g. "2022-11-24T15:00:00.000Z"
   * See https://date-fns.org/v2.29.3/docs/parseISO
   */
  start: Scalars['String']['input'];
};

export type IntervalInput = {
  endTime: Scalars['DateTime']['input'];
  startTime: Scalars['DateTime']['input'];
};

/** Input payload for the invoke aux mutation */
export type InvokeAuxEffectsInput = {
  /**
   * The list of applicable context Ids
   * Context Ids are used within the ecosystem platform to identify product
   * controlled areas into which apps can be installed. Host products should
   * determine how this list of contexts is constructed.
   *
   * *Important:* this should start with the most specific context as the
   * most specific extension will be the selected extension.
   */
  contextIds: Array<Scalars['ID']['input']>;
  /** An identifier for an alternative entry point function to invoke */
  entryPoint?: InputMaybe<Scalars['String']['input']>;
  /**
   * An identifier for the extension to invoke
   *
   * Note: Either `extensionDetails` or `extensionId` must be provided
   */
  extensionId?: InputMaybe<Scalars['ID']['input']>;
  /** The payload to invoke an AUX Effect */
  payload: AuxEffectsInvocationPayload;
};

/** Input payload for the invoke mutation */
export type InvokeExtensionInput = {
  /**
   * The list of applicable context Ids
   * Context Ids are used within the ecosystem platform to identify product
   * controlled areas into which apps can be installed. Host products should
   * determine how this list of contexts is constructed.
   *
   * *Important:* this should start with the most specific context as the
   * most specific extension will be the selected extension.
   */
  contextIds: Array<Scalars['ID']['input']>;
  /** An identifier for an alternative entry point function to invoke */
  entryPoint?: InputMaybe<Scalars['String']['input']>;
  /**
   * An identifier for the extension to invoke
   *
   * Note: Either `extensionDetails` or `extensionId` must be provided
   */
  extensionId?: InputMaybe<Scalars['ID']['input']>;
  /** The payload to send as part of the invocation */
  payload: Scalars['JSON']['input'];
  /** An identifier for a schema to validate the response against */
  schema?: InputMaybe<Scalars['String']['input']>;
};

export type InvokePolarisObjectInput = {
  /** Snippet action */
  action: Scalars['JSON']['input'];
  /** Custom auth token that will be used in unfurl request and saved if request was successful */
  authToken?: InputMaybe<Scalars['String']['input']>;
  /** Snippet data */
  data: Scalars['JSON']['input'];
  /** Issue ARI */
  issue: Scalars['ID']['input'];
  /** OauthClientId of CaaS app */
  oauthClientId: Scalars['String']['input'];
  /** Project ARI */
  project: Scalars['ID']['input'];
  /** Resource url that will be used to unfurl data */
  resourceUrl: Scalars['String']['input'];
};

export enum IssueDevOpsCommitChangeType {
  Added = 'ADDED',
  Copied = 'COPIED',
  Deleted = 'DELETED',
  Modified = 'MODIFIED',
  /** Deprecated - use MODIFIED instead. */
  Modify = 'MODIFY',
  Moved = 'MOVED',
  Unknown = 'UNKNOWN'
}

export enum IssueDevOpsDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum IssueDevOpsDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum IssueDevOpsPullRequestStatus {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum JsmIncidentLinkDirection {
  /** Going from the other issue to this incident. */
  Inward = 'INWARD',
  /** Going from this incident to the other issue. */
  Outward = 'OUTWARD'
}

export enum JsmMajorIncident {
  MajorIncident = 'MAJOR_INCIDENT'
}

/** Input type for ADF values on fields */
export type JiraAdfInput = {
  /** ADF based input for rich text field */
  jsonValue?: InputMaybe<Scalars['JSON']['input']>;
  /** A numeric id for the version */
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** The different action types that a user can perform on a global level */
export enum JiraActionType {
  /** Can current user create a Company Managed project */
  CreateCompanyManagedProject = 'CREATE_COMPANY_MANAGED_PROJECT',
  /** Can current user create any project */
  CreateProject = 'CREATE_PROJECT',
  /** Can current user create a Team Managed project */
  CreateTeamManagedProject = 'CREATE_TEAM_MANAGED_PROJECT'
}

export type JiraAddFieldsToProjectInput = {
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId: Scalars['ID']['input'];
  /** Unique identifiers of the fields to be added. */
  fieldIds: Array<Scalars['ID']['input']>;
  /** Unique identifier of the project. */
  projectId: Scalars['ID']['input'];
};

/** The input to associate issues with a fix version. */
export type JiraAddIssuesToFixVersionInput = {
  /** The IDs of the issues to be associated with the fix version. */
  issueIds: Array<Scalars['ID']['input']>;
  /** The ID of the version to be associated with the issues. */
  versionId: Scalars['ID']['input'];
};

export type JiraAddPostIncidentReviewLinkMutationInput = {
  /**
   * The ID of the incident the PIR link will be added to. Initially only Jira Service Management
   * incidents are supported, but eventually 3rd party / Data Depot incidents will follow.
   */
  incidentId: Scalars['ID']['input'];
  /**
   * The title of the post-incident review. May be null, in which case the frontend can use either
   * a generic title or a smart link for display purposes.
   */
  postIncidentReviewTitle?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the post-incident review (e.g. a Confluence page or Google Doc URL). */
  postIncidentReviewUrl: Scalars['URL']['input'];
  /**
   * Project whose permissions the PIR link will be tied to. Users with access to this project
   * will be able to view/edit/remove this PIR link.
   */
  projectId: Scalars['ID']['input'];
};

/** Input to create a new related work item and associated with a version. */
export type JiraAddRelatedWorkToVersionInput = {
  /** Category for the related work item. */
  category: Scalars['String']['input'];
  /** Client-generated ID for the related work item. */
  relatedWorkId: Scalars['ID']['input'];
  /** Related work title; can be null if a `url` was given. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Related work URL. Pass null to create a placeholder work item (a non-null `title` must be given in this case). */
  url?: InputMaybe<Scalars['URL']['input']>;
  /** The identifier of the Jira version. */
  versionId: Scalars['ID']['input'];
};

/** Operations that can be performed on fields like attachments and issuelinks etc. */
export enum JiraAddValueFieldOperations {
  /** Overrides single value field. */
  Add = 'ADD'
}

export type JiraAdjustmentEstimate = {
  adjustEstimateType: JiraWorklogAdjustmentEstimateOperation;
  /** this field will be ignored for auto and leave adjustEstimate. */
  adjustTimeInMinutes?: InputMaybe<Scalars['Long']['input']>;
};

/** Input type for affected services field */
export type JiraAffectedServicesFieldInput = {
  /** List of affected services */
  affectedServices: Array<JiraAffectedServicesInput>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

/** Input type for defining the operation on Affected Services(Service Entity) field of a Jira issue. */
export type JiraAffectedServicesFieldOperationInput = {
  /** Accept ARI(s): service */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The operations to perform on Affected Services field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
};

/** Input type representing a single affected service */
export type JiraAffectedServicesInput = {
  /** An identifier for the affected service */
  serviceId: Scalars['ID']['input'];
};

/** An input representing an issue */
export type JiraAiEnablementIssueInput = {
  /** The ID of the issue */
  issueId?: InputMaybe<Scalars['ID']['input']>;
  /** The key of the issue */
  issueKey?: InputMaybe<Scalars['String']['input']>;
};

/** Visibility settings for an announcement banner. */
export enum JiraAnnouncementBannerVisibility {
  /** The announcement banner is shown to logged in users only. */
  Private = 'PRIVATE',
  /** The announcement banner is shown to anyone on the internet. */
  Public = 'PUBLIC'
}

/** The approval decision input */
export type JiraAnswerApprovalDecisionInput = {
  approvalId: Scalars['Int']['input'];
  decision: JiraApprovalDecision;
};

/** List of values identifying the different app types */
export enum JiraAppType {
  Connect = 'CONNECT',
  Forge = 'FORGE'
}

/** Representation of each Jira application/sub-product. */
export enum JiraApplicationKey {
  /** Jira Work Management application key */
  JiraCore = 'JIRA_CORE',
  /** Jira Product Discovery application key */
  JiraProductDiscovery = 'JIRA_PRODUCT_DISCOVERY',
  /** Jira Service Management application key */
  JiraServiceDesk = 'JIRA_SERVICE_DESK',
  /** Jira Software application key */
  JiraSoftware = 'JIRA_SOFTWARE'
}

export enum JiraApprovalDecision {
  Approved = 'APPROVED',
  Rejected = 'REJECTED'
}

/** The input type to approve access request of connected workspace(organization in Jira term) */
export type JiraApproveJiraBitbucketWorkspaceAccessRequestInput = {
  /** The approval location for the analytics and Jira's organization approval event. If not given, it will default to UNKNOWN */
  approvalLocation?: InputMaybe<JiraOrganizationApprovalLocation>;
  /** The workspace id(organization in Jira term) to approve the access request */
  workspaceId: Scalars['ID']['input'];
};

/** Input type to filter archived issues */
export type JiraArchivedIssuesFilterInput = {
  /** Filter By archival date range. */
  byArchivalDateRange?: InputMaybe<JiraArchivedOnDateRange>;
  /** Filter by the user who archived the issue. */
  byArchivedBy?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filter by the assignee of the issue. */
  byAssignee?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filter by the create date of the issue. */
  byCreatedOn?: InputMaybe<Scalars['Date']['input']>;
  /** Filter by the issue type. */
  byIssueType?: InputMaybe<Array<JiraIssueTypeInput>>;
  /** Filter by the name of the project. */
  byProject?: InputMaybe<Scalars['String']['input']>;
  /** Filter by the reporter of the issue. */
  byReporter?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Input type for archival date range */
export type JiraArchivedOnDateRange = {
  /** The date from which archived issues are to be fetched. */
  from?: InputMaybe<Scalars['Date']['input']>;
  /** The date till which archived issues are to be fetched. */
  to?: InputMaybe<Scalars['Date']['input']>;
};

/** Input type for asset field */
export type JiraAssetFieldInput = {
  /** List of jira assets on which the operation will be performed */
  assets: Array<JiraAssetInput>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

/** Input type for asset value */
export type JiraAssetInput = {
  /** String representing application key */
  appKey: Scalars['String']['input'];
  /** An identifier for the origin */
  originId: Scalars['String']['input'];
  /** Serialized value of origin */
  serializedOrigin: Scalars['String']['input'];
  /** Value of the asset field */
  value: Scalars['String']['input'];
};

/**
 * DEPRECATED: Superseded by issue linking
 *
 * Input to assign/unassign a related work item to a user.
 */
export type JiraAssignRelatedWorkInput = {
  /**
   * The account ID of the user the related work item is being assigned to. Pass `null` to unassign the
   * item from its current assignee.
   */
  assigneeId?: InputMaybe<Scalars['ID']['input']>;
  /** The related work item's ID (not applicable for the NATIVE_RELEASE_NOTES type - pass `null` in that case). */
  relatedWorkId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The type of related work item being assigned. If the type is not NATIVE_RELEASE_NOTES, the work
   * item's ID must also be passed in via `relatedWorkId`.
   */
  relatedWorkType: JiraVersionRelatedWorkType;
  /** The ARI of the version the related work lives in. */
  versionId: Scalars['ID']['input'];
};

/** Features that Atlassian Intelligence can be enabled for. */
export enum JiraAtlassianIntelligenceFeatureEnum {
  AiMate = 'AI_MATE',
  NaturalLanguageToJql = 'NATURAL_LANGUAGE_TO_JQL'
}

/** Input used to specify which product or feature to check for Atlassian Intelligence. */
export type JiraAtlassianIntelligenceProductFeatureInput = {
  /** The feature for Atlassian Intelligence. */
  feature?: InputMaybe<JiraAtlassianIntelligenceFeatureEnum>;
  /** The product for Atlassian Intelligence. */
  product?: InputMaybe<JiraProductEnum>;
};

/** Input type for Atlassian team field */
export type JiraAtlassianTeamFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Represents an Atlassian team field's data */
  team: JiraAtlassianTeamInput;
};

/** Input type for Atlassian team data */
export type JiraAtlassianTeamInput = {
  /** An identifier for the team */
  teamId: Scalars['String']['input'];
};

/** Input type for defining the operation on the Attachment field of a Jira issue. */
export type JiraAttachmentFieldOperationInput = {
  /** Only ADD operation is supported for attachments field in purview of Issue Transition Modernisation flow. */
  operation: JiraAddValueFieldOperations;
  /** Accepts : Temporary Attachment UUIDs */
  temporaryAttachmentIds: Array<Scalars['String']['input']>;
};

export type JiraAttachmentFilterInput = {
  /** Filters attachments based on the author's AAID. */
  authorIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Defines the date range for the attachment's upload date to be included in the response. */
  dateRange?: InputMaybe<JiraDateTimeRange>;
  /** Filters attachments based on matching filename (case-insensitive). */
  fileName?: InputMaybe<Scalars['String']['input']>;
  /**
   * List of mime types to be used as filters. Attachments matching these types will be included in the response.
   * eg. ["JPEG", "PNG", "GIF"]
   */
  mimeTypes?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Represents a fixed set of attachments' parents */
export enum JiraAttachmentParentName {
  Comment = 'COMMENT',
  Customfield = 'CUSTOMFIELD',
  Description = 'DESCRIPTION',
  Environment = 'ENVIRONMENT',
  Form = 'FORM',
  Issue = 'ISSUE',
  Worklog = 'WORKLOG'
}

export type JiraAttachmentSearchViewContextInput = {
  /** A list of user AAIDs to limit searched attachments. */
  authorIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only returns attachments created after this date (exclusive) */
  createdAfter?: InputMaybe<Scalars['DateTime']['input']>;
  /** Only returns attachments created before this date (exclusive) */
  createdBefore?: InputMaybe<Scalars['DateTime']['input']>;
  /** Filters attachments by file name (case-insensitive) */
  fileName?: InputMaybe<Scalars['String']['input']>;
  /**
   * A list of mime types to filter attachments
   * e.g. text/plain, image/jpeg
   */
  mimeTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Project keys to search for attachments in */
  projectKeys: Array<Scalars['String']['input']>;
};

/** The field for sorting attachments. */
export enum JiraAttachmentSortField {
  /** sorts by the created date */
  Created = 'CREATED'
}

export type JiraAttachmentSortInput = {
  /** The field to sort on. */
  field: JiraAttachmentSortField;
  /** The sort direction. */
  order?: SortDirection;
};

export type JiraAttachmentsOrderField = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export enum JiraAttachmentsPermissions {
  /** Allows the user to create atachments on the correspondig Issue. */
  CreateAttachments = 'CREATE_ATTACHMENTS',
  /** Allows the user to delete attachments on the corresponding Issue. */
  DeleteOwnAttachments = 'DELETE_OWN_ATTACHMENTS'
}

/** Renamed to JiraAutodevCodeChangeEnumType to be compatible with jira/gira prefix validation */
export enum JiraAutodevCodeChangeEnumType {
  Add = 'ADD',
  Delete = 'DELETE',
  Edit = 'EDIT',
  Other = 'OTHER'
}

/** Autodev job state */
export enum JiraAutodevPhase {
  /** transitions to CODE_REVIEW upon success */
  CodeGenerating = 'CODE_GENERATING',
  /** When code is generated successfully --> CODE_RE_GENERATING */
  CodeReview = 'CODE_REVIEW',
  /** When user press regenerate code button --> CODE_REVIEW */
  CodeReGenerating = 'CODE_RE_GENERATING',
  /** When job is created --> PLAN_REVIEW */
  PlanGenerating = 'PLAN_GENERATING',
  /** When plan is generated successfully --> PLAN_RE_GENERATING || CODE_GENERATING */
  PlanReview = 'PLAN_REVIEW',
  /** When user press button to regenerate plan --> PLAN_REVIEW */
  PlanReGenerating = 'PLAN_RE_GENERATING'
}

/** Autodev job state */
export enum JiraAutodevState {
  /** When an autodev job is cancelled by the user. */
  Cancelled = 'CANCELLED',
  /** This state is entered when the code is being generated */
  CodeGenerating = 'CODE_GENERATING',
  /** This state is entered when the code generation fails */
  CodeGenerationFail = 'CODE_GENERATION_FAIL',
  /** This state is entered when user confirm to say that â€œplan looks okay, now generate codeâ€. */
  CodeGenerationReady = 'CODE_GENERATION_READY',
  /** This state is entered when the code generation is successful */
  CodeGenerationSuccess = 'CODE_GENERATION_SUCCESS',
  /** When an autodev job is first created, it will enter this state. */
  Created = 'CREATED',
  /** This state will be automatically enter when backend service started work on the job id. */
  PlanGenerating = 'PLAN_GENERATING',
  /** This state will be be entered when the plan generation fails */
  PlanGenerationFail = 'PLAN_GENERATION_FAIL',
  /** This state will be be entered when the plan generation succeeds */
  PlanGenerationSuccess = 'PLAN_GENERATION_SUCCESS',
  /** This state should be automatically enter when backend service pick up the CODE_GENERATION_SUCCESS state. */
  PullrequestCreating = 'PULLREQUEST_CREATING',
  /** This state should be entered when pull request fails to be created */
  PullrequestCreationFail = 'PULLREQUEST_CREATION_FAIL',
  /** This state should be entered when pull request creation has succeeded */
  PullrequestCreationSuccess = 'PULLREQUEST_CREATION_SUCCESS',
  /** Fallback state for any unexpected error */
  Unknown = 'UNKNOWN'
}

/** Autodev job status */
export enum JiraAutodevStatus {
  /** The autodev job was cancelled */
  Cancelled = 'CANCELLED',
  /** The autodev job completed successfully */
  Completed = 'COMPLETED',
  /** The autodev job stopped running because of an error */
  Failed = 'FAILED',
  /** The autodev job is currently running */
  InProgress = 'IN_PROGRESS',
  /** The autodev job hasn't started yet */
  Pending = 'PENDING'
}

/** The input type to create an autofix job */
export type JiraAutofixInput = {
  /** The issue ari */
  issueAri: Scalars['ID']['input'];
  /** The type of job to create */
  jobType: JiraAutofixJobType;
};

/** Type of autofix job */
export enum JiraAutofixJobType {
  /** Autofix job to remove feature flags */
  InternalRemoveFeatureFlag = 'INTERNAL_REMOVE_FEATURE_FLAG'
}

/** Autofix job status */
export enum JiraAutofixStatus {
  /** Job successfully completed */
  Completed = 'COMPLETED',
  /** Job failed */
  Failed = 'FAILED',
  /** Job in progress */
  InProgress = 'IN_PROGRESS',
  /** Job not started */
  Pending = 'PENDING'
}

/** The supported background types */
export enum JiraBackgroundType {
  Attachment = 'ATTACHMENT',
  Color = 'COLOR',
  Custom = 'CUSTOM',
  Gradient = 'GRADIENT',
  Unsplash = 'UNSPLASH'
}

export enum JiraBatchWindowPreference {
  DefaultBatching = 'DEFAULT_BATCHING',
  FifteenMinutes = 'FIFTEEN_MINUTES',
  FiveMinutes = 'FIVE_MINUTES',
  NoBatching = 'NO_BATCHING',
  OncePerDay = 'ONCE_PER_DAY',
  OneDay = 'ONE_DAY',
  OneHour = 'ONE_HOUR',
  TenMinutes = 'TEN_MINUTES',
  ThirtyMinutes = 'THIRTY_MINUTES'
}

export enum JiraBitbucketWorkspaceApprovalState {
  Approved = 'APPROVED',
  PendingApproval = 'PENDING_APPROVAL'
}

export type JiraBoardLocation = {
  /** Id of the project on which the board located in. Applicable for PROJECT location type only. Null otherwise. */
  locationId?: InputMaybe<Scalars['String']['input']>;
  /** Location type of the board */
  locationType: JiraBoardLocationType;
};

/** Types of containers that boards can be located in */
export enum JiraBoardLocationType {
  /** Boards located in a project */
  Project = 'PROJECT',
  /** Boards located under a user */
  User = 'USER'
}

/** Types of Jira boards */
export enum JiraBoardType {
  /** The board type without sprints */
  Kanban = 'KANBAN',
  /** The board type with sprints */
  Scrum = 'SCRUM'
}

/** The input type for scheduling the execution of project cleanup recommendations */
export type JiraBulkCleanupProjectsInput = {
  /** Recommendation action for the stale project. */
  projectCleanupAction?: InputMaybe<JiraProjectCleanupRecommendationAction>;
  /** List of recommendation identifiers to be archived */
  recommendationIds?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type JiraBulkCreateIssueLinksInput = {
  /** The ID of the type of issue link being created. */
  issueLinkTypeId: Scalars['ID']['input'];
  /** The ID of the source issue. */
  sourceIssueId: Scalars['ID']['input'];
  /** The IDs of the target issues. */
  targetIssueIds: Array<Scalars['ID']['input']>;
};

/** Specifies inputs for search on fields and a boolean to override them */
export type JiraBulkEditFieldsSearch = {
  /** Specifies the search text for fields */
  searchByText?: InputMaybe<Scalars['String']['input']>;
};

/** Specified bulk edit operation input */
export type JiraBulkEditInput = {
  /** Info of the fields edited by user. It will contain the values of edited field */
  editedFieldsInput: JiraIssueFieldsInput;
  /** Refers to the fields selected by user to bulk edit */
  selectedActions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Refers to issue IDs selected by user for bulk edit */
  selectedIssueIds: Array<Scalars['ID']['input']>;
};

/**
 * Contains all options available for fields with multi select options available
 * This field is required only for 4 system field: Fix Versions, Affects Versions, Label and Component
 */
export enum JiraBulkEditMultiSelectFieldOptions {
  /** Represents the Bulk Edit multi select field option for which the field values provided in Bulk Edit will be added to the already set field values */
  Add = 'ADD',
  /** Represents the Bulk Edit multi select field option for which the field values provided in Bulk Edit will be removed from the already set field values (if they exist) */
  Remove = 'REMOVE',
  /** Represents Bulk Edit multi select field option for which the already set field values will be all removed */
  RemoveAll = 'REMOVE_ALL',
  /** Represents the Bulk Edit multi select field option for which the field values provided in Bulk Edit will replace the already set field values */
  Replace = 'REPLACE'
}

/** Specified bulk operation input */
export type JiraBulkOperationInput = {
  /** Specifies bulk edit input. Payload which comes as an input for bulk edit */
  bulkEditInput?: InputMaybe<JiraBulkEditInput>;
  /** Specifies bulk transitions payload. Payload which comes as an input for bulk transition */
  bulkTransitionsInput?: InputMaybe<Array<JiraBulkTransitionsInput>>;
  /** Refers to whether to send bulk change notification or not */
  sendBulkNotification?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Specified the type of bulk operation */
export enum JiraBulkOperationType {
  /** Specified bulk edit operation type */
  BulkEdit = 'BULK_EDIT',
  /** Specified bulk transition operation type */
  BulkTransition = 'BULK_TRANSITION'
}

/** Input type for bulk transition */
export type JiraBulkTransitionsInput = {
  /** Refers to issue IDs selected by user for bulk transition */
  selectedIssueIds: Array<Scalars['ID']['input']>;
  /** Refers to a unique transition */
  transitionId: Scalars['String']['input'];
  /** Refers to any fields which need to be edited due to the transition */
  transitionScreenInput?: InputMaybe<JiraTransitionScreenInput>;
};

export type JiraCalendarCrossProjectVersionsInput = {
  /**
   * The active window to filter the Versions to.
   * The window bounds are equivalent to filtering Versions where (startDate > start AND startDate < end)
   * OR (releasedate > start AND releasedate < end)
   * If no start or end is provided, the window is considered unbounded in that direction.
   */
  activeWithin?: InputMaybe<JiraDateTimeWindow>;
  /** Versions that have name match this search string will be returned. */
  searchString?: InputMaybe<Scalars['String']['input']>;
  /** The status of the Versions to filter to. */
  statuses?: InputMaybe<Array<InputMaybe<JiraVersionStatus>>>;
};

export type JiraCalendarIssuesInput = {
  /** Additional JQL to adjust the search for */
  additionalFilterQuery?: InputMaybe<Scalars['String']['input']>;
};

export enum JiraCalendarMode {
  Day = 'DAY',
  Month = 'MONTH',
  Week = 'WEEK'
}

export enum JiraCalendarPermissionKey {
  ManageSprintsPermission = 'MANAGE_SPRINTS_PERMISSION'
}

export type JiraCalendarSprintsInput = {
  /** Additional filtering on sprint states within the calendar date range. */
  sprintStates?: InputMaybe<Array<JiraSprintState>>;
};

export type JiraCalendarVersionsInput = {
  /**
   * Queries for additional software release versions from projects identified by the ARIs below.
   * This is used for subsequent software release version loading after a project is connected or disconnected on the calendar.
   * Note that this parameter cannot be used in conjunction with includeSharedReleases.
   */
  additionalProjectAris?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * Queries for additional software release versions based on project relationships from AGS.
   * Note that this parameter cannot be used in conjunction with additionalProjectAris.
   */
  includeSharedReleases?: InputMaybe<Scalars['Boolean']['input']>;
  /** Additional filtering on version statuses within the calendar date range. */
  versionStatuses?: InputMaybe<Array<JiraVersionStatus>>;
};

/**  View settings for Jira Calendar */
export type JiraCalendarViewConfigurationInput = {
  /** The date in which the fetched calendar view will be based. Default is the current date. */
  date?: InputMaybe<Scalars['DateTime']['input']>;
  /** The alias of the custom field that will be used as the end date of the query */
  endDateField?: InputMaybe<Scalars['String']['input']>;
  /** The view mode of the calendar, used to determine date ranges to search for issues, sprints, versions, etc. Default is MONTH. */
  mode?: InputMaybe<JiraCalendarMode>;
  /** The alias of the custom field that will be used as the start date of the query */
  startDateField?: InputMaybe<Scalars['String']['input']>;
  /**
   * The id to derive view configuration from this is most likely the location of the calendar.
   * When a plan ARI is passed in this determines which startDate & endDate fields are used by the calendar.
   */
  viewId?: InputMaybe<Scalars['ID']['input']>;
  /** The week start day of the calendar, used to determine the first day of the week in the calendar. Default is SUNDAY. */
  weekStart?: InputMaybe<JiraCalendarWeekStart>;
};

export enum JiraCalendarWeekStart {
  Monday = 'MONDAY',
  Saturday = 'SATURDAY',
  Sunday = 'SUNDAY'
}

/**
 * #########################
 *  Mutation Inputs
 * #########################
 */
export type JiraCannedResponseCreateInput = {
  content: Scalars['String']['input'];
  isSignature?: InputMaybe<Scalars['Boolean']['input']>;
  projectAri: Scalars['ID']['input'];
  scope: JiraCannedResponseScope;
  title: Scalars['String']['input'];
};

/**
 * #########################
 *  Query Inputs
 * #########################
 */
export type JiraCannedResponseFilter = {
  /** The project under which canned response should be searched */
  projectAri: Scalars['ID']['input'];
  /** Query text to search for in title/name */
  query?: InputMaybe<Scalars['String']['input']>;
  /** The scopes that should be used to filter canned responses */
  scopes?: InputMaybe<Array<JiraCannedResponseScope>>;
  /** Whether to search only signature canned response */
  signature?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum JiraCannedResponseScope {
  Personal = 'PERSONAL',
  Project = 'PROJECT'
}

export type JiraCannedResponseSort = {
  name?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<JiraCannedResponseSortOrder>;
};

export enum JiraCannedResponseSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type JiraCannedResponseUpdateInput = {
  content: Scalars['String']['input'];
  /** ID represents a canned response ARI */
  id: Scalars['ID']['input'];
  isSignature?: InputMaybe<Scalars['Boolean']['input']>;
  scope: JiraCannedResponseScope;
  title: Scalars['String']['input'];
};

/** Input type representing cascading field inputs */
export type JiraCascadingSelectFieldInput = {
  /** Value of the child option selected for a cascading select field */
  childOptionValue?: InputMaybe<JiraSelectedOptionInput>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Value of the parent option selected for a cascading select field */
  parentOptionValue: JiraSelectedOptionInput;
};

export type JiraCascadingSelectFieldOperationInput = {
  /** Accept ARI(s): issue-field-option */
  childOption?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
  /** Accept ARI(s): issue-field-option */
  parentOption?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * Cascading options can either be a parent or a child - this enum captures this characteristic.
 *
 * E.g. If there is a parent cascading option named `P1`, it may or may not have
 * child cascading options named `C1` and `C2`.
 * - `P1` would be a `PARENT` enum
 * - `C1` and `C2` would be `CHILD` enums
 */
export enum JiraCascadingSelectOptionType {
  /** All options, regardless of whether they're a parent or child. */
  All = 'ALL',
  /** Child option only */
  Child = 'CHILD',
  /** Parent option only */
  Parent = 'PARENT'
}

/** An input filter used to specify the cascading options returned. */
export type JiraCascadingSelectOptionsFilter = {
  /** The type of cascading option to be returned. */
  optionType: JiraCascadingSelectOptionType;
  /** Used for retrieving CHILD cascading options by specifying the PARENT cascading option's id. */
  parentOptionId?: InputMaybe<Scalars['ID']['input']>;
  /** Used for retrieving CHILD cascading options by specifying the PARENT cascading option's name. */
  parentOptionName?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for defining the operation on the Checkboxes field of a Jira issue. */
export type JiraCheckboxesFieldOperationInput = {
  /**  Accepts ARI(s): issue-field-option  */
  ids: Array<Scalars['ID']['input']>;
  /**
   * The operation to perform on the Checkboxes field.
   * SET, ADD, REMOVE operations are supported.
   */
  operation: JiraMultiValueFieldOperations;
};

export type JiraClassificationLevelFilterInput = {
  /** Filter the available classification levels by JiraClassificationLevelStatus. */
  filterByStatus: Array<JiraClassificationLevelStatus>;
  /** Filter the available classification levels by JiraClassificationLevelType. */
  filterByType: Array<JiraClassificationLevelType>;
};

/** Enum to define the classification level source. */
export enum JiraClassificationLevelSource {
  Issue = 'ISSUE',
  Project = 'PROJECT'
}

/** Enum to define the classification level status. */
export enum JiraClassificationLevelStatus {
  Archived = 'ARCHIVED',
  Draft = 'DRAFT',
  Published = 'PUBLISHED'
}

/** Enum to define the classification level type. */
export enum JiraClassificationLevelType {
  System = 'SYSTEM',
  User = 'USER'
}

/** Input type for a clearable number field */
export type JiraClearableNumberFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  value?: InputMaybe<Scalars['Float']['input']>;
};

/** The category of the CMDB attribute that can be created. */
export enum JiraCmdbAttributeType {
  /** Bitbucket repository attribute. */
  BitbucketRepo = 'BITBUCKET_REPO',
  /** Confluence attribute. */
  Confluence = 'CONFLUENCE',
  /** Default attributes, e.g. text, boolean, integer, date. */
  Default = 'DEFAULT',
  /** Group attribute. */
  Group = 'GROUP',
  /** Opsgenie team attribute. */
  OpsgenieTeam = 'OPSGENIE_TEAM',
  /** Project attribute. */
  Project = 'PROJECT',
  /** Reference object attribute. */
  ReferencedObject = 'REFERENCED_OBJECT',
  /** Status attribute. */
  Status = 'STATUS',
  /** User attribute. */
  User = 'USER',
  /** Version attribute. */
  Version = 'VERSION'
}

/** Input type for a color field */
export type JiraColorFieldInput = {
  /** Represents a single color */
  color: JiraColorInput;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

export type JiraColorFieldOperationInput = {
  color: Scalars['String']['input'];
  operation: JiraSingleValueFieldOperations;
};

/** Input type representing a single colour */
export type JiraColorInput = {
  /** Name/Value of the color */
  name: Scalars['String']['input'];
};

/** The options for the Jira color scheme theme preference. */
export enum JiraColorSchemeThemeSetting {
  /** Theme matches the user browser settings */
  Automatic = 'AUTOMATIC',
  /** Dark mode theme */
  Dark = 'DARK',
  /** Light mode theme */
  Light = 'LIGHT'
}

/** The field for sorting comments. */
export enum JiraCommentSortField {
  /** sorts by the created date */
  Created = 'CREATED'
}

export type JiraCommentSortInput = {
  /** The field to sort on. */
  field: JiraCommentSortField;
  /** The sort direction. */
  order: SortDirection;
};

export type JiraComponentFieldOperationInput = {
  /** Accept ARI(s): component */
  ids: Array<Scalars['ID']['input']>;
  operation: JiraMultiValueFieldOperations;
};

/** Input type for component field */
export type JiraComponentInput = {
  /** An identifier representing a component */
  componentId: Scalars['ID']['input'];
};

/**  Represent the types of fields that can be configured for an Issue type in a Jira */
export enum JiraConfigFieldType {
  /**  Allows multiple values to be selected using two select lists */
  CustomCascadingSelect = 'CUSTOM_CASCADING_SELECT',
  /**  Stores a date with a time component */
  CustomDatetime = 'CUSTOM_DATETIME',
  /**  Stores a date using a picker control */
  CustomDatePicker = 'CUSTOM_DATE_PICKER',
  /**  Stores and validates a numeric (floating point) input */
  CustomFloat = 'CUSTOM_FLOAT',
  /**  Stores a user group using a picker control */
  CustomGroupPicker = 'CUSTOM_GROUP_PICKER',
  /**  A read-only field that stores the previous ID of the issue from the system that it was imported from */
  CustomImportId = 'CUSTOM_IMPORT_ID',
  /**  Stores labels */
  CustomLabels = 'CUSTOM_LABELS',
  /**  Stores multiple values using checkboxes */
  CustomMultiCheckboxes = 'CUSTOM_MULTI_CHECKBOXES',
  /**  Stores multiple user groups using a picker control */
  CustomMultiGroupPicker = 'CUSTOM_MULTI_GROUP_PICKER',
  /**  Stores multiple values using a select list */
  CustomMultiSelect = 'CUSTOM_MULTI_SELECT',
  /**  Stores multiple users using a picker control */
  CustomMultiUserPicker = 'CUSTOM_MULTI_USER_PICKER',
  /**  Stores multiple versions from the versions available in a project using a picker control */
  CustomMultiVersion = 'CUSTOM_MULTI_VERSION',
  /**  Stores a project from a list of projects that the user is permitted to view */
  CustomProject = 'CUSTOM_PROJECT',
  /**  Stores a value using radio buttons */
  CustomRadioButtons = 'CUSTOM_RADIO_BUTTONS',
  /**  Stores a read-only text value, which can only be populated via the API */
  CustomReadonlyField = 'CUSTOM_READONLY_FIELD',
  /**  Stores a value from a configurable list of options */
  CustomSelect = 'CUSTOM_SELECT',
  /**  Stores a long text string using a multiline text area */
  CustomTextarea = 'CUSTOM_TEXTAREA',
  /**  Stores a text string using a single-line text box */
  CustomTextField = 'CUSTOM_TEXT_FIELD',
  /**  Stores a URL */
  CustomUrl = 'CUSTOM_URL',
  /**  Stores a user using a picker control */
  CustomUserPicker = 'CUSTOM_USER_PICKER',
  /**  Stores a version using a picker control */
  CustomVersion = 'CUSTOM_VERSION',
  /**  Servicedesk approvals field */
  ServicedeskApprovals = 'SERVICEDESK_APPROVALS',
  /**  Servicedesk cmdb field */
  ServicedeskCmdbField = 'SERVICEDESK_CMDB_FIELD',
  /**  Servicedesk customer organizations field */
  ServicedeskCustomerOrganizations = 'SERVICEDESK_CUSTOMER_ORGANIZATIONS',
  /**  Servicedesk request feedback field */
  ServicedeskRequestFeedback = 'SERVICEDESK_REQUEST_FEEDBACK',
  /**  Servicedesk feedback date field */
  ServicedeskRequestFeedbackDate = 'SERVICEDESK_REQUEST_FEEDBACK_DATE',
  /**  Servicedesk request language field */
  ServicedeskRequestLanguage = 'SERVICEDESK_REQUEST_LANGUAGE',
  /**  Servicedesk request participants field */
  ServicedeskRequestParticipants = 'SERVICEDESK_REQUEST_PARTICIPANTS',
  /**  Servicedesk sla field */
  ServicedeskSlaField = 'SERVICEDESK_SLA_FIELD',
  /**  Servicedesk vp origin field */
  ServicedeskVpOrigin = 'SERVICEDESK_VP_ORIGIN',
  /**  Software epic color field */
  SoftwareEpicColor = 'SOFTWARE_EPIC_COLOR',
  /**  Software epic issue color field */
  SoftwareEpicIssueColor = 'SOFTWARE_EPIC_ISSUE_COLOR',
  /**  Software epic label field */
  SoftwareEpicLabel = 'SOFTWARE_EPIC_LABEL',
  /**  Software epic lexo rank field */
  SoftwareEpicLexoRank = 'SOFTWARE_EPIC_LEXO_RANK',
  /**  Software epic link field */
  SoftwareEpicLink = 'SOFTWARE_EPIC_LINK',
  /**  Software epic sprint field */
  SoftwareEpicSprint = 'SOFTWARE_EPIC_SPRINT',
  /**  Software epic status field */
  SoftwareEpicStatus = 'SOFTWARE_EPIC_STATUS',
  /**  Standard affected versions issue field */
  StandardAffectedVersions = 'STANDARD_AFFECTED_VERSIONS',
  /**  Standard aggregate progress issue field */
  StandardAggregateProgress = 'STANDARD_AGGREGATE_PROGRESS',
  /**  Standard aggregate time estimate issue field */
  StandardAggregateTimeEstimate = 'STANDARD_AGGREGATE_TIME_ESTIMATE',
  /**  Standard aggregate time original estimate issue field */
  StandardAggregateTimeOriginalEstimate = 'STANDARD_AGGREGATE_TIME_ORIGINAL_ESTIMATE',
  /**  Standard aggregate time spent issue field */
  StandardAggregateTimeSpent = 'STANDARD_AGGREGATE_TIME_SPENT',
  /**  Standard assignee issue field */
  StandardAssignee = 'STANDARD_ASSIGNEE',
  /**  Standard attachment issue field */
  StandardAttachment = 'STANDARD_ATTACHMENT',
  /**  Standard comment issue field */
  StandardComment = 'STANDARD_COMMENT',
  /**  Standard components issue field */
  StandardComponents = 'STANDARD_COMPONENTS',
  /**  Standard created issue field */
  StandardCreated = 'STANDARD_CREATED',
  /**  Standard creator issue field */
  StandardCreator = 'STANDARD_CREATOR',
  /**  Standard description issue field */
  StandardDescription = 'STANDARD_DESCRIPTION',
  /**  Standard due date issue field */
  StandardDueDate = 'STANDARD_DUE_DATE',
  /**  Standard environment issue field */
  StandardEnvironment = 'STANDARD_ENVIRONMENT',
  /**  Standard fix for versions issue field */
  StandardFixForVersions = 'STANDARD_FIX_FOR_VERSIONS',
  /**  Standard form token issue field */
  StandardFormToken = 'STANDARD_FORM_TOKEN',
  /**  Standard issue key issue field */
  StandardIssueKey = 'STANDARD_ISSUE_KEY',
  /**  Standard issue links issue field */
  StandardIssueLinks = 'STANDARD_ISSUE_LINKS',
  /**  Standard issue number issue field */
  StandardIssueNumber = 'STANDARD_ISSUE_NUMBER',
  /**  Standard issue type issue field */
  StandardIssueType = 'STANDARD_ISSUE_TYPE',
  /**  Standard labels issue field */
  StandardLabels = 'STANDARD_LABELS',
  /**  Standard last viewed issue field */
  StandardLastViewed = 'STANDARD_LAST_VIEWED',
  /**  Standard parent issue field */
  StandardParent = 'STANDARD_PARENT',
  /**  Standard priority issue field */
  StandardPriority = 'STANDARD_PRIORITY',
  /**  Standard progress issue field */
  StandardProgress = 'STANDARD_PROGRESS',
  /**  Standard project issue field */
  StandardProject = 'STANDARD_PROJECT',
  /**  Standard project key issue field */
  StandardProjectKey = 'STANDARD_PROJECT_KEY',
  /**  Standard reporter issue field */
  StandardReporter = 'STANDARD_REPORTER',
  /**  Standard resolution issue field */
  StandardResolution = 'STANDARD_RESOLUTION',
  /**  Standard resolution date issue field */
  StandardResolutionDate = 'STANDARD_RESOLUTION_DATE',
  /**  Standard security issue field */
  StandardSecurity = 'STANDARD_SECURITY',
  /**  Standard status issue field */
  StandardStatus = 'STANDARD_STATUS',
  /**  Standard subtasks issue field */
  StandardSubtasks = 'STANDARD_SUBTASKS',
  /**  Standard summary issue field */
  StandardSummary = 'STANDARD_SUMMARY',
  /**  Standard thumbnail issue field */
  StandardThumbnail = 'STANDARD_THUMBNAIL',
  /**  Standard time tracking issue field */
  StandardTimetracking = 'STANDARD_TIMETRACKING',
  /**  Standard time estimate issue field */
  StandardTimeEstimate = 'STANDARD_TIME_ESTIMATE',
  /**  Standard original estimate issue field */
  StandardTimeOriginalEstimate = 'STANDARD_TIME_ORIGINAL_ESTIMATE',
  /**  Standard time spent issue field */
  StandardTimeSpent = 'STANDARD_TIME_SPENT',
  /**  Standard updated issue field */
  StandardUpdated = 'STANDARD_UPDATED',
  /**  Standard voters issue field */
  StandardVoters = 'STANDARD_VOTERS',
  /**  Standard votes issue field */
  StandardVotes = 'STANDARD_VOTES',
  /**  Standard watchers issue field */
  StandardWatchers = 'STANDARD_WATCHERS',
  /**  Standard watches issue field */
  StandardWatches = 'STANDARD_WATCHES',
  /**  Standard worklog issue field */
  StandardWorklog = 'STANDARD_WORKLOG',
  /**  Standard work ratio issue field */
  StandardWorkratio = 'STANDARD_WORKRATIO',
  /**  Used to represent a Field type that is currently not handled */
  Unsupported = 'UNSUPPORTED'
}

/**  Enum representing the configured status for a jira app/workspace  */
export enum JiraConfigStateConfigurationStatus {
  /** App is in configured state  */
  Configured = 'CONFIGURED',
  /** App is not in configured state  */
  NotConfigured = 'NOT_CONFIGURED',
  /** App is not installed  */
  NotInstalled = 'NOT_INSTALLED',
  /** Configured state not set  */
  NotSet = 'NOT_SET',
  /** App is in partially configured state */
  PartiallyConfigured = 'PARTIALLY_CONFIGURED',
  /** Provider action is in configured state  */
  ProviderActionConfigured = 'PROVIDER_ACTION_CONFIGURED',
  /** Provider action is not in configured state  */
  ProviderActionNotConfigured = 'PROVIDER_ACTION_NOT_CONFIGURED'
}

/**  Enum representing Provider Type of App for Config State Service  */
export enum JiraConfigStateProviderType {
  /** Represents a provider type of an app which providers build service  */
  Builds = 'BUILDS',
  /** Represents a provider type of an app which providers deployments service  */
  Deployments = 'DEPLOYMENTS',
  /** Represents a provider type of an app which providers designs service  */
  Designs = 'DESIGNS',
  /** Represents a provider type of an app which providers dev Info service  */
  DevelopmentInfo = 'DEVELOPMENT_INFO',
  /** Represents a provider type of an app which providers feature flag service  */
  FeatureFlags = 'FEATURE_FLAGS',
  /** Represents a provider type of an app which providers remote links service  */
  RemoteLinks = 'REMOTE_LINKS',
  /** Represents a provider type of an app which providers security service  */
  Security = 'SECURITY',
  /** Represents a provider type of an app which does not fit in above categories  */
  Unknown = 'UNKNOWN'
}

/** Each individual nav item that is configurable by the user. */
export type JiraConfigurableNavigationItemInput = {
  /** The visibility of the navigation item. */
  isVisible: Scalars['Boolean']['input'];
  /** The menuID for the navigation item. */
  menuId: Scalars['String']['input'];
};

/** State of the modal for contacting the org admin to enable Atlassian Intelligence. */
export enum JiraContactOrgAdminToEnableAtlassianIntelligenceState {
  /** The modal is available to be shown. */
  Available = 'AVAILABLE',
  /** The modal is not available to be shown. */
  Unavailable = 'UNAVAILABLE'
}

/** Input to query the navigation of a container scoped to a project by its key. */
export type JiraContainerNavigationByProjectKeyQueryInput = {
  /** The identifier which indicates the cloud instance this data is to be fetched for, required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** Key of the project to retrieve the navigation for. */
  projectKey: Scalars['String']['input'];
};

/**
 * Input to retrieve the navigation details of a container. As per the `@oneOf` directive, Only one of the fields
 * `byScopeId` or `byProjectKey` must be provided.
 */
export type JiraContainerNavigationQueryInput = {
  /**
   * Input to retrieve the navigation for a project by key. Clients can use this when they don't have access to
   * the project ID or the default Board ID.
   */
  projectKeyQuery?: InputMaybe<JiraContainerNavigationByProjectKeyQueryInput>;
  /** ARI of the container scope to retrieve the navigation for. Supports project ARI and Board ARI. */
  scopeId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraCreateActivityConfigurationInput = {
  /** Id of the activity configuration */
  id: Scalars['ID']['input'];
  /** Name of the activity */
  issueTypeId?: InputMaybe<Scalars['ID']['input']>;
  /** Name of the activity */
  name: Scalars['String']['input'];
  /** Name of the activity */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** Name of the activity */
  requestTypeId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * Input for creating a navigation item of type `JiraNavigationItemTypeKey.APP`. The related app is identified by
 * the `appId` input field.
 */
export type JiraCreateAppNavigationItemInput = {
  /**
   * The app id for the app to add. Supported ARIs:
   * - [Forge app ARI](https://developer.atlassian.com/platform/atlassian-resource-identifier/resource-owners/registry/#ati%3Acloud%3Aecosystem%3Aapp)
   * - [Connect app ARI](https://developer.atlassian.com/platform/atlassian-resource-identifier/resource-owners/registry/#ati%3Acloud%3Aecosystem%3Aconnect-app)
   */
  appId: Scalars['ID']['input'];
  /** ARI of the scope to add the navigation item for. */
  scopeId: Scalars['ID']['input'];
};

/** The field name of the new approver list field and its associated project */
export type JiraCreateApproverListFieldInput = {
  fieldName: Scalars['String']['input'];
  projectId: Scalars['Int']['input'];
};

/** The input for creating an attachment background */
export type JiraCreateAttachmentBackgroundInput = {
  /** The entityId (ARI) of the entity to be updated */
  entityId: Scalars['ID']['input'];
  /** The Media API File ID of the background */
  mediaApiFileId: Scalars['String']['input'];
};

export type JiraCreateBoardFieldInput = {
  /** Issue types to be included in the new board */
  issueTypes?: InputMaybe<Array<JiraIssueTypeInput>>;
  /** Labels to be included in the new board */
  labels?: InputMaybe<Array<JiraLabelsInput>>;
  /** Projects to be included in the new board */
  projects: Array<JiraProjectInput>;
  /** Teams to be included in the new board */
  teams?: InputMaybe<Array<JiraAtlassianTeamInput>>;
};

export type JiraCreateBoardInput = {
  /** Source from which the board to be created - either projectIds or savedFilterId */
  createBoardSource: JiraCreateBoardSource;
  /** Location of the board */
  location: JiraBoardLocation;
  /** Name of board to create */
  name: Scalars['String']['input'];
  /** Preset of the board */
  preset: JiraBoardType;
};

export type JiraCreateBoardSource = {
  /** Fields with values that can be used to create a filter for the board. */
  fieldInput?: InputMaybe<JiraCreateBoardFieldInput>;
  /** Saved filter id that can be used to create the board. */
  savedFilterId?: InputMaybe<Scalars['Long']['input']>;
};

/** Input for creating a Jira Custom Background */
export type JiraCreateCustomBackgroundInput = {
  /** The alt text associated with the custom background */
  altText: Scalars['String']['input'];
  /** The entityId (ARI) of the entity to be updated with the created background */
  entityId: Scalars['ID']['input'];
  /** The created mediaApiFileId of the background to create */
  mediaApiFileId: Scalars['String']['input'];
};

/** Input for creating a JiraCustomFilter. */
export type JiraCreateCustomFilterInput = {
  /** A string containing filter description */
  description?: InputMaybe<Scalars['String']['input']>;
  /**
   * The list of edit grants for the filter. Edit Grants represent different ways that users have been granted access to edit the filter.
   * Empty array represents private edit grant.
   */
  editGrants: Array<InputMaybe<JiraShareableEntityEditGrantInput>>;
  /** If present, column configuration will be copied from Filter represented by this filterId to the newly created filter */
  filterId?: InputMaybe<Scalars['String']['input']>;
  /** Determines whether the filter is currently starred by the user viewing the filter */
  isFavourite: Scalars['Boolean']['input'];
  /** JQL associated with the filter */
  jql: Scalars['String']['input'];
  /** A string representing the name of the filter */
  name: Scalars['String']['input'];
  /** A string representing namespace of the issue search view */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /**
   * The list of share grants for the filter. Share Grants represent different ways that users have been granted access to the filter.
   * Empty array represents private and null represents default share grant.
   */
  shareGrants: Array<InputMaybe<JiraShareableEntityShareGrantInput>>;
};

/** Input for creating a formatting rule. */
export type JiraCreateFormattingRuleInput = {
  /**
   * The id based cursor of a rule where the new rule should be created after.
   * If not specified, the new rule will be created on top of the rule list.
   */
  afterRuleId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** Content of this rule. */
  expression: JiraFormattingRuleExpressionInput;
  /** Formatting area of this rule (row or cell). */
  formattingArea: JiraFormattingArea;
  /** Color to be applied if condition matches. */
  formattingColor?: InputMaybe<JiraColorInput>;
  /** Id of the project to create a formatting rule for. Must provide either project key or id. */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** Key of the project to create a formatting rule for. Must provide either project key or id. */
  projectKey?: InputMaybe<Scalars['String']['input']>;
};

export type JiraCreateJourneyConfigurationInput = {
  /** List of new activity configuration */
  createActivityConfigurations?: InputMaybe<Array<InputMaybe<JiraCreateActivityConfigurationInput>>>;
  /** Name of the journey */
  name: Scalars['String']['input'];
  /** Parent issue of the journey configuration */
  parentIssue: JiraJourneyParentIssueInput;
  /** The trigger of this journey */
  trigger: JiraJourneyTriggerInput;
};

/** The input for creating the release notes in Confluence for the given version */
export type JiraCreateReleaseNoteConfluencePageInput = {
  /** The app link id that will correspond to the target confluence instance */
  appLinkId?: InputMaybe<Scalars['ID']['input']>;
  /** Exclude the issue key from the generated report */
  excludeIssueKey?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ARIs of issue fields(issue-field-meta ARI) to include when generating the release note
   *
   * Note: An empty array indicates no issue properties should be included in the release notes generation. Only summary will be included as the summary is included by default.
   */
  issueFieldIds: Array<Scalars['ID']['input']>;
  /**
   * The ARIs of issue types(issue-type ARI) to include when generating release notes
   *
   * Note: An empty array indicates all the issue types should be included in the release notes generation
   */
  issueTypeIds: Array<Scalars['ID']['input']>;
  /** The ARI of the confluence page under which the release note will be created */
  parentPageId?: InputMaybe<Scalars['ID']['input']>;
  /** The Confluence space ARI under which the release note will be created */
  spaceId: Scalars['ID']['input'];
  /** The ARI of the version to create a release note in Confluence */
  versionId: Scalars['ID']['input'];
};

export type JiraCreateShortcutInput = {
  /** ARI of the project the shortcut is being added to. */
  projectId: Scalars['ID']['input'];
  /** Data of shortcut being added */
  shortcutData: JiraShortcutDataInput;
  /** The type of the shortcut to be added. */
  type: JiraProjectShortcutType;
};

/** Input for creating a simple navigation item which doesn't require any additional data other than its `typeKey`. */
export type JiraCreateSimpleNavigationItemInput = {
  /** ARI of the scope to add the navigation item for. */
  scopeId: Scalars['ID']['input'];
  /** The key of the type of navigation item to add. */
  typeKey: JiraNavigationItemTypeKey;
};

/** The type of error returned from a custom search implementation */
export enum JiraCustomIssueSearchErrorType {
  /** A specific, internal error was generated by the custom search implementation */
  CustomImplementationError = 'CUSTOM_IMPLEMENTATION_ERROR',
  /** The requested custom search implementation is not enabled for this request */
  CustomSearchDisabled = 'CUSTOM_SEARCH_DISABLED',
  /** An ARI used as input to a custom search implementation was invalid */
  InvalidAri = 'INVALID_ARI',
  /** An ARI used as input to a custom search implementation is not supported by the implementation */
  UnsupportedAri = 'UNSUPPORTED_ARI'
}

export type JiraDataClassificationFieldOperationInput = {
  /** The new classification level to set. */
  classificationLevel?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The operation to perform on the Data Classification field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
};

/** Input type for date field */
export type JiraDateFieldInput = {
  /** A date input on which the action will be performed */
  date: JiraDateInput;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

export type JiraDateFieldOperationInput = {
  date?: InputMaybe<Scalars['Date']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Input type for date */
export type JiraDateInput = {
  /** Formatted date string value in format DD/MMM/YY */
  formattedDate: Scalars['String']['input'];
};

/** Input type for date time field */
export type JiraDateTimeFieldInput = {
  dateTime: JiraDateTimeInput;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

export type JiraDateTimeFieldOperationInput = {
  datetime?: InputMaybe<Scalars['DateTime']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Input type for date time */
export type JiraDateTimeInput = {
  /** Formatted date time string value in format DD/MMM/YY hh:mm A */
  formattedDateTime: Scalars['String']['input'];
};

export type JiraDateTimeRange = {
  /** Specifies the start date (exclusive) for filtering attachments by upload date. */
  after?: InputMaybe<Scalars['DateTime']['input']>;
  /** Specifies the end date (exclusive) for filtering attachments by upload date. */
  before?: InputMaybe<Scalars['DateTime']['input']>;
};

export type JiraDateTimeWindow = {
  /** The end date time of the window. */
  end?: InputMaybe<Scalars['DateTime']['input']>;
  /** The start date time of the window. */
  start?: InputMaybe<Scalars['DateTime']['input']>;
};

/**
 * The input for searching an Unsplash Collection. Can only be used to retrieve photos from the "Unsplash Editorial".
 * Uses Unsplash's API definition for pagination https://unsplash.com/documentation#parameters-16
 */
export type JiraDefaultUnsplashImagesInput = {
  /**  CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The page number, defaults to 1 */
  pageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** The page size, defaults to 10 */
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  /** The requested width in pixels of the thumbnail image, default is 200px */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** The input for deleting a custom background */
export type JiraDeleteCustomBackgroundInput = {
  /**  CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The customBackgroundId of the custom background to delete */
  customBackgroundId: Scalars['ID']['input'];
};

export type JiraDeleteFormattingRuleInput = {
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The rule to delete. */
  ruleId: Scalars['ID']['input'];
};

/** Input for deleting a navigation item. */
export type JiraDeleteNavigationItemInput = {
  /** Global identifier (ARI) for the navigation item to delete. */
  id: Scalars['ID']['input'];
};

/** This is an input argument for deleting project notification preferences. */
export type JiraDeleteProjectNotificationPreferencesInput = {
  /** The ARI of the project for which the notification preferences are to be deleted. */
  projectId: Scalars['ID']['input'];
};

export type JiraDeleteShortcutInput = {
  /** ARI of the project the shortcut is belongs to. */
  projectId: Scalars['ID']['input'];
  /** ARI of the shortcut */
  shortcutId: Scalars['ID']['input'];
};

/** The input to delete a version with no issues. */
export type JiraDeleteVersionWithNoIssuesInput = {
  /** The ID of the version to delete. */
  id: Scalars['ID']['input'];
};

/** The input contain details of a deployment app. */
export type JiraDeploymentAppInput = {
  /** Key name of the deployment app */
  appKey: Scalars['String']['input'];
};

/** The precondition state of the deployments JSW feature for a particular project and user. */
export enum JiraDeploymentsFeaturePrecondition {
  /** The deployments feature is available as the project has satisfied all precondition checks. */
  AllSatisfied = 'ALL_SATISFIED',
  /** The deployments feature is available and will show the empty-state page as no CI/CD provider is sending deployment data. */
  DeploymentsEmptyState = 'DEPLOYMENTS_EMPTY_STATE',
  /** The deployments feature is not available as the precondition checks have not been satisfied. */
  NotAvailable = 'NOT_AVAILABLE'
}

/** The possible config error type with a provider that feed devinfo details. */
export enum JiraDevInfoConfigErrorType {
  Incapable = 'INCAPABLE',
  NotConfigured = 'NOT_CONFIGURED',
  Unauthorized = 'UNAUTHORIZED',
  UnknownConfigError = 'UNKNOWN_CONFIG_ERROR'
}

/** The input type for a devOps association */
export type JiraDevOpsAssociationInput = {
  /** The association type */
  associationType: Scalars['String']['input'];
  /** List of associations */
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** The types of capabilities a devOps provider can support */
export enum JiraDevOpsCapability {
  Branch = 'BRANCH',
  Build = 'BUILD',
  Commit = 'COMMIT',
  Deployment = 'DEPLOYMENT',
  FeatureFlag = 'FEATURE_FLAG',
  PullRequest = 'PULL_REQUEST',
  Review = 'REVIEW'
}

/** The input type for devOps entity associations */
export type JiraDevOpsEntityAssociationsInput = {
  /** The associations to add to the entity ID */
  addAssociations?: InputMaybe<Array<JiraDevOpsAssociationInput>>;
  /** The entity ID to update the associations on */
  entityId: Scalars['ID']['input'];
  /** The associations to remove from the entity ID */
  removeAssociations?: InputMaybe<Array<JiraDevOpsAssociationInput>>;
};

export enum JiraDevOpsInContextConfigPromptLocation {
  DevelopmentPanel = 'DEVELOPMENT_PANEL',
  ReleasesPanel = 'RELEASES_PANEL',
  SecurityPanel = 'SECURITY_PANEL'
}

export enum JiraDevOpsIssuePanelBannerType {
  /** Banner that explains how to add issue keys in your commits, branches and PRs */
  IssueKeyOnboarding = 'ISSUE_KEY_ONBOARDING'
}

/** The possible States the DevOps Issue Panel can be in */
export enum JiraDevOpsIssuePanelState {
  /** Panel should show the available Dev Summary */
  DevSummary = 'DEV_SUMMARY',
  /** Panel should be hidden */
  Hidden = 'HIDDEN',
  /** Panel should show the "not connected" state to prompt user to integrate tools */
  NotConnected = 'NOT_CONNECTED'
}

export enum JiraDevOpsUpdateAssociationsEntityType {
  Vulnerability = 'VULNERABILITY'
}

/** The input type for updating devOps associations */
export type JiraDevOpsUpdateAssociationsInput = {
  /** List of entities with associations to add or remove */
  entityAssociations: Array<JiraDevOpsEntityAssociationsInput>;
  /** The type of the entities */
  entityType: JiraDevOpsUpdateAssociationsEntityType;
  /** The provider ID that the entities being associated belong to */
  providerId: Scalars['String']['input'];
};

/** The response payload to dismiss the banner that displays workspaces that are pending acceptance of access requests */
export type JiraDismissBitbucketPendingAccessRequestBannerInput = {
  /** if the banner should be dismissed. The default is true, if not given */
  isDismissed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The input type for devops panel banner dismissal */
export type JiraDismissDevOpsIssuePanelBannerInput = {
  /**
   * Only "issue-key-onboarding" is supported currently as this is the only banner
   * that can be displayed in the panel for now
   */
  bannerType: JiraDevOpsIssuePanelBannerType;
  /** ID of the issue this banner was dismissed on */
  issueId: Scalars['ID']['input'];
};

/** The response payload to dismiss in-context configuration prompt that is per user setting */
export type JiraDismissInContextConfigPromptInput = {
  /** if the prompt should be dismissed. The default is true, if not given */
  isDismissed?: InputMaybe<Scalars['Boolean']['input']>;
  /** The location of the dismissed prompt. If array is empty, it won't do anything. */
  locations: Array<JiraDevOpsInContextConfigPromptLocation>;
};

/** Input for OriginalEstimate field */
export type JiraDurationFieldInput = {
  /** Represents the time original estimate */
  originalEstimateField?: InputMaybe<Scalars['String']['input']>;
};

/** Represents the possible email MIME types. */
export enum JiraEmailMimeType {
  Html = 'HTML',
  Text = 'TEXT'
}

/** Input type for Entitlement field */
export type JiraEntitlementFieldInput = {
  /** Represents entitlement field data */
  entitlement: JiraEntitlementInput;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

/** Input type representing a single entitlement */
export type JiraEntitlementInput = {
  /** An identifier for the entitlement */
  entitlementId: Scalars['ID']['input'];
};

/** Scope of values for the Entity (Ex: Field) */
export enum JiraEntityScope {
  Global = 'GLOBAL',
  Project = 'PROJECT'
}

/** Input type for epic link field */
export type JiraEpicLinkFieldInput = {
  /** Represents an epic link field */
  epicLink: JiraEpicLinkInput;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

/** Input type for epic link field */
export type JiraEpicLinkInput = {
  /** Issue key for epic */
  issueKey: Scalars['String']['input'];
};

export type JiraEstimateInput = {
  /** Does not currently support null. Use 0 to get a similar effect. */
  timeInSeconds: Scalars['Long']['input'];
};

/**
 * Context where the extensions are supposed to be shown.
 *
 * Provide only the most specific entity. For example, there is no need to provide the project if an issue is given; the project will be inferred from the issue automatically.
 */
export type JiraExtensionRenderingContextInput = {
  issueKey?: InputMaybe<Scalars['String']['input']>;
  projectKey?: InputMaybe<Scalars['String']['input']>;
};

export type JiraFavouriteFilter = {
  /** Filter the results by the keyword */
  keyword?: InputMaybe<Scalars['String']['input']>;
  /** Sorting the results. If not provided, the oldest favourited entity will be returned first. */
  sort?: InputMaybe<JiraFavouriteSortInput>;
  /** The Jira entity type to get. */
  type?: InputMaybe<JiraFavouriteType>;
  /** List of Jira entity types to get, if both type and types are provided, type will be ignored. */
  types?: InputMaybe<Array<JiraFavouriteType>>;
};

export type JiraFavouriteSortInput = {
  /**
   * The order to sort by.
   * ASC: oldest favourited entity will be returned first.
   * DESC: recent favourited entity will be returned first.
   */
  order: SortDirection;
};

/** Currently supported favouritable entities in Jira. */
export enum JiraFavouriteType {
  Board = 'BOARD',
  Dashboard = 'DASHBOARD',
  Filter = 'FILTER',
  Plan = 'PLAN',
  Project = 'PROJECT',
  Queue = 'QUEUE'
}

export type JiraFieldConfigFilterInput = {
  /**
   * The field ID alias.
   * Applies to managed or commonly known custom fields in Jira, which allow lookup without requiring the custom field ID.
   * E.g. rank or startdate.
   * If specified, the result will only contain the fields that matches the provided aliasFieldIds
   */
  aliasFieldIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  The cloud id of the tenant. */
  cloudId: Scalars['ID']['input'];
  /**  If specified the result will be filtered by specific fieldIds */
  fieldIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  if not specified the result will include all Field types matched */
  includedFieldTypes?: InputMaybe<Array<JiraConfigFieldType>>;
  /**  If not specified all field configs in the system across projects will be returned */
  projectIdOrKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  The search string used to perform a contains search on the field name of the Field config */
  searchString?: InputMaybe<Scalars['String']['input']>;
};

/** Represents argument input type for `fieldOptions` query to provide capability to filter field options by list of IDs */
export type JiraFieldOptionIdsFilterInput = {
  /** Filter operation to perform on the list of optionsIds provided in input. */
  operation: JiraFieldOptionIdsFilterOperation;
  /**
   * Filter the available field options with provided option ids by specifying a filter operation.
   * Upto maximum 100 Option Ids are can be provided in the input.
   * Accepts ARI(s): OptionID
   */
  optionIds: Array<Scalars['ID']['input']>;
};

/** Enum to define a filter operation on the optionIds in input JiraFieldOptionIdsFilterInput */
export enum JiraFieldOptionIdsFilterOperation {
  /**
   * Allow the optionIds provided in the JiraFieldOptionIdsFilterInput from available options
   * with intersection of result from searchBy query string.
   */
  Allow = 'ALLOW',
  /**
   * Exclude the optionIds provided in the JiraFieldOptionIdsFilterInput from available options
   * with intersection of result from searchBy query string.
   */
  Exclude = 'EXCLUDE'
}

export type JiraFieldSetPreferencesMutationInput = {
  /** Input object which contains the fieldSets preferences */
  nodes?: InputMaybe<Array<JiraUpdateFieldSetPreferencesInput>>;
};

export type JiraFieldSetsMutationInput = {
  /** Input object which contains the new fieldSets */
  replaceFieldSetsInput?: InputMaybe<JiraReplaceIssueSearchViewFieldSetsInput>;
  /** Boolean which resets the fieldSets of a view to default fieldSets */
  resetToDefaultFieldSets?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The environment type the extension can be installed into. See [Environments and versions](https://developer.atlassian.com/platform/forge/environments-and-versions/) for more details. */
export enum JiraForgeEnvironmentType {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING'
}

export type JiraForgeObjectFieldOperationInput = {
  object?: InputMaybe<Scalars['String']['input']>;
  operation: JiraSingleValueFieldOperations;
};

export enum JiraFormattingArea {
  Cell = 'CELL',
  Row = 'ROW'
}

export enum JiraFormattingColor {
  /** @deprecated Use JiraColor instead */
  Blue = 'BLUE',
  /** @deprecated Use JiraColor instead */
  Green = 'GREEN',
  /** @deprecated Use JiraColor instead */
  Red = 'RED'
}

export type JiraFormattingMultipleValueOperandInput = {
  fieldId: Scalars['String']['input'];
  operator: JiraFormattingMultipleValueOperator;
  values: Array<Scalars['String']['input']>;
};

export enum JiraFormattingMultipleValueOperator {
  Contains = 'CONTAINS',
  DoesNotContain = 'DOES_NOT_CONTAIN',
  HasAnyOf = 'HAS_ANY_OF'
}

export type JiraFormattingNoValueOperandInput = {
  fieldId: Scalars['String']['input'];
  operator: JiraFormattingNoValueOperator;
};

export enum JiraFormattingNoValueOperator {
  IsEmpty = 'IS_EMPTY',
  IsNotEmpty = 'IS_NOT_EMPTY'
}

export type JiraFormattingRuleExpressionInput = {
  multipleValueOperand?: InputMaybe<JiraFormattingMultipleValueOperandInput>;
  noValueOperand?: InputMaybe<JiraFormattingNoValueOperandInput>;
  singleValueOperand?: InputMaybe<JiraFormattingSingleValueOperandInput>;
  twoValueOperand?: InputMaybe<JiraFormattingTwoValueOperandInput>;
};

export type JiraFormattingSingleValueOperandInput = {
  fieldId: Scalars['String']['input'];
  operator: JiraFormattingSingleValueOperator;
  value: Scalars['String']['input'];
};

export enum JiraFormattingSingleValueOperator {
  Contains = 'CONTAINS',
  DoesNotContain = 'DOES_NOT_CONTAIN',
  DoesNotEqual = 'DOES_NOT_EQUAL',
  Equals = 'EQUALS',
  GreaterThan = 'GREATER_THAN',
  GreaterThanOrEquals = 'GREATER_THAN_OR_EQUALS',
  Is = 'IS',
  IsAfter = 'IS_AFTER',
  IsBefore = 'IS_BEFORE',
  IsNot = 'IS_NOT',
  IsOnOrAfter = 'IS_ON_OR_AFTER',
  IsOnOrBefore = 'IS_ON_OR_BEFORE',
  LessThan = 'LESS_THAN',
  LessThanOrEquals = 'LESS_THAN_OR_EQUALS'
}

export type JiraFormattingTwoValueOperandInput = {
  fieldId: Scalars['String']['input'];
  first: Scalars['String']['input'];
  operator: JiraFormattingTwoValueOperator;
  second: Scalars['String']['input'];
};

export enum JiraFormattingTwoValueOperator {
  IsBetween = 'IS_BETWEEN',
  IsNotBetween = 'IS_NOT_BETWEEN'
}

/** The global issue create modal view types. */
export enum JiraGlobalIssueCreateView {
  /** The global issue create full modal view. */
  FullModal = 'FULL_MODAL',
  /** The global issue create mini modal view. */
  MiniModal = 'MINI_MODAL'
}

export type JiraGlobalPermissionAddGroupGrantInput = {
  /** The group ari to be added. */
  groupAri: Scalars['ID']['input'];
  /** The unique key of the permission. */
  key: Scalars['String']['input'];
};

export type JiraGlobalPermissionDeleteGroupGrantInput = {
  /** The group ari to be deleted. */
  groupAri: Scalars['ID']['input'];
  /** The unique key of the permission. */
  key: Scalars['String']['input'];
};

/** Different Global permissions that the user can have */
export enum JiraGlobalPermissionType {
  /**
   * Create and administer projects, issue types, fields, workflows, and schemes for all projects.
   * Users with this permission can perform most administration tasks, except: managing users,
   * importing data, and editing system email settings.
   */
  Administer = 'ADMINISTER',
  /** Users with this permission can see the names of all users and groups on your site. */
  UserPicker = 'USER_PICKER'
}

export enum JiraGoalStatus {
  Archived = 'ARCHIVED',
  AtRisk = 'AT_RISK',
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Done = 'DONE',
  OffTrack = 'OFF_TRACK',
  OnTrack = 'ON_TRACK',
  Paused = 'PAUSED',
  Pending = 'PENDING'
}

/**
 * The grant type key enum represents all the possible grant types available in Jira.
 * A grant type may take an optional parameter value.
 * For example: PROJECT_ROLE grant type takes project role id as parameter. And, PROJECT_LEAD grant type do not.
 *
 * The actual ARI formats are documented on the various concrete grant type values.
 */
export enum JiraGrantTypeKeyEnum {
  /**
   * The anonymous access represents the public access without logging in.
   * It takes no parameter.
   */
  AnonymousAccess = 'ANONYMOUS_ACCESS',
  /**
   * Any user who has the product access.
   * It takes no parameter.
   */
  AnyLoggedinUserApplicationRole = 'ANY_LOGGEDIN_USER_APPLICATION_ROLE',
  /**
   * A application role is used to grant a user/group access to the application group.
   * It takes application role as parameter.
   */
  ApplicationRole = 'APPLICATION_ROLE',
  /**
   * The issue assignee role.
   * It takes platform defined 'assignee' as parameter to represent the issue field value.
   */
  Assignee = 'ASSIGNEE',
  /**
   * A group is a collection of users who can be given access together.
   * It represents group in the organization's user base.
   * It takes group id as parameter.
   */
  Group = 'GROUP',
  /**
   * A multi group picker custom field.
   * It takes multi group picker custom field id as parameter.
   */
  MultiGroupPicker = 'MULTI_GROUP_PICKER',
  /**
   * A multi user picker custom field.
   * It takes multi user picker custom field id as parameter.
   */
  MultiUserPicker = 'MULTI_USER_PICKER',
  /**
   * The project lead role.
   * It takes no parameter.
   */
  ProjectLead = 'PROJECT_LEAD',
  /**
   * A role that user/group can play in a project.
   * It takes project role as parameter.
   */
  ProjectRole = 'PROJECT_ROLE',
  /**
   * The issue reporter role.
   * It takes platform defined 'reporter' as parameter to represent the issue field value.
   */
  Reporter = 'REPORTER',
  /**
   * The grant type defines what the customers can do from the portal view.
   * It takes no parameter.
   */
  ServiceProjectCustomerPortalAccess = 'SERVICE_PROJECT_CUSTOMER_PORTAL_ACCESS',
  /**
   * An individual user who can be given the access to work on one or more projects.
   * It takes user account id as parameter.
   */
  User = 'USER'
}

/** Input for Groups values on fields */
export type JiraGroupInput = {
  /** Unique identifier for group field */
  groupName: Scalars['ID']['input'];
};

/** The types of Contexts supported by Groups field. */
export enum JiraGroupsContext {
  /** This corresponds to fields that accepts only "Group" entities as RHS value. */
  Group = 'GROUP',
  /** This corresponds to fields that accepts "User" entities as RHS value. */
  User = 'USER'
}

/** The different home page types a user can be directed to. */
export enum JiraHomePageType {
  /** The Dashboards home page */
  Dashboards = 'DASHBOARDS',
  /** The login redirect page for some anonymous users */
  LoginRedirect = 'LOGIN_REDIRECT',
  /** The Projects directory home page */
  ProjectsDirectory = 'PROJECTS_DIRECTORY',
  /** The Your Work home page */
  YourWork = 'YOUR_WORK'
}

/** The JSM incident priority values */
export enum JiraIncidentPriority {
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5'
}

/** This is the input argument for initializing the project notification preferences. */
export type JiraInitializeProjectNotificationPreferencesInput = {
  /** The ARI of the project for which the notification preferences are to be initialized. */
  projectId: Scalars['ID']['input'];
};

/**
 * DEPRECATED: Banner experiment is no longer active
 *
 * The precondition state of the install-deployments banner for a particular project and user.
 */
export enum JiraInstallDeploymentsBannerPrecondition {
  /** The deployments banner is available but no CI/CD provider is sending deployment data. */
  DeploymentsEmptyState = 'DEPLOYMENTS_EMPTY_STATE',
  /** The deployments banner is available but the feature has not been enabled. */
  FeatureNotEnabled = 'FEATURE_NOT_ENABLED',
  /** The deployments banner is not available as the precondition checks have not been satisfied. */
  NotAvailable = 'NOT_AVAILABLE'
}

/** Represents the input data required for Jira issue creation. */
export type JiraIssueCreateInput = {
  /** Field data to populate the created issue with. Mandatory due to required fields such as Summary. */
  fields: JiraIssueFieldsInput;
  /** Issue type of issue to create, encoded as an ARI */
  issueTypeId: Scalars['ID']['input'];
  /** Project to create issue within, encoded as an ARI */
  projectId: Scalars['ID']['input'];
  /** Rank Issue following creation */
  rank?: InputMaybe<JiraIssueCreateRankInput>;
};

export type JiraIssueCreateRankInput = {
  /** ID of Issue after which the created issue should be ranked. Encoded as an ARI. Cannot be sent alongside before. */
  afterIssueId?: InputMaybe<Scalars['ID']['input']>;
  /** ID of Issue before which the created issue should be ranked. Encoded as an ARI. Cannot be sent alongside after. */
  beforeIssueId?: InputMaybe<Scalars['ID']['input']>;
};

/** Possible states for a deployment environment */
export enum JiraIssueDeploymentEnvironmentState {
  /** The deployment was deployed successfully */
  Deployed = 'DEPLOYED',
  /** The deployment was not deployed successfully */
  NotDeployed = 'NOT_DEPLOYED'
}

/** Input for the onIssueExported subscription. */
export type JiraIssueExportInput = {
  /** Unique ID for the Jira cloud instance. */
  cloudId: Scalars['ID']['input'];
  /** Type of export, e.g., CSV_CURRENT_FIELDS or CSV_WITH_BOM_ALL_FIELDS. */
  exportType?: InputMaybe<JiraIssueExportType>;
  /** ID of the Jira filter. Uses filter's JQL if 'modified' is false. */
  filterId?: InputMaybe<Scalars['String']['input']>;
  /** JQL query for exporting issues. Used if no filterId or 'modified' is true. */
  jql?: InputMaybe<Scalars['String']['input']>;
  /** Maximum number of issues to export. */
  maxResults?: InputMaybe<Scalars['Int']['input']>;
  /** If true, use 'jql' instead of the filter's JQL. */
  modified?: InputMaybe<Scalars['Boolean']['input']>;
  /** The zero-based index of the first item to return in the current page of results (page offset). */
  pagerStart?: InputMaybe<Scalars['Int']['input']>;
};

/** Types of exports available. */
export enum JiraIssueExportType {
  /** Export to CSV with all fields. */
  CsvAllFields = 'CSV_ALL_FIELDS',
  /** Export to CSV with current visible fields. */
  CsvCurrentFields = 'CSV_CURRENT_FIELDS',
  /** Export to CSV with BOM, all fields. */
  CsvWithBomAllFields = 'CSV_WITH_BOM_ALL_FIELDS',
  /** Export to CSV with BOM, current fields. */
  CsvWithBomCurrentFields = 'CSV_WITH_BOM_CURRENT_FIELDS'
}

/** Inputs for adding fields during an issue create or update */
export type JiraIssueFieldsInput = {
  /** Represents the input data for affected services field in jira */
  affectedServicesField?: InputMaybe<JiraAffectedServicesFieldInput>;
  /** Represents the input data for asset field */
  assetsField?: InputMaybe<JiraAssetFieldInput>;
  /** Represents the input data for team field in jira */
  atlassianTeamFields?: InputMaybe<Array<JiraAtlassianTeamFieldInput>>;
  /** Represents the input data for cascading select fields */
  cascadingSelectFields?: InputMaybe<Array<JiraCascadingSelectFieldInput>>;
  /** Represents the input data for clearable number fields */
  clearableNumberFields?: InputMaybe<Array<JiraClearableNumberFieldInput>>;
  /** Represents the input data for color fields */
  colorFields?: InputMaybe<Array<JiraColorFieldInput>>;
  /** Represents the input data for date fields */
  datePickerFields?: InputMaybe<Array<JiraDateFieldInput>>;
  /** Represents the input data for date time fields */
  dateTimePickerFields?: InputMaybe<Array<JiraDateTimeFieldInput>>;
  /** Represents the input data for entitlement field in jsm */
  entitlementField?: InputMaybe<JiraEntitlementFieldInput>;
  /** Represents the input data for epic link field */
  epicLinkField?: InputMaybe<JiraEpicLinkFieldInput>;
  /** Represents the input data for issue type field */
  issueType?: InputMaybe<JiraIssueTypeInput>;
  /** Represents the input data for labels field */
  labelsFields?: InputMaybe<Array<JiraLabelsFieldInput>>;
  /** Represents the input data for multiple group picker fields */
  multipleGroupPickerFields?: InputMaybe<Array<JiraMultipleGroupPickerFieldInput>>;
  /** Represents the input data for multiple select clearable user picker fields */
  multipleSelectClearableUserPickerFields?: InputMaybe<Array<JiraMultipleSelectClearableUserPickerFieldInput>>;
  /** Represents the input data for multiple select fields */
  multipleSelectFields?: InputMaybe<Array<JiraMultipleSelectFieldInput>>;
  /** Represents the input data for multiple select user picker fields */
  multipleSelectUserPickerFields?: InputMaybe<Array<JiraMultipleSelectUserPickerFieldInput>>;
  /** Represents the input data for multiple version picker fields */
  multipleVersionPickerFields?: InputMaybe<Array<JiraMultipleVersionPickerFieldInput>>;
  /** Represents the input data for multiselect components field used in BulkOps */
  multiselectComponents?: InputMaybe<JiraMultiSelectComponentFieldInput>;
  /** Represents the input data for number fields */
  numberFields?: InputMaybe<Array<JiraNumberFieldInput>>;
  /** Represents the input data for customer organization field in jsm projects */
  organizationField?: InputMaybe<JiraOrganizationFieldInput>;
  /** Represents the input data for Original Estimate field */
  originalEstimateField?: InputMaybe<JiraDurationFieldInput>;
  /** Represents the parent issue */
  parentField?: InputMaybe<JiraParentFieldInput>;
  /** Represents the input data for people field in jira */
  peopleFields?: InputMaybe<Array<JiraPeopleFieldInput>>;
  /** Represents the input data for jira system priority field */
  priority?: InputMaybe<JiraPriorityInput>;
  /** Represents the input data for Project field */
  projectFields?: InputMaybe<Array<JiraProjectFieldInput>>;
  /** Represents the input data for jira system resolution field */
  resolution?: InputMaybe<JiraResolutionInput>;
  /** Represents the input data for rich text fields ex:- description, environment */
  richTextFields?: InputMaybe<Array<JiraRichTextFieldInput>>;
  /** Represents the input data for jira system securityLevel field */
  security?: InputMaybe<JiraSecurityLevelInput>;
  /** Represents the input data for single group picker fields */
  singleGroupPickerFields?: InputMaybe<Array<JiraSingleGroupPickerFieldInput>>;
  /** Represents the input data for text fields ex:- summary, epicName */
  singleLineTextFields?: InputMaybe<Array<JiraSingleLineTextFieldInput>>;
  /** Represents the input data for single select clearable user picker fields */
  singleSelectClearableUserPickerFields?: InputMaybe<Array<JiraUserFieldInput>>;
  /** Represents the input data for single select fields */
  singleSelectFields?: InputMaybe<Array<JiraSingleSelectFieldInput>>;
  /** Represents the input data for single select user picker fields */
  singleSelectUserPickerFields?: InputMaybe<Array<JiraSingleSelectUserPickerFieldInput>>;
  /** Represents the input data for single version picker fields */
  singleVersionPickerFields?: InputMaybe<Array<JiraSingleVersionPickerFieldInput>>;
  /** Represents the input data for sprint field */
  sprintsField?: InputMaybe<JiraSprintFieldInput>;
  /** Represents the input data for team field in jira */
  teamFields?: InputMaybe<Array<JiraTeamFieldInput>>;
  /** Represents the input data for TimeTracking field */
  timeTrackingField?: InputMaybe<JiraTimeTrackingFieldInput>;
  /** Represents the input data for url fields */
  urlFields?: InputMaybe<Array<JiraUrlFieldInput>>;
};

export type JiraIssueHierarchyConfigInput = {
  /** A list of issue type IDs */
  issueTypeIds: Array<Scalars['ID']['input']>;
  /** Level number */
  level: Scalars['Int']['input'];
  /** Level title */
  title: Scalars['String']['input'];
};

export type JiraIssueHierarchyConfigurationMutationInput = {
  /** This indicates if the service needs to make a simulation run */
  dryRun: Scalars['Boolean']['input'];
  /** A list of hierarchy config input objects */
  issueHierarchyConfig: Array<JiraIssueHierarchyConfigInput>;
};

/** Represents the type of items that the default location rule applies to. */
export enum JiraIssueItemLayoutItemLocationRuleType {
  /** Date items. For example: date or time related fields. */
  Dates = 'DATES',
  /** Multiline text items. For example: a description field or custom multi-line test fields. */
  MultilineText = 'MULTILINE_TEXT',
  /** Any other item types not covered by previous item types. */
  Other = 'OTHER',
  /** People items. For example: user pickers, team pickers or group picker. */
  People = 'PEOPLE',
  /** Time tracking items. For example: estimate, original estimate or time tracking panels. */
  Timetracking = 'TIMETRACKING'
}

/** The system container types that are available for placing items. */
export enum JiraIssueItemSystemContainerType {
  /** The container type for the issue content. */
  Content = 'CONTENT',
  /** The container type for the issue context. */
  Context = 'CONTEXT',
  /** The container type for the issue hidden items. */
  HiddenItems = 'HIDDEN_ITEMS',
  /** The container type for the issue primary context. */
  Primary = 'PRIMARY',
  /** The container type for the request in JSM projects. */
  Request = 'REQUEST',
  /** The container type for the request portal in JSM projects. */
  RequestPortal = 'REQUEST_PORTAL',
  /** The container type for the issue secondary context. */
  Secondary = 'SECONDARY'
}

/** Represents a collection of system container types to be fetched by passing in an issue id. */
export type JiraIssueItemSystemContainerTypeWithIdInput = {
  /** ARI of the issue. */
  issueId: Scalars['ID']['input'];
  /** Whether the default (first) tab should be returned or not (defaults to false). */
  supportDefaultTab?: InputMaybe<Scalars['Boolean']['input']>;
  /** The collection of system container types. */
  systemContainerTypes: Array<JiraIssueItemSystemContainerType>;
};

/** Represents a collection of system container types to be fetched by passing in an issue key and a cloud id. */
export type JiraIssueItemSystemContainerTypeWithKeyInput = {
  /** The cloudId associated with this Issue. */
  cloudId: Scalars['ID']['input'];
  /** The {projectKey}-{issueNumber} associated with this Issue. */
  issueKey: Scalars['String']['input'];
  /** Whether the default (first) tab should be returned or not (defaults to false). */
  supportDefaultTab?: InputMaybe<Scalars['Boolean']['input']>;
  /** The collection of system container types. */
  systemContainerTypes: Array<JiraIssueItemSystemContainerType>;
};

/** This class contains all the possible states an Issue can be in. */
export enum JiraIssueLifecycleState {
  /** An active issue is present and visible (Default state) */
  Active = 'ACTIVE',
  /**
   * An archived issue is present but hidden. It can be retrieved
   * back to active state.
   */
  Archived = 'ARCHIVED'
}

/** Represents the possible linking directions between issues. */
export enum JiraIssueLinkDirection {
  /** Going from the other issue to this issue. */
  Inward = 'INWARD',
  /** Going from this issue to the other issue. */
  Outward = 'OUTWARD'
}

/** Input type for defining the operation on the IssueLink field of a Jira issue. */
export type JiraIssueLinkFieldOperationInputForIssueTransitions = {
  /** Accepts input for either inward or outward link */
  linkIssues?: InputMaybe<JiraLinkedIssuesInput>;
  /** Accepts ARI(s): issue-link-type */
  linkType: Scalars['ID']['input'];
  /** Single value ADD operation is supported. */
  operation: JiraAddValueFieldOperations;
};

/** Types of modules that can provide content for issues. */
export enum JiraIssueModuleType {
  /** A module that provides a content panel for displaying issue data. */
  IssueModule = 'ISSUE_MODULE',
  /** A module that provides a legacy web panel. */
  WebPanel = 'WEB_PANEL'
}

/** The options for issue navigator search layout. */
export enum JiraIssueNavigatorSearchLayout {
  /** Detailed or aka split-view of issues */
  Detail = 'DETAIL',
  /** List view of issues */
  List = 'LIST'
}

/** Container type for different definitions of custom input definitions. */
export type JiraIssueSearchCustomInput = {
  /** Input type used for Jira Software issue search. */
  jiraSoftwareInput?: InputMaybe<JiraSoftwareIssueSearchCustomInput>;
};

/** Specifies which field config sets should be returned. */
export enum JiraIssueSearchFieldSetSelectedState {
  /** Both selected and non-selected field config sets. */
  All = 'ALL',
  /** Only the field config sets that have not been selected in the current view. */
  NonSelected = 'NON_SELECTED',
  /** Only the field config sets selected in the current view. */
  Selected = 'SELECTED'
}

/**
 * A filter for the JiraIssueSearchFieldSet connections.
 * By default, if no fieldSetSelectedState is specified, only SELECTED fields are returned.
 */
export type JiraIssueSearchFieldSetsFilter = {
  /** An enum specifying which field config sets should be returned based on the selected status. */
  fieldSetSelectedState?: InputMaybe<JiraIssueSearchFieldSetSelectedState>;
  /** Only the fieldSets that case-insensitively, contain this searchString in their displayName will be returned. */
  searchString?: InputMaybe<Scalars['String']['input']>;
};

/**
 * The input used for an issue search.
 * The issue search will either rely on the specified JQL, the specified filter's underlying JQL,
 * or the specified custom input, specific to a Jira family product.
 */
export type JiraIssueSearchInput = {
  /** The custom input used for issue search. */
  customInput?: InputMaybe<JiraIssueSearchCustomInput>;
  /** The saved filter used for issue search. */
  filterId?: InputMaybe<Scalars['String']['input']>;
  /** The JQL used for issue search. */
  jql?: InputMaybe<Scalars['String']['input']>;
};

/**
 * The options used for an issue search.
 * The issueKey determines the target page for search.
 * Do not provide pagination arguments alongside issueKey.
 */
export type JiraIssueSearchOptions = {
  issueKey?: InputMaybe<Scalars['String']['input']>;
};

/**
 * The input used for an issue search when FE needs to tell the BE the specific view configuration to be used for an issue search query.
 * E.g. this can be used on pagination to make sure that the same view configuration calculated on initial load is used for the subsequent queries.
 * This would prevent scenrios where an user has two tabs open (one with hierarchy enabled and one with hierarchy disabled) and the BE needs to return
 * different results to respect the view configuration used on the initial load of each tab.
 */
export type JiraIssueSearchStaticViewInput = {
  /** A nullable boolean indicating if the Issue Hierarchy is enabled */
  isHierarchyEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type JiraIssueSearchViewFieldSetsContext = {
  projectContext?: InputMaybe<JiraIssueSearchViewFieldSetsProjectContext>;
};

export type JiraIssueSearchViewFieldSetsProjectContext = {
  issueType?: InputMaybe<Scalars['ID']['input']>;
  project?: InputMaybe<Scalars['ID']['input']>;
};

/** Input type for Jira comment, which may be optional input to perform a transition for the issue */
export type JiraIssueTransitionCommentInput = {
  /** Accept ADF ( Atlassian Document Format) of paragraph */
  body: JiraAdfInput;
  /** Only ADD operation is supported for comment section in the context of Issue Transition Modernisation experience.. */
  operation: JiraAddValueFieldOperations;
  /** Type of comment to be added while transitioning, possible values are INTERNAL_NOTE, REPLY_TO_CUSTOMER */
  type?: InputMaybe<JiraIssueTransitionCommentType>;
  /** Jira issue transition comment visibility */
  visibility?: InputMaybe<JiraIssueTransitionCommentVisibilityInput>;
};

/** Possible Comment Types that can be made on the Transition screen. */
export enum JiraIssueTransitionCommentType {
  /** Comment has to be shared internally with the team */
  InternalNote = 'INTERNAL_NOTE',
  /** Comment has to be shared with the customer */
  ReplyToCustomer = 'REPLY_TO_CUSTOMER'
}

export type JiraIssueTransitionCommentVisibilityInput = {
  /**
   * Unique identifier for a group
   * Accepts ARI(s): group
   */
  groupId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Unique identifier for a project role
   * Accepts ARI(s): role
   */
  roleId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input type for field level inputs, which may be required to perform a transition for the issue */
export type JiraIssueTransitionFieldLevelInput = {
  /** An entry corresponding for input for JiraAffectedServicesField */
  JiraAffectedServicesField?: InputMaybe<Array<JiraUpdateAffectedServicesFieldInput>>;
  /** An entry corresponding for input for JiraAttachmentsField */
  JiraAttachmentsField?: InputMaybe<Array<JiraUpdateAttachmentFieldInput>>;
  /** An entry corresponding for input for JiraCascadingSelectField */
  JiraCascadingSelectField?: InputMaybe<Array<JiraUpdateCascadingSelectFieldInput>>;
  /** An entry corresponding for input for JiraCheckboxesField */
  JiraCheckboxesField?: InputMaybe<Array<JiraUpdateCheckboxesFieldInput>>;
  /** An entry corresponding for input for JiraColorField */
  JiraColorField?: InputMaybe<Array<JiraUpdateColorFieldInput>>;
  /** An entry corresponding for input for JirComponentsField */
  JiraComponentsField?: InputMaybe<Array<JiraUpdateComponentsFieldInput>>;
  /** An entry corresponding for input for JiraConnectMultipleSelectField */
  JiraConnectMultipleSelectField?: InputMaybe<Array<JiraUpdateMultipleSelectFieldInput>>;
  /** An entry corresponding for input for JiraConnectNumberField */
  JiraConnectNumberField?: InputMaybe<Array<JiraUpdateNumberFieldInput>>;
  /** An entry corresponding for input for JiraConnectRichTextField */
  JiraConnectRichTextField?: InputMaybe<Array<JiraUpdateRichTextFieldInput>>;
  /** An entry corresponding for input for JiraConnectSingleSelectField */
  JiraConnectSingleSelectField?: InputMaybe<Array<JiraUpdateSingleSelectFieldInput>>;
  /** An entry corresponding for input for JiraConnectTextField */
  JiraConnectTextField?: InputMaybe<Array<JiraUpdateSingleLineTextFieldInput>>;
  /** An entry corresponding for input for JiraDatePickerField */
  JiraDatePickerField?: InputMaybe<Array<JiraUpdateDateFieldInput>>;
  /** An entry corresponding for input for JiraDateTimePickerField */
  JiraDateTimePickerField?: InputMaybe<Array<JiraUpdateDateTimeFieldInput>>;
  /** An entry corresponding for input for JiraForgeStringField */
  JiraForgeStringField?: InputMaybe<Array<JiraUpdateSingleLineTextFieldInput>>;
  /** An entry corresponding for input for JiraIssueLinkField */
  JiraIssueLinkField?: InputMaybe<Array<JiraUpdateIssueLinkFieldInputForIssueTransitions>>;
  /** An entry corresponding for input for JiraIssueTypeField */
  JiraIssueTypeField?: InputMaybe<Array<JiraUpdateIssueTypeFieldInput>>;
  /** An entry corresponding for input for JiraLabelsField */
  JiraLabelsField?: InputMaybe<Array<JiraUpdateLabelsFieldInput>>;
  /** An entry corresponding for input for JiraMultipleGroupPickerField */
  JiraMultipleGroupPickerField?: InputMaybe<Array<JiraUpdateMultipleGroupPickerFieldInput>>;
  /** An entry corresponding for input for JiraMultipleSelectField */
  JiraMultipleSelectField?: InputMaybe<Array<JiraUpdateMultipleSelectFieldInput>>;
  /** An entry corresponding for input for JiraMultipleSelectUserPickerField */
  JiraMultipleSelectUserPickerField?: InputMaybe<Array<JiraUpdateMultipleSelectUserPickerFieldInput>>;
  /** An entry corresponding for input for JiraMultipleVersionPickerField */
  JiraMultipleVersionPickerField?: InputMaybe<Array<JiraUpdateMultipleVersionPickerFieldInput>>;
  /** An entry corresponding for input for JiraNumberField */
  JiraNumberField?: InputMaybe<Array<JiraUpdateNumberFieldInput>>;
  /** An entry corresponding for input for JiraParentIssueField */
  JiraParentIssueField?: InputMaybe<Array<JiraUpdateParentFieldInput>>;
  /** An entry corresponding for input for JiraPeopleField */
  JiraPeopleField?: InputMaybe<Array<JiraUpdatePeopleFieldInput>>;
  /** An entry corresponding for input for JiraPriorityField */
  JiraPriorityField?: InputMaybe<Array<JiraUpdatePriorityFieldInput>>;
  /** An entry corresponding for input for JiraProjectField */
  JiraProjectField?: InputMaybe<Array<JiraUpdateProjectFieldInput>>;
  /** An entry corresponding for input for JiraRadioSelectField */
  JiraRadioSelectField?: InputMaybe<Array<JiraUpdateRadioSelectFieldInput>>;
  /** An entry corresponding for input for JiraResolutionField */
  JiraResolutionField?: InputMaybe<Array<JiraUpdateResolutionFieldInput>>;
  /** An entry corresponding for input for JiraRichTextField */
  JiraRichTextField?: InputMaybe<Array<JiraUpdateRichTextFieldInput>>;
  /** An entry corresponding for input for JiraSecurityLevelField */
  JiraSecurityLevelField?: InputMaybe<Array<JiraUpdateSecurityLevelFieldInput>>;
  /** An entry corresponding for input for JiraServiceManagementOrganizationField */
  JiraServiceManagementOrganizationField?: InputMaybe<Array<JiraServiceManagementUpdateOrganizationFieldInput>>;
  /** An entry corresponding for input for JiraSingleGroupPickerField */
  JiraSingleGroupPickerField?: InputMaybe<Array<JiraUpdateSingleGroupPickerFieldInput>>;
  /** An entry corresponding for input for JiraSingleLineTextField */
  JiraSingleLineTextField?: InputMaybe<Array<JiraUpdateSingleLineTextFieldInput>>;
  /** An entry corresponding for input for JiraSingleSelectField */
  JiraSingleSelectField?: InputMaybe<Array<JiraUpdateSingleSelectFieldInput>>;
  /** An entry corresponding for input for JiraSingleSelectUserPickerField */
  JiraSingleSelectUserPickerField?: InputMaybe<Array<JiraUpdateSingleSelectUserPickerFieldInput>>;
  /** An entry corresponding for input for JiraSingleVersionPickerField */
  JiraSingleVersionPickerField?: InputMaybe<Array<JiraUpdateSingleVersionPickerFieldInput>>;
  /** An entry corresponding for input for JiraSprintField */
  JiraSprintField?: InputMaybe<Array<JiraUpdateSprintFieldInput>>;
  /** An entry corresponding for input for JiraTeamViewField */
  JiraTeamViewField?: InputMaybe<Array<JiraUpdateTeamFieldInput>>;
  /** An entry corresponding for input for JiraTimeTrackingField */
  JiraTimeTrackingField?: InputMaybe<Array<JiraUpdateTimeTrackingFieldInput>>;
  /** An entry corresponding for input for JiraURLField */
  JiraUrlField?: InputMaybe<Array<JiraUpdateUrlFieldInput>>;
  /** An entry corresponding for input for JiraWorkLogField */
  JiraWorkLogField?: InputMaybe<Array<JiraUpdateWorklogFieldInputForIssueTransitions>>;
};

/** Enum representing different types of messages to be shown on modal load screen */
export enum JiraIssueTransitionLayoutMessageType {
  /** An error message type is sent when there is any error while fetching the screen */
  Error = 'ERROR',
  /** An info message configured on the transition modal */
  Info = 'INFO',
  /** A send a success message during modal load */
  Success = 'SUCCESS',
  /** A warning message that might be configured on the BE or shown based on the screen configuration/field support etc. */
  Warn = 'WARN'
}

/** Input type for defining the operation on the IssueType field of a Jira issue. */
export type JiraIssueTypeFieldOperationInput = {
  /** Accepts : issue-type */
  id: Scalars['ID']['input'];
  /** Only SET operation is supported. */
  operation: JiraSingleValueFieldOperations;
};

/** Return only issue types that match this filter */
export type JiraIssueTypeFilterInput = {
  /** All issue types with a level max or lower will be returned. */
  maxHierarchyLevel?: InputMaybe<Scalars['Int']['input']>;
  /** All issue types with a level min or higher will be returned */
  minHierarchyLevel?: InputMaybe<Scalars['Int']['input']>;
};

/** Input type for issue type field */
export type JiraIssueTypeInput = {
  /** An identifier for the field */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** An identifier for a issue type value */
  issueTypeId: Scalars['ID']['input'];
};

/** The options for the activity feed sort order. */
export enum JiraIssueViewActivityFeedSortOrder {
  NewestFirst = 'NEWEST_FIRST',
  OldestFirst = 'OLDEST_FIRST'
}

/** The options for the selected attachment view. */
export enum JiraIssueViewAttachmentPanelViewMode {
  ListView = 'LIST_VIEW',
  StripView = 'STRIP_VIEW'
}

/** The options for displaying timestamps. */
export enum JiraIssueViewTimestampDisplayMode {
  Absolute = 'ABSOLUTE',
  Relative = 'RELATIVE'
}

export enum JiraIteration {
  Iteration_1 = 'ITERATION_1',
  Iteration_2 = 'ITERATION_2',
  IterationDynamic = 'ITERATION_DYNAMIC'
}

/** The options for jql builder search mode. */
export enum JiraJqlBuilderSearchMode {
  /** JQL text based builder. */
  Advanced = 'ADVANCED',
  /** User friendly JQL Builder. */
  Basic = 'BASIC'
}

export type JiraJqlContextFieldsFilter = {
  /**
   * Fields to be excluded from the result.
   * This is an optional parameter that will attempt to exactly match individual field names and filter them from the result.
   */
  excludeJqlTerms?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only the fields that support the provided JqlClauseType will be returned. */
  forClause?: InputMaybe<JiraJqlClauseType>;
  /** Only the jqlTerms requested will be returned. */
  jqlTerms?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only the fields that contain this searchString in their displayName will be returned. */
  searchString?: InputMaybe<Scalars['String']['input']>;
  /**
   * When true only the fields that are shown in JQL context are returned
   * When false only the fields that are not shown in JQL context are returned
   * When null or not specified, all fields are returned
   */
  shouldShowInContext?: InputMaybe<Scalars['Boolean']['input']>;
};

export type JiraJourneyParentIssueInput = {
  /** The id of the project which the parent issue belongs to */
  projectId: Scalars['ID']['input'];
  /** The type of the parent issue, e.g. 'request' */
  type: JiraJourneyParentIssueType;
  /** The value of the parent issue, e.g. '10000' */
  value: Scalars['String']['input'];
};

export enum JiraJourneyParentIssueType {
  /** Jira issue */
  Request = 'REQUEST'
}

export enum JiraJourneyStatus {
  /** The journey is archived and can not be triggered or modified */
  Archived = 'ARCHIVED',
  /** The journey is disabled and can not be triggered */
  Disabled = 'DISABLED',
  /** The journey is in draft status and can not be triggered */
  Draft = 'DRAFT',
  /** The journey is enabled and can be triggered */
  Published = 'PUBLISHED'
}

export type JiraJourneyTriggerInput = {
  /** The type of the trigger, e.g. 'parentIssueCreated' */
  type: JiraJourneyTriggerType;
};

export enum JiraJourneyTriggerType {
  /** When a parent issue is created */
  ParentIssueCreated = 'PARENT_ISSUE_CREATED'
}

/**
 * The autocomplete types available for Jira fields in the context of the Jira Query Language.
 *
 * This enum also describes which fields have field-value support from this schema.
 */
export enum JiraJqlAutocompleteType {
  /** The Jira basic field JQL autocomplete type. */
  Basic = 'BASIC',
  /** The Jira cascadingOption field JQL autocomplete type. */
  Cascadingoption = 'CASCADINGOPTION',
  /** The Jira component field JQL autocomplete type. */
  Component = 'COMPONENT',
  /** The Jira group field JQL autocomplete type. */
  Group = 'GROUP',
  /** The Jira issue field JQL autocomplete type. */
  Issue = 'ISSUE',
  /** The Jira issue field type JQL autocomplete type. */
  Issuetype = 'ISSUETYPE',
  /** The Jira JWM Category field type JQL autocomplete type. */
  JwmCategory = 'JWM_CATEGORY',
  /** The Jira labels field type JQL autocomplete type. */
  Labels = 'LABELS',
  /** No autocomplete support. */
  None = 'NONE',
  /** The Jira option field type JQL autocomplete type. */
  Option = 'OPTION',
  /** The Jira Organization field JQL autocomplete type. */
  Organization = 'ORGANIZATION',
  /** The Jira priority field JQL autocomplete type. */
  Priority = 'PRIORITY',
  /** The Jira project field JQL autocomplete type. */
  Project = 'PROJECT',
  /** The Jira RequestType field JQL autocomplete type. */
  Requesttype = 'REQUESTTYPE',
  /** The Jira resolution field JQL autocomplete type. */
  Resolution = 'RESOLUTION',
  /** The Jira sprint field JQL autocomplete type. */
  Sprint = 'SPRINT',
  /** The Jira status field JQL autocomplete type. */
  Status = 'STATUS',
  /** The Jira status category field JQL autocomplete type. */
  Statuscategory = 'STATUSCATEGORY',
  /** The Jira TicketCategory field JQL autocomplete type. */
  TicketCategory = 'TICKET_CATEGORY',
  /** The Jira user field JQL autocomplete type. */
  User = 'USER',
  /** The Jira version field JQL autocomplete type. */
  Version = 'VERSION'
}

/** The modes the JQL builder can be displayed and used in. */
export enum JiraJqlBuilderMode {
  /**
   * The basic mode, allows queries to be built and executed via the JQL basic editor.
   *
   * This mode allows users to easily construct JQL queries by interacting with the UI.
   */
  Basic = 'BASIC',
  /**
   * The JQL mode, allows queries to be built and executed via the JQL advanced editor.
   *
   * This mode allows users to manually type and construct complex JQL queries.
   */
  Jql = 'JQL'
}

/** The types of JQL clauses supported by Jira. */
export enum JiraJqlClauseType {
  /** This denotes both WHERE and ORDER_BY. */
  Any = 'ANY',
  /** This corresponds to fields used to sort Jira Issues. */
  OrderBy = 'ORDER_BY',
  /** This corresponds to jql fields used as filter criteria of Jira issues. */
  Where = 'WHERE'
}

export enum JiraJqlFunctionStatus {
  Finished = 'FINISHED',
  Processing = 'PROCESSING',
  Unknown = 'UNKNOWN'
}

/**
 * The types of JQL operators supported by Jira.
 *
 * An operator in JQL is one or more symbols or words,which compares the value of a field on its left with one or more values (or functions) on its right,
 * such that only true results are retrieved by the clause.
 *
 * For more information on JQL operators please visit: https://support.atlassian.com/jira-software-cloud/docs/advanced-search-reference-jql-operators.
 */
export enum JiraJqlOperator {
  /** The `CHANGED` operator is used to find issues that have a value that had changed for the specified field. */
  Changed = 'CHANGED',
  /** The `CHANGED` operator is used to find issues that have a value that had changed for the specified field. */
  Contains = 'CONTAINS',
  /** The `=` operator is used to search for issues where the value of the specified field exactly matches the specified value. */
  Equals = 'EQUALS',
  /** The `>` operator is used to search for issues where the value of the specified field is greater than the specified value. */
  GreaterThan = 'GREATER_THAN',
  /** The `>=` operator is used to search for issues where the value of the specified field is greater than or equal to the specified value. */
  GreaterThanOrEqual = 'GREATER_THAN_OR_EQUAL',
  /** The `IN` operator is used to search for issues where the value of the specified field is one of multiple specified values. */
  In = 'IN',
  /** The `IS` operator can only be used with EMPTY or NULL. That is, it is used to search for issues where the specified field has no value. */
  Is = 'IS',
  /** The `IS NOT` operator can only be used with EMPTY or NULL. That is, it is used to search for issues where the specified field has a value. */
  IsNot = 'IS_NOT',
  /** The `<` operator is used to search for issues where the value of the specified field is less than the specified value. */
  LessThan = 'LESS_THAN',
  /** The `<=` operator is used to search for issues where the value of the specified field is less than or equal to than the specified value. */
  LessThanOrEqual = 'LESS_THAN_OR_EQUAL',
  /** The `!~` operator is used to search for issues where the value of the specified field is not a "fuzzy" match for the specified value. */
  NotContains = 'NOT_CONTAINS',
  /** The `!=` operator is used to search for issues where the value of the specified field does not match the specified value. */
  NotEquals = 'NOT_EQUALS',
  /** The `NOT IN` operator is used to search for issues where the value of the specified field is not one of multiple specified values. */
  NotIn = 'NOT_IN',
  /** The `WAS` operator is used to find issues that currently have or previously had the specified value for the specified field. */
  Was = 'WAS',
  /** The `WAS IN` operator is used to find issues that currently have or previously had any of multiple specified values for the specified field. */
  WasIn = 'WAS_IN',
  /** The `WAS NOT` operator is used to find issues that have never had the specified value for the specified field. */
  WasNot = 'WAS_NOT',
  /** The `WAS NOT IN` operator is used to search for issues where the value of the specified field has never been one of multiple specified values. */
  WasNotIn = 'WAS_NOT_IN'
}

export enum JiraJqlSyntaxError {
  BadFieldId = 'BAD_FIELD_ID',
  BadFunctionArgument = 'BAD_FUNCTION_ARGUMENT',
  BadOperator = 'BAD_OPERATOR',
  BadPropertyId = 'BAD_PROPERTY_ID',
  EmptyField = 'EMPTY_FIELD',
  EmptyFunction = 'EMPTY_FUNCTION',
  EmptyFunctionArgument = 'EMPTY_FUNCTION_ARGUMENT',
  IllegalCharacter = 'ILLEGAL_CHARACTER',
  IllegalEscape = 'ILLEGAL_ESCAPE',
  IllegalNumber = 'ILLEGAL_NUMBER',
  MissingFieldName = 'MISSING_FIELD_NAME',
  MissingLogicalOperator = 'MISSING_LOGICAL_OPERATOR',
  NoOperator = 'NO_OPERATOR',
  NoOrder = 'NO_ORDER',
  OperandUnsupported = 'OPERAND_UNSUPPORTED',
  PredicateUnsupported = 'PREDICATE_UNSUPPORTED',
  ReservedCharacter = 'RESERVED_CHARACTER',
  ReservedWord = 'RESERVED_WORD',
  UnexpectedText = 'UNEXPECTED_TEXT',
  UnfinishedString = 'UNFINISHED_STRING',
  Unknown = 'UNKNOWN'
}

/** The types of view contexts supported by JQL Fields. */
export enum JiraJqlViewContext {
  /** This corresponds to fields requested for Jira Software Plans. */
  JswPlans = 'JSW_PLANS',
  /** This corresponds to fields requested for Jira Work Management (JWM). */
  Jwm = 'JWM',
  /** This corresponds to the shadow request client. */
  ShadowRequest = 'SHADOW_REQUEST'
}

/** Input type for labels field */
export type JiraLabelsFieldInput = {
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List of labels on which the action will be performed */
  labels?: InputMaybe<Array<JiraLabelsInput>>;
};

export type JiraLabelsFieldOperationInput = {
  labels: Array<Scalars['String']['input']>;
  operation: JiraMultiValueFieldOperations;
};

/** Represents the data of a single Label */
export type JiraLabelsInput = {
  /** Name of the label selected */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for defining the operation on the Team field of a Jira issue. */
export type JiraLegacyTeamFieldOperationInput = {
  /**
   * The operation to perform on the Team field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
  /**  Accepts the team ID  */
  teamId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input to link/unlink an issue to/from a related work item. */
export type JiraLinkIssueToVersionRelatedWorkInput = {
  /**
   * The identifier for the Jira issue. To unlink an issue from the related work item, leave this field
   * as null.
   */
  issueId?: InputMaybe<Scalars['ID']['input']>;
  /** Client-generated ID for the related work item. */
  relatedWorkId?: InputMaybe<Scalars['ID']['input']>;
  /** The type of related work item being assigned. */
  relatedWorkType: JiraVersionRelatedWorkType;
  /** The identifier of the Jira version. */
  versionId: Scalars['ID']['input'];
};

export enum JiraLinkIssuesToIncidentIssueLinkTypeName {
  PostIncidentReviews = 'POST_INCIDENT_REVIEWS',
  Relates = 'RELATES'
}

export type JiraLinkIssuesToIncidentMutationInput = {
  /** The id of the JSM incident to have issues linked to it. */
  incidentId: Scalars['ID']['input'];
  /**
   * The ids of the issues to link to an incident. This can be a JSW issue as an
   * action item or a JSM issues as a post incident review.
   */
  issueIds: Array<Scalars['ID']['input']>;
  /**
   * The issue link type to create. If not provided, will fall back to the first
   * found one. The issue link created will use the outbound issue link name i.e.
   *
   * RELATES -> incident 'relates to' issue
   * POST_INCIDENT_REVIEWS -> incident 'reviewed by' issue
   */
  issueLinkTypeName: JiraLinkIssuesToIncidentIssueLinkTypeName;
};

export type JiraLinkedIssuesInput = {
  /** Accepts ARI(s): issue */
  inwardIssues?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Accepts ARI(s): issue */
  outwardIssues?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum JiraLongRunningTaskStatus {
  /** Indicates someone has been successfully cancelled */
  Cancelled = 'CANCELLED',
  /** Indicates someone has requested the task to be cancelled */
  CancelRequested = 'CANCEL_REQUESTED',
  /** Indicates the task has been successfully completed */
  Complete = 'COMPLETE',
  /** Indicates the task has been unresponsive for some time and was marked to be dead */
  Dead = 'DEAD',
  /** Indicates the task has been created and waiting in the queue */
  Enqueued = 'ENQUEUED',
  /** Indicates the task has failed */
  Failed = 'FAILED',
  /** Indicates the task is currently running */
  Running = 'RUNNING'
}

/**
 * The input to merge one version with another, which deletes the source version and moves
 * all issues from the source version to the target version.
 */
export type JiraMergeVersionInput = {
  /** The ID of the source version that is being merged. */
  id: Scalars['ID']['input'];
  /** The ID of the target version for the merge. */
  targetVersionId: Scalars['ID']['input'];
};

/** The input to reassign issues from an existing fix version to another fix version. */
export type JiraMoveIssuesToFixVersionInput = {
  /** The IDs of the issues to be reassigned to another fix version. */
  issueIds: Array<Scalars['ID']['input']>;
  /** The ID of the version to remove the issues from. */
  originalVersionId: Scalars['ID']['input'];
  /** The ID of the version to add the issues to. */
  targetVersionId: Scalars['ID']['input'];
};

/**
 * Input to update a version's sequence so that it is the latest version ordered
 * relative to other versions in the project.
 */
export type JiraMoveVersionToEndInput = {
  /** The identifier of the Jira version being updated. */
  id: Scalars['ID']['input'];
};

/**
 * Input to update a version's sequence so that it is the earliest version ordered
 * relative to other versions in the project.
 */
export type JiraMoveVersionToStartInput = {
  /** The identifier of the Jira version being updated. */
  id: Scalars['ID']['input'];
};

/** Input type for multi select component field */
export type JiraMultiSelectComponentFieldInput = {
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** List of component fields on which the action will be performed */
  components?: InputMaybe<Array<JiraComponentInput>>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

/** Operations that can be performed on multi value fields like labels, components, etc. */
export enum JiraMultiValueFieldOperations {
  /** Adds value to multi value field. */
  Add = 'ADD',
  /** Removes value from multi value field. */
  Remove = 'REMOVE',
  /** Overrides multi value field. */
  Set = 'SET'
}

/** Input type for multiple group picker field */
export type JiraMultipleGroupPickerFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List og groups associated with the field */
  groups: Array<JiraGroupInput>;
};

/** Input type for defining the operation on the MultipleGroupPicker field of a Jira issue. */
export type JiraMultipleGroupPickerFieldOperationInput = {
  /**
   * Group Id(s) for field update.
   * Accepts ARI(s): group
   */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Operations supported: ADD, REMOVE and SET. */
  operation: JiraMultiValueFieldOperations;
};

/** Input type for multiple select clearable user picker fields */
export type JiraMultipleSelectClearableUserPickerFieldInput = {
  fieldId: Scalars['ID']['input'];
  users?: InputMaybe<Array<JiraUserInput>>;
};

/** Input type for multi select field */
export type JiraMultipleSelectFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List of options on which the action will be performed */
  options: Array<JiraSelectedOptionInput>;
};

export type JiraMultipleSelectFieldOperationInput = {
  /**  Accepts ARI(s): issue-field-option  */
  ids: Array<Scalars['ID']['input']>;
  operation: JiraMultiValueFieldOperations;
};

/** Input type for multiple select user picker fields */
export type JiraMultipleSelectUserPickerFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Input data for users being selected */
  users: Array<JiraUserInput>;
};

/** Input type for defining the operation on MultipleSelectUserPicker field of a Jira issue. */
export type JiraMultipleSelectUserPickerFieldOperationInput = {
  /** Accepts ARI(s): user */
  ids: Array<Scalars['ID']['input']>;
  /** The operation to perform on the MultipleSelectUserPicker field. */
  operation: JiraMultiValueFieldOperations;
};

/** Input type for multiple select version picker fields */
export type JiraMultipleVersionPickerFieldInput = {
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List of versions on which the action will be performed */
  versions: Array<JiraVersionInput>;
};

/** Input type for defining the operation on Multiple Version Picker field of a Jira issue. */
export type JiraMultipleVersionPickerFieldOperationInput = {
  /** Accept ARI(s): version */
  ids: Array<Scalars['ID']['input']>;
  /**
   * The operations to perform on Multiple Version Picker field.
   * SET, ADD, REMOVE operations are supported.
   */
  operation: JiraMultiValueFieldOperations;
};

/** The input used for an natural language to JQL conversion */
export type JiraNaturalLanguageToJqlInput = {
  naturalLanguageInput: Scalars['String']['input'];
};

/**
 * List of values identifying the known navigation item types. This list is shared between
 * business and software projects but only some are supported by one or the other.
 */
export enum JiraNavigationItemTypeKey {
  App = 'APP',
  Approvals = 'APPROVALS',
  /** @deprecated Replaced by APP as each app will have its own navigation item */
  Apps = 'APPS',
  ArchivedIssues = 'ARCHIVED_ISSUES',
  Attachments = 'ATTACHMENTS',
  Backlog = 'BACKLOG',
  Board = 'BOARD',
  Calendar = 'CALENDAR',
  Code = 'CODE',
  Components = 'COMPONENTS',
  Deployments = 'DEPLOYMENTS',
  Development = 'DEVELOPMENT',
  Forms = 'FORMS',
  Goals = 'GOALS',
  Incidents = 'INCIDENTS',
  Issues = 'ISSUES',
  List = 'LIST',
  OnCall = 'ON_CALL',
  Pages = 'PAGES',
  Releases = 'RELEASES',
  Reports = 'REPORTS',
  Requests = 'REQUESTS',
  Security = 'SECURITY',
  /** @deprecated Replaced by SHORTCUTS as all shortcuts are shown under a single navigation item */
  Shortcut = 'SHORTCUT',
  Shortcuts = 'SHORTCUTS',
  Summary = 'SUMMARY',
  Timeline = 'TIMELINE'
}

/** Represents the possible notification categories for notification types. */
export enum JiraNotificationCategoryType {
  CommentChanges = 'COMMENT_CHANGES',
  IssueAssigned = 'ISSUE_ASSIGNED',
  IssueChanges = 'ISSUE_CHANGES',
  IssueMentioned = 'ISSUE_MENTIONED',
  IssueMiscellaneous = 'ISSUE_MISCELLANEOUS',
  IssueWorklogChanges = 'ISSUE_WORKLOG_CHANGES'
}

/** Represents the possible types notification channels. */
export enum JiraNotificationChannelType {
  Email = 'EMAIL',
  InProduct = 'IN_PRODUCT',
  MobilePush = 'MOBILE_PUSH'
}

/** Represents a notification preferences to be updated. */
export type JiraNotificationPreferenceInput = {
  /** The channel to enable/disable this preference for */
  channel?: InputMaybe<JiraNotificationChannelType>;
  /** Whether this channel should be enabled or disabled */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The notification type to be updated */
  type: JiraNotificationType;
};

/** Represents the possible types of notifications. */
export enum JiraNotificationType {
  CommentCreated = 'COMMENT_CREATED',
  CommentDeleted = 'COMMENT_DELETED',
  CommentEdited = 'COMMENT_EDITED',
  IssueAssigned = 'ISSUE_ASSIGNED',
  IssueCreated = 'ISSUE_CREATED',
  IssueDeleted = 'ISSUE_DELETED',
  IssueMoved = 'ISSUE_MOVED',
  IssueUpdated = 'ISSUE_UPDATED',
  MentionsCombined = 'MENTIONS_COMBINED',
  MiscellaneousIssueEventCombined = 'MISCELLANEOUS_ISSUE_EVENT_COMBINED',
  WorklogCombined = 'WORKLOG_COMBINED'
}

/** Input type for a number field */
export type JiraNumberFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  value: Scalars['Float']['input'];
};

export type JiraNumberFieldOperationInput = {
  number?: InputMaybe<Scalars['Float']['input']>;
  operation: JiraSingleValueFieldOperations;
};

export type JiraOAuthAppsAppInput = {
  /** Module for reading/writing builds data using these credentials */
  buildsModule?: InputMaybe<JiraOAuthAppsBuildsModuleInput>;
  /** Module for reading/writing deployments data using these credentials */
  deploymentsModule?: InputMaybe<JiraOAuthAppsDeploymentsModuleInput>;
  /** Module for reading/writing development information data using these credentials */
  devInfoModule?: InputMaybe<JiraOAuthAppsDevInfoModuleInput>;
  /** Module for reading/writing feature flags data using these credentials */
  featureFlagsModule?: InputMaybe<JiraOAuthAppsFeatureFlagsModuleInput>;
  /** Home URL from which this app should be accessible */
  homeUrl: Scalars['String']['input'];
  /** Logo of this app which will be shown on the screen */
  logoUrl: Scalars['String']['input'];
  /** Name of this app */
  name: Scalars['String']['input'];
  /** Module for reading/writing remoteLinks information data using these credentials */
  remoteLinksModule?: InputMaybe<JiraOAuthAppsRemoteLinksModuleInput>;
};

export type JiraOAuthAppsAppUpdateInput = {
  /** Module for reading/writing builds data using these credentials */
  buildsModule?: InputMaybe<JiraOAuthAppsBuildsModuleInput>;
  /** Module for reading/writing deployments data using these credentials */
  deploymentsModule?: InputMaybe<JiraOAuthAppsDeploymentsModuleInput>;
  /** Module for reading/writing development information data using these credentials */
  devInfoModule?: InputMaybe<JiraOAuthAppsDevInfoModuleInput>;
  /** Module for reading/writing feature flags data using these credentials */
  featureFlagsModule?: InputMaybe<JiraOAuthAppsFeatureFlagsModuleInput>;
  /** Module for reading/writing remoteLinks information data using these credentials */
  remoteLinksModule?: InputMaybe<JiraOAuthAppsRemoteLinksModuleInput>;
};

export type JiraOAuthAppsBuildsModuleInput = {
  /** True if this app can read/write builds data */
  isEnabled: Scalars['Boolean']['input'];
};

export type JiraOAuthAppsCreateAppInput = {
  /** The app that should be created */
  app: JiraOAuthAppsAppInput;
  /** An id for this mutation */
  clientMutationId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraOAuthAppsDeleteAppInput = {
  /** The id of the app which will be deleted */
  clientId: Scalars['ID']['input'];
  /** An id for this mutation */
  clientMutationId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraOAuthAppsDeploymentsModuleActionsInput = {
  /** A UrlTemplate which the app can inject a list deployments button on the issue view */
  listDeployments?: InputMaybe<JiraOAuthAppsUrlTemplateInput>;
};

export type JiraOAuthAppsDeploymentsModuleInput = {
  /** Actions that this app can invoke on deployments data */
  actions?: InputMaybe<JiraOAuthAppsDeploymentsModuleActionsInput>;
  /** True if this app can read/write deployments data */
  isEnabled: Scalars['Boolean']['input'];
};

export type JiraOAuthAppsDevInfoModuleActionsInput = {
  /** A UrlTemplate which the app can inject a create branch button on the issue view */
  createBranch?: InputMaybe<JiraOAuthAppsUrlTemplateInput>;
};

export type JiraOAuthAppsDevInfoModuleInput = {
  /** Actions that this app can invoke on development information data */
  actions?: InputMaybe<JiraOAuthAppsDevInfoModuleActionsInput>;
  /** True if this app can read/write development information data */
  isEnabled: Scalars['Boolean']['input'];
};

export type JiraOAuthAppsFeatureFlagsModuleActionsInput = {
  /** A UrlTemplate which the app can inject a create feature flag button on the issue view */
  createFlag?: InputMaybe<JiraOAuthAppsUrlTemplateInput>;
  /** A UrlTemplate which the app can inject a link feature flag button on the issue view */
  linkFlag?: InputMaybe<JiraOAuthAppsUrlTemplateInput>;
  /** A UrlTemplate which the app can inject a list feature flags button on the issue view */
  listFlag?: InputMaybe<JiraOAuthAppsUrlTemplateInput>;
};

export type JiraOAuthAppsFeatureFlagsModuleInput = {
  /** Actions that this app can invoke on feature flags data */
  actions?: InputMaybe<JiraOAuthAppsFeatureFlagsModuleActionsInput>;
  /** True if this app can read/write feature flags data */
  isEnabled: Scalars['Boolean']['input'];
};

export type JiraOAuthAppsRemoteLinksModuleActionInput = {
  id: Scalars['String']['input'];
  label: JiraOAuthAppsRemoteLinksModuleActionLabelInput;
  urlTemplate: Scalars['String']['input'];
};

export type JiraOAuthAppsRemoteLinksModuleActionLabelInput = {
  value: Scalars['String']['input'];
};

export type JiraOAuthAppsRemoteLinksModuleInput = {
  /** Actions that this app can invoke on remoteLinks information data */
  actions?: InputMaybe<Array<JiraOAuthAppsRemoteLinksModuleActionInput>>;
  /** True if this app can read/write remoteLinks information data */
  isEnabled: Scalars['Boolean']['input'];
};

export type JiraOAuthAppsUpdateAppInput = {
  /** The state the app should be after updating it */
  app: JiraOAuthAppsAppUpdateInput;
  /** The id of the app which will be changed */
  clientId: Scalars['ID']['input'];
  /** An id for this mutation */
  clientMutationId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraOAuthAppsUrlTemplateInput = {
  urlTemplate: Scalars['String']['input'];
};

/** The input type for opting out of the Not Connected state in the DevOpsPanel */
export type JiraOptoutDevOpsIssuePanelNotConnectedInput = {
  /** Cloud ID of the tenant this change is applied to */
  cloudId: Scalars['ID']['input'];
};

export type JiraOrderDirection = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraOrderFormattingRuleInput = {
  /** Move the current rule after this given rule. If not provided, move the current rule to top of the rule list. */
  afterRuleId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The rule to reorder. */
  ruleId: Scalars['ID']['input'];
};

export enum JiraOrganizationApprovalLocation {
  /** When the approval is done during the organization installation process */
  DuringInstallationFlow = 'DURING_INSTALLATION_FLOW',
  /** When the approval is done during the provisioning the tenant */
  DuringProvisioning = 'DURING_PROVISIONING',
  /** When the approval is done via DVCS page in Jira */
  OnAdminScreen = 'ON_ADMIN_SCREEN',
  /** When the approval is done during the provisioning the tenant. This should be specific to Bitbucket only. */
  RemindBitbucketApprovalBanner = 'REMIND_BITBUCKET_APPROVAL_BANNER',
  /** When the approval is done in unknown UI */
  Unknown = 'UNKNOWN'
}

/** Input type for an organization field */
export type JiraOrganizationFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List of organizations */
  organizations: Array<JiraOrganizationsInput>;
};

/** Input type for an organization value */
export type JiraOrganizationsInput = {
  /** An identifier for the organization */
  organizationId: Scalars['ID']['input'];
};

/** Possible changeboarding statuses. */
export enum JiraOverviewPlanMigrationChangeboardingStatus {
  /** Indicate that the user has completed the changeboarding flow. */
  Completed = 'COMPLETED',
  /** @deprecated Not used, replaced by COMPLETED status */
  Triggered = 'TRIGGERED'
}

/** Input type for the parent field of an issue */
export type JiraParentFieldInput = {
  /** An identifier for the issue */
  issueId: Scalars['ID']['input'];
};

/** Input type for defining the operation on the Parent field of a Jira issue. */
export type JiraParentFieldOperationInput = {
  /** Accept ARI(s): issue */
  id?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The operation to perform on the Parent field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
};

/** Input type for people field */
export type JiraPeopleFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Input data for users being selected */
  users: Array<JiraUserInput>;
};

/** Input type for defining the operation on People field of a Jira issue. */
export type JiraPeopleFieldOperationInput = {
  /** Accepts ARI(s): user */
  ids: Array<Scalars['ID']['input']>;
  /** The operation to perform on the People field. */
  operation: JiraMultiValueFieldOperations;
};

/** The JiraPermissionMessageTypeEnum represents category of the message section. */
export enum JiraPermissionMessageTypeEnum {
  /** Represents a basic message. */
  Information = 'INFORMATION',
  /** Represents a warning message. */
  Warning = 'WARNING'
}

/** The input type to add new permission grants to the given permission scheme. */
export type JiraPermissionSchemeAddGrantInput = {
  /** The list of one or more grants to be added. */
  grants: Array<JiraPermissionSchemeGrantInput>;
  /** The permission scheme ID in ARI format. */
  schemeId: Scalars['ID']['input'];
};

/** Specifies permission scheme grant for the combination of permission key, grant type key, and grant type value ARI. */
export type JiraPermissionSchemeGrantInput = {
  /** The grant type key such as USER. */
  grantType: JiraGrantTypeKeyEnum;
  /**
   * The optional grant value in ARI format. Some grantType like PROJECT_LEAD, REPORTER etc. have no grantValue. Any grantValue passed will be silently ignored.
   * For example: project role ID ari is of the format - ari:cloud:jira:a2520569-493f-45bc-807b-54b02bc724d1:role/project-role/activation/bd0c43a9-a23a-4302-8ffa-ca04bde7c747/projectrole/b434089d-7f6d-476b-884b-7811661f91d2
   */
  grantValue?: InputMaybe<Scalars['ID']['input']>;
  /** the project permission key. */
  permissionKey: Scalars['String']['input'];
};

/** The input type to remove permission grants from the given permission scheme. */
export type JiraPermissionSchemeRemoveGrantInput = {
  /** The list of permission grant ids. */
  grantIds: Array<Scalars['Long']['input']>;
  /** The permission scheme ID in ARI format. */
  schemeId: Scalars['ID']['input'];
};

/** The JiraPermissionTagEnum represents additional tags for the permission key. */
export enum JiraPermissionTagEnum {
  /** Represents a permission that is about to be deprecated. */
  Deprecated = 'DEPRECATED',
  /** Represents a permission that is only available to enterprise customers. */
  Enterprise = 'ENTERPRISE',
  /** Represents a permission that is newly added. */
  New = 'NEW'
}

/** The different permission types that a user can perform on a global level */
export enum JiraPermissionType {
  /** user with this permission can browse at least one project */
  BrowseProjects = 'BROWSE_PROJECTS',
  /** user with this permission can modify collections of issues at once */
  BulkChange = 'BULK_CHANGE'
}

/** The status of a Jira Plan */
export enum JiraPlanStatus {
  Active = 'ACTIVE',
  Archived = 'ARCHIVED',
  Trashed = 'TRASHED'
}

export type JiraPriorityFieldOperationInput = {
  /** Accepts ARI(s): priority */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Input type for priority field */
export type JiraPriorityInput = {
  /** An identifier for a priority value */
  priorityId: Scalars['ID']['input'];
};

/** Representation of each Jira product offering. */
export enum JiraProductEnum {
  JiraProductDiscovery = 'JIRA_PRODUCT_DISCOVERY',
  JiraServiceManagement = 'JIRA_SERVICE_MANAGEMENT',
  JiraSoftware = 'JIRA_SOFTWARE',
  JiraWorkManagement = 'JIRA_WORK_MANAGEMENT'
}

/** The different action types that a user can perform on a project */
export enum JiraProjectActionType {
  /** Create issues within the project and fill out their fields upon creation. */
  CreateIssues = 'CREATE_ISSUES',
  /** Delete issues within the project. */
  DeleteIssues = 'DELETE_ISSUES',
  /** Edit issues within the project. */
  EditIssues = 'EDIT_ISSUES',
  /** Edit project configuration such as edit access, manage people and permissions, configure issue types and their fields, and enable project features. */
  EditProjectConfig = 'EDIT_PROJECT_CONFIG',
  /** Link issues within the project. */
  LinkIssues = 'LINK_ISSUES',
  /** Schedule issues within the project. */
  ScheduleIssues = 'SCHEDULE_ISSUES',
  /** Transition issues within the project. */
  TransitionIssues = 'TRANSITION_ISSUES',
  /** View issues within the project. */
  ViewIssues = 'VIEW_ISSUES',
  /** View some set of project configurations such as edit workflows, edit issue layout, or project details. If EditProjectConfig is true this should be too. */
  ViewProjectConfig = 'VIEW_PROJECT_CONFIG'
}

/** #################### Filtering and Sorting Inputs ##################### */
export type JiraProjectAndRepositoryRelationshipFilter = {
  /** Include only relationships with the specified certainty */
  certainty?: InputMaybe<DevOpsRelationshipCertaintyFilter>;
  /** Include only relationships with the specified repository hosting provider type */
  hostingProvider?: InputMaybe<DevOpsRepositoryHostingProviderFilter>;
  /**
   * Include only relationships with all of the specified property keys.
   * If this is omitted, no filtering by 'all property keys' is applied.
   */
  withAllPropertyKeys?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type JiraProjectAndRepositoryRelationshipSort = {
  /** The field to apply sorting on */
  by: JiraProjectAndRepositoryRelationshipSortBy;
  /** The direction of sorting */
  order?: SortDirection;
};

/** #################### Enums ##################### */
export enum JiraProjectAndRepositoryRelationshipSortBy {
  LastInferredAt = 'LAST_INFERRED_AT'
}

export type JiraProjectAssociatedFieldsInput = {
  /**  if not specified the result will include all Field types matched */
  includedFieldTypes?: InputMaybe<Array<JiraConfigFieldType>>;
};

/** Represents an input to available fields query */
export type JiraProjectAvailableFieldsInput = {
  /** Search fields by list of field type groups. If empty, fields will not be filtered by field type group. */
  fieldTypeGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Search fields by field name. If null or empty, fields will not be filtered by field name. */
  filterContains?: InputMaybe<Scalars['String']['input']>;
};

export type JiraProjectCategoryFilterInput = {
  /** Filter the project categories list with these category ids */
  categoryIds?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Recommendation action for a project cleanup. */
export enum JiraProjectCleanupRecommendationAction {
  /** This project can be archived. */
  Archive = 'ARCHIVE',
  /** This project can be trashed. */
  Trash = 'TRASH'
}

/** A period of time since the project was found stale. */
export enum JiraProjectCleanupRecommendationStaleSince {
  OneYear = 'ONE_YEAR',
  SixMonths = 'SIX_MONTHS',
  TwoYears = 'TWO_YEARS'
}

export enum JiraProjectCleanupTaskStatusType {
  Complete = 'COMPLETE',
  Error = 'ERROR',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  TerminalError = 'TERMINAL_ERROR'
}

/**
 * String formats for DateTime in JiraProject, the format is in the value of the jira.date.time.picker.java.format property
 * Please refer to the "Change date and time formats" section of the "Configure the look and feel of Jira applications" page
 * https://support.atlassian.com/jira-cloud-administration/docs/configure-the-look-and-feel-of-jira-applications/
 */
export enum JiraProjectDateTimeFormat {
  /** dd/MMM/yy h:mm a    E.g. 23/May/07 3:55 AM */
  CompleteDatetimeFormat = 'COMPLETE_DATETIME_FORMAT',
  /** EEEE h:mm a     E.g. Wednesday 3:55 AM */
  DayFormat = 'DAY_FORMAT',
  /** dd/MMM/yy   E.g. 23/May/07 */
  DayMonthYearFormat = 'DAY_MONTH_YEAR_FORMAT',
  /** E.g. 2 days ago */
  Relative = 'RELATIVE',
  /** h:mm a  E.g. 3:55 AM */
  TimeFormat = 'TIME_FORMAT'
}

/** Input type for a project field */
export type JiraProjectFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Represents a project field data */
  project: JiraProjectInput;
};

export type JiraProjectFieldOperationInput = {
  /** Accept ARI(s): project */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
};

export type JiraProjectFilterInput = {
  /**  Filter the results using a literal string. Projects witha matching key or name are returned (case insensitive). */
  keyword?: InputMaybe<Scalars['String']['input']>;
  /** Filter the results based on whether the user has configured notification preferences for it. */
  notificationConfigurationState?: InputMaybe<JiraProjectNotificationConfigurationState>;
  /** the project category that can be used to filter list of projects */
  projectCategoryId?: InputMaybe<Scalars['ID']['input']>;
  /** the sort criteria that is used while filtering the projects */
  sortBy?: InputMaybe<JiraProjectSortInput>;
  /** the project types that can be used to filter list of projects */
  types?: InputMaybe<Array<JiraProjectType>>;
};

/** Input type for a project */
export type JiraProjectInput = {
  /** An identifier for the field */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the project */
  projectId: Scalars['ID']['input'];
};

export type JiraProjectKeysInput = {
  /** Cloud ID of the Jira instance containing the project keys. Required for routing. */
  cloudId: Scalars['ID']['input'];
  /** Project keys to fetch data for. */
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** The options for the project list sidebar state. */
export enum JiraProjectListRightPanelState {
  /** The project list sidebar is closed. */
  Closed = 'CLOSED',
  /** The project list sidebar is open. */
  Open = 'OPEN'
}

/** Whether or not the user has configured notification preferences for the project. */
export enum JiraProjectNotificationConfigurationState {
  /** The user has configured notification preferences for this project */
  Configured = 'CONFIGURED',
  /** The user has not configured notification preferences for this project. Computed defaults will be returned. */
  Default = 'DEFAULT'
}

/** Options to filter based on project properties */
export type JiraProjectOptions = {
  /** The type of projects we need to filter */
  projectType?: InputMaybe<JiraProjectType>;
};

/**
 * The category of the project permission.
 * It represents the logical grouping of the project permissions.
 */
export enum JiraProjectPermissionCategoryEnum {
  /** Represents one or more permissions to manage issue attacments such as create and delete. */
  Attachments = 'ATTACHMENTS',
  /** Represents one or more permissions to manage issue comments such as add, delete and edit. */
  Comments = 'COMMENTS',
  /** Represents one or more permissions applicable at issue level to manage operations such as create, delete, edit, and transition. */
  Issues = 'ISSUES',
  /** Represents one or more permissions representing default category if not any other existing category. */
  Other = 'OTHER',
  /** Represents one or more permissions applicable at project level such as project administration, view project information, and manage sprints. */
  Projects = 'PROJECTS',
  /** Represents one or more permissions to manage worklogs, time tracking for billing purpose in some cases. */
  TimeTracking = 'TIME_TRACKING',
  /** Represents one or more permissions to manage watchers and voters of an issue. */
  VotersAndWatchers = 'VOTERS_AND_WATCHERS'
}

/** The different permissions that the user can have for a project */
export enum JiraProjectPermissionType {
  /** Ability to comment on issues. */
  AddComments = 'ADD_COMMENTS',
  /** Ability to administer a project in Jira. */
  AdministerProjects = 'ADMINISTER_PROJECTS',
  /** Ability to archive issues within a project. */
  ArchiveIssues = 'ARCHIVE_ISSUES',
  /** Users with this permission may be assigned to issues. */
  AssignableUser = 'ASSIGNABLE_USER',
  /** Ability to assign issues to other people. */
  AssignIssues = 'ASSIGN_ISSUES',
  /** Ability to browse projects and the issues within them. */
  BrowseProjects = 'BROWSE_PROJECTS',
  /** Ability to close issues. Often useful where your developers resolve issues, and a QA department closes them. */
  CloseIssues = 'CLOSE_ISSUES',
  /** Users with this permission may create attachments. */
  CreateAttachments = 'CREATE_ATTACHMENTS',
  /** Ability to create issues. */
  CreateIssues = 'CREATE_ISSUES',
  /** Users with this permission may delete all attachments. */
  DeleteAllAttachments = 'DELETE_ALL_ATTACHMENTS',
  /** Ability to delete all comments made on issues. */
  DeleteAllComments = 'DELETE_ALL_COMMENTS',
  /** Ability to delete all worklogs made on issues. */
  DeleteAllWorklogs = 'DELETE_ALL_WORKLOGS',
  /** Ability to delete issues. */
  DeleteIssues = 'DELETE_ISSUES',
  /** Users with this permission may delete own attachments. */
  DeleteOwnAttachments = 'DELETE_OWN_ATTACHMENTS',
  /** Ability to delete own comments made on issues. */
  DeleteOwnComments = 'DELETE_OWN_COMMENTS',
  /** Ability to delete own worklogs made on issues. */
  DeleteOwnWorklogs = 'DELETE_OWN_WORKLOGS',
  /** Ability to edit all comments made on issues. */
  EditAllComments = 'EDIT_ALL_COMMENTS',
  /** Ability to edit all worklogs made on issues. */
  EditAllWorklogs = 'EDIT_ALL_WORKLOGS',
  /** Ability to edit issues. */
  EditIssues = 'EDIT_ISSUES',
  /** Ability to manage issue layout, and add, remove, and search for fields in Jira. */
  EditIssueLayout = 'EDIT_ISSUE_LAYOUT',
  /** Ability to edit own comments made on issues. */
  EditOwnComments = 'EDIT_OWN_COMMENTS',
  /** Ability to edit own worklogs made on issues. */
  EditOwnWorklogs = 'EDIT_OWN_WORKLOGS',
  /** Ability to edit a workflow. */
  EditWorkflow = 'EDIT_WORKFLOW',
  /** Ability to link issues together and create linked issues. Only useful if issue linking is turned on. */
  LinkIssues = 'LINK_ISSUES',
  /** Ability to manage the watchers of an issue. */
  ManageWatchers = 'MANAGE_WATCHERS',
  /** Ability to modify the reporter when creating or editing an issue. */
  ModifyReporter = 'MODIFY_REPORTER',
  /** Ability to move issues between projects or between workflows of the same project (if applicable). Note the user can only move issues to a project they have the create permission for. */
  MoveIssues = 'MOVE_ISSUES',
  /** Ability to resolve and reopen issues. This includes the ability to set a fix version. */
  ResolveIssues = 'RESOLVE_ISSUES',
  /** Ability to view or edit an issue's due date. */
  ScheduleIssues = 'SCHEDULE_ISSUES',
  /** Ability to set the level of security on an issue so that only people in that security level can see the issue. */
  SetIssueSecurity = 'SET_ISSUE_SECURITY',
  /** Ability to transition issues. */
  TransitionIssues = 'TRANSITION_ISSUES',
  /** Ability to unarchive issues within a project. */
  UnarchiveIssues = 'UNARCHIVE_ISSUES',
  /** Allows users in a software project to view development-related information on the issue, such as commits, reviews and build information. */
  ViewDevTools = 'VIEW_DEV_TOOLS',
  /** Users with this permission may view a read-only version of a workflow. */
  ViewReadonlyWorkflow = 'VIEW_READONLY_WORKFLOW',
  /** Ability to view the voters and watchers of an issue. */
  ViewVotersAndWatchers = 'VIEW_VOTERS_AND_WATCHERS',
  /** Ability to log work done against an issue. Only useful if Time Tracking is turned on. */
  WorkOnIssues = 'WORK_ON_ISSUES'
}

/** Recommendation action for a project role actor. */
export enum JiraProjectRoleActorRecommendationAction {
  /** This project role actor can be trashed. */
  Trash = 'TRASH'
}

/** User status for a project role actor. */
export enum JiraProjectRoleActorUserStatus {
  /** The user associated with this project role actor is deleted. */
  Deleted = 'DELETED',
  /** The user associated with this project role actor is not active. */
  Inactive = 'INACTIVE'
}

/** The supported different shortcut types */
export enum JiraProjectShortcutType {
  /** A shortcut which links to a repository */
  Repository = 'REPOSITORY',
  /** The basic shortcut link */
  ShortcutLink = 'SHORTCUT_LINK',
  /** When an unexpected shortcut type is encountered which is not yet supported */
  Unknown = 'UNKNOWN'
}

export enum JiraProjectSortField {
  /** sorts by category */
  Category = 'CATEGORY',
  /** sorts by favourite value of the project */
  Favourite = 'FAVOURITE',
  /** sorts by project key */
  Key = 'KEY',
  /** sorts by the time of the last updated issue in the project */
  LastIssueUpdatedTime = 'LAST_ISSUE_UPDATED_TIME',
  /** sorts by lead */
  Lead = 'LEAD',
  /** sorts by project name */
  Name = 'NAME'
}

export type JiraProjectSortInput = {
  order?: InputMaybe<SortDirection>;
  sortBy?: InputMaybe<JiraProjectSortField>;
};

/** Jira Project statuses. */
export enum JiraProjectStatus {
  /** An active project. */
  Active = 'ACTIVE',
  /** An archived project. */
  Archived = 'ARCHIVED',
  /** A deleted project. */
  Deleted = 'DELETED'
}

/** Jira Project Styles. */
export enum JiraProjectStyle {
  /** A company-managed project. */
  CompanyManagedProject = 'COMPANY_MANAGED_PROJECT',
  /** A team-managed project. */
  TeamManagedProject = 'TEAM_MANAGED_PROJECT'
}

/** Jira Project types. */
export enum JiraProjectType {
  /** A business project. */
  Business = 'BUSINESS',
  /** A customer service project. */
  CustomerService = 'CUSTOMER_SERVICE',
  /** A product discovery project. */
  ProductDiscovery = 'PRODUCT_DISCOVERY',
  /** A service desk project. */
  ServiceDesk = 'SERVICE_DESK',
  /** A software project. */
  Software = 'SOFTWARE'
}

/** Input for updating a project's avatar. */
export type JiraProjectUpdateAvatarInput = {
  /** The new project avatarId. */
  avatarId: Scalars['ID']['input'];
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The id or key of the project to update the name for. */
  projectIdOrKey: Scalars['String']['input'];
};

/** Input for updating a project's name. */
export type JiraProjectUpdateNameInput = {
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The new project name. */
  name: Scalars['String']['input'];
  /** The id or key of the project to update the name for. */
  projectIdOrKey: Scalars['String']['input'];
};

/** Whether or not the user wants linked, unlinked or all the projects. */
export enum JiraProjectsHelpCenterMappingStatus {
  All = 'ALL',
  Linked = 'LINKED',
  Unlinked = 'UNLINKED'
}

export type JiraProjectsMappedToHelpCenterFilterInput = {
  /** help center ARI that can be used to filter the projects mapped to Help Center */
  helpCenterARI?: InputMaybe<Scalars['ID']['input']>;
  /** the help center id that can be used to filter the projects mapped to Help Center */
  helpCenterId: Scalars['ID']['input'];
  /** Filter the results based on whether the user wants linked, unlinked or all the projects. */
  helpCenterMappingStatus?: InputMaybe<JiraProjectsHelpCenterMappingStatus>;
};

export type JiraPublishJourneyConfigurationInput = {
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
  /** The version number of the entity. */
  version: Scalars['Long']['input'];
};

/** Possible states for Pull Requests */
export enum JiraPullRequestState {
  /** Pull Request is Declined */
  Declined = 'DECLINED',
  /** Pull Request is Draft */
  Draft = 'DRAFT',
  /** Pull Request is Merged */
  Merged = 'MERGED',
  /** Pull Request is Open */
  Open = 'OPEN'
}

export type JiraRadioSelectFieldOperationInput = {
  /** Accept ARI(s): issue-field-option */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Represents a direction in the ranking of two issues. */
export enum JiraRankMutationEdge {
  Bottom = 'BOTTOM',
  Top = 'TOP'
}

/** Input for ranking issues against one another using a rank field. */
export type JiraRankMutationInput = {
  /** The edge the issues will be ranked in (TOP/BOTTOM) */
  edge: JiraRankMutationEdge;
  /** The list of issue ARIs to be ranked. */
  issues: Array<Scalars['ID']['input']>;
  /** The issue ARI of the target issue which the `issues` will be positioned against. */
  relativeToIssue: Scalars['ID']['input'];
};

/** Input for ranking a navigation item. Only pass one of beforeItemId or afterItemId. */
export type JiraRankNavigationItemInput = {
  /** Global identifier (ARI) of the navigation item that the navigation item being ranked will be placed after. */
  afterItemId?: InputMaybe<Scalars['ID']['input']>;
  /** Global identifier (ARI) of the navigation item that the navigation item being ranked will be placed before. */
  beforeItemId?: InputMaybe<Scalars['ID']['input']>;
  /** Global identifier (ARI) of the navigation item to rank. */
  id: Scalars['ID']['input'];
};

/** Input type for the recentItems' filter. */
export type JiraRecentItemsFilter = {
  /** Filter the results by the keyword */
  keyword?: InputMaybe<Scalars['String']['input']>;
  /** List of Jira entity types to get, */
  types?: InputMaybe<Array<JiraSearchableEntityType>>;
};

/** Category of recommendation */
export enum JiraRecommendationCategory {
  /** Recommendation to delete a custom field */
  CustomField = 'CUSTOM_FIELD',
  /** Recommendation to archive issues */
  IssueArchival = 'ISSUE_ARCHIVAL',
  /** Recommendation to clean (archive or trash) the project */
  ProjectCleanup = 'PROJECT_CLEANUP',
  /** Recommendation to delete a project role actor */
  ProjectRoleActor = 'PROJECT_ROLE_ACTOR'
}

/** Enum describing the possible states to represent issue keys when generating release notes */
export enum JiraReleaseNotesIssueKeyConfig {
  /** Include issue keys in the generated release notes as hyperlinks to their respective issue view */
  Linked = 'LINKED',
  /** Exclude issue keys from the generated release notes */
  None = 'NONE',
  /** Include issue keys in the generated release notes as plain text */
  Unlinked = 'UNLINKED'
}

export type JiraReleasesDeploymentFilter = {
  /** Only deployments in these environment types will be returned. */
  environmentCategories?: InputMaybe<Array<DevOpsEnvironmentCategory>>;
  /** Only deployments in these environments will be returned. */
  environmentDisplayNames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only deployments associated with these issues will be returned. */
  issueIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Only deployments associated with these services will be returned. */
  serviceIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Only deployments in this time window will be returned. */
  timeWindow: JiraReleasesTimeWindowInput;
};

export type JiraReleasesEpicFilter = {
  /** Only epics in this project will be returned. */
  projectId: Scalars['ID']['input'];
  /** Determines whether epics that haven't been released should be included in the results. */
  releaseStatusFilter?: InputMaybe<JiraReleasesEpicReleaseStatusFilter>;
  /** Only epics matching this text filter will be returned. */
  text?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Used for specifying whether or not epics that haven't been released should be included
 * in the results.
 *
 * For an epic to be considered as released, at least one of the issues or subtasks within
 * it must have been released.
 */
export enum JiraReleasesEpicReleaseStatusFilter {
  /** Only epics that have been released (to any environment) will be included in the results. */
  Released = 'RELEASED',
  /**
   * Epics that have been released will be returned first, followed by epics that haven't
   * yet been released.
   */
  ReleasedAndUnreleased = 'RELEASED_AND_UNRELEASED'
}

export type JiraReleasesIssueFilter = {
  /** Only issues assigned to these users will be returned. */
  assignees?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Only issues that have been released in these environment *types* will be returned. */
  environmentCategories?: InputMaybe<Array<InputMaybe<DevOpsEnvironmentCategory>>>;
  /** Only issues that have been released in these environments will be returned. */
  environmentDisplayNames?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * Only issues in these epics will be returned.
   *
   * Note:
   * * If a null ID is included in the list, issues not in epics will be included in the results.
   * * If a subtask's parent issue is in one of the epics, the subtask will also be returned.
   */
  epicIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Only issues with the supplied fixVersions will be returned. */
  fixVersions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only issues of these types will be returned. */
  issueTypes?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Only issues in this project will be returned. */
  projectId: Scalars['ID']['input'];
  /** Determines whether issues that haven't been released should be included in the results. */
  releaseStatusFilter?: JiraReleasesIssueReleaseStatusFilter;
  /** Only issues matching this text filter will be returned (will match against all issue fields). */
  text?: InputMaybe<Scalars['String']['input']>;
  /**
   * Only issues that have been released within this time window will be returned.
   *
   * Note: Issues that have not been released within the time window will still be returned
   * if the `includeIssuesWithoutReleases` argument is `true`.
   */
  timeWindow: JiraReleasesTimeWindowInput;
};

/**
 * Used for specifying whether or not issues that haven't been released should be included
 * in the results.
 */
export enum JiraReleasesIssueReleaseStatusFilter {
  /** Only issues that have been released (to any environment) will be included in the results. */
  Released = 'RELEASED',
  /**
   * Issues that have been released will be returned first, followed by issues that haven't
   * yet been released.
   */
  ReleasedAndUnreleased = 'RELEASED_AND_UNRELEASED',
  /** Only issues that have *not* been released (to any environment) will be included in the results. */
  Unreleased = 'UNRELEASED'
}

export type JiraReleasesTimeWindowInput = {
  after: Scalars['DateTime']['input'];
  before: Scalars['DateTime']['input'];
};

/** Input type for updating the Remaining Time Estimate field of a Jira issue. */
export type JiraRemainingTimeEstimateFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The new value to be placed in the Remaining Time Estimate field */
  remainingEstimate: JiraEstimateInput;
};

/** The input for deleting an active background */
export type JiraRemoveActiveBackgroundInput = {
  /** The entityId (ARI) of the entity to remove the active background for */
  entityId: Scalars['ID']['input'];
};

/** The input to remove isses from all versions */
export type JiraRemoveIssuesFromAllFixVersionsInput = {
  /** The IDs of the issues to be removed from all versions. */
  issueIds: Array<Scalars['ID']['input']>;
};

/** The input to remove issues from a fix version. */
export type JiraRemoveIssuesFromFixVersionInput = {
  /** The IDs of the issues to be removed from a fix version. */
  issueIds: Array<Scalars['ID']['input']>;
  /** The ID of the version to remove the issues from. */
  versionId: Scalars['ID']['input'];
};

/** The input type to remove bitbucket workspace(organization in Jira term) connection */
export type JiraRemoveJiraBitbucketWorkspaceConnectionInput = {
  /** The workspace id(organization in Jira term) to remove the connection */
  workspaceId: Scalars['ID']['input'];
};

export type JiraRemovePostIncidentReviewLinkMutationInput = {
  /**
   * The ID of the incident the PIR link will be removed from. Initially only Jira Service Management
   * incidents are supported, but eventually 3rd party / Data Depot incidents will follow.
   */
  incidentId: Scalars['ID']['input'];
  /** The ID of the PIR link that will be removed from the incident. */
  postIncidentReviewLinkId: Scalars['ID']['input'];
};

/** Input to delete a related work item and unlink it from a version. */
export type JiraRemoveRelatedWorkFromVersionInput = {
  /**
   * Client-generated ID for the related work item.
   *
   * To delete native release notes, leave this as null and pass `removeNativeReleaseNotes` instead.
   */
  relatedWorkId?: InputMaybe<Scalars['ID']['input']>;
  /** If true the "native release notes" related work item will be deleted. */
  removeNativeReleaseNotes?: InputMaybe<Scalars['Boolean']['input']>;
  /** The identifier of the Jira version. */
  versionId: Scalars['ID']['input'];
};

/** Input for renaming a navigation item. */
export type JiraRenameNavigationItemInput = {
  /** Global identifier (ARI) for the navigation item to rename. */
  id: Scalars['ID']['input'];
  /** The new label for the navigation item. */
  label: Scalars['String']['input'];
};

export type JiraReplaceIssueSearchViewFieldSetsInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  context?: InputMaybe<JiraIssueSearchViewFieldSetsContext>;
  /**  Denotes whether `before` and/or `after` nodes will be replaced inclusively. If not specified, defaults to false. */
  inclusive?: InputMaybe<Scalars['Boolean']['input']>;
  nodes: Array<Scalars['String']['input']>;
};

/** Input type for defining the operation on the Resolution field of a Jira issue. */
export type JiraResolutionFieldOperationInput = {
  /**  Accepts ARI(s): resolution  */
  id?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The operation to perform on the Resolution field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
};

/** Input type for resolution field */
export type JiraResolutionInput = {
  /** An identifier for the resolution field */
  resolutionId: Scalars['ID']['input'];
};

/** Recommendation action for a custom field. */
export enum JiraResourceUsageCustomFieldRecommendationAction {
  /** This custom field can be trashed. */
  Trash = 'TRASH'
}

/** Status of the recommendation. */
export enum JiraResourceUsageRecommendationStatus {
  /** The recommendation has been archived */
  Archived = 'ARCHIVED',
  /** The recommendation has been executed */
  Executed = 'EXECUTED',
  /** The recommendation has been created, user hasn't been notified about it or acted on it */
  New = 'NEW',
  /** The recommendation is not relevant anymore */
  Obsolete = 'OBSOLETE',
  /** The recommendation has been trashed */
  Trashed = 'TRASHED'
}

/** Possible states for Reviews */
export enum JiraReviewState {
  /** Review is in Require Approval state */
  Approval = 'APPROVAL',
  /** Review has been closed */
  Closed = 'CLOSED',
  /** Review is in Dead state */
  Dead = 'DEAD',
  /** Review is in Draft state */
  Draft = 'DRAFT',
  /** Review has been rejected */
  Rejected = 'REJECTED',
  /** Review is in Review state */
  Review = 'REVIEW',
  /** Review is in Summarize state */
  Summarize = 'SUMMARIZE',
  /** Review state is unknown */
  Unknown = 'UNKNOWN'
}

/** Input type for rich text fields. Supports both text area and wiki text fields */
export type JiraRichTextFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Rich text input on which the action will be performed */
  richText: JiraRichTextInput;
};

export type JiraRichTextFieldOperationInput = {
  /** Accept ADF ( Atlassian Document Format) of paragraph */
  document: JiraAdfInput;
  operation: JiraSingleValueFieldOperations;
};

/** Input type for rich text field */
export type JiraRichTextInput = {
  /** ADF based input for rich text field */
  adfValue?: InputMaybe<Scalars['JSON']['input']>;
  /** Plain text input */
  wikiText?: InputMaybe<Scalars['String']['input']>;
};

/** Types of scenarios that can be an issue. */
export enum JiraScenarioType {
  Added = 'ADDED',
  Deleted = 'DELETED',
  Deletedfromjira = 'DELETEDFROMJIRA',
  Updated = 'UPDATED'
}

/** The entity types of searchable items. */
export enum JiraSearchableEntityType {
  /** A searchable board item. */
  Board = 'BOARD',
  /** A searchable dashboard item. */
  Dashboard = 'DASHBOARD',
  /** A searchable filter item. */
  Filter = 'FILTER',
  /** An searchable issue item. */
  Issue = 'ISSUE',
  /** A searchable plan item. */
  Plan = 'PLAN',
  /** A searchable project item. */
  Project = 'PROJECT',
  /** A searchable queue item. */
  Queue = 'QUEUE'
}

/** Input type for defining the operation on the Security Level field of a Jira issue. */
export type JiraSecurityLevelFieldOperationInput = {
  /** Accepts ARI(s): SecurityLevel ARI */
  id?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The operation to perform on the Security Level field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
};

/** Input type for security level field */
export type JiraSecurityLevelInput = {
  /** An identifier for the security level */
  securityLevelId: Scalars['ID']['input'];
};

/** Input type for selected option */
export type JiraSelectedOptionInput = {
  /** An identifier for the field */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** An identifier for the option */
  optionId?: InputMaybe<Scalars['ID']['input']>;
};

/** Represents the possible decisions that can be made by an approver. */
export enum JiraServiceManagementApprovalDecisionResponseType {
  /** Indicates that the decision is approved by the approver. */
  Approved = 'approved',
  /** Indicates that the decision is declined by the approver. */
  Declined = 'declined',
  /** Indicates that the decision is pending by the approver. */
  Pending = 'pending'
}

/** Represent whether approval can be achieved or not. */
export enum JiraServiceManagementApprovalState {
  /** Indicates that approval can not be completed due to lack of approvers. */
  InsufficientApprovers = 'INSUFFICIENT_APPROVERS',
  /** Indicates that approval has sufficient user to complete. */
  Ok = 'OK'
}

export type JiraServiceManagementBulkCreateRequestTypeFromTemplateInput = {
  /** Collection of create request type input configuration */
  createRequestTypeFromTemplateInputItems: Array<JiraServiceManagementCreateRequestTypeFromTemplateInput>;
  /** Project ARI where request types will be created */
  projectId: Scalars['ID']['input'];
};

/** The visibility property of a comment within a JSM project type. */
export enum JiraServiceManagementCommentVisibility {
  /** This comment will only appear in JIRA's issue view. Also called private. */
  Internal = 'INTERNAL',
  /** This comment will appear in the portal, visible to all customers. Also called public. */
  VisibleToHelpseeker = 'VISIBLE_TO_HELPSEEKER'
}

/** Represent the input data for create workflow and associate it to the issue type. */
export type JiraServiceManagementCreateAndAssociateWorkflowFromTemplateInput = {
  /** The avatar id for the issue type icon. */
  avatarId?: InputMaybe<Scalars['ID']['input']>;
  /** The name of the created new issue type. */
  issueTypeName?: InputMaybe<Scalars['String']['input']>;
  /** The project ARI workflow is created in. */
  projectId: Scalars['ID']['input'];
  /** Template id to be used to create workflow. */
  templateId: Scalars['String']['input'];
  /** The name of create new workflow, which should be a unique name. */
  workflowName?: InputMaybe<Scalars['String']['input']>;
};

export type JiraServiceManagementCreateRequestTypeFromTemplateInput = {
  /**
   * Id of the creation request/attempt, to track which requests were created and which were not, to retry only failed ones
   * Format: UUID
   */
  clientMutationId: Scalars['String']['input'];
  /** Description of the new request type */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name of the new request type (that's going to be created) */
  name: Scalars['String']['input'];
  /** Portal instructions of the new request type */
  portalInstructions?: InputMaybe<Scalars['String']['input']>;
  /** Practice (work category) which will be associated with the new request type */
  practice?: InputMaybe<JiraServiceManagementPractice>;
  /** Request form content of the new request type */
  requestForm: JiraServiceManagementCreateRequestTypeFromTemplateRequestFormInput;
  /** Request type groups which will be associated with the new request type */
  requestTypeGroup?: InputMaybe<JiraServiceManagementCreateRequestTypeFromTemplateRequestTypeGroupInput>;
  /** Icon of the new request type */
  requestTypeIconInternalId?: InputMaybe<Scalars['String']['input']>;
  /** Workflow which will be associated with the new request type */
  workflow?: InputMaybe<JiraServiceManagementCreateRequestTypeFromTemplateWorkflowInput>;
};

/** Input for FORM_TEMPLATE_REFERENCE or REQUEST_TYPE_TEMPLATE_REFERENCE JiraServiceManagementCreateRequestTypeFromTemplateRequestFormInputType. */
export type JiraServiceManagementCreateRequestTypeFromTemplateReferenceInput = {
  /** Reference of the request type template id, not ARI format */
  formTemplateInternalId: Scalars['String']['input'];
};

export type JiraServiceManagementCreateRequestTypeFromTemplateRequestFormInput = {
  /** Request form input type. */
  inputType: JiraServiceManagementCreateRequestTypeFromTemplateRequestFormInputType;
  /** Input for CreateRequestTypeFromTemplateRequestFormInputType.FORM_TEMPLATE_REFERENCE . */
  templateFormReferenceInput: JiraServiceManagementCreateRequestTypeFromTemplateReferenceInput;
};

/** This enum represents different input variation for the "request form" part of the new request type to be created. */
export enum JiraServiceManagementCreateRequestTypeFromTemplateRequestFormInputType {
  /** This means the reference of the proforma form template will be sent as input. */
  FormTemplateReference = 'FORM_TEMPLATE_REFERENCE',
  /** This means the reference of the jira request type template will be sent as input. */
  RequestTypeTemplateReference = 'REQUEST_TYPE_TEMPLATE_REFERENCE'
}

export type JiraServiceManagementCreateRequestTypeFromTemplateRequestTypeGroupInput = {
  /** Collection of request type group reference */
  requestTypeGroupInternalIds: Array<Scalars['String']['input']>;
};

/** This enum represent different action variation for workflow. */
export enum JiraServiceManagementCreateRequestTypeFromTemplateWorkflowAction {
  /** This mean workflow will be shared with going to created request type. */
  Share = 'SHARE'
}

export type JiraServiceManagementCreateRequestTypeFromTemplateWorkflowInput = {
  /** Action to perform with input workflow. */
  action: JiraServiceManagementCreateRequestTypeFromTemplateWorkflowAction;
  /** Workflow input type. */
  inputType: JiraServiceManagementCreateRequestTypeFromTemplateWorkflowInputType;
  /** Input for CreateRequestTypeFromTemplateWorkflowInputType.REFERENCE_THROUGH_ISSUE_TYPE . */
  workflowIssueTypeReferenceInput: JiraServiceManagementCreateRequestTypeFromTemplateWorkflowIssueTypeReferenceInput;
};

/** This enum represent different input variation for workflow which will be associated with the new request type to be created. */
export enum JiraServiceManagementCreateRequestTypeFromTemplateWorkflowInputType {
  /** This mean use workflow that associated with given issue type */
  ReferenceThroughIssueType = 'REFERENCE_THROUGH_ISSUE_TYPE'
}

/** Input for CreateRequestTypeFromTemplateWorkflowInputType.REFERENCE_THROUGH_ISSUE_TYPE . */
export type JiraServiceManagementCreateRequestTypeFromTemplateWorkflowIssueTypeReferenceInput = {
  /** Issue type ARI */
  workflowIssueTypeId: Scalars['ID']['input'];
};

/** An enum representing possible values for Major Incident JSM field. */
export enum JiraServiceManagementMajorIncident {
  MajorIncident = 'MAJOR_INCIDENT'
}

/**
 * Input type for defining the operation on Jira Service Management Organization field of a Jira issue.
 * Renamed to JsmOrganizationFieldOperationInput to compatible with jira/gira prefix validation
 */
export type JiraServiceManagementOrganizationFieldOperationInput = {
  /**  Accepts ARI(s): organization  */
  ids: Array<Scalars['ID']['input']>;
  /**
   * The operations to perform on Jira Service Management Organization field.
   * SET, ADD, REMOVE operations are supported.
   */
  operation: JiraMultiValueFieldOperations;
};

/** ITSM project practice categorization. */
export enum JiraServiceManagementPractice {
  /** Empower the IT operations teams with richer contextual information around changes from software development tools so they can make better decisions and minimize risk. */
  ChangeManagement = 'CHANGE_MANAGEMENT',
  /** Provide customer support teams with the tools they need to escalate requests to software development teams. */
  DeveloperEscalation = 'DEVELOPER_ESCALATION',
  /** Bring the development and IT operations teams together to rapidly respond to, resolve, and continuously learn from incidents. */
  IncidentManagement = 'INCIDENT_MANAGEMENT',
  /** Bring people and teams together to discuss the details of an incident: why it happened, what impact it had, what actions were taken to resolve it, and how the team can prevent it from happening again. */
  PostIncidentReview = 'POST_INCIDENT_REVIEW',
  /** Group incidents to problems, fast-track root cause analysis, and record workarounds to minimize the impact of incidents. */
  ProblemManagement = 'PROBLEM_MANAGEMENT',
  /** Manage work across teams with one platform so the employees and customers quickly get the help they need. */
  ServiceRequest = 'SERVICE_REQUEST'
}

/**
 * Renderer Preview Type
 * Represents the type of editing experience to load for a multi-line text field.
 */
export enum JiraServiceManagementRendererType {
  AtlassianWikiRendererType = 'ATLASSIAN_WIKI_RENDERER_TYPE',
  JiraTextRendererType = 'JIRA_TEXT_RENDERER_TYPE'
}

/** Input type for updating the Entitlement field of the Jira issue. */
export type JiraServiceManagementUpdateEntitlementFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Entitlement field. */
  operation?: InputMaybe<JiraServiceManagementUpdateEntitlementOperationInput>;
};

/** Input type for defining the operation on the Entitlement field of a Jira issue. */
export type JiraServiceManagementUpdateEntitlementOperationInput = {
  /** UUID value of the selected entitlement. */
  entitlementId?: InputMaybe<Scalars['ID']['input']>;
  /** Only SET operation is supported. */
  operation: JiraSingleValueFieldOperations;
};

/**
 * Input type for updating the Jira Service Management Organization field of a Jira issue.
 * Renamed to JsmUpdateOrganizationFieldInput to compatible with jira/gira prefix validation
 */
export type JiraServiceManagementUpdateOrganizationFieldInput = {
  /**  Accepts ARI(s): issuefieldvalue  */
  id: Scalars['ID']['input'];
  /** The operations to perform on Jira Service Management Organization field. */
  operations: Array<JiraServiceManagementOrganizationFieldOperationInput>;
};

/** Input type for updating the Sentiment field of the Jira issue. */
export type JiraServiceManagementUpdateSentimentFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Sentiment field. */
  operation?: InputMaybe<JiraServiceManagementUpdateSentimentOperationInput>;
};

/** Input type for defining the operation on the Sentiment field of a Jira issue. */
export type JiraServiceManagementUpdateSentimentOperationInput = {
  /** Only SET operation is supported. */
  operation: JiraSingleValueFieldOperations;
  /** ID value of the selected sentiment. */
  sentimentId?: InputMaybe<Scalars['String']['input']>;
};

/** The key of the property you want to update, and the new value you want to set it to */
export type JiraSetApplicationPropertyInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** Input for setting a navigation item as default. */
export type JiraSetDefaultNavigationItemInput = {
  /** Global identifier (ARI) for the navigation item to set as default. */
  id: Scalars['ID']['input'];
};

export type JiraSetFieldAssociationWithIssueTypesInput = {
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId: Scalars['ID']['input'];
  /** Unique identifier of the field. */
  fieldId: Scalars['ID']['input'];
  /** List of issue type ids to be removed from the field */
  issueTypeIdsToRemove: Array<Scalars['ID']['input']>;
  /** List of issue type ids to be associated with the field */
  issueTypeIdsToUpsert: Array<Scalars['ID']['input']>;
  /** Unique identifier of the project. */
  projectId: Scalars['ID']['input'];
};

/** The isFavourite of the entityId of type entityType you want to update, and the new value you want to set it to */
export type JiraSetIsFavouriteInput = {
  /**
   * ARI of the entity the ordered before the position the selectedEntity is being moved to. beforeEntity can be null when
   * there is no before entity (i.e. favourite is ordered at the end of the list) or the favourite is being removed.
   */
  beforeEntityId?: InputMaybe<Scalars['ID']['input']>;
  /** ARI of the Atlassian entity to be modified */
  entityId: Scalars['ID']['input'];
  /** The new value to set */
  isFavourite: Scalars['Boolean']['input'];
};

/** The input type for settings deployment apps property of a JSW project. */
export type JiraSetProjectSelectedDeploymentAppsPropertyInput = {
  /** Deployment apps to set */
  deploymentApps?: InputMaybe<Array<JiraDeploymentAppInput>>;
  /** ARI of the project to set the property on */
  projectId: Scalars['ID']['input'];
};

/**
 * Input for when the shareable entity is intended to be shared with all users on a Jira instance
 * and anonymous users.
 */
export type JiraShareableEntityAnonymousAccessGrantInput = {
  /** JiraShareableEntityGrant ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * Input for when the shareable entity is intended to be shared with all users on a Jira instance
 * and NOT anonymous users.
 */
export type JiraShareableEntityAnyLoggedInUserGrantInput = {
  /** JiraShareableEntityGrant ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** Input type for JiraShareableEntityEditGrants. */
export type JiraShareableEntityEditGrantInput = {
  /** User group that will be granted permission. */
  group?: InputMaybe<JiraShareableEntityGroupGrantInput>;
  /** Members of the specifid project will be granted permission. */
  project?: InputMaybe<JiraShareableEntityProjectGrantInput>;
  /** Users with the specified role in the project will be granted permission. */
  projectRole?: InputMaybe<JiraShareableEntityProjectRoleGrantInput>;
  /** User that will be granted permission. */
  user?: InputMaybe<JiraShareableEntityUserGrantInput>;
};

/** The grant types to share or edit ShareableEntities. */
export enum JiraShareableEntityGrant {
  /** The anonymous access represents the public access without logging in. */
  AnonymousAccess = 'ANONYMOUS_ACCESS',
  /** Any user who has the product access. */
  AnyLoggedinUserApplicationRole = 'ANY_LOGGEDIN_USER_APPLICATION_ROLE',
  /**
   * A group is a collection of users who can be given access together.
   * It represents group in the organization's user base.
   */
  Group = 'GROUP',
  /** A project or a role that user can play in a project. */
  Project = 'PROJECT',
  /** A project or a role that user can play in a project. */
  ProjectRole = 'PROJECT_ROLE',
  /**
   * Indicates that the user does not have access to the project
   * the members of which have been granted permission.
   */
  ProjectUnknown = 'PROJECT_UNKNOWN',
  /** An individual user who can be given the access to work on one or more projects. */
  User = 'USER'
}

/** Input for the group that will be granted permission. */
export type JiraShareableEntityGroupGrantInput = {
  /** ID of the user group */
  groupId: Scalars['ID']['input'];
  /** JiraShareableEntityGrant ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** Input for the project ID, members of which will be granted permission. */
export type JiraShareableEntityProjectGrantInput = {
  /** JiraShareableEntityGrant ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** ARI of the project in the format `ari:cloud:jira:{siteId}:project/{projectId}`. */
  projectId: Scalars['ID']['input'];
};

/**
 * Input for the id of the role.
 * Users with the specified role will be granted permission.
 */
export type JiraShareableEntityProjectRoleGrantInput = {
  /** JiraShareableEntityGrant ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** ARI of the project in the format `ari:cloud:jira:{siteId}:project/{projectId}`. */
  projectId: Scalars['ID']['input'];
  /** Tenant local roleId. */
  projectRoleId: Scalars['Int']['input'];
};

/** Input type for JiraShareableEntityShareGrants. */
export type JiraShareableEntityShareGrantInput = {
  /** All users with access to the instance and anonymous users will be granted permission. */
  anonymousAccess?: InputMaybe<JiraShareableEntityAnonymousAccessGrantInput>;
  /** All users with access to the instance will be granted permission. */
  anyLoggedInUser?: InputMaybe<JiraShareableEntityAnyLoggedInUserGrantInput>;
  /** User group that will be granted permission. */
  group?: InputMaybe<JiraShareableEntityGroupGrantInput>;
  /** Members of the specified project will be granted permission. */
  project?: InputMaybe<JiraShareableEntityProjectGrantInput>;
  /** Users with the specified role in the project will be granted permission. */
  projectRole?: InputMaybe<JiraShareableEntityProjectRoleGrantInput>;
  /** User that will be granted permission. */
  user?: InputMaybe<JiraShareableEntityUserGrantInput>;
};

/** Input for user that will be granted permission. */
export type JiraShareableEntityUserGrantInput = {
  /** JiraShareableEntityGrant ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** ARI of the user in the form of ARI: ari:cloud:identity::user/{userId}. */
  userId: Scalars['ID']['input'];
};

export type JiraShortcutDataInput = {
  /** The name identifying this shortcut. */
  name: Scalars['String']['input'];
  /** The url link of this shortcut. */
  url: Scalars['String']['input'];
};

/** Input type for single group picker field */
export type JiraSingleGroupPickerFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Group value for the field */
  group: JiraGroupInput;
};

/** Input type for defining the operation on the SingleGroupPicker field of a Jira issue. */
export type JiraSingleGroupPickerFieldOperationInput = {
  /**
   * Group Id for field update.
   * Accepts ARI: group
   */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Operation supported: SET. */
  operation: JiraSingleValueFieldOperations;
};

/** Input for single line text fields like summary */
export type JiraSingleLineTextFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Single line text input on which the action will be performed */
  text?: InputMaybe<Scalars['String']['input']>;
};

export type JiraSingleLineTextFieldOperationInput = {
  operation: JiraSingleValueFieldOperations;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for single select field */
export type JiraSingleSelectFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Option on which the action will be performed */
  option: JiraSelectedOptionInput;
};

export type JiraSingleSelectOperationInput = {
  /** Accepts ARI(s): issue-field-option */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Input type for single select user picker fields */
export type JiraSingleSelectUserPickerFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Input data for user being selected */
  user: JiraUserInput;
};

export type JiraSingleSelectUserPickerFieldOperationInput = {
  /** Accepts ARI(s): user */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Operations that can be performed on single value fields like date, date time, etc. */
export enum JiraSingleValueFieldOperations {
  /** Overrides single value field. */
  Set = 'SET'
}

/** Input type for single select version picker fields */
export type JiraSingleVersionPickerFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Version field on which the action will be performed */
  version: JiraVersionInput;
};

/** Input type for defining the operation on the SingleVersionPicker field of a Jira issue. */
export type JiraSingleVersionPickerFieldOperationInput = {
  /** Accepts ARI(s): version */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Operation supported: SET. */
  operation: JiraSingleValueFieldOperations;
};

/** Custom input definition for Jira Software issue search. */
export type JiraSoftwareIssueSearchCustomInput = {
  /** Additional JQL clause that can be added to the search (e.g. 'AND <additionalJql>') */
  additionalJql?: InputMaybe<Scalars['String']['input']>;
  /** Additional context for issue search, optionally constraining the returned issues */
  context?: InputMaybe<JiraSoftwareIssueSearchCustomInputContext>;
  /**
   * The Jira entity ARI of the object to constrain search to.
   * Currently only supports board ARI.
   */
  jiraEntityId: Scalars['ID']['input'];
};

/**
 * Additional context for Jira Software custom issue search, optionally constraining the search
 * by adding additional clauses to the search query.
 */
export enum JiraSoftwareIssueSearchCustomInputContext {
  /** Search is constrained to issues visible on backlogs */
  Backlog = 'BACKLOG',
  /** Search is constrained to issues visible on boards */
  Board = 'BOARD',
  /** No additional visibility constraints are applied to the search */
  None = 'NONE'
}

/** Types of Jira built in jira pages available for navigation */
export enum JiraSoftwareSimpleNavigationItemEnum {
  /** @deprecated Replaced by JiraNavigationItemTypeKey.BACKLOG */
  JswBacklog = 'JSW_BACKLOG',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.BOARD */
  JswBoard = 'JSW_BOARD',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.CALENDAR */
  JswCalendar = 'JSW_CALENDAR',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.CODE */
  JswCode = 'JSW_CODE',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.COMPONENTS */
  JswComponents = 'JSW_COMPONENTS',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.DEPLOYMENTS */
  JswDeployments = 'JSW_DEPLOYMENTS',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.GOALS */
  JswGoals = 'JSW_GOALS',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.INCIDENTS */
  JswIncidents = 'JSW_INCIDENTS',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.ISSUES */
  JswIssues = 'JSW_ISSUES',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.LIST */
  JswList = 'JSW_LIST',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.ON_CALL */
  JswOnCall = 'JSW_ON_CALL',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.PAGES */
  JswPages = 'JSW_PAGES',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.RELEASES */
  JswReleases = 'JSW_RELEASES',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.REPORTS */
  JswReports = 'JSW_REPORTS',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.REQUESTS */
  JswRequests = 'JSW_REQUESTS',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.SECURITY */
  JswSecurity = 'JSW_SECURITY',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.SHORTCUTS */
  JswShortcuts = 'JSW_SHORTCUTS',
  /** @deprecated Replaced by JiraNavigationItemTypeKey.TIMELINE */
  JswTimeline = 'JSW_TIMELINE'
}

/** Input type for sprint field */
export type JiraSprintFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List of sprints on which the action will be performed */
  sprints: Array<JiraSprintInput>;
};

export type JiraSprintFieldOperationInput = {
  /** Accepts ARI(s): sprint */
  id?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Accepts operation type and sprintId.
   * The sprintId is optional, in case of a missing sprintId the sprint field will be cleared.
   */
  operation: JiraSingleValueFieldOperations;
};

export type JiraSprintFilterInput = {
  /**
   * The active window to filter the Sprints to.
   * The window bounds are equivalent to filtering Sprints where (startDate > start AND startDate < end)
   * OR if sprint is completed (completionDate > start AND completionDate < end),
   * otherwise if sprint isn't completed (endDate > start AND < endDate < end).
   * If no start or end is provided, the window is considered unbounded in that direction.
   */
  activeWithin?: InputMaybe<JiraDateTimeWindow>;
  /**
   * The Board ids to filter Sprints to.
   * A Sprint is considered to be in a Board if it is associated with that board directly
   * or if it is associated with an Issue that is part of the Board's saved filter.
   */
  boardIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The Project ids to filter Sprints to.
   * A Sprint is considered to be in a Project if it is associated with a board that is associated with the Project
   * or if it is associated with an Issue that is associated with the Project.
   */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The raw Project keys to filter Sprints to.
   * A Sprint is considered to be in a Project if it is associated with a board that is associated with the Project
   * or if it is associated with an Issue that is associated with the Project.
   */
  projectKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The state of the Sprints to filter to. */
  states?: InputMaybe<Array<JiraSprintState>>;
};

/** Input type for sprints */
export type JiraSprintInput = {
  /** An identifier for the sprint */
  sprintId: Scalars['ID']['input'];
};

/** Represents the state of the sprint. */
export enum JiraSprintState {
  /** The sprint is in progress. */
  Active = 'ACTIVE',
  /** The sprint has been completed. */
  Closed = 'CLOSED',
  /** The sprint hasn't been started yet. */
  Future = 'FUTURE'
}

export type JiraSprintUpdateInput = {
  /** End date of the sprint */
  endDate?: InputMaybe<Scalars['String']['input']>;
  /** The id of the sprint that needs to be updated */
  sprintId: Scalars['ID']['input'];
  /** Start date of the sprint */
  startDate?: InputMaybe<Scalars['String']['input']>;
};

/** Color of the status category. */
export enum JiraStatusCategoryColor {
  /** #4a6785 */
  BlueGray = 'BLUE_GRAY',
  /** #815b3a */
  Brown = 'BROWN',
  /** #14892c */
  Green = 'GREEN',
  /** #707070 */
  MediumGray = 'MEDIUM_GRAY',
  /** #d04437 */
  WarmRed = 'WARM_RED',
  /** #f6c342 */
  Yellow = 'YELLOW'
}

export type JiraStoryPointEstimateFieldOperationInput = {
  operation: JiraSingleValueFieldOperations;
  /** Only positive storypoint and null are allowed */
  storyPoint?: InputMaybe<Scalars['Float']['input']>;
};

/** This is an input argument client will have to give in order to perform bulk edit submit */
export type JiraSubmitBulkOperationInput = {
  /** Payload provided to perform the bulk operation */
  bulkOperationInput: JiraBulkOperationInput;
  /** Represents the type of bulk operation */
  bulkOperationType: JiraBulkOperationType;
};

/** The type representing the status of the suggest child issues feature */
export enum JiraSuggestedChildIssueStatusType {
  /** The feature has completed its work and the stream is finished */
  Complete = 'COMPLETE',
  /** The service is refining suggested issues based on the user's additional context prompt */
  RefiningSuggestedIssues = 'REFINING_SUGGESTED_ISSUES',
  /** The service is reformatting the suggested issues to the standard format for their issue type */
  ReformattingIssues = 'REFORMATTING_ISSUES',
  /**
   * The service is removing issues that are semantically similar to existing child issues or issues provided in
   * excludeSimilarIssues argument
   */
  RemovingDuplicateIssues = 'REMOVING_DUPLICATE_ISSUES',
  /** The service is retrieving context for the source issue from the DB */
  RetrievingSourceContext = 'RETRIEVING_SOURCE_CONTEXT',
  /** The service is generating suggestions for child issues based on the source issue context */
  SuggestingInitialIssues = 'SUGGESTING_INITIAL_ISSUES'
}

/** Represents the different types of errors that will be returned by the suggest child issues feature */
export enum JiraSuggestedIssueErrorType {
  /** There are communication problems with downstream services used by the feature. */
  CommunicationsError = 'COMMUNICATIONS_ERROR',
  /** The source issue did not contain enough information to suggest any quality child issues */
  NotEnoughInformation = 'NOT_ENOUGH_INFORMATION',
  /**
   * All quality child issues have already been suggested by the issues.  Generally this indicates that all viable child
   * issues have already been added to the issue
   */
  NoFurtherSuggestions = 'NO_FURTHER_SUGGESTIONS',
  /** A general catch all for other types of errors encountered while suggesting child issues. */
  Unclassified = 'UNCLASSIFIED',
  /** The feature has deemed the content in the source issue to be unethical and will not suggest child issues. */
  UnethicalContent = 'UNETHICAL_CONTENT'
}

export enum JiraSuggestedIssueFieldValueError {
  /** We don't support issue which has required field yet */
  HaveRequiredField = 'HAVE_REQUIRED_FIELD',
  /** We don't support issue which is sub-task */
  IsSubTask = 'IS_SUB_TASK',
  /** The LLM responded that it does not have enough information to suggest any issues */
  NotEnoughInformation = 'NOT_ENOUGH_INFORMATION',
  /**
   * The LLM response that it has no further suggestions, generally this indicates that all viable child issues
   * have already been added to the issue
   */
  NoFurtherSuggestions = 'NO_FURTHER_SUGGESTIONS',
  /** We don't support suggestion if feature is not enabled (ie not opt-in to ai, etc) */
  SuggestionIsNotEnabled = 'SUGGESTION_IS_NOT_ENABLED',
  /**
   * A general catch all for other types of errors. This will not be generated by the LLM, but used for invalid LLM
   * responses
   */
  Unclassified = 'UNCLASSIFIED'
}

/**
 * Represents an issue supplied to the suggest child issues feature to prevent semantically similar issues from being
 * suggested
 */
export type JiraSuggestedIssueInput = {
  /** The description of the issue */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The summary of the issue */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for team field */
export type JiraTeamFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Represents a team field */
  team: JiraTeamInput;
};

export type JiraTeamFieldOperationInput = {
  /** Accept ARI(s): team */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Input type for team data */
export type JiraTeamInput = {
  /** An identifier for the team */
  teamId: Scalars['ID']['input'];
};

/** Different time formats supported for entering & displaying time tracking related data. */
export enum JiraTimeFormat {
  /** E.g. 2d 4.5h */
  Days = 'DAYS',
  /** E.g. 52.5h */
  Hours = 'HOURS',
  /** E.g. 2 days, 4 hours, 30 minutes */
  Pretty = 'PRETTY'
}

/** Input for TimeTracking field */
export type JiraTimeTrackingFieldInput = {
  /** Represents the original time tracking estimate */
  originalEstimate?: InputMaybe<Scalars['String']['input']>;
  /** Represents the remaining time tracking estimate */
  timeRemaining?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Different time units supported for entering & displaying time tracking related data.
 * Get the currently configured default duration to use when parsing duration string for time tracking.
 */
export enum JiraTimeUnit {
  /** When the current duration is in days. */
  Day = 'DAY',
  /** When the current duration is in hours. */
  Hour = 'HOUR',
  /** When the current duration is in minutes. */
  Minute = 'MINUTE',
  /** When the current duration is in weeks. */
  Week = 'WEEK'
}

/** Input type for transition screen when fields have to be edited */
export type JiraTransitionScreenInput = {
  /** Info of the fields which are edited on transition screen */
  editedFieldsInput: JiraIssueFieldsInput;
  /** Set of fields edited on the transition screen. */
  selectedActions?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Enum representing different sort options for transitions. */
export enum JiraTransitionSortOption {
  OpsBar = 'OPS_BAR',
  OpsBarThenStatusCategory = 'OPS_BAR_THEN_STATUS_CATEGORY'
}

export type JiraUiModificationsContextInput = {
  issueTypeId?: InputMaybe<Scalars['ID']['input']>;
  portalId?: InputMaybe<Scalars['ID']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  requestTypeId?: InputMaybe<Scalars['ID']['input']>;
  viewType: JiraUiModificationsViewType;
};

export enum JiraUiModificationsViewType {
  Gic = 'GIC',
  IssueTransition = 'IssueTransition',
  IssueView = 'IssueView',
  JsmRequestCreate = 'JSMRequestCreate'
}

export type JiraUnlinkIssuesFromIncidentMutationInput = {
  /** The id of the JSM incident to have issues linked to it. */
  incidentId: Scalars['ID']['input'];
  /**
   * The ids of the issues to unlink from an incident. This can be a JSW issue as an
   * action item or a JSM issues as a post incident review.
   */
  issueIds: Array<Scalars['ID']['input']>;
};

/** Input for attributing Unsplash images */
export type JiraUnsplashAttributionInput = {
  /**  CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /**
   * The list of unsplash image filepaths to attribute. Returned by the sourceId field of JiraCustomBackground.
   * A maximum of 50 images can be attributed at once.
   */
  filePaths: Array<Scalars['ID']['input']>;
};

/**
 * The input for searching Unsplash images. Uses Unsplash's API definition for pagination
 * https://unsplash.com/documentation#parameters-16
 */
export type JiraUnsplashSearchInput = {
  /**  CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The page number, defaults to 1 */
  pageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** The page size, defaults to 10 */
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  /** The search query */
  query: Scalars['String']['input'];
  /** The requested width in pixels of the thumbnail image, default is 200px */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** Input type for updating the Affected Services(Service Entity) field of a Jira issue. */
export type JiraUpdateAffectedServicesFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on Affected Services field. */
  operation: JiraAffectedServicesFieldOperationInput;
};

/**
 * Input type for updating the Attachment field of a Jira issue.
 * Note: This schema is intended for GraphQL submit API only. It might not work with other Inline mutations
 */
export type JiraUpdateAttachmentFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on the Attachment field. */
  operation: JiraAttachmentFieldOperationInput;
};

/** The input for updating a Jira Background */
export type JiraUpdateBackgroundInput = {
  /** The type of background to update to */
  backgroundType: JiraBackgroundType;
  /**
   * The gradient/color if the background is a gradient/color type,
   * the customBackgroundId if the background is a custom (user uploaded) type, or
   * the image filePath if the background is from Unsplash
   */
  backgroundValue: Scalars['String']['input'];
  /** The entityId (ARI) of the entity to be updated */
  entityId: Scalars['ID']['input'];
};

export type JiraUpdateCascadingSelectFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraCascadingSelectFieldOperationInput;
};

/** Input type for updating the Checkboxes field of a Jira issue. */
export type JiraUpdateCheckboxesFieldInput = {
  /**  Accepts ARI(s): issuefieldvalue  */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Checkboxes field. */
  operations: Array<JiraCheckboxesFieldOperationInput>;
};

export type JiraUpdateColorFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraColorFieldOperationInput;
};

export type JiraUpdateComponentsFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operations: Array<JiraComponentFieldOperationInput>;
};

/** The input for updating a custom background */
export type JiraUpdateCustomBackgroundInput = {
  /** The new alt text */
  altText: Scalars['String']['input'];
  /**  CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The customBackgroundId of the custom background to update */
  customBackgroundId: Scalars['ID']['input'];
};

/** Input for updating a JiraCustomFilter. */
export type JiraUpdateCustomFilterDetailsInput = {
  /** A string containing filter description */
  description?: InputMaybe<Scalars['String']['input']>;
  /**
   * The list of edit grants for the filter. Edit Grants represent different ways that users have been granted access to edit the filter.
   * Empty array represents private edit grant.
   */
  editGrants: Array<InputMaybe<JiraShareableEntityEditGrantInput>>;
  /** ARI of the filter */
  id: Scalars['ID']['input'];
  /** A string representing the name of the filter */
  name: Scalars['String']['input'];
  /**
   * The list of share grants for the filter. Share Grants represent different ways that users have been granted access to the filter.
   * Empty array represents private share grant.
   */
  shareGrants: Array<InputMaybe<JiraShareableEntityShareGrantInput>>;
};

/** Input for updating the JQL of a JiraCustomFilter. */
export type JiraUpdateCustomFilterJqlInput = {
  /** An ARI-format value that encodes the filterId. */
  id: Scalars['ID']['input'];
  /** JQL associated with the filter */
  jql: Scalars['String']['input'];
};

export type JiraUpdateDataClassificationFieldInput = {
  /** Accepts ARI: issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Data Classification field. */
  operation: JiraDataClassificationFieldOperationInput;
};

export type JiraUpdateDateFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraDateFieldOperationInput;
};

export type JiraUpdateDateTimeFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraDateTimeFieldOperationInput;
};

export type JiraUpdateFieldSetPreferencesInput = {
  fieldSetId: Scalars['String']['input'];
  width?: InputMaybe<Scalars['Int']['input']>;
};

export type JiraUpdateForgeObjectFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraForgeObjectFieldOperationInput;
};

/** Input for update a formatting rule. */
export type JiraUpdateFormattingRuleInput = {
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** Content of this rule. */
  expression?: InputMaybe<JiraFormattingRuleExpressionInput>;
  /** Format type of this rule. */
  formatType?: InputMaybe<JiraFormattingArea>;
  /** Color to be applied if condition matches. */
  formattingColor?: InputMaybe<JiraColorInput>;
  /** The rule to update. */
  ruleId: Scalars['ID']['input'];
};

/** This is an input argument for updating the global notification preferences. */
export type JiraUpdateGlobalNotificationPreferencesInput = {
  /** A list of notification preferences to update. */
  preferences: Array<JiraNotificationPreferenceInput>;
};

/**
 * Input type for updating the IssueLink field of a Jira issue.
 * Note: This schema is intended for GraphQL submit API only. It might not work with other Inline mutations
 */
export type JiraUpdateIssueLinkFieldInputForIssueTransitions = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on the IssueLink field. */
  operation: JiraIssueLinkFieldOperationInputForIssueTransitions;
};

/** Input type for performing a transition for the issue */
export type JiraUpdateIssueTransitionInput = {
  /** Jira Comment for Issue Transition */
  comment?: InputMaybe<JiraIssueTransitionCommentInput>;
  /** This contains list of all field level inputs, that may be required for mutation */
  fieldInputs?: InputMaybe<JiraIssueTransitionFieldLevelInput>;
  /**
   * Unique identifier for the issue
   * Accepts ARI(s): issue
   */
  issueId: Scalars['ID']['input'];
  /** Identifier for the transition to be performed */
  transitionId: Scalars['Int']['input'];
};

/** Input type for updating the IssueType field of a Jira issue. */
export type JiraUpdateIssueTypeFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the IssueType field. */
  operation: JiraIssueTypeFieldOperationInput;
};

export type JiraUpdateJourneyActivityConfigurationInput = {
  /** List of new activity configuration */
  createActivityConfigurations?: InputMaybe<Array<InputMaybe<JiraCreateActivityConfigurationInput>>>;
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
  /** The version number of the entity. */
  version: Scalars['Long']['input'];
};

export type JiraUpdateJourneyConfigurationInput = {
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
  /** Name of the journey configuration */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Parent issue of the journey configuration */
  parentIssue?: InputMaybe<JiraJourneyParentIssueInput>;
  /** The trigger of this journey */
  trigger?: InputMaybe<JiraJourneyTriggerInput>;
  /** The version number of the entity. */
  version: Scalars['Long']['input'];
};

export type JiraUpdateLabelsFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operations: Array<JiraLabelsFieldOperationInput>;
};

/** Input type for updating the Team field of a Jira issue. */
export type JiraUpdateLegacyTeamFieldInput = {
  /**  Accepts ARI(s): issuefieldvalue  */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Team field. */
  operation: JiraLegacyTeamFieldOperationInput;
};

/** Input type for updating the MultipleGroupPicker field of a Jira issue. */
export type JiraUpdateMultipleGroupPickerFieldInput = {
  /** Accepts ARI: issuefieldvalue. */
  id: Scalars['ID']['input'];
  /** The operation to be performed on MultipleGroupPicker field. */
  operations: Array<JiraMultipleGroupPickerFieldOperationInput>;
};

export type JiraUpdateMultipleSelectFieldInput = {
  /**  Accepts ARI(s): issuefieldvalue  */
  id: Scalars['ID']['input'];
  operations: Array<JiraMultipleSelectFieldOperationInput>;
};

/** Input type for updating the MultipleSelectUserPicker field of a Jira issue. */
export type JiraUpdateMultipleSelectUserPickerFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on MultipleSelectUserPicker field. */
  operations: Array<JiraMultipleSelectUserPickerFieldOperationInput>;
};

/** Input type for updating the Multiple Version Picker field of a Jira issue. */
export type JiraUpdateMultipleVersionPickerFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on Multiple Version Picker field. */
  operations: Array<JiraMultipleVersionPickerFieldOperationInput>;
};

/** This is an input argument for updating the notification options */
export type JiraUpdateNotificationOptionsInput = {
  /** Indicates the idle time for emails awaiting changes per issue, multiple emails within this time are consolidated and sent together in a single batched email */
  batchWindow?: InputMaybe<JiraBatchWindowPreference>;
  /** Indicates the local time to receive email notifications if user has chosen once-per-day email batching */
  dailyBatchLocalTime?: InputMaybe<Scalars['String']['input']>;
  /** The updated email MIME type preference that we wish to persist. */
  emailMimeType?: InputMaybe<JiraEmailMimeType>;
  /** Whether or not email notifications are enabled for this user. */
  isEmailNotificationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not to notify user for there own actions. */
  notifyOwnChangesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not notify when user is assignee on issue. */
  notifyWhenRoleAssigneeEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not notify when user is reporter on issue. */
  notifyWhenRoleReporterEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type JiraUpdateNumberFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraNumberFieldOperationInput;
};

/**
 * Mutation input used to update the changeboarding status of the current user in the context of the overview-plan
 * migration.
 */
export type JiraUpdateOverviewPlanMigrationChangeboardingInput = {
  /** Status of the changeboarding to be updated. */
  changeboardingStatus: JiraOverviewPlanMigrationChangeboardingStatus;
  /** ID of the tenant this mutation input is for. Only used for AGG tenant routing, ignored otherwise. */
  cloudId: Scalars['ID']['input'];
};

/** Input type for updating the Parent field of a Jira issue. */
export type JiraUpdateParentFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Parent field. */
  operation: JiraParentFieldOperationInput;
};

/** Input type for updating the People field of a Jira issue. */
export type JiraUpdatePeopleFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on People field. */
  operations: Array<JiraPeopleFieldOperationInput>;
};

export type JiraUpdatePriorityFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraPriorityFieldOperationInput;
};

export type JiraUpdateProjectFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraProjectFieldOperationInput;
};

/** This is the input argument for updating project notification preferences. */
export type JiraUpdateProjectNotificationPreferencesInput = {
  /** A list of notification preferences to update. */
  preferences: Array<JiraNotificationPreferenceInput>;
  /** The ARI of the project for which the notification preferences are to be updated. */
  projectId: Scalars['ID']['input'];
};

export type JiraUpdateRadioSelectFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraRadioSelectFieldOperationInput;
};

/** The input for updating the release notes configuration options for a version */
export type JiraUpdateReleaseNotesConfigurationInput = {
  /** The ARI of the version to update the release notes configuration for */
  id: Scalars['ID']['input'];
  /** The ARIs of issue fields(issue-field-meta ARI) to include when generating release notes */
  issueFieldIds: Array<Scalars['ID']['input']>;
  /** The issue key config to include when generating release notes */
  issueKeyConfig: JiraReleaseNotesIssueKeyConfig;
  /** The ARIs of issue types(issue-type ARI) to include when generating release notes */
  issueTypeIds: Array<Scalars['ID']['input']>;
};

/** Input type for updating the Resolution field of a Jira issue. */
export type JiraUpdateResolutionFieldInput = {
  /**  Accepts ARI(s): issuefieldvalue  */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Resolution field. */
  operation: JiraResolutionFieldOperationInput;
};

export type JiraUpdateRichTextFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraRichTextFieldOperationInput;
};

/** Input type for updating the Security Level field of a Jira issue. */
export type JiraUpdateSecurityLevelFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Security Level field. */
  operation: JiraSecurityLevelFieldOperationInput;
};

export type JiraUpdateShortcutInput = {
  /** ARI of the project the shortcut is belongs to. */
  projectId: Scalars['ID']['input'];
  /** Data of shortcut being updated */
  shortcutData: JiraShortcutDataInput;
  /** ARI of the shortcut */
  shortcutId: Scalars['ID']['input'];
};

/** Input type for updating the SingleGroupPicker field of a Jira issue. */
export type JiraUpdateSingleGroupPickerFieldInput = {
  /** Accepts ARI: issuefieldvalue. */
  id: Scalars['ID']['input'];
  /** The operation to be performed on SingleGroupPicker field. */
  operation: JiraSingleGroupPickerFieldOperationInput;
};

export type JiraUpdateSingleLineTextFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraSingleLineTextFieldOperationInput;
};

export type JiraUpdateSingleSelectFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraSingleSelectOperationInput;
};

export type JiraUpdateSingleSelectUserPickerFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraSingleSelectUserPickerFieldOperationInput;
};

/** Input type for updating the SingleVersionPicker field of a Jira issue. */
export type JiraUpdateSingleVersionPickerFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to be performed on SingleVersionPicker field. */
  operation: JiraSingleVersionPickerFieldOperationInput;
};

export type JiraUpdateSprintFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraSprintFieldOperationInput;
};

export type JiraUpdateStatusFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** Accepts Transition actionId as input */
  statusTransitionId: Scalars['Int']['input'];
};

export type JiraUpdateStoryPointEstimateFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraStoryPointEstimateFieldOperationInput;
};

export type JiraUpdateTeamFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraTeamFieldOperationInput;
};

export type JiraUpdateTimeTrackingFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /**
   * Provide `null` to keep originalEstimate unchanged.
   *
   * Note: Setting originalEstimate when both originalEstimate & remainingEstimate are null, will also set
   * remainingEstimate to the value provided for originalEstimate.
   */
  originalEstimate?: InputMaybe<JiraEstimateInput>;
  /** Provide `null` to keep remainingEstimate unchanged. */
  remainingEstimate?: InputMaybe<JiraEstimateInput>;
};

export type JiraUpdateUrlFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraUrlFieldOperationInput;
};

export type JiraUpdateUserNavigationConfigurationInput = {
  /** The identifier that indicates that cloud instance this data is to be fetched for */
  cloudID: Scalars['ID']['input'];
  /**
   * A list of all the navigation items that the user has configured for this navigation section.
   * The order of the items in this list is the order in which they will be stored in the database.
   */
  navItems: Array<JiraConfigurableNavigationItemInput>;
  /** The uniques key describing the particular navigation section. */
  navKey: Scalars['String']['input'];
};

/** Input to update whether a version is archived or not. */
export type JiraUpdateVersionArchivedStatusInput = {
  /** The identifier for the Jira version. */
  id: Scalars['ID']['input'];
  /** Boolean that indicates if the version is archived. */
  isArchived: Scalars['Boolean']['input'];
};

/** Input to update the version description. */
export type JiraUpdateVersionDescriptionInput = {
  /** Version description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The identifier of the Jira version. */
  id: Scalars['ID']['input'];
};

/** Input shape to update(set/unset) Driver of a Jira Version */
export type JiraUpdateVersionDriverInput = {
  /** Atlassian Account ID (AAID) of the driver of the version. */
  driver?: InputMaybe<Scalars['ID']['input']>;
  /** Version ARI */
  id: Scalars['ID']['input'];
};

/** Input to update the version name. */
export type JiraUpdateVersionNameInput = {
  /** The identifier of the Jira version. */
  id: Scalars['ID']['input'];
  /** Version name. */
  name: Scalars['String']['input'];
};

/**
 * Input to update the version's sequence, which affects the version's
 * position and display order relative to other versions in the project.
 */
export type JiraUpdateVersionPositionInput = {
  /** The ID of the version preceding the version being updated. */
  afterVersionId: Scalars['ID']['input'];
  /** The identifier of the Jira version being updated. */
  id: Scalars['ID']['input'];
};

/**
 * Input to update/edit a related work item's title/URL/category.
 *
 * Only applicable for "generic link" work items.
 */
export type JiraUpdateVersionRelatedWorkGenericLinkInput = {
  /** The new related work item category. */
  category: Scalars['String']['input'];
  /** The identifier for the related work item. */
  relatedWorkId: Scalars['ID']['input'];
  /** The new related work title (can be null only if a `url` was given). */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The new URL for the related work item (pass `null` to make the item a placeholder). */
  url?: InputMaybe<Scalars['URL']['input']>;
  /** The identifier for the Jira version the work item lives in. */
  versionId: Scalars['ID']['input'];
};

/** Input to update the version release date. */
export type JiraUpdateVersionReleaseDateInput = {
  /** The identifier of the Jira version. */
  id: Scalars['ID']['input'];
  /** The date at which the version was released to customers. Must occur after startDate. */
  releaseDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Input to update whether a version is released or not. */
export type JiraUpdateVersionReleasedStatusInput = {
  /** The identifier for the Jira version. */
  id: Scalars['ID']['input'];
  /** Boolean that indicates if the version is released. */
  isReleased: Scalars['Boolean']['input'];
};

/** Input to update the rich text section's title for a given version */
export type JiraUpdateVersionRichTextSectionContentInput = {
  /** The rich text section's content in ADF */
  content?: InputMaybe<Scalars['JSON']['input']>;
  /** The identifier of the Jira version. */
  id: Scalars['ID']['input'];
};

/** Input to update the rich text section's title for a given version */
export type JiraUpdateVersionRichTextSectionTitleInput = {
  /** The identifier of the Jira version. */
  id: Scalars['ID']['input'];
  /** The rich text section's title. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Input to update the version start date. */
export type JiraUpdateVersionStartDateInput = {
  /** The identifier of the Jira version. */
  id: Scalars['ID']['input'];
  /** The date at which work on the version began. */
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** The input to update the version details page warning report. */
export type JiraUpdateVersionWarningConfigInput = {
  /** The ARI of the Jira project. */
  jiraProjectId: Scalars['ID']['input'];
  /** The version configuration options to be updated. */
  updatedVersionWarningConfig: JiraVersionUpdatedWarningConfigInput;
};

export type JiraUpdateViewConfigInput = {
  /** The field id for the end date field */
  endDateFieldId?: InputMaybe<Scalars['String']['input']>;
  /**
   * viewId is the unique identifier for the view: ari:cloud:jira:{siteId}:view/activation/{activationId}/{scopeType}/{scopeId}
   * https://developer.atlassian.com/platform/atlassian-resource-identifier/resource-owners/registry/#ati%3Acloud%3Ajira%3Aview
   */
  id: Scalars['ID']['input'];
  /** The field id for the start date field */
  startDateFieldId?: InputMaybe<Scalars['String']['input']>;
};

export type JiraUpdateVotesFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraVotesFieldOperationInput;
};

export type JiraUpdateWatchesFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraWatchesFieldOperationInput;
};

/**
 * Input type for updating the Worklog field of a Jira issue.
 * Note: This schema is intended for GraphQL submit API only. It will not work with other Inline mutations
 */
export type JiraUpdateWorklogFieldInputForIssueTransitions = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on the Worklog field. */
  operation: JiraWorklogFieldOperationInputForIssueTransitions;
};

/** Input type for url field */
export type JiraUrlFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Represents a url on which the action will be performed */
  url: Scalars['String']['input'];
};

export type JiraUrlFieldOperationInput = {
  operation: JiraSingleValueFieldOperations;
  uri?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for user field input */
export type JiraUserFieldInput = {
  fieldId: Scalars['ID']['input'];
  user?: InputMaybe<JiraUserInput>;
};

/** Input type for user field */
export type JiraUserInput = {
  /** ARI representing the user */
  accountId: Scalars['ID']['input'];
};

export type JiraVersionAddApproverInput = {
  /** Atlassian Account ID (AAID) of approver. */
  approverAccountId: Scalars['ID']['input'];
  /** Version ARI */
  versionId: Scalars['ID']['input'];
};

/** The status of an Approver task in the version */
export enum JiraVersionApproverStatus {
  /** Indicates the task has been approved */
  Approved = 'APPROVED',
  /** Indicates the task has been declined */
  Declined = 'DECLINED',
  /** Indicates the task is yet to be approved or rejected */
  Pending = 'PENDING'
}

/** GraphQL input shape for creating new version */
export type JiraVersionCreateMutationInput = {
  /** Description of the version */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Atlassian Account ID (AAID) of the user who is the driver for the version */
  driver?: InputMaybe<Scalars['ID']['input']>;
  /** Name of the version. */
  name: Scalars['String']['input'];
  /** Project ID of the version */
  projectId: Scalars['ID']['input'];
  /** Release Date of the version */
  releaseDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Start Date of the version */
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** The section UI in version details page that are collapsed */
export enum JiraVersionDetailsCollapsedUi {
  Description = 'DESCRIPTION',
  Issues = 'ISSUES',
  IssueAssociatedDesigns = 'ISSUE_ASSOCIATED_DESIGNS',
  ProgressCard = 'PROGRESS_CARD',
  RelatedWork = 'RELATED_WORK',
  RichTextSection = 'RICH_TEXT_SECTION',
  RightSidebar = 'RIGHT_SIDEBAR'
}

export type JiraVersionDetailsCollapsedUisInput = {
  collapsedUis: Array<JiraVersionDetailsCollapsedUi>;
  versionId: Scalars['ID']['input'];
};

export type JiraVersionFilterInput = {
  /**
   * The active window to filter the Versions to.
   * The window bounds are equivalent to filtering Versions where (startDate > start AND startDate < end)
   * OR (releasedate > start AND releasedate < end)
   * If no start or end is provided, the window is considered unbounded in that direction.
   */
  activeWithin?: InputMaybe<JiraDateTimeWindow>;
  /** The Project ids to filter Versions to. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The raw Project keys to filter Versions to. */
  projectKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Versions that have name match this search string will be returned. */
  searchString?: InputMaybe<Scalars['String']['input']>;
  /** The statuses of the Versions to filter to. */
  statuses?: InputMaybe<Array<InputMaybe<JiraVersionStatus>>>;
};

/** Input for Versions values on fields */
export type JiraVersionInput = {
  /** Unique identifier for version field */
  versionId?: InputMaybe<Scalars['ID']['input']>;
};

/** The table column enum of version details page. */
export enum JiraVersionIssueTableColumn {
  /** build status column */
  BuildStatus = 'BUILD_STATUS',
  /** deployment status column (either from Bamboo or other providers) */
  DeploymentStatus = 'DEPLOYMENT_STATUS',
  /** development status column */
  DevelopmentStatus = 'DEVELOPMENT_STATUS',
  /** feature flag status column */
  FeatureFlagStatus = 'FEATURE_FLAG_STATUS',
  /** Issue assignee column */
  IssueAssignee = 'ISSUE_ASSIGNEE',
  /** Priority column */
  IssuePriority = 'ISSUE_PRIORITY',
  /** Issue status column */
  IssueStatus = 'ISSUE_STATUS',
  /** More action meat ball menu column */
  MoreAction = 'MORE_ACTION',
  /** Warnings column */
  Warnings = 'WARNINGS'
}

export type JiraVersionIssueTableColumnHiddenStateInput = {
  /** The columns to hide */
  hiddenColumns: Array<JiraVersionIssueTableColumn>;
  /** Version ARI */
  versionId: Scalars['ID']['input'];
};

/** The filter for a version's issues */
export enum JiraVersionIssuesFilter {
  All = 'ALL',
  Done = 'DONE',
  FailingBuild = 'FAILING_BUILD',
  InProgress = 'IN_PROGRESS',
  OpenPullRequest = 'OPEN_PULL_REQUEST',
  OpenReview = 'OPEN_REVIEW',
  Todo = 'TODO',
  UnreviewedCode = 'UNREVIEWED_CODE'
}

export type JiraVersionIssuesFiltersInput = {
  /** Assignee field account ARIs to filter by. Null means, don't apply assignee filter. Null inside array means unassigned issues. */
  assigneeAccountIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Epic ARIs to filter by */
  epicIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Search string to filter by. This will search issue title, description, id and key. */
  searchStr?: InputMaybe<Scalars['String']['input']>;
  /** Status categories to filter by */
  statusCategories?: InputMaybe<Array<JiraVersionIssuesStatusCategories>>;
  /** Warning categories to filter by */
  warningCategories?: InputMaybe<Array<JiraVersionWarningCategories>>;
};

/** Fields that can be used to sort issues returned on the version. */
export enum JiraVersionIssuesSortField {
  /** Sort by assignee */
  Assignee = 'ASSIGNEE',
  /** Sort by date issue was created */
  Created = 'CREATED',
  /** Sort by issue key */
  Key = 'KEY',
  /** Sort by priority */
  Priority = 'PRIORITY',
  /** Sort by status */
  Status = 'STATUS',
  /** Sort by type */
  Type = 'TYPE'
}

/** The sort criteria used for a version's issues */
export type JiraVersionIssuesSortInput = {
  order?: InputMaybe<SortDirection>;
  sortByField?: InputMaybe<JiraVersionIssuesSortField>;
};

export enum JiraVersionIssuesStatusCategories {
  /** Issue status done category */
  Done = 'DONE',
  /** Issue status in-progress category */
  InProgress = 'IN_PROGRESS',
  /** Issue status todo category */
  Todo = 'TODO'
}

/** Enumeration of the kinds of Jira version related work items. */
export enum JiraVersionRelatedWorkType {
  /** A related work item that links to the version's release notes in a Confluence page. */
  ConfluenceReleaseNotes = 'CONFLUENCE_RELEASE_NOTES',
  /** The most general kind of related work item - an arbitrary link/URL. */
  GenericLink = 'GENERIC_LINK',
  /**
   * A related work item that represents the "native" release notes for the version. These release notes are
   * generated dynamically, and there is at most one per version.
   */
  NativeReleaseNotes = 'NATIVE_RELEASE_NOTES'
}

/** The input for fetching a preview of the release notes */
export type JiraVersionReleaseNotesConfigurationInput = {
  /** The ids of issue fields to include when generating release notes */
  issueFieldIds: Array<Scalars['ID']['input']>;
  /** The issue key config to include when generating release notes */
  issueKeyConfig: JiraReleaseNotesIssueKeyConfig;
  /** The ids of issue types to include when generating release notes */
  issueTypeIds: Array<Scalars['ID']['input']>;
};

/** Types of Release Notes that are available */
export enum JiraVersionReleaseNotesType {
  /** Represents a Release Note generated in Confluence */
  ConfluenceReleaseNote = 'CONFLUENCE_RELEASE_NOTE',
  /** Represents the standard html/markdown Release Note Type */
  NativeReleaseNote = 'NATIVE_RELEASE_NOTE'
}

/** The argument for sorting project versions. */
export enum JiraVersionSortField {
  Description = 'DESCRIPTION',
  Name = 'NAME',
  ReleaseDate = 'RELEASE_DATE',
  Sequence = 'SEQUENCE',
  StartDate = 'START_DATE'
}

export type JiraVersionSortInput = {
  order: SortDirection;
  sortByField: JiraVersionSortField;
};

/** The status of a version field. */
export enum JiraVersionStatus {
  /** Indicates the version is archived, no further changes can be made to this version unless it is un-archived */
  Archived = 'ARCHIVED',
  /** Indicates the version is available to public */
  Released = 'RELEASED',
  /** Indicates the version is not launched yet */
  Unreleased = 'UNRELEASED'
}

export type JiraVersionUpdateApproverDeclineReasonInput = {
  /** Approver ARI to update decline reason */
  approverId: Scalars['ID']['input'];
  /** The new decline reason. Null means no reason saved, that is identical to empty string */
  reason?: InputMaybe<Scalars['String']['input']>;
};

/** The input to update approval description */
export type JiraVersionUpdateApproverDescriptionInput = {
  /** Approver ARI. */
  approverId: Scalars['ID']['input'];
  /** The description of the task to be approved. Null means empty description. */
  description?: InputMaybe<Scalars['String']['input']>;
};

/** The input to update approval status */
export type JiraVersionUpdateApproverStatusInput = {
  /** Approver ARI. */
  approverId: Scalars['ID']['input'];
  /** The status of the task */
  status?: InputMaybe<JiraVersionApproverStatus>;
};

/** GraphQL input shape for updating an entire(all fields) version object */
export type JiraVersionUpdateMutationInput = {
  /** Description of the version */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Atlassian Account ID (AAID) of the user who is the driver for the version */
  driver?: InputMaybe<Scalars['ID']['input']>;
  /** JiraVersion ARI. */
  id: Scalars['ID']['input'];
  /** Name of the version. */
  name: Scalars['String']['input'];
  /** Release Date of the version */
  releaseDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Start Date of the version */
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/**
 * The warning configuration to be updated for version details page warning report.
 * Applicable values will have their value updated. Null values will default to true.
 */
export type JiraVersionUpdatedWarningConfigInput = {
  /** The warnings for issues that has failing build and in done issue status category. */
  isFailingBuildEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The warnings for issues that has open pull request and in done issue status category. */
  isOpenPullRequestEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The warnings for issues that has open review(FishEye/Crucible integration) and in done issue status category. */
  isOpenReviewEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The warnings for issues that has unreviewed code and in done issue status category. */
  isUnreviewedCodeEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum JiraVersionWarningCategories {
  /** Category to list issues with failing build in the version */
  FailingBuild = 'FAILING_BUILD',
  /** Category to list issues with pull request still open in the version */
  OpenPullRequest = 'OPEN_PULL_REQUEST',
  /** Category to list issues with review(FishEye/Crucible specific entity) still open in the version */
  OpenReview = 'OPEN_REVIEW',
  /** Category to list issues with some code linked that is not reviewed in the version */
  UnreviewedCode = 'UNREVIEWED_CODE'
}

/** The warning config for version details page to generate warning report. Depending on tenant settings and providers installed, some warning config could be in NOT_APPLICABLE state. */
export enum JiraVersionWarningConfigState {
  Disabled = 'DISABLED',
  Enabled = 'ENABLED',
  NotApplicable = 'NOT_APPLICABLE'
}

/** Input for the view that can be shared across multiple products, i.e., Jira Calendar */
export type JiraViewScopeInput = {
  /** Combination of ARIs to fetch data from different entities. Supported ARIs now are project and board. */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Project keys provided as a way to fetch data relating to projects. */
  projectKeys?: InputMaybe<JiraProjectKeysInput>;
};

/** The reason why an extension shouldn't be visible in the given context. */
export enum JiraVisibilityControlMechanism {
  /** A Jira admin blocked the app from accessing the data in the given context using [App Access Rules](https://support.atlassian.com/security-and-access-policies/docs/block-app-access/). */
  AppAccessRules = 'AppAccessRules',
  /** The extension specified [Display Conditions](https://developer.atlassian.com/platform/forge/manifest-reference/display-conditions/) that evaluated to `false`. The app doesn't want the extension to be visible in the given context. */
  DisplayConditions = 'DisplayConditions'
}

export type JiraVotesFieldOperationInput = {
  operation: JiraVotesOperations;
};

/** Operations that can be performed on vote field. */
export enum JiraVotesOperations {
  /** Adds voter to an issue. */
  Add = 'ADD',
  /** Removes voter from an issue. */
  Remove = 'REMOVE'
}

export type JiraWatchesFieldOperationInput = {
  /**
   * Accepts ARI(s): user
   * The user is optional, in case of missing user the logged in user will be added/removed as a watcher.
   */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraWatchesOperations;
};

/** Operations that can be performed on watches field. */
export enum JiraWatchesOperations {
  /** Adds watcher to an issue. */
  Add = 'ADD',
  /** Removes watcher from an issue. */
  Remove = 'REMOVE'
}

/** The supported background types */
export enum JiraWorkManagementBackgroundType {
  Attachment = 'ATTACHMENT',
  Color = 'COLOR',
  Custom = 'CUSTOM',
  Gradient = 'GRADIENT'
}

/** Input for creating a Jira Work Management Custom Background */
export type JiraWorkManagementCreateCustomBackgroundInput = {
  /** The alt text associated with the custom background */
  altText: Scalars['String']['input'];
  /** The entityId (ARI) of the entity to be updated with the created background */
  entityId: Scalars['ID']['input'];
  /** The created mediaApiFileId of the background to create */
  mediaApiFileId: Scalars['String']['input'];
};

export type JiraWorkManagementCreateFilterInput = {
  /** ARI that encodes the ID of the project or project overview the filter was created on */
  contextId: Scalars['ID']['input'];
  /** JQL of filter to store */
  jql: Scalars['String']['input'];
  /** Name of filter to create */
  name: Scalars['String']['input'];
};

/** Represents the input data required for JWM issue creation. */
export type JiraWorkManagementCreateIssueInput = {
  /** Field data to populate the created issue with. Mandatory due to required fields such as Summary. */
  fields: JiraIssueFieldsInput;
  /** Issue type of issue to create in numeric format. E.g. 10000 */
  issueTypeId: Scalars['ID']['input'];
  /** Project to create issue within, encoded as an ARI */
  projectId: Scalars['ID']['input'];
  /** Rank Issue following creation */
  rank?: InputMaybe<JiraWorkManagementRankInput>;
  /** Transition Issue following creation in numeric format. E.g. 10000 */
  transitionId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input for creating a Jira Work Management Overview. */
export type JiraWorkManagementCreateOverviewInput = {
  /** Name of the Jira Work Management Overview. */
  name: Scalars['String']['input'];
  /** Project IDs (ARIs) to include in the created Jira Work Management Overview. */
  projectIds: Array<Scalars['ID']['input']>;
  /** Theme to set for the created Jira Work Management Overview. */
  theme?: InputMaybe<Scalars['String']['input']>;
};

/** Input for creating a saved view. */
export type JiraWorkManagementCreateSavedViewInput = {
  /** The label for the saved view, for display purposes. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** ARI of the project to create a saved view for. */
  projectId: Scalars['ID']['input'];
  /** The key of the type of the saved view. */
  typeKey: Scalars['String']['input'];
};

/** Represents the input data required for Jwm Delete Attachment mutation. */
export type JiraWorkManagementDeleteAttachmentInput = {
  /** The ARI of the attachment to be deleted */
  id: Scalars['ID']['input'];
};

/** The input for deleting a custom background */
export type JiraWorkManagementDeleteCustomBackgroundInput = {
  /** The identifier which indicates the cloud instance this data is to be fetched for */
  cloudId: Scalars['ID']['input'];
  /** The customBackgroundId of the custom background to delete */
  customBackgroundId: Scalars['ID']['input'];
};

/** Input for deleting a Jira Work Management Overview. */
export type JiraWorkManagementDeleteOverviewInput = {
  /** Global identifier (ARI) of the Jira Work Management Overview to delete. */
  id: Scalars['ID']['input'];
};

export type JiraWorkManagementFilterSearchInput = {
  /** An ARI of the context to search for filters by */
  contextId: Scalars['ID']['input'];
  /** Search for only favorite filters */
  favoritesOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Search by filter name. The string is broken into white-space delimited words and each word is
   * used as a OR'ed partial match for the filter name.  If this is null, the filters returned will not be filtered by name
   */
  keyword?: InputMaybe<Scalars['String']['input']>;
};

/** Represents the input data to rank an issue upon creation. */
export type JiraWorkManagementRankInput = {
  /**
   * ID of Issue after which the created issue should be ranked. Encoded as an ARI. Cannot be sent alongside before.
   * Accepts ARI(s): issue
   */
  after?: InputMaybe<Scalars['ID']['input']>;
  /**
   * ID of Issue before which the created issue should be ranked. Encoded as an ARI. Cannot be sent alongside after.
   * Accepts ARI(s): issue
   */
  before?: InputMaybe<Scalars['ID']['input']>;
};

/** The input for deleting an active background */
export type JiraWorkManagementRemoveActiveBackgroundInput = {
  /** The entityId (ARI) of the entity to remove the active background for */
  entityId: Scalars['ID']['input'];
};

/** The input for updating a Jira Work Management Background */
export type JiraWorkManagementUpdateBackgroundInput = {
  /** The type of background to update to */
  backgroundType: JiraWorkManagementBackgroundType;
  /**
   * The gradient/color if the background is a gradient/color type or
   * a customBackgroundId if the background is a custom (user uploaded) type
   */
  backgroundValue: Scalars['String']['input'];
  /** The entityId (ARI) of the entity to be updated */
  entityId: Scalars['ID']['input'];
};

/** The input for updating a custom background */
export type JiraWorkManagementUpdateCustomBackgroundInput = {
  /** The new alt text */
  altText: Scalars['String']['input'];
  /** The identifier which indicates the cloud instance this data is to be fetched for */
  cloudId: Scalars['ID']['input'];
  /** The customBackgroundId of the custom background to update */
  customBackgroundId: Scalars['ID']['input'];
};

export type JiraWorkManagementUpdateFilterInput = {
  /** An ARI-format value that encodes the filterId. */
  id: Scalars['ID']['input'];
  /** New filter name */
  name: Scalars['String']['input'];
};

/** Input for updating a Jira Work Management Overview. */
export type JiraWorkManagementUpdateOverviewInput = {
  /** Global identifier (ARI) of the Jira Work Management Overview to update. */
  id: Scalars['ID']['input'];
  /** New name of the Jira Work Management Overview. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** New project IDs to replace the existing project IDs for the Jira Work Management Overview. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** New theme to set for the Jira Work Management Overview. */
  theme?: InputMaybe<Scalars['String']['input']>;
};

export enum JiraWorkManagementUserLicenseSeatEdition {
  Free = 'FREE',
  Premium = 'PREMIUM',
  Standard = 'STANDARD'
}

/** Accepted Worklog adjustments */
export enum JiraWorklogAdjustmentEstimateOperation {
  /** To adjust estimate automatically whatever time spent mentioned. */
  Auto = 'AUTO',
  /** To leave time tracking without auto adjusting based on time spent */
  Leave = 'LEAVE',
  /** To reduce the time remaining manually. */
  Manual = 'MANUAL',
  /** To specifiy new time remaining. */
  New = 'NEW'
}

/** Input type for defining the operation on the Worklog field of a Jira issue. */
export type JiraWorklogFieldOperationInputForIssueTransitions = {
  /** provide a way to adjust the Estimate */
  adjustEstimateInput: JiraAdjustmentEstimate;
  /** Only ADD operation is supported for worklog field in purview of Issue Transition Modernisation flow. */
  operation: JiraAddValueFieldOperations;
  /** If user didn't provide this field or if it is `null` then startedTime will be logged as current time. */
  startedTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** If user didn't provide this field or if it is `null` then work will be logged with 0 minites. */
  timeSpentInMinutes?: InputMaybe<Scalars['Long']['input']>;
};

export enum JsmChatChannelType {
  Agent = 'AGENT',
  Request = 'REQUEST'
}

export enum JsmChatConnectedApps {
  Slack = 'SLACK',
  Teams = 'TEAMS'
}

export enum JsmChatConversationAnalyticsEvent {
  UserClearedChat = 'USER_CLEARED_CHAT',
  UserMarkedAsNotResolved = 'USER_MARKED_AS_NOT_RESOLVED',
  UserMarkedAsResolved = 'USER_MARKED_AS_RESOLVED',
  UserSharedCsat = 'USER_SHARED_CSAT',
  VaRespondedWithKnowledgeAnswer = 'VA_RESPONDED_WITH_KNOWLEDGE_ANSWER',
  VaRespondedWithNonKnowledgeAnswer = 'VA_RESPONDED_WITH_NON_KNOWLEDGE_ANSWER'
}

export type JsmChatConversationAnalyticsMetadataInput = {
  channelType?: InputMaybe<JsmChatConversationChannelType>;
  csatScore?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['String']['input']>;
};

export enum JsmChatConversationChannelType {
  Email = 'EMAIL',
  HelpCenter = 'HELP_CENTER',
  Portal = 'PORTAL',
  Slack = 'SLACK',
  Widget = 'WIDGET'
}

export enum JsmChatConversationMessageContentType {
  Adf = 'ADF'
}

export enum JsmChatConversationUserRole {
  JsmAgent = 'JSM_Agent',
  Participant = 'Participant',
  Reporter = 'Reporter',
  VirtualAgent = 'VirtualAgent'
}

export type JsmChatCreateChannelInput = {
  channelName: Scalars['String']['input'];
  channelType: JsmChatChannelType;
  isVirtualAgentChannel?: InputMaybe<Scalars['Boolean']['input']>;
  isVirtualAgentTestChannel?: InputMaybe<Scalars['Boolean']['input']>;
  requestTypeIds: Array<Scalars['String']['input']>;
};

export type JsmChatCreateCommentInput = {
  message: Scalars['JSON']['input'];
  messageSource: JsmChatMessageSource;
  messageType: JsmChatMessageType;
};

export type JsmChatCreateConversationAnalyticsInput = {
  conversationAnalyticsEvent: JsmChatConversationAnalyticsEvent;
  conversationAnalyticsMetadata?: InputMaybe<JsmChatConversationAnalyticsMetadataInput>;
  conversationId: Scalars['String']['input'];
  messageId?: InputMaybe<Scalars['String']['input']>;
};

export enum JsmChatCreateWebConversationMessageContentType {
  Adf = 'ADF'
}

export enum JsmChatCreateWebConversationUserRole {
  Init = 'Init',
  JsmAgent = 'JSM_Agent',
  Participant = 'Participant',
  Reporter = 'Reporter',
  VirtualAgent = 'VirtualAgent'
}

export type JsmChatDisconnectJiraProjectInput = {
  activationId: Scalars['ID']['input'];
  projectId: Scalars['ID']['input'];
  siteId: Scalars['ID']['input'];
  teamId: Scalars['ID']['input'];
};

export type JsmChatDisconnectMsTeamsJiraProjectInput = {
  tenantId: Scalars['String']['input'];
};

export type JsmChatInitializeConfigRequest = {
  activationId: Scalars['ID']['input'];
  projectId: Scalars['ID']['input'];
  siteId: Scalars['ID']['input'];
};

export enum JsmChatMessageSource {
  Email = 'EMAIL'
}

export enum JsmChatMessageType {
  Adf = 'ADF'
}

export type JsmChatMsTeamsUpdatedProjectSettings = {
  jsmApproversEnabled: Scalars['Boolean']['input'];
};

export type JsmChatPaginationConfig = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset: Scalars['Int']['input'];
};

export type JsmChatUpdateChannelSettingsInput = {
  isDeflectionChannel?: InputMaybe<Scalars['Boolean']['input']>;
  isVirtualAgentChannel?: InputMaybe<Scalars['Boolean']['input']>;
  requestTypeIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type JsmChatUpdateMsTeamsChannelSettingsInput = {
  requestTypeIds: Array<Scalars['String']['input']>;
};

export type JsmChatUpdateMsTeamsProjectSettingsInput = {
  settings?: InputMaybe<JsmChatMsTeamsUpdatedProjectSettings>;
};

export type JsmChatUpdateProjectSettingsInput = {
  activationId: Scalars['String']['input'];
  projectId: Scalars['String']['input'];
  settings?: InputMaybe<JsmChatUpdatedProjectSettings>;
  siteId: Scalars['String']['input'];
};

export type JsmChatUpdatedProjectSettings = {
  agentAssignedMessageDisabled: Scalars['Boolean']['input'];
  agentIssueClosedMessageDisabled: Scalars['Boolean']['input'];
  agentThreadMessageDisabled: Scalars['Boolean']['input'];
  areRequesterThreadRepliesPrivate: Scalars['Boolean']['input'];
  hideQueueDuringTicketCreation: Scalars['Boolean']['input'];
  jsmApproversEnabled: Scalars['Boolean']['input'];
  requesterIssueClosedMessageDisabled: Scalars['Boolean']['input'];
  requesterThreadMessageDisabled: Scalars['Boolean']['input'];
};

export enum JsmChatWebConversationMessageContentType {
  Adf = 'ADF'
}

export enum JsmChatWebConversationUserRole {
  JsmAgent = 'JSM_Agent',
  Participant = 'Participant',
  Reporter = 'Reporter',
  VirtualAgent = 'VirtualAgent'
}

export enum KnowledgeBaseSpacePermissionType {
  /**  Permission for anonymous users (view only)  */
  AnonymousUsers = 'ANONYMOUS_USERS',
  /**  Permission for Confluence licensed users  */
  ConfluenceLicensedUsers = 'CONFLUENCE_LICENSED_USERS',
  /**  Permission for Confluence unlicensed users  */
  ConfluenceUnlicensedUsers = 'CONFLUENCE_UNLICENSED_USERS'
}

export type KnowledgeBaseSpacePermissionUpdateViewInput = {
  /**  The space ARI  */
  spaceAri: Scalars['ID']['input'];
  /**  The new view permission  */
  viewPermission?: InputMaybe<KnowledgeBaseSpacePermissionType>;
};

export type KnowledgeDiscoveryCreateAdminhubBookmarkInput = {
  cloudId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  keyPhrases?: InputMaybe<Array<Scalars['String']['input']>>;
  orgId: Scalars['String']['input'];
  title: Scalars['String']['input'];
  url: Scalars['String']['input'];
};

export type KnowledgeDiscoveryCreateDefinitionInput = {
  definition: Scalars['String']['input'];
  entityIdInScope: Scalars['String']['input'];
  keyPhrase: Scalars['String']['input'];
  referenceContentId?: InputMaybe<Scalars['String']['input']>;
  referenceUrl?: InputMaybe<Scalars['String']['input']>;
  scope: KnowledgeDiscoveryDefinitionScope;
  workspaceId: Scalars['String']['input'];
};

export enum KnowledgeDiscoveryDefinitionScope {
  Blogpost = 'BLOGPOST',
  Organization = 'ORGANIZATION',
  Page = 'PAGE',
  Project = 'PROJECT',
  Space = 'SPACE'
}

export type KnowledgeDiscoveryDefinitionScopeIdConfluence = {
  contentId?: InputMaybe<Scalars['String']['input']>;
  spaceId?: InputMaybe<Scalars['String']['input']>;
};

export type KnowledgeDiscoveryDefinitionScopeIdJira = {
  projectId?: InputMaybe<Scalars['String']['input']>;
};

export type KnowledgeDiscoveryDeleteBookmarkInput = {
  bookmarkAdminhubId: Scalars['ID']['input'];
  keyPhrases?: InputMaybe<Array<Scalars['String']['input']>>;
  url: Scalars['String']['input'];
};

export type KnowledgeDiscoveryDeleteBookmarksInput = {
  cloudId: Scalars['ID']['input'];
  deleteRequests?: InputMaybe<Array<KnowledgeDiscoveryDeleteBookmarkInput>>;
  orgId: Scalars['ID']['input'];
};

export enum KnowledgeDiscoveryEntityType {
  ConfluenceBlogpost = 'CONFLUENCE_BLOGPOST',
  ConfluenceDocument = 'CONFLUENCE_DOCUMENT',
  ConfluencePage = 'CONFLUENCE_PAGE',
  ConfluenceSpace = 'CONFLUENCE_SPACE',
  JiraProject = 'JIRA_PROJECT',
  KeyPhrase = 'KEY_PHRASE',
  Topic = 'TOPIC',
  User = 'USER'
}

export enum KnowledgeDiscoveryKeyPhraseCategory {
  Acronym = 'ACRONYM',
  Other = 'OTHER',
  Project = 'PROJECT',
  Team = 'TEAM'
}

export type KnowledgeDiscoveryKeyPhraseInputText = {
  format: KnowledgeDiscoveryKeyPhraseInputTextFormat;
  text: Scalars['String']['input'];
};

export enum KnowledgeDiscoveryKeyPhraseInputTextFormat {
  Adf = 'ADF',
  Plain = 'PLAIN'
}

export type KnowledgeDiscoveryRelatedEntityAction = {
  action?: InputMaybe<KnowledgeDiscoveryRelatedEntityActionType>;
  relatedEntityId: Scalars['ID']['input'];
};

export enum KnowledgeDiscoveryRelatedEntityActionType {
  Delete = 'DELETE',
  Persist = 'PERSIST'
}

export enum KnowledgeDiscoverySearchQueryClassification {
  KeywordOrAcronym = 'KEYWORD_OR_ACRONYM',
  NaturalLanguageQuery = 'NATURAL_LANGUAGE_QUERY',
  None = 'NONE',
  Person = 'PERSON',
  Team = 'TEAM'
}

export enum KnowledgeDiscoveryTopicType {
  Area = 'AREA',
  Company = 'COMPANY',
  Event = 'EVENT',
  Process = 'PROCESS',
  Program = 'PROGRAM',
  Team = 'TEAM'
}

export type KnowledgeDiscoveryUpdateAdminhubBookmarkInput = {
  bookmarkAdminhubId: Scalars['ID']['input'];
  cloudId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  keyPhrases?: InputMaybe<Array<Scalars['String']['input']>>;
  orgId: Scalars['String']['input'];
  title: Scalars['String']['input'];
  url: Scalars['String']['input'];
};

export type KnowledgeDiscoveryUpdateRelatedEntitiesInput = {
  actions?: InputMaybe<Array<InputMaybe<KnowledgeDiscoveryRelatedEntityAction>>>;
  cloudId?: InputMaybe<Scalars['String']['input']>;
  entity: Scalars['ID']['input'];
  entityType: KnowledgeDiscoveryEntityType;
  relatedEntityType: KnowledgeDiscoveryEntityType;
  workspaceId?: InputMaybe<Scalars['String']['input']>;
};

export enum LicenseOverrideState {
  Active = 'ACTIVE',
  Advanced = 'ADVANCED',
  Inactive = 'INACTIVE',
  Standard = 'STANDARD',
  Trial = 'TRIAL'
}

/**
 * See https://developer.atlassian.com/platform/graphql-gateway/schemas/lifecycle-support/#lifecycle-stages for more
 * information on how to use these stages and what they mean in detail.
 * | Lifecycle            | Visible in Prod | Needs `@optIn` directive |                     Allow third parties                       |
 * |----------------------|:---------------:|:------------------------:|:-------------------------------------------------------------:|
 * | STAGING              |       No        |            No            | By default no. Can enable via `allowThirdParties` directive   |
 * | EXPERIMENTAL         |       Yes       |           Yes            | By default no. Can enable via `allowThirdParties` directive   |
 * | BETA                 |       Yes       |           Yes            |                       Always                                  |
 * | PRODUCTION (default) |       Yes       |            No            |                       Always                                  |
 */
export enum LifecycleStage {
  Beta = 'BETA',
  Experimental = 'EXPERIMENTAL',
  Production = 'PRODUCTION',
  Staging = 'STAGING'
}

export type ListStorageInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  contextAri: Scalars['ID']['input'];
  environmentId: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** The input for choosing invocations of interest. */
export type LogQueryInput = {
  /**
   * Limits the search to a particular version of the app.
   * Optional: if empty will search all versions of the app
   */
  appVersion?: InputMaybe<Scalars['String']['input']>;
  /**
   * Limits the search to a list of versions of the app.
   * Optional: if empty will search all versions of the app
   */
  appVersions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Limits the search to a particular date range.
   *
   * Note: Logs may have a TTL on them so older logs may not be available
   * despite search parameters.
   */
  dates?: InputMaybe<DateSearchInput>;
  /**
   * Limits the search to a particular function in the app.
   * Optional: if empty will search all functions.
   */
  functionKey?: InputMaybe<Scalars['String']['input']>;
  /**
   * Limits the search to a particular functionKeys of the app.
   * Optional: if empty will search all functionKeys of the app
   */
  functionKeys?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Specify which installations you want to search.
   * Optional: if empty will search all installations user has access to.
   */
  installationContexts?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * Limits the search to a particular log level type of message.
   * Optional: if empty will search all log levels
   */
  lvl?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Searches all logs matching the search input from user.
   * Optional: if empty will search all logs
   */
  msg?: InputMaybe<Scalars['String']['input']>;
};

export type LpCertSort = {
  sortDirection?: InputMaybe<SortDirection>;
  sortField?: InputMaybe<LpCertSortField>;
};

export enum LpCertSortField {
  ActiveDate = 'ACTIVE_DATE',
  ExpireDate = 'EXPIRE_DATE',
  Id = 'ID',
  ImageUrl = 'IMAGE_URL',
  Name = 'NAME',
  NameAbbr = 'NAME_ABBR',
  PublicUrl = 'PUBLIC_URL',
  Status = 'STATUS',
  Type = 'TYPE'
}

export enum LpCertStatus {
  Active = 'ACTIVE',
  Expired = 'EXPIRED'
}

export enum LpCertType {
  Badge = 'BADGE',
  Certification = 'CERTIFICATION',
  Standing = 'STANDING'
}

export type LpCourseSort = {
  sortDirection?: InputMaybe<SortDirection>;
  sortField?: InputMaybe<LpCourseSortField>;
};

export enum LpCourseSortField {
  CompletedDate = 'COMPLETED_DATE',
  CourseId = 'COURSE_ID',
  Id = 'ID',
  Status = 'STATUS',
  Title = 'TITLE',
  Url = 'URL'
}

export enum LpCourseStatus {
  Completed = 'COMPLETED',
  InProgress = 'IN_PROGRESS'
}

export enum LpSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

/** Payment model for integrating an app with an Atlassian product. */
export enum MarketplaceAppPaymentModel {
  Free = 'FREE',
  PaidViaAtlassian = 'PAID_VIA_ATLASSIAN',
  PaidViaPartner = 'PAID_VIA_PARTNER'
}

export type MarketplaceAppVersionFilter = {
  /** Unique id of Cloud App's version */
  cloudAppVersionId?: InputMaybe<Scalars['ID']['input']>;
  /** Excludes hidden versions as per Marketplace */
  excludeHiddenIn?: InputMaybe<MarketplaceLocation>;
  /** Options of Atlassian product instance hosting types for which app versions are available. */
  productHostingOptions?: InputMaybe<Array<AtlassianProductHostingType>>;
  /** Visibility of the version. */
  visibility?: InputMaybe<MarketplaceAppVersionVisibility>;
};

/** Visibility of the Marketplace app's version */
export enum MarketplaceAppVersionVisibility {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

/** Filters to apply when querying for my apps. */
export type MarketplaceAppsFilter = {
  /** The apps' status in the Cloud Fortified program */
  cloudFortifiedStatus?: InputMaybe<Array<MarketplaceProgramStatus>>;
  /** Includes private apps or versions if you are authorized to see them */
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  /** Options of Atlassian product instance hosting types for which app versions are available. */
  productHostingOptions?: InputMaybe<Array<AtlassianProductHostingType>>;
};

/** Billing cycle for which pricing plan applies */
export enum MarketplaceBillingCycle {
  Annual = 'ANNUAL',
  Monthly = 'MONTHLY'
}

export enum MarketplaceCloudFortifiedStatus {
  Applied = 'APPLIED',
  Approved = 'APPROVED',
  NotAParticipant = 'NOT_A_PARTICIPANT',
  Rejected = 'REJECTED'
}

export type MarketplaceConsoleAppSoftwareVersionCompatibilityInput = {
  hosting: MarketplaceConsoleHosting;
  maxBuildNumber?: InputMaybe<Scalars['Int']['input']>;
  minBuildNumber?: InputMaybe<Scalars['Int']['input']>;
  parentSoftwareId: Scalars['ID']['input'];
};

export type MarketplaceConsoleAppSoftwareVersionFrameworkDetailsInput = {
  attributes: MarketplaceConsoleFrameworkAttributesInput;
  frameworkId: Scalars['ID']['input'];
};

export enum MarketplaceConsoleAppSoftwareVersionLicenseTypeId {
  Asl = 'ASL',
  AtlassianClosedSource = 'ATLASSIAN_CLOSED_SOURCE',
  Bsd = 'BSD',
  Commercial = 'COMMERCIAL',
  CommercialFree = 'COMMERCIAL_FREE',
  Epl = 'EPL',
  Gpl = 'GPL',
  Lgpl = 'LGPL'
}

export enum MarketplaceConsoleAppSoftwareVersionState {
  Active = 'ACTIVE',
  Approved = 'APPROVED',
  Archived = 'ARCHIVED',
  AutoApproved = 'AUTO_APPROVED',
  Draft = 'DRAFT',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED'
}

export type MarketplaceConsoleAppVersionCreateRequestInput = {
  buildNumber?: InputMaybe<Scalars['Int']['input']>;
  compatibilities: Array<MarketplaceConsoleAppSoftwareVersionCompatibilityInput>;
  frameworkDetails: MarketplaceConsoleAppSoftwareVersionFrameworkDetailsInput;
  versionNumber?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleAppVersionDeleteRequestInput = {
  appKey?: InputMaybe<Scalars['ID']['input']>;
  appSoftwareId?: InputMaybe<Scalars['ID']['input']>;
  buildNumber: Scalars['ID']['input'];
};

export type MarketplaceConsoleConnectFrameworkAttributesInput = {
  descriptorId: Scalars['String']['input'];
  href: Scalars['String']['input'];
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type MarketplaceConsoleDeploymentInstructionInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  screenshotImageUrl?: InputMaybe<Scalars['String']['input']>;
};

export enum MarketplaceConsoleDevSpaceProgram {
  AtlassianParter = 'ATLASSIAN_PARTER',
  FreeLicense = 'FREE_LICENSE',
  MarketplacePartner = 'MARKETPLACE_PARTNER',
  SolutionPartner = 'SOLUTION_PARTNER'
}

export enum MarketplaceConsoleDevSpaceTier {
  Gold = 'GOLD',
  Platinum = 'PLATINUM',
  Silver = 'SILVER'
}

export type MarketplaceConsoleEditionInput = {
  features: Array<MarketplaceConsoleFeatureInput>;
  id?: InputMaybe<Scalars['ID']['input']>;
  isDefault: Scalars['Boolean']['input'];
  pricingPlan: MarketplaceConsolePricingPlanInput;
  type: MarketplaceConsoleEditionType;
};

export enum MarketplaceConsoleEditionType {
  Advanced = 'ADVANCED',
  Standard = 'STANDARD'
}

export type MarketplaceConsoleEditionsActivationRequest = {
  rejectionReason?: InputMaybe<Scalars['String']['input']>;
  status: MarketplaceConsoleEditionsActivationStatus;
};

/**  --------------------------------------------------------------------------------------------- */
export enum MarketplaceConsoleEditionsActivationStatus {
  Approved = 'APPROVED',
  Pending = 'PENDING',
  Rejected = 'REJECTED'
}

export type MarketplaceConsoleEditionsInput = {
  appKey?: InputMaybe<Scalars['String']['input']>;
  productId?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleExternalFrameworkAttributesInput = {
  authorization: Scalars['Boolean']['input'];
  binaryUrl?: InputMaybe<Scalars['String']['input']>;
  learnMoreUrl?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleFeatureInput = {
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  position: Scalars['Int']['input'];
};

export type MarketplaceConsoleForgeFrameworkAttributesInput = {
  appId: Scalars['String']['input'];
  envId: Scalars['String']['input'];
  versionId: Scalars['String']['input'];
};

export type MarketplaceConsoleFrameworkAttributesInput = {
  connect?: InputMaybe<MarketplaceConsoleConnectFrameworkAttributesInput>;
  external?: InputMaybe<MarketplaceConsoleExternalFrameworkAttributesInput>;
  forge?: InputMaybe<MarketplaceConsoleForgeFrameworkAttributesInput>;
  plugin?: InputMaybe<MarketplaceConsolePluginFrameworkAttributesInput>;
  workflow?: InputMaybe<MarketplaceConsoleWorkflowFrameworkAttributesInput>;
};

/**
 * The file contains the common types that are used across
 * different parts of the Marketplace Console BFF GQL schema.
 */
export enum MarketplaceConsoleHosting {
  Cloud = 'CLOUD',
  DataCenter = 'DATA_CENTER',
  Server = 'SERVER'
}

export enum MarketplaceConsoleLegacyMongoPluginHiddenIn {
  HiddenInSiteAndAppMarketplace = 'HIDDEN_IN_SITE_AND_APP_MARKETPLACE',
  HiddenInSiteOnly = 'HIDDEN_IN_SITE_ONLY'
}

/**  --------------------------------------------------------------------------------------------- */
export enum MarketplaceConsoleLegacyMongoStatus {
  Notassigned = 'NOTASSIGNED',
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  Readytolaunch = 'READYTOLAUNCH',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED'
}

export type MarketplaceConsoleListingHighLightInput = {
  caption?: InputMaybe<Scalars['String']['input']>;
  screenshotUrl: Scalars['String']['input'];
  summary: Scalars['String']['input'];
  thumbnailUrl: Scalars['String']['input'];
  title: Scalars['String']['input'];
};

export type MarketplaceConsoleListingScreenshotInput = {
  caption?: InputMaybe<Scalars['String']['input']>;
  imageUrl: Scalars['String']['input'];
};

/** For the nullable fields in request, null value means that the input was not provided and therefore would not be updated */
export type MarketplaceConsoleMakeAppVersionPublicRequest = {
  appKey: Scalars['ID']['input'];
  appSoftwareId: Scalars['ID']['input'];
  appStatusPageUrl?: InputMaybe<Scalars['String']['input']>;
  binaryUrl?: InputMaybe<Scalars['String']['input']>;
  buildNumber: Scalars['ID']['input'];
  categories?: InputMaybe<Array<Scalars['String']['input']>>;
  communityEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  compatibilities?: InputMaybe<Array<MarketplaceConsoleAppSoftwareVersionCompatibilityInput>>;
  dataCenterReviewIssueKey?: InputMaybe<Scalars['String']['input']>;
  deploymentInstructions?: InputMaybe<Array<MarketplaceConsoleDeploymentInstructionInput>>;
  documentationUrl?: InputMaybe<Scalars['String']['input']>;
  eulaUrl?: InputMaybe<Scalars['String']['input']>;
  forumsUrl?: InputMaybe<Scalars['String']['input']>;
  googleAnalytics4Id?: InputMaybe<Scalars['String']['input']>;
  googleAnalyticsId?: InputMaybe<Scalars['String']['input']>;
  heroImageUrl?: InputMaybe<Scalars['String']['input']>;
  highlights?: InputMaybe<Array<MarketplaceConsoleListingHighLightInput>>;
  isBeta?: InputMaybe<Scalars['Boolean']['input']>;
  isSupported?: InputMaybe<Scalars['Boolean']['input']>;
  issueTrackerUrl?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Array<Scalars['String']['input']>>;
  learnMoreUrl?: InputMaybe<Scalars['String']['input']>;
  licenseType?: InputMaybe<MarketplaceConsoleAppSoftwareVersionLicenseTypeId>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  moreDetails?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentModel?: InputMaybe<MarketplaceConsolePaymentModel>;
  privacyUrl?: InputMaybe<Scalars['String']['input']>;
  productId: Scalars['ID']['input'];
  releaseNotes?: InputMaybe<Scalars['String']['input']>;
  releaseSummary?: InputMaybe<Scalars['String']['input']>;
  screenshots?: InputMaybe<Array<MarketplaceConsoleListingScreenshotInput>>;
  segmentWriteKey?: InputMaybe<Scalars['String']['input']>;
  sourceCodeLicenseUrl?: InputMaybe<Scalars['String']['input']>;
  storesPersonalData?: InputMaybe<Scalars['Boolean']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supportTicketSystemUrl?: InputMaybe<Scalars['String']['input']>;
  tagLine?: InputMaybe<Scalars['String']['input']>;
  youtubeId?: InputMaybe<Scalars['String']['input']>;
};

export enum MarketplaceConsoleParentSoftwareState {
  Active = 'ACTIVE',
  Archived = 'ARCHIVED',
  Draft = 'DRAFT'
}

export enum MarketplaceConsolePaymentModel {
  Free = 'FREE',
  PaidViaAtlassian = 'PAID_VIA_ATLASSIAN',
  PaidViaVendor = 'PAID_VIA_VENDOR'
}

export type MarketplaceConsolePluginFrameworkAttributesInput = {
  artifactId: Scalars['String']['input'];
  href: Scalars['String']['input'];
};

export enum MarketplaceConsolePluginFrameworkType {
  P1 = 'P1',
  P2 = 'P2'
}

export enum MarketplaceConsolePricingCurrency {
  Jpy = 'JPY',
  Usd = 'USD'
}

export type MarketplaceConsolePricingItemInput = {
  amount: Scalars['Float']['input'];
  ceiling: Scalars['Float']['input'];
  floor: Scalars['Float']['input'];
};

export type MarketplaceConsolePricingPlanInput = {
  currency: MarketplaceConsolePricingCurrency;
  expertDiscountOptOut: Scalars['Boolean']['input'];
  status: MarketplaceConsolePricingPlanStatus;
  tieredPricing: Array<MarketplaceConsolePricingItemInput>;
};

export enum MarketplaceConsolePricingPlanStatus {
  Draft = 'DRAFT',
  Live = 'LIVE',
  Pending = 'PENDING'
}

export type MarketplaceConsoleWorkflowFrameworkAttributesInput = {
  artifactId: Scalars['String']['input'];
  href: Scalars['String']['input'];
};

/** Status of an entity in Marketplace system */
export enum MarketplaceEntityStatus {
  Active = 'ACTIVE',
  Archived = 'ARCHIVED'
}

/** Status of appâ€™s listing in Marketplace. */
export enum MarketplaceListingStatus {
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  ReadyToLaunch = 'READY_TO_LAUNCH',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED'
}

/** Marketplace location */
export enum MarketplaceLocation {
  InProduct = 'IN_PRODUCT',
  Website = 'WEBSITE'
}

/** Tells whether support is on holiday only one time or if it repeats annually. */
export enum MarketplacePartnerSupportHolidayFrequency {
  Annual = 'ANNUAL',
  OneTime = 'ONE_TIME'
}

export enum MarketplacePartnerTierType {
  Gold = 'GOLD',
  Platinum = 'PLATINUM',
  Silver = 'SILVER'
}

/** Tells if the Marketplace partner is an Atlassianâ€™s internal one. */
export enum MarketplacePartnerType {
  AtlassianInternal = 'ATLASSIAN_INTERNAL'
}

/** Option parameters to fetch pricing plan for a marketplace entity */
export type MarketplacePricingPlanOptions = {
  /** Period for which Pricing Plan is to be fetched. Defaults to MONTHLY */
  billingCycle?: InputMaybe<MarketplaceBillingCycle>;
  /** Country code (ISO 3166-1 alpha-2) of the client. Either of currencyCode and countryCode is needed. If both are not present, fallback to default currency - USD */
  countryCode?: InputMaybe<Scalars['String']['input']>;
  /** Currency code (ISO 4217) to return the amount in pricing items. Either of currencyCode and countryCode is needed. If currency code is not present, fallback to country code to fetch currency */
  currencyCode?: InputMaybe<Scalars['String']['input']>;
  /** Fetch pricing plan with status: LIVE, PENDING, DRAFT. Unless, pricing plan will be fetched based on user access */
  planStatus?: InputMaybe<MarketplacePricingPlanStatus>;
};

/** Status of the plan : LIVE, PENDING or DRAFT */
export enum MarketplacePricingPlanStatus {
  Draft = 'DRAFT',
  Live = 'LIVE',
  Pending = 'PENDING'
}

/** Mode of the tier : GRADUATED (progressive PUP), VOLUME (constant for all users) */
export enum MarketplacePricingTierMode {
  Graduated = 'GRADUATED',
  Volume = 'VOLUME'
}

/** Policy of the tier : BLOCK (FLAT) or PER_UNIT (PUP) */
export enum MarketplacePricingTierPolicy {
  Block = 'BLOCK',
  PerUnit = 'PER_UNIT'
}

/** Type of the tier */
export enum MarketplacePricingTierType {
  RemoteAgentTiered = 'REMOTE_AGENT_TIERED',
  UserTiered = 'USER_TIERED'
}

export enum MarketplaceProgramStatus {
  Applied = 'APPLIED',
  Approved = 'APPROVED',
  NotAParticipant = 'NOT_A_PARTICIPANT',
  Rejected = 'REJECTED'
}

/** Hosting type where Atlassian product instance is installed. */
export enum MarketplaceStoreAtlassianProductHostingType {
  Cloud = 'CLOUD',
  Datacenter = 'DATACENTER',
  Server = 'SERVER'
}

export enum MarketplaceStoreBillingSystem {
  Ccp = 'CCP',
  Hams = 'HAMS'
}

/**  --------------------------------------------------------------------------------------------- */
export type MarketplaceStoreBillingSystemInput = {
  cloudId: Scalars['String']['input'];
};

export enum MarketplaceStoreDeveloperSpaceStatus {
  Active = 'ACTIVE',
  Archived = 'ARCHIVED',
  Inactive = 'INACTIVE'
}

export enum MarketplaceStoreEditionType {
  Advanced = 'ADVANCED',
  Standard = 'STANDARD'
}

export type MarketplaceStoreEditionsInput = {
  appId?: InputMaybe<Scalars['String']['input']>;
};

/**  --------------------------------------------------------------------------------------------- */
export enum MarketplaceStoreHomePageHighlightedSectionVariation {
  Prominent = 'PROMINENT'
}

export type MarketplaceStoreInstallAppInput = {
  appKey: Scalars['String']['input'];
  target: MarketplaceStoreInstallAppTargetInput;
};

/** Status of an app installation request */
export enum MarketplaceStoreInstallAppStatus {
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  ProvisioningFailure = 'PROVISIONING_FAILURE',
  Success = 'SUCCESS',
  TimedOut = 'TIMED_OUT'
}

/** Input for specifying the target or "site" of an app installation. */
export type MarketplaceStoreInstallAppTargetInput = {
  cloudId: Scalars['ID']['input'];
  product: MarketplaceStoreInstallationTargetProduct;
};

/** Products onto which an app can be installed */
export enum MarketplaceStoreInstallationTargetProduct {
  Compass = 'COMPASS',
  Confluence = 'CONFLUENCE',
  Jira = 'JIRA'
}

/**  --------------------------------------------------------------------------------------------- */
export enum MarketplaceStorePartnerEnrollmentProgram {
  MarketplacePartner = 'MARKETPLACE_PARTNER',
  SolutionPartner = 'SOLUTION_PARTNER'
}

export enum MarketplaceStorePartnerEnrollmentProgramValue {
  Gold = 'GOLD',
  Platinum = 'PLATINUM',
  Silver = 'SILVER'
}

export enum MarketplaceStorePartnerSupportAvailabilityDay {
  Friday = 'FRIDAY',
  Monday = 'MONDAY',
  Saturday = 'SATURDAY',
  Sunday = 'SUNDAY',
  Thursday = 'THURSDAY',
  Tuesday = 'TUESDAY',
  Wednesday = 'WEDNESDAY'
}

export enum MarketplaceStorePricingCurrency {
  Jpy = 'JPY',
  Usd = 'USD'
}

export type MarketplaceStoreReviewFilterInput = {
  hosting?: InputMaybe<MarketplaceStoreAtlassianProductHostingType>;
  sort?: InputMaybe<MarketplaceStoreReviewsSorting>;
};

export enum MarketplaceStoreReviewsSorting {
  Helpful = 'HELPFUL',
  Recent = 'RECENT'
}

/** The roles that a member can have within a team */
export enum MembershipRole {
  /** A team member with administrative permissions */
  Admin = 'ADMIN',
  /** A regular team member */
  Regular = 'REGULAR'
}

/** The settings which a team can have describing how members are added to the team */
export enum MembershipSetting {
  /** Members may invite others to join the team */
  MemberInvite = 'MEMBER_INVITE',
  /** Anyone may join */
  Open = 'OPEN'
}

/** The states that a member can have within a team */
export enum MembershipState {
  /** A member who was previously a full member of the team, but has been removed or has left the team */
  Alumni = 'ALUMNI',
  /** A full member of the team */
  FullMember = 'FULL_MEMBER',
  /** A member who has been invited to the team but has not yet joined */
  Invited = 'INVITED',
  /** A member who has requested to join the team and is pending approval */
  RequestingToJoin = 'REQUESTING_TO_JOIN'
}

/**
 *  ------------------------------------------------------
 *   Watch/Unwatch Focus Area mutations
 *  ------------------------------------------------------
 */
export type MercuryAddWatcherToFocusAreaInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};

export type MercuryAggregatedHeadcountSort = {
  field?: InputMaybe<MercuryAggregatedHeadcountSortField>;
  order: SortOrder;
};

export enum MercuryAggregatedHeadcountSortField {
  FilledPositions = 'FILLED_POSITIONS',
  OpenPositions = 'OPEN_POSITIONS',
  TotalHeadcount = 'TOTAL_HEADCOUNT'
}

export type MercuryCreateCommentInput = {
  cloudId: Scalars['ID']['input'];
  commentText: Scalars['MercuryJSONString']['input'];
  entityId: Scalars['ID']['input'];
  entityType: MercuryEntityType;
};

/**
 *  ------------------------------------------------------
 *   Focus Area
 *  ------------------------------------------------------
 */
export type MercuryCreateFocusAreaInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaTypeId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  /** Optional ID of the parent Focus Area in the hierarchy. If not provided the Focus Area has no parent. */
  parentFocusAreaId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 *  ----------------------------------------
 *   Focus Area status update mutations
 *  ----------------------------------------
 */
export type MercuryCreateFocusAreaStatusUpdateInput = {
  cloudId: Scalars['ID']['input'];
  /** ID of the Focus Area for which an update is posted. */
  focusAreaId: Scalars['ID']['input'];
  /** The new target date for the Focus Area. */
  newTargetDate?: InputMaybe<MercuryFocusAreaTargetDateInput>;
  /** The ID of the status to transition the Focus Area to as part of the update. */
  statusTransitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The summary text (ADF) for the update. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

export type MercuryCreatePortfolioFocusAreasInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaIds: Array<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
};

export type MercuryDeleteAllPreferenceInput = {
  cloudId: Scalars['ID']['input'];
};

export type MercuryDeleteCommentInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryDeleteFocusAreaGoalLinkInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryDeleteFocusAreaGoalLinksInput = {
  atlasGoalAris: Array<Scalars['String']['input']>;
  focusAreaAri: Scalars['String']['input'];
};

export type MercuryDeleteFocusAreaInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryDeleteFocusAreaLinkInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryDeleteFocusAreaStatusUpdateInput = {
  cloudId: Scalars['ID']['input'];
  /** The ID of the Focus Area status update entry. */
  id: Scalars['ID']['input'];
};

export type MercuryDeleteFocusAreaWorkLinkInput = {
  cloudId: Scalars['ID']['input'];
  /** The ID of the link to delete. */
  id: Scalars['ID']['input'];
};

export type MercuryDeleteFocusAreaWorkLinksInput = {
  focusAreaAri: Scalars['String']['input'];
  workAris: Array<Scalars['String']['input']>;
};

export type MercuryDeletePortfolioFocusAreaLinkInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaIds: Array<Scalars['ID']['input']>;
  portfolioId: Scalars['ID']['input'];
};

export type MercuryDeletePortfolioInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryDeletePreferenceInput = {
  cloudId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
};

export enum MercuryEntityType {
  Comment = 'COMMENT',
  FocusArea = 'FOCUS_AREA',
  FocusAreaStatusUpdate = 'FOCUS_AREA_STATUS_UPDATE',
  Program = 'PROGRAM',
  ProgramStatusUpdate = 'PROGRAM_STATUS_UPDATE'
}

export enum MercuryEventType {
  Create = 'CREATE',
  Delete = 'DELETE',
  Import = 'IMPORT',
  Link = 'LINK',
  Unlink = 'UNLINK',
  Update = 'UPDATE'
}

/**
 *  ----------------------------------------
 *   Focus Area Activity
 *  ----------------------------------------
 */
export type MercuryFocusAreaActivitySort = {
  order: SortOrder;
};

export enum MercuryFocusAreaHealthColor {
  Green = 'GREEN',
  Red = 'RED',
  Yellow = 'YELLOW'
}

export type MercuryFocusAreaHierarchySort = {
  field?: InputMaybe<MercuryFocusAreaHierarchySortField>;
  order: SortOrder;
};

export enum MercuryFocusAreaHierarchySortField {
  HierarchyLevel = 'HIERARCHY_LEVEL',
  Name = 'NAME'
}

export type MercuryFocusAreaSort = {
  field?: InputMaybe<MercuryFocusAreaSortField>;
  order: SortOrder;
};

export enum MercuryFocusAreaSortField {
  Budget = 'BUDGET',
  FocusAreaType = 'FOCUS_AREA_TYPE',
  HasParent = 'HAS_PARENT',
  HierarchyLevel = 'HIERARCHY_LEVEL',
  LastUpdated = 'LAST_UPDATED',
  Name = 'NAME',
  Spend = 'SPEND',
  Status = 'STATUS',
  TargetDate = 'TARGET_DATE',
  Watching = 'WATCHING'
}

export type MercuryFocusAreaTargetDateInput = {
  targetDate?: InputMaybe<Scalars['String']['input']>;
  targetDateType?: InputMaybe<MercuryTargetDateType>;
};

export type MercuryFocusAreaTeamAllocationAggregationSort = {
  field?: InputMaybe<MercuryFocusAreaTeamAllocationAggregationSortField>;
  order: SortOrder;
};

export enum MercuryFocusAreaTeamAllocationAggregationSortField {
  FilledPositions = 'FILLED_POSITIONS',
  OpenPositions = 'OPEN_POSITIONS',
  TeamName = 'TEAM_NAME',
  TotalPositions = 'TOTAL_POSITIONS'
}

export type MercuryLinkAtlassianWorkToFocusAreaInput = {
  /** The focus area ARI the work is linked to. */
  focusAreaAri: Scalars['String']['input'];
  /** The external ARIs as they are in the 1P provider of the work to link. */
  workAris: Array<Scalars['String']['input']>;
};

/**
 *  ------------------------------------------------------
 *   Focus Area links
 *  ------------------------------------------------------
 */
export type MercuryLinkFocusAreasToFocusAreaInput = {
  childFocusAreaIds: Array<Scalars['ID']['input']>;
  cloudId: Scalars['ID']['input'];
  parentFocusAreaId: Scalars['ID']['input'];
};

/**
 *  ------------------------------------------------------
 *   Portfolio
 *  ------------------------------------------------------
 */
export type MercuryLinkFocusAreasToPortfolioInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaIds: Array<Scalars['ID']['input']>;
  portfolioId: Scalars['ID']['input'];
};

/**
 *  ------------------------------------------------------
 *   Goal links
 *  ------------------------------------------------------
 */
export type MercuryLinkGoalsToFocusAreaInput = {
  atlasGoalAris: Array<Scalars['String']['input']>;
  focusAreaAri: Scalars['String']['input'];
};

/**
 *  ------------------------------------------------------
 *   Work links
 *  ------------------------------------------------------
 */
export type MercuryLinkWorkToFocusAreaInput = {
  cloudId: Scalars['ID']['input'];
  /** The external IDs as they are in the 1P/3P provider of the work to link. */
  externalChildWorkIds: Array<Scalars['ID']['input']>;
  /** The focus area the work is linked to. */
  parentFocusAreaId: Scalars['ID']['input'];
  /** The provider of the work. */
  providerKey: Scalars['String']['input'];
  /** The provider container of the work(site ari for jira) */
  workContainerAri?: InputMaybe<Scalars['String']['input']>;
};

export enum MercuryProviderConfigurationStatus {
  Connected = 'CONNECTED',
  SignUp = 'SIGN_UP'
}

export enum MercuryProviderWorkErrorType {
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  NoPermissions = 'NO_PERMISSIONS'
}

export enum MercuryProviderWorkStatusColor {
  Blue = 'BLUE',
  Gray = 'GRAY',
  Green = 'GREEN',
  Red = 'RED',
  Yellow = 'YELLOW'
}

export enum MercuryProviderWorkTargetDateType {
  Day = 'DAY',
  Month = 'MONTH',
  Quarter = 'QUARTER'
}

export type MercuryRecreatePortfolioFocusAreasInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaIds: Array<Scalars['ID']['input']>;
  id: Scalars['ID']['input'];
};

export type MercuryRemoveWatcherFromFocusAreaInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};

/**
 *  ----------------------------------------
 *   Preference Mutations
 *  ----------------------------------------
 */
export type MercurySetPreferenceInput = {
  cloudId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export enum MercuryTargetDateType {
  Day = 'DAY',
  Month = 'MONTH',
  Quarter = 'QUARTER'
}

export enum MercuryTeamFocusAreaAllocationSortField {
  FilledPositions = 'FILLED_POSITIONS',
  OpenPositions = 'OPEN_POSITIONS'
}

export type MercuryTeamFocusAreaAllocationsSort = {
  field?: InputMaybe<MercuryTeamFocusAreaAllocationSortField>;
  order: SortOrder;
};

export type MercuryTeamSort = {
  field?: InputMaybe<MercuryTeamSortField>;
  order: SortOrder;
};

/**
 *  ------------------------------------------------------
 *   Team
 *  ------------------------------------------------------
 */
export enum MercuryTeamSortField {
  Name = 'NAME'
}

/**
 *  ----------------------------------------
 *   Focus Area workflow mutations
 *  ----------------------------------------
 */
export type MercuryTransitionFocusAreaStatusInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
  statusTransitionId: Scalars['ID']['input'];
};

export type MercuryUpdateCommentInput = {
  cloudId: Scalars['ID']['input'];
  commentText: Scalars['MercuryJSONString']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryUpdateFocusAreaAboutContentInput = {
  aboutContent: Scalars['String']['input'];
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryUpdateFocusAreaNameInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

export type MercuryUpdateFocusAreaOwnerInput = {
  aaid: Scalars['String']['input'];
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryUpdateFocusAreaStatusUpdateInput = {
  cloudId: Scalars['ID']['input'];
  /** The ID of the Focus Area status update entry. */
  id: Scalars['ID']['input'];
  /** The new target date for the Focus Area. */
  newTargetDate?: InputMaybe<MercuryFocusAreaTargetDateInput>;
  /** The ID of the status to transition the Focus Area to as part of the update. */
  statusTransitionId?: InputMaybe<Scalars['ID']['input']>;
  /** Summary text (ADF) for the update. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

export type MercuryUpdateFocusAreaTargetDateInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
  targetDate?: InputMaybe<Scalars['String']['input']>;
  targetDateType?: InputMaybe<MercuryTargetDateType>;
};

export type MercuryUpdatePortfolioNameInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

export type MigrateComponentTypeInput = {
  /** The ID of the component type to which components will be migrated. */
  destinationTypeId: Scalars['ID']['input'];
  /** The ID of the component type from which components will be migrated. */
  sourceTypeId: Scalars['ID']['input'];
};

/** An enum of the possible statuses of a migration event. */
export enum MigrationEventStatus {
  Cancelled = 'CANCELLED',
  Cancelling = 'CANCELLING',
  Failed = 'FAILED',
  Incomplete = 'INCOMPLETE',
  InProgress = 'IN_PROGRESS',
  Paused = 'PAUSED',
  Ready = 'READY',
  Skipped = 'SKIPPED',
  Success = 'SUCCESS',
  TimedOut = 'TIMED_OUT'
}

/** An enum of the possible types of a migration event. */
export enum MigrationEventType {
  Container = 'CONTAINER',
  Migration = 'MIGRATION',
  Transfer = 'TRANSFER'
}

/** Move sprint down */
export type MoveSprintDownInput = {
  boardId: Scalars['ID']['input'];
  sprintId: Scalars['ID']['input'];
};

/** Move sprint up */
export type MoveSprintUpInput = {
  boardId: Scalars['ID']['input'];
  sprintId: Scalars['ID']['input'];
};

export type MyActivityFilter = {
  arguments?: InputMaybe<ActivityFilterArgs>;
  /** set of top-level container ARIs (ex: Cloud ID, workspace ID) */
  rootContainerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Defines relationship between the filter arguments. Default: AND */
  type?: InputMaybe<ActivitiesFilterType>;
};

/**  =========================== */
export type NadelBatchObjectIdentifiedBy = {
  resultId: Scalars['String']['input'];
  sourceId: Scalars['String']['input'];
};

/** This allows you to hydrate new values into fields */
export type NadelHydrationArgument = {
  name: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** Specify a condition for the hydration to activate */
export type NadelHydrationCondition = {
  result: NadelHydrationResultCondition;
};

/** This allows you to hydrate new values into fields with the @hydratedFrom directive */
export type NadelHydrationFromArgument = {
  name: Scalars['String']['input'];
  valueFromArg?: InputMaybe<Scalars['String']['input']>;
  valueFromField?: InputMaybe<Scalars['String']['input']>;
};

/** Specify a condition for the hydration to activate based on the result */
export type NadelHydrationResultCondition = {
  predicate: NadelHydrationResultFieldPredicate;
  /** The exact name of the field to use, do not prefix with $source */
  sourceField: Scalars['String']['input'];
};

export type NadelHydrationResultFieldPredicate = {
  /** Can be Int, Boolean or String */
  equals?: InputMaybe<Scalars['JSON']['input']>;
  /** Supply a regex that the resulting String should match */
  matches?: InputMaybe<Scalars['String']['input']>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

/**  This can be extended with new enums which are templates */
export enum NadelHydrationTemplate {
  NadelPlaceholder = 'NADEL_PLACEHOLDER'
}

/**  Minimal details required to create a new card (as opposed to Card which is everything). */
export type NewCard = {
  assigneeId?: InputMaybe<Scalars['ID']['input']>;
  fixVersions?: InputMaybe<Array<Scalars['ID']['input']>>;
  issueTypeId: Scalars['ID']['input'];
  labels?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  parentId?: InputMaybe<Scalars['ID']['input']>;
  summary: Scalars['String']['input'];
};

export type NewCardParent = {
  issueTypeId: Scalars['ID']['input'];
  summary: Scalars['String']['input'];
};

export type NewSplitIssueRequest = {
  destinationId?: InputMaybe<Scalars['ID']['input']>;
  estimate?: InputMaybe<Scalars['String']['input']>;
  estimateFieldId?: InputMaybe<Scalars['String']['input']>;
  summary: Scalars['String']['input'];
};

export enum NlpDisclaimer {
  WhoQuestion = 'WHO_QUESTION'
}

export enum NlpErrorState {
  AcceptableUseViolations = 'ACCEPTABLE_USE_VIOLATIONS',
  AiDisabled = 'AI_DISABLED',
  NoAnswer = 'NO_ANSWER',
  NoAnswerHydration = 'NO_ANSWER_HYDRATION',
  NoAnswerKeywords = 'NO_ANSWER_KEYWORDS',
  NoAnswerOpenAiResponseErr = 'NO_ANSWER_OPEN_AI_RESPONSE_ERR',
  NoAnswerRelevantContent = 'NO_ANSWER_RELEVANT_CONTENT',
  NoAnswerSearchResults = 'NO_ANSWER_SEARCH_RESULTS',
  NoAnswerWhoQuestion = 'NO_ANSWER_WHO_QUESTION',
  OpenaiRateLimitUserAbuse = 'OPENAI_RATE_LIMIT_USER_ABUSE',
  SubjectiveQuery = 'SUBJECTIVE_QUERY'
}

/** For Reading Aids */
export enum NlpGetKeywordsTextFormat {
  Adf = 'ADF',
  PlainText = 'PLAIN_TEXT'
}

export type NlpGetKeywordsTextInput = {
  format: NlpGetKeywordsTextFormat;
  text: Scalars['String']['input'];
};

export enum NlpSearchResultFormat {
  Adf = 'ADF',
  Json = 'JSON',
  Markdown = 'MARKDOWN',
  PlainText = 'PLAIN_TEXT'
}

export enum NlpSearchResultType {
  Blogpost = 'blogpost',
  Page = 'page',
  User = 'user'
}

export type OriginalSplitIssue = {
  destinationId?: InputMaybe<Scalars['ID']['input']>;
  estimate?: InputMaybe<Scalars['String']['input']>;
  estimateFieldId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  summary: Scalars['String']['input'];
};

export type PeapConfluenceSiteEnrollmentMutationInput = {
  cloudId: Scalars['ID']['input'];
  desiredStatus: Scalars['Boolean']['input'];
  programId: Scalars['ID']['input'];
};

export type PeapConfluenceSiteEnrollmentQueryInput = {
  cloudId: Scalars['ID']['input'];
  programId: Scalars['ID']['input'];
};

/**
 * input PEAPUserSiteEnrollmentQueryInput {
 *   programId: ID!
 *   cloudId: ID! #@ARI(....)
 * }
 * input PEAPOrgEnrollmentQueryInput {
 *   programId: ID!
 *   orgId: ID! @ARI(type: "org", owner: "platform")
 * }
 * input PEAPOrgUserEnrollmentQueryInput {
 *   programId: ID!
 *   orgId: ID! @ARI(type: "org", owner: "platform")
 * }
 */
export type PeapJiraSiteEnrollmentMutationInput = {
  cloudId: Scalars['ID']['input'];
  desiredStatus: Scalars['Boolean']['input'];
  programId: Scalars['ID']['input'];
};

export type PeapJiraSiteEnrollmentQueryInput = {
  cloudId: Scalars['ID']['input'];
  programId: Scalars['ID']['input'];
};

/** Parameters that can be used to create new EAPs */
export type PeapNewProgramInput = {
  /** A description of the EAP */
  description: Scalars['String']['input'];
  /** A URL where partners can find the documentation of the features under EAP */
  documentationURL: Scalars['String']['input'];
  /** A short name that provides a crisp summary of the EAP */
  name: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['String']['input']>;
  /** Slack channel for owning team */
  teamChannel?: InputMaybe<Scalars['String']['input']>;
};

/** All status values for EAPs */
export enum PeapProgramStatus {
  Abandoned = 'ABANDONED',
  Active = 'ACTIVE',
  Ended = 'ENDED',
  New = 'NEW',
  Planned = 'PLANNED'
}

/** Query Parameters when looking for EAPs */
export type PeapQueryParams = {
  /** Any term that should be used to lookup EAPs by description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Any term that should be used to lookup EAPs by name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** An array of statuses, to lookup EAPs that are only in any of the given statuses */
  status?: InputMaybe<Array<PeapProgramStatus>>;
};

export type PeapSiteEnrollmentQueryInput = {
  cloudId: Scalars['ID']['input'];
  programId: Scalars['ID']['input'];
};

/** Parameters that can be used to update existing EAPs */
export type PeapUpdateProgramInput = {
  /** A description of the EAP */
  description?: InputMaybe<Scalars['String']['input']>;
  /** A URL where partners can find the documentation of the features under EAP */
  documentationURL?: InputMaybe<Scalars['String']['input']>;
  /** A short name that provides a crisp summary of the EAP */
  name?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['String']['input']>;
  /** Slack channel for owning team */
  teamChannel?: InputMaybe<Scalars['String']['input']>;
};

export enum PartnerBtfLicenseType {
  Academic = 'ACADEMIC',
  Commercial = 'COMMERCIAL',
  Evaluation = 'EVALUATION',
  Starter = 'STARTER'
}

export enum PartnerCloudLicenseType {
  Academic = 'ACADEMIC',
  Commercial = 'COMMERCIAL',
  Community = 'COMMUNITY',
  Demonstration = 'DEMONSTRATION',
  Developer = 'DEVELOPER',
  Evaluation = 'EVALUATION',
  Free = 'FREE',
  OpenSource = 'OPEN_SOURCE',
  Starter = 'STARTER'
}

export enum PartnerCurrency {
  Jpy = 'JPY',
  Usd = 'USD'
}

export enum PartnerInvoiceJsonCurrency {
  Aud = 'AUD',
  Eur = 'EUR',
  Gbp = 'GBP',
  Jpy = 'JPY',
  Usd = 'USD'
}

/**  --------------------------------------------------------------------------------------------- */
export type PartnerInvoiceJsonFilter = {
  id?: InputMaybe<Scalars['ID']['input']>;
  number?: InputMaybe<Scalars['ID']['input']>;
};

export type PartnerOfferingBtfInput = {
  /** Available currencies for a BTF product or app */
  currency?: InputMaybe<Array<InputMaybe<PartnerCurrency>>>;
  /** Available license types for a BTF offering */
  licenseType?: InputMaybe<Array<InputMaybe<PartnerBtfLicenseType>>>;
  /** Unique identifier for a BTF product */
  productKey: Scalars['ID']['input'];
};

export type PartnerOfferingCloudInput = {
  /** Available currencies for a cloud product or app */
  currency?: InputMaybe<Array<InputMaybe<PartnerCurrency>>>;
  /** Unique identifier for a cloud product */
  id: Scalars['ID']['input'];
  /** Available license types for a cloud offering */
  pricingPlanType?: InputMaybe<Array<InputMaybe<PartnerCloudLicenseType>>>;
};

/** Search for available product offerings */
export type PartnerOfferingFilter = {
  /** Search BTF offerings by product key */
  btfProduct?: InputMaybe<PartnerOfferingBtfInput>;
  /** Search cloud offerings by product key */
  cloudProduct?: InputMaybe<PartnerOfferingCloudInput>;
};

/** ## Plan mode create cards ### */
export type PlanModeCardCreateInput = {
  boardId: Scalars['ID']['input'];
  destination: PlanModeDestination;
  destinationId?: InputMaybe<Scalars['ID']['input']>;
  newCards: Array<InputMaybe<NewCard>>;
  rankBeforeCardId?: InputMaybe<Scalars['Long']['input']>;
};

export type PlanModeCardMoveInput = {
  boardId: Scalars['ID']['input'];
  cardIds: Array<Scalars['ID']['input']>;
  destination: PlanModeDestination;
  rankAfterCardId?: InputMaybe<Scalars['Long']['input']>;
  rankBeforeCardId?: InputMaybe<Scalars['Long']['input']>;
  sprintId?: InputMaybe<Scalars['ID']['input']>;
};

export enum PlanModeDestination {
  Backlog = 'BACKLOG',
  Board = 'BOARD',
  Sprint = 'SPRINT'
}

export type PolarisAddReactionInput = {
  ari: Scalars['String']['input'];
  containerAri: Scalars['String']['input'];
  emojiId: Scalars['String']['input'];
  metadata?: InputMaybe<Scalars['JSON']['input']>;
};

/** # Types */
export enum PolarisCommentKind {
  PlayContribution = 'PLAY_CONTRIBUTION',
  View = 'VIEW'
}

export type PolarisDeleteReactionInput = {
  ari: Scalars['String']['input'];
  containerAri: Scalars['String']['input'];
  emojiId: Scalars['String']['input'];
  metadata?: InputMaybe<Scalars['JSON']['input']>;
};

/** # Types */
export enum PolarisFieldType {
  PolarisIdeaDateField = 'PolarisIdeaDateField',
  PolarisIdeaDateTimeField = 'PolarisIdeaDateTimeField',
  PolarisIdeaExternalReferenceField = 'PolarisIdeaExternalReferenceField',
  PolarisIdeaExternalReferencePropertyField = 'PolarisIdeaExternalReferencePropertyField',
  PolarisIdeaIntervalField = 'PolarisIdeaIntervalField',
  PolarisIdeaLabelsField = 'PolarisIdeaLabelsField',
  PolarisIdeaNumberField = 'PolarisIdeaNumberField',
  PolarisIdeaOptionField = 'PolarisIdeaOptionField',
  PolarisIdeaOptionsField = 'PolarisIdeaOptionsField',
  PolarisIdeaPlayField = 'PolarisIdeaPlayField',
  PolarisIdeaReactionsField = 'PolarisIdeaReactionsField',
  PolarisIdeaStringField = 'PolarisIdeaStringField',
  PolarisIdeaUserField = 'PolarisIdeaUserField',
  PolarisIdeaUsersField = 'PolarisIdeaUsersField',
  PolarisJiraField = 'PolarisJiraField'
}

export type PolarisFilterInput = {
  jql?: InputMaybe<Scalars['String']['input']>;
};

export type PolarisGetDetailedReactionInput = {
  ari: Scalars['String']['input'];
  containerAri: Scalars['String']['input'];
  emojiId: Scalars['String']['input'];
};

export type PolarisGetReactionsInput = {
  aris?: InputMaybe<Array<Scalars['String']['input']>>;
  containerAri: Scalars['String']['input'];
};

export type PolarisGroupValueInput = {
  /**  a label value (which has no identity besides its string value) */
  id?: InputMaybe<Scalars['String']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};

export enum PolarisPlayKind {
  PolarisBudgetAllocationPlay = 'PolarisBudgetAllocationPlay'
}

export enum PolarisRefreshError {
  InternalError = 'INTERNAL_ERROR',
  InvalidSnippet = 'INVALID_SNIPPET',
  NeedAuth = 'NEED_AUTH',
  NotFound = 'NOT_FOUND'
}

/** # Types */
export enum PolarisResolvedObjectAuthType {
  ApiKey = 'API_KEY',
  Oauth2 = 'OAUTH2'
}

export enum PolarisSnippetPropertyKind {
  /**  1-5 integer rating */
  Labels = 'LABELS',
  Number = 'NUMBER',
  /**  generic number */
  Rating = 'RATING'
}

export type PolarisSortFieldInput = {
  field: Scalars['ID']['input'];
  order?: InputMaybe<PolarisSortOrder>;
};

export enum PolarisSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export enum PolarisTimelineMode {
  Months = 'MONTHS',
  Quarters = 'QUARTERS',
  Years = 'YEARS'
}

export enum PolarisValueOperator {
  Eq = 'EQ',
  Gt = 'GT',
  Gte = 'GTE',
  Lt = 'LT',
  Lte = 'LTE'
}

export type PolarisViewFieldRollupInput = {
  field: Scalars['ID']['input'];
  /**  polaris field ID */
  rollup: PolarisViewFieldRollupType;
};

export enum PolarisViewFieldRollupType {
  Avg = 'AVG',
  Count = 'COUNT',
  Empty = 'EMPTY',
  Filled = 'FILLED',
  Max = 'MAX',
  Median = 'MEDIAN',
  Min = 'MIN',
  Range = 'RANGE',
  Sum = 'SUM'
}

export type PolarisViewFilterInput = {
  field?: InputMaybe<Scalars['ID']['input']>;
  kind: PolarisViewFilterKind;
  values: Array<PolarisViewFilterValueInput>;
};

/** # Types */
export enum PolarisViewFilterKind {
  FieldIdentity = 'FIELD_IDENTITY',
  /**  a field being matched by identity */
  FieldNumeric = 'FIELD_NUMERIC',
  Interval = 'INTERVAL',
  /**  a field being matched by numeric comparison */
  Text = 'TEXT'
}

export enum PolarisViewFilterOperator {
  EndAfterNow = 'END_AFTER_NOW',
  EndBeforeNow = 'END_BEFORE_NOW',
  Eq = 'EQ',
  Gt = 'GT',
  Gte = 'GTE',
  Lt = 'LT',
  Lte = 'LTE',
  Neq = 'NEQ',
  StartAfterNow = 'START_AFTER_NOW',
  StartBeforeNow = 'START_BEFORE_NOW'
}

export type PolarisViewFilterValueInput = {
  operator?: InputMaybe<PolarisViewFilterOperator>;
  text?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['Float']['input']>;
};

export enum PolarisViewLayoutType {
  Compact = 'COMPACT',
  Detailed = 'DETAILED',
  Summary = 'SUMMARY'
}

/** # Types */
export enum PolarisViewSetType {
  Capture = 'CAPTURE',
  Custom = 'CUSTOM',
  Deliver = 'DELIVER',
  Prioritize = 'PRIORITIZE',
  /**  for views that are used to manage the display of single ideas (e.g., Idea views) */
  Section = 'SECTION',
  Single = 'SINGLE',
  System = 'SYSTEM'
}

export enum PolarisViewSortMode {
  FieldsSort = 'FIELDS_SORT',
  ProjectRank = 'PROJECT_RANK',
  ViewRank = 'VIEW_RANK'
}

export type PolarisViewTableColumnSizeInput = {
  field: Scalars['ID']['input'];
  /**  polaris field ID */
  size: Scalars['Int']['input'];
};

export enum PolarisVisualizationType {
  Board = 'BOARD',
  Matrix = 'MATRIX',
  Table = 'TABLE',
  Timeline = 'TIMELINE',
  Twoxtwo = 'TWOXTWO'
}

/**
 * Principals types that App can allow for unlicensed access. This maps to different type of users in product.
 * For example - in case of JSM users can be UNLICENSED, CUSTOMER and ANONYMOUS.
 * UNLICENSED is Atlassian Account users who do not have a license on the underlying product where the extension is rendering
 * CUSTOMER - A site-specific Customer Account (accountId in format qm:{uuid}:{uuid} see https://developer.atlassian.com/platform/identity/rest/v1/))
 * ANONYMOUS - An invocation by a user that is not authenticated i.e. a Public JSM Portal/Confluence Space/Jira Project etc
 */
export enum PrincipalType {
  Anonymous = 'ANONYMOUS',
  Customer = 'CUSTOMER',
  Unlicensed = 'UNLICENSED'
}

/** Accepts input to find pull requests based on the status and time range. */
export type PullRequestStatusInTimeRangeQueryFilter = {
  /** Returns the pull requests with this status. */
  status: CompassPullRequestStatusForStatusInTimeRangeFilter;
  /** The time range of the query. */
  timeRange: CompassQueryTimeRange;
};

/** Metadata on any analytics related fields, these do not affect the search */
export type QuerySuggestionAnalyticsInput = {
  queryVersion?: InputMaybe<Scalars['Int']['input']>;
  searchReferrerId?: InputMaybe<Scalars['String']['input']>;
  searchSessionId?: InputMaybe<Scalars['String']['input']>;
  /** The product which is running the experience e.g. confluence. */
  sourceProduct?: InputMaybe<Scalars['String']['input']>;
};

/** Filters to apply to query suggestions */
export type QuerySuggestionFilterInput = {
  /**
   * ATI strings of which entities to search for. In this context, these entities correspond to the 'product.indexType'.
   * For our specific use case, they should be represented as 'query-suggestion.query-suggestion-item'.
   * These inputs are sent to the 'xpsearch-aggregator' to perform a search in the content index."
   */
  entities: Array<Scalars['String']['input']>;
  /** ARIs of which cloudIds or orgs to search in */
  locations: Array<Scalars['String']['input']>;
};

export type RankColumnInput = {
  boardId: Scalars['ID']['input'];
  columnId: Scalars['ID']['input'];
  position: Scalars['Int']['input'];
};

export type RankCustomFilterInput = {
  afterFilterId?: InputMaybe<Scalars['String']['input']>;
  boardId: Scalars['ID']['input'];
  id: Scalars['String']['input'];
};

export type RateLimitPolicyProperty = {
  argumentPath: Scalars['String']['input'];
  useCloudIdFromARI?: Scalars['Boolean']['input'];
};

export enum RateLimitingCurrency {
  CannedResponseMutationCurrency = 'CANNED_RESPONSE_MUTATION_CURRENCY',
  CannedResponseQueryCurrency = 'CANNED_RESPONSE_QUERY_CURRENCY',
  CompassSynchronizeLinkAssociationsCurrency = 'COMPASS_SYNCHRONIZE_LINK_ASSOCIATIONS_CURRENCY',
  DevopsContainerRelationshipsReadCurrency = 'DEVOPS_CONTAINER_RELATIONSHIPS_READ_CURRENCY',
  DevopsContainerRelationshipsWriteCurrency = 'DEVOPS_CONTAINER_RELATIONSHIPS_WRITE_CURRENCY',
  DevopsServiceReadCurrency = 'DEVOPS_SERVICE_READ_CURRENCY',
  DevopsServiceWriteCurrency = 'DEVOPS_SERVICE_WRITE_CURRENCY',
  ExportMetricsCurrency = 'EXPORT_METRICS_CURRENCY',
  ForgeAlertsCurrency = 'FORGE_ALERTS_CURRENCY',
  ForgeAppContributorCurrency = 'FORGE_APP_CONTRIBUTOR_CURRENCY',
  ForgeAuditLogsCurrency = 'FORGE_AUDIT_LOGS_CURRENCY',
  ForgeMetricsCurrency = 'FORGE_METRICS_CURRENCY',
  HelpCenterCurrency = 'HELP_CENTER_CURRENCY',
  HelpLayoutCurrency = 'HELP_LAYOUT_CURRENCY',
  HelpObjectStoreCurrency = 'HELP_OBJECT_STORE_CURRENCY',
  KnowledgeBaseCurrency = 'KNOWLEDGE_BASE_CURRENCY',
  PolarisBetaUserCurrency = 'POLARIS_BETA_USER_CURRENCY',
  PolarisCollabTokenQueryCurrency = 'POLARIS_COLLAB_TOKEN_QUERY_CURRENCY',
  PolarisCommentCurrency = 'POLARIS_COMMENT_CURRENCY',
  PolarisCurrency = 'POLARIS_CURRENCY',
  PolarisFieldCurrency = 'POLARIS_FIELD_CURRENCY',
  PolarisIdeaCurrency = 'POLARIS_IDEA_CURRENCY',
  PolarisIdeaTemplatesQueryCurrency = 'POLARIS_IDEA_TEMPLATES_QUERY_CURRENCY',
  PolarisIdeaTemplateCurrency = 'POLARIS_IDEA_TEMPLATE_CURRENCY',
  PolarisInsightsQueryCurrency = 'POLARIS_INSIGHTS_QUERY_CURRENCY',
  PolarisInsightsWithErrorsQueryCurrency = 'POLARIS_INSIGHTS_WITH_ERRORS_QUERY_CURRENCY',
  PolarisInsightCurrency = 'POLARIS_INSIGHT_CURRENCY',
  PolarisInsightQueryCurrency = 'POLARIS_INSIGHT_QUERY_CURRENCY',
  PolarisLabelsQueryCurrency = 'POLARIS_LABELS_QUERY_CURRENCY',
  PolarisOnboardingCurrency = 'POLARIS_ONBOARDING_CURRENCY',
  PolarisPlayCurrency = 'POLARIS_PLAY_CURRENCY',
  PolarisProjectConfigCurrency = 'POLARIS_PROJECT_CONFIG_CURRENCY',
  PolarisProjectQueryCurrency = 'POLARIS_PROJECT_QUERY_CURRENCY',
  PolarisRankingCurrency = 'POLARIS_RANKING_CURRENCY',
  PolarisReactionCurrency = 'POLARIS_REACTION_CURRENCY',
  PolarisSnippetCurrency = 'POLARIS_SNIPPET_CURRENCY',
  PolarisSnippetPropertiesConfigQueryCurrency = 'POLARIS_SNIPPET_PROPERTIES_CONFIG_QUERY_CURRENCY',
  PolarisTermsConsentQueryCurrency = 'POLARIS_TERMS_CONSENT_QUERY_CURRENCY',
  PolarisUnfurlCurrency = 'POLARIS_UNFURL_CURRENCY',
  PolarisViewsetCurrency = 'POLARIS_VIEWSET_CURRENCY',
  /**  Depraecated currency */
  PolarisViewArrangementInfoQueryCurrency = 'POLARIS_VIEW_ARRANGEMENT_INFO_QUERY_CURRENCY',
  PolarisViewCurrency = 'POLARIS_VIEW_CURRENCY',
  PolarisViewQueryCurrency = 'POLARIS_VIEW_QUERY_CURRENCY',
  PolarisWriteCurrency = 'POLARIS_WRITE_CURRENCY',
  ShepherdDefaultCurrency = 'SHEPHERD_DEFAULT_CURRENCY',
  ShepherdMultipleReadsCurrency = 'SHEPHERD_MULTIPLE_READS_CURRENCY',
  ShepherdReadAlertCurrency = 'SHEPHERD_READ_ALERT_CURRENCY',
  TeamsCurrency = 'TEAMS_CURRENCY',
  TeamMembersCurrency = 'TEAM_MEMBERS_CURRENCY',
  TeamMembersV2Currency = 'TEAM_MEMBERS_V2_CURRENCY',
  TeamRoleGrantsMutatePrincipalsCurrency = 'TEAM_ROLE_GRANTS_MUTATE_PRINCIPALS_CURRENCY',
  TeamRoleGrantsQueryPrincipalsCurrency = 'TEAM_ROLE_GRANTS_QUERY_PRINCIPALS_CURRENCY',
  TeamSearchCurrency = 'TEAM_SEARCH_CURRENCY',
  /** This isn't used anywhere but we're keeping it around so pipelines don't break */
  TeamSearchV2Currency = 'TEAM_SEARCH_V2_CURRENCY',
  TeamV2Currency = 'TEAM_V2_CURRENCY',
  TestingService = 'TESTING_SERVICE',
  TrelloCurrency = 'TRELLO_CURRENCY',
  TrelloMutationCurrency = 'TRELLO_MUTATION_CURRENCY'
}

export type RefreshPolarisSnippetsInput = {
  project: Scalars['ID']['input'];
  /**
   * Specifies a set of snippets to be refreshed for finer-grain control than
   * at the project level (a required property for this API).  This field
   * is optional, and if specified must refer to either an issue, an
   * insight, or a snippet.
   */
  subject?: InputMaybe<Scalars['ID']['input']>;
  /**
   * An optional flag indicating whether or not the refresh should be performed
   * synchronously.  By default (if this flag is not included, or if its value
   * is false), the refresh is performed asynchronously.
   */
  synchronous?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RefreshTokenInput = {
  refreshTokenRotation: Scalars['Boolean']['input'];
};

/**
 * Establish tunnels for a specific environment of an app.
 *
 * This will create a cloudflare tunnel for forge app debugging
 */
export type RegisterTunnelInput = {
  /** The app to setup a tunnel for */
  appId: Scalars['ID']['input'];
  /** The environment key */
  environmentKey: Scalars['String']['input'];
};

export type RemoveAppContributorsInput = {
  accountIds?: InputMaybe<Array<Scalars['String']['input']>>;
  appId: Scalars['ID']['input'];
  emails?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Accepts input for removing labels from a component. */
export type RemoveCompassComponentLabelsInput = {
  /** The ID of the component to remove the labels from. */
  componentId: Scalars['ID']['input'];
  /** The collection of labels to remove from the component. */
  labelNames: Array<Scalars['String']['input']>;
};

export type RemovePolarisColumnInput = {
  /** The column position to be removed */
  column: Scalars['ID']['input'];
};

export type ResolvePolarisObjectInput = {
  /** Custom auth token that will be used in unfurl request and saved if request was successful */
  authToken?: InputMaybe<Scalars['String']['input']>;
  /** Issue ARI */
  issue: Scalars['ID']['input'];
  /** Project ARI */
  project: Scalars['ID']['input'];
  /** Resource url that will be used to unfurl data */
  resourceUrl: Scalars['String']['input'];
};

/**  Input of a roadmap add item mutation. */
export type RoadmapAddItemInput = {
  /**  AccountId of the assignee. */
  assignee?: InputMaybe<Scalars['String']['input']>;
  /**  What color should be shown for this item */
  color?: InputMaybe<RoadmapPaletteColor>;
  /**  List of ids of the components on this item */
  componentIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**  When this item is due; date in RFC3339 DateTime format */
  dueDate?: InputMaybe<Scalars['Date']['input']>;
  /**  The type of this item */
  itemTypeId: Scalars['ID']['input'];
  /**  Jql of the board the issue is being created for */
  jql?: InputMaybe<Scalars['String']['input']>;
  /**  A list of Jql of the board the issue is being created for */
  jqlContexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  List of labels to be added to the newly created issue. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  The ID of the parent */
  parentId?: InputMaybe<Scalars['ID']['input']>;
  /**  Roadmap project ID; used only to fetch custom fields and won't have any impact on the item itself */
  projectId: Scalars['ID']['input'];
  /**  Item rank request */
  rank?: InputMaybe<RoadmapAddItemRank>;
  /**  When this item is set to start; date in RFC3339 DateTime format */
  startDate?: InputMaybe<Scalars['Date']['input']>;
  /**  The summary of this item */
  summary: Scalars['String']['input'];
  /**  List of ids of the versions on this item */
  versionIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type RoadmapAddItemRank = {
  /**  Rank before ID; used only to rank the item before the input item ID */
  beforeId?: InputMaybe<Scalars['ID']['input']>;
};

export type RoadmapAddLevelOneIssueTypeHealthcheckResolution = {
  /**  Information required to create a new level one issue type */
  create?: InputMaybe<RoadmapCreateLevelOneIssueType>;
  /**  Information required to promote an existing issue type to a level one issue type */
  promote?: InputMaybe<RoadmapPromoteLevelOneIssueType>;
};

/**  Child Issue Planning Mode */
export enum RoadmapChildIssuePlanningMode {
  /**  Use Date based planning */
  Date = 'DATE',
  /**  Disabled child issue planning */
  Disabled = 'DISABLED',
  /**  Use Sprint based planning */
  Sprint = 'SPRINT'
}

export type RoadmapCreateLevelOneIssueType = {
  /**  The description of the epic type */
  epicTypeDescription: Scalars['String']['input'];
  /**  The name of the epic type */
  epicTypeName: Scalars['String']['input'];
};

/** View settings for epics on the roadmap */
export enum RoadmapEpicView {
  /** All epics regardless of status */
  All = 'ALL',
  /** Epics with status complete */
  Completed = 'COMPLETED',
  /** Epics with status incomplete */
  Incomplete = 'INCOMPLETE'
}

export type RoadmapItemRankInput = {
  /**  The existing item to rank the updated or created item before/after */
  id: Scalars['ID']['input'];
  /**  The position relative to id to rank the item */
  position: RoadmapRankPosition;
};

/** View settings for hierarchy level one items on the roadmap */
export enum RoadmapLevelOneView {
  /** Show level one items completed within last 1 month */
  Complete1M = 'COMPLETE1M',
  /** Show level one items completed within last 3 months */
  Complete3M = 'COMPLETE3M',
  /** Show level one items completed within last 6 months */
  Complete6M = 'COMPLETE6M',
  /** Show level one items completed within last 9 months */
  Complete9M = 'COMPLETE9M',
  /** Show level one items completed within last 12 months */
  Complete12M = 'COMPLETE12M',
  /** Do not show completed level one items */
  Incomplete = 'INCOMPLETE'
}

/** Supported colors in the Palette */
export enum RoadmapPaletteColor {
  Blue = 'BLUE',
  DarkBlue = 'DARK_BLUE',
  DarkGreen = 'DARK_GREEN',
  DarkGrey = 'DARK_GREY',
  DarkOrange = 'DARK_ORANGE',
  DarkPurple = 'DARK_PURPLE',
  DarkTeal = 'DARK_TEAL',
  DarkYellow = 'DARK_YELLOW',
  Green = 'GREEN',
  Grey = 'GREY',
  Orange = 'ORANGE',
  Purple = 'PURPLE',
  Teal = 'TEAL',
  Yellow = 'YELLOW'
}

export type RoadmapPromoteLevelOneIssueType = {
  /**  The numeric id of the item type that will be promoted to level one */
  promoteItemTypeId: Scalars['ID']['input'];
};

export enum RoadmapRankPosition {
  /**  Rank the item after the provided id */
  After = 'AFTER',
  /**  Rank the item before the provided id */
  Before = 'BEFORE'
}

/**  Input for setting up a project with a roadmap */
export type RoadmapResolveHealthcheckInput = {
  /**  The healthcheck action id */
  actionId: Scalars['ID']['input'];
  /**  Required to fix add-level-one-issue-type healthcheck */
  addLevelOneIssueType?: InputMaybe<RoadmapAddLevelOneIssueTypeHealthcheckResolution>;
};

/**  Input for a single roadmap schedule item. */
export type RoadmapScheduleItemInput = {
  /**  When this item is due; date in RFC3339 DateTime format */
  dueDate?: InputMaybe<Scalars['Date']['input']>;
  /**  Roadmap item ID */
  itemId: Scalars['ID']['input'];
  /**  When this item is set to start; date in RFC3339 DateTime format */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/**  Input of a roadmap schedule items mutation. */
export type RoadmapScheduleItemsInput = {
  /**  List of schedule requests */
  scheduleRequests: Array<InputMaybe<RoadmapScheduleItemInput>>;
};

/** States that a sprint can be in */
export enum RoadmapSprintState {
  /** A current sprint */
  Active = 'ACTIVE',
  /** A sprint that was completed in the past */
  Closed = 'CLOSED',
  /** A sprint that is planned for the future */
  Future = 'FUTURE'
}

/** Defines the available timeline modes */
export enum RoadmapTimelineMode {
  /** Months */
  Months = 'MONTHS',
  /** Quarters */
  Quarters = 'QUARTERS',
  /** Weeks */
  Weeks = 'WEEKS'
}

export type RoadmapToggleDependencyInput = {
  /**  "dependee" requires/depends on "dependency" */
  dependee: Scalars['ID']['input'];
  /**  "dependency" is required/depended on by "dependee" */
  dependency: Scalars['ID']['input'];
};

/**  Input of a roadmap update item mutation. */
export type RoadmapUpdateItemInput = {
  /**  Field to be cleared; clearFields take precedence over other field input */
  clearFields?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  What color should be shown for this item */
  color?: InputMaybe<RoadmapPaletteColor>;
  /**  When this item is due; date in RFC3339 DateTime format */
  dueDate?: InputMaybe<Scalars['Date']['input']>;
  /**  Roadmap item ID */
  itemId: Scalars['ID']['input'];
  /**  The id of the parent of the issue */
  parentId?: InputMaybe<Scalars['ID']['input']>;
  /**  Roadmap project ID; used only to fetch custom fields and won't have any impact on the item itself */
  projectId: Scalars['ID']['input'];
  /**  Item rank request */
  rank?: InputMaybe<RoadmapItemRankInput>;
  /**  Sprint id of the roadmap item */
  sprintId?: InputMaybe<Scalars['ID']['input']>;
  /**  When this item is set to start; date in RFC3339 DateTime format */
  startDate?: InputMaybe<Scalars['Date']['input']>;
  /**  The summary of this item */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/**  Input for updating roadmap settings */
export type RoadmapUpdateSettingsInput = {
  /**  indicates to enable or disable child issue planning on the roadmap */
  childIssuePlanningEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /**  The child issue planning mode */
  childIssuePlanningMode?: InputMaybe<RoadmapChildIssuePlanningMode>;
  /**  indicates to enable or disable the roadmap */
  roadmapEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Avaliable version statuses */
export enum RoadmapVersionStatus {
  /** version has been archived */
  Archived = 'ARCHIVED',
  /** version has been released */
  Released = 'RELEASED',
  /** version has not been released */
  Unreleased = 'UNRELEASED'
}

/** An enum of the possible values of a sandbox event result. */
export enum SandboxEventResult {
  Failed = 'failed',
  Incomplete = 'incomplete',
  Successful = 'successful',
  Unknown = 'unknown'
}

/** An enum of the possible values of a sandbox event source. */
export enum SandboxEventSource {
  Admin = 'admin',
  System = 'system',
  User = 'user'
}

/** An enum of the possible values of a sandbox event status. */
export enum SandboxEventStatus {
  AwaitingReplay = 'awaiting_replay',
  Cancelled = 'cancelled',
  Completed = 'completed',
  Started = 'started'
}

/** An enum of the possible values of a sandbox event type. */
export enum SandboxEventType {
  Create = 'create',
  DataClone = 'data_clone',
  DataCloneSelective = 'data_clone_selective',
  HardDelete = 'hard_delete',
  Reset = 'reset',
  Reshard = 'reshard',
  Rollback = 'rollback',
  SoftDelete = 'soft_delete'
}

export type ScanPolarisProjectInput = {
  project: Scalars['ID']['input'];
  refresh?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum Scope {
  /** outbound-auth */
  AdminContainer = 'ADMIN_CONTAINER',
  ApiAccess = 'API_ACCESS',
  /**
   * jira - granular scopes.
   * Each Jira Mutation and Query should have one or more of these in an `@scope` tag and one of the non-granular scopes above
   */
  ApplicationRoleRead = 'APPLICATION_ROLE_READ',
  AsyncTaskDelete = 'ASYNC_TASK_DELETE',
  AttachmentDelete = 'ATTACHMENT_DELETE',
  AttachmentRead = 'ATTACHMENT_READ',
  AttachmentWrite = 'ATTACHMENT_WRITE',
  AuditLogRead = 'AUDIT_LOG_READ',
  AuthConfluenceUser = 'AUTH_CONFLUENCE_USER',
  AvatarDelete = 'AVATAR_DELETE',
  AvatarRead = 'AVATAR_READ',
  AvatarWrite = 'AVATAR_WRITE',
  /** papi */
  CatalogRead = 'CATALOG_READ',
  CommentDelete = 'COMMENT_DELETE',
  CommentPropertyDelete = 'COMMENT_PROPERTY_DELETE',
  CommentPropertyRead = 'COMMENT_PROPERTY_READ',
  CommentPropertyWrite = 'COMMENT_PROPERTY_WRITE',
  CommentRead = 'COMMENT_READ',
  CommentWrite = 'COMMENT_WRITE',
  /** compass */
  CompassAtlassianExternal = 'COMPASS_ATLASSIAN_EXTERNAL',
  /** confluence */
  ConfluenceAtlassianExternal = 'CONFLUENCE_ATLASSIAN_EXTERNAL',
  CustomFieldContextualConfigurationRead = 'CUSTOM_FIELD_CONTEXTUAL_CONFIGURATION_READ',
  CustomFieldContextualConfigurationWrite = 'CUSTOM_FIELD_CONTEXTUAL_CONFIGURATION_WRITE',
  DashboardDelete = 'DASHBOARD_DELETE',
  DashboardPropertyDelete = 'DASHBOARD_PROPERTY_DELETE',
  DashboardPropertyRead = 'DASHBOARD_PROPERTY_READ',
  DashboardPropertyWrite = 'DASHBOARD_PROPERTY_WRITE',
  DashboardRead = 'DASHBOARD_READ',
  DashboardWrite = 'DASHBOARD_WRITE',
  DeleteConfluenceAttachment = 'DELETE_CONFLUENCE_ATTACHMENT',
  DeleteConfluenceBlogpost = 'DELETE_CONFLUENCE_BLOGPOST',
  DeleteConfluenceComment = 'DELETE_CONFLUENCE_COMMENT',
  DeleteConfluenceCustomContent = 'DELETE_CONFLUENCE_CUSTOM_CONTENT',
  DeleteConfluencePage = 'DELETE_CONFLUENCE_PAGE',
  DeleteConfluenceSpace = 'DELETE_CONFLUENCE_SPACE',
  DeleteJswBoardScopeAdmin = 'DELETE_JSW_BOARD_SCOPE_ADMIN',
  DeleteJswSprint = 'DELETE_JSW_SPRINT',
  DeleteOrganization = 'DELETE_ORGANIZATION',
  DeleteOrganizationProperty = 'DELETE_ORGANIZATION_PROPERTY',
  DeleteOrganizationUser = 'DELETE_ORGANIZATION_USER',
  DeleteRequesttypeProperty = 'DELETE_REQUESTTYPE_PROPERTY',
  DeleteRequestFeedback = 'DELETE_REQUEST_FEEDBACK',
  DeleteRequestNotification = 'DELETE_REQUEST_NOTIFICATION',
  DeleteRequestParticipant = 'DELETE_REQUEST_PARTICIPANT',
  DeleteServicedeskCustomer = 'DELETE_SERVICEDESK_CUSTOMER',
  DeleteServicedeskOrganization = 'DELETE_SERVICEDESK_ORGANIZATION',
  DeleteServicedeskProperty = 'DELETE_SERVICEDESK_PROPERTY',
  FieldConfigurationDelete = 'FIELD_CONFIGURATION_DELETE',
  FieldConfigurationRead = 'FIELD_CONFIGURATION_READ',
  FieldConfigurationSchemeDelete = 'FIELD_CONFIGURATION_SCHEME_DELETE',
  FieldConfigurationSchemeRead = 'FIELD_CONFIGURATION_SCHEME_READ',
  FieldConfigurationSchemeWrite = 'FIELD_CONFIGURATION_SCHEME_WRITE',
  FieldConfigurationWrite = 'FIELD_CONFIGURATION_WRITE',
  FieldDefaultValueRead = 'FIELD_DEFAULT_VALUE_READ',
  FieldDefaultValueWrite = 'FIELD_DEFAULT_VALUE_WRITE',
  FieldDelete = 'FIELD_DELETE',
  FieldOptionsRead = 'FIELD_OPTIONS_READ',
  FieldOptionDelete = 'FIELD_OPTION_DELETE',
  FieldOptionRead = 'FIELD_OPTION_READ',
  FieldOptionWrite = 'FIELD_OPTION_WRITE',
  FieldRead = 'FIELD_READ',
  FieldWrite = 'FIELD_WRITE',
  FilterColumnDelete = 'FILTER_COLUMN_DELETE',
  FilterColumnRead = 'FILTER_COLUMN_READ',
  FilterColumnWrite = 'FILTER_COLUMN_WRITE',
  FilterDefaultShareScopeRead = 'FILTER_DEFAULT_SHARE_SCOPE_READ',
  FilterDefaultShareScopeWrite = 'FILTER_DEFAULT_SHARE_SCOPE_WRITE',
  FilterDelete = 'FILTER_DELETE',
  FilterRead = 'FILTER_READ',
  FilterWrite = 'FILTER_WRITE',
  GroupDelete = 'GROUP_DELETE',
  GroupRead = 'GROUP_READ',
  GroupWrite = 'GROUP_WRITE',
  IdentityAtlassianExternal = 'IDENTITY_ATLASSIAN_EXTERNAL',
  InstanceConfigurationRead = 'INSTANCE_CONFIGURATION_READ',
  InstanceConfigurationWrite = 'INSTANCE_CONFIGURATION_WRITE',
  IssueAdjustmentsDelete = 'ISSUE_ADJUSTMENTS_DELETE',
  IssueAdjustmentsRead = 'ISSUE_ADJUSTMENTS_READ',
  IssueAdjustmentsWrite = 'ISSUE_ADJUSTMENTS_WRITE',
  IssueChangelogRead = 'ISSUE_CHANGELOG_READ',
  IssueDelete = 'ISSUE_DELETE',
  IssueDetailsRead = 'ISSUE_DETAILS_READ',
  IssueEventRead = 'ISSUE_EVENT_READ',
  IssueFieldValuesRead = 'ISSUE_FIELD_VALUES_READ',
  IssueLinkDelete = 'ISSUE_LINK_DELETE',
  IssueLinkRead = 'ISSUE_LINK_READ',
  IssueLinkTypeDelete = 'ISSUE_LINK_TYPE_DELETE',
  IssueLinkTypeRead = 'ISSUE_LINK_TYPE_READ',
  IssueLinkTypeWrite = 'ISSUE_LINK_TYPE_WRITE',
  IssueLinkWrite = 'ISSUE_LINK_WRITE',
  IssueMetaRead = 'ISSUE_META_READ',
  IssuePropertyDelete = 'ISSUE_PROPERTY_DELETE',
  IssuePropertyRead = 'ISSUE_PROPERTY_READ',
  IssuePropertyWrite = 'ISSUE_PROPERTY_WRITE',
  IssueRead = 'ISSUE_READ',
  IssueRemoteLinkDelete = 'ISSUE_REMOTE_LINK_DELETE',
  IssueRemoteLinkRead = 'ISSUE_REMOTE_LINK_READ',
  IssueRemoteLinkWrite = 'ISSUE_REMOTE_LINK_WRITE',
  IssueSecurityLevelRead = 'ISSUE_SECURITY_LEVEL_READ',
  IssueSecuritySchemeRead = 'ISSUE_SECURITY_SCHEME_READ',
  IssueStatusRead = 'ISSUE_STATUS_READ',
  IssueTimeTrackingRead = 'ISSUE_TIME_TRACKING_READ',
  IssueTimeTrackingWrite = 'ISSUE_TIME_TRACKING_WRITE',
  IssueTransitionRead = 'ISSUE_TRANSITION_READ',
  IssueTypeDelete = 'ISSUE_TYPE_DELETE',
  IssueTypeHierarchyRead = 'ISSUE_TYPE_HIERARCHY_READ',
  IssueTypePropertyDelete = 'ISSUE_TYPE_PROPERTY_DELETE',
  IssueTypePropertyRead = 'ISSUE_TYPE_PROPERTY_READ',
  IssueTypePropertyWrite = 'ISSUE_TYPE_PROPERTY_WRITE',
  IssueTypeRead = 'ISSUE_TYPE_READ',
  IssueTypeSchemeDelete = 'ISSUE_TYPE_SCHEME_DELETE',
  IssueTypeSchemeRead = 'ISSUE_TYPE_SCHEME_READ',
  IssueTypeSchemeWrite = 'ISSUE_TYPE_SCHEME_WRITE',
  IssueTypeScreenSchemeDelete = 'ISSUE_TYPE_SCREEN_SCHEME_DELETE',
  IssueTypeScreenSchemeRead = 'ISSUE_TYPE_SCREEN_SCHEME_READ',
  IssueTypeScreenSchemeWrite = 'ISSUE_TYPE_SCREEN_SCHEME_WRITE',
  IssueTypeWrite = 'ISSUE_TYPE_WRITE',
  IssueVotesRead = 'ISSUE_VOTES_READ',
  IssueVoteRead = 'ISSUE_VOTE_READ',
  IssueVoteWrite = 'ISSUE_VOTE_WRITE',
  IssueWatcherRead = 'ISSUE_WATCHER_READ',
  IssueWatcherWrite = 'ISSUE_WATCHER_WRITE',
  IssueWorklogDelete = 'ISSUE_WORKLOG_DELETE',
  IssueWorklogPropertyDelete = 'ISSUE_WORKLOG_PROPERTY_DELETE',
  IssueWorklogPropertyRead = 'ISSUE_WORKLOG_PROPERTY_READ',
  IssueWorklogPropertyWrite = 'ISSUE_WORKLOG_PROPERTY_WRITE',
  IssueWorklogRead = 'ISSUE_WORKLOG_READ',
  IssueWorklogWrite = 'ISSUE_WORKLOG_WRITE',
  IssueWrite = 'ISSUE_WRITE',
  JiraAtlassianExternal = 'JIRA_ATLASSIAN_EXTERNAL',
  JiraExpressionsRead = 'JIRA_EXPRESSIONS_READ',
  JqlRead = 'JQL_READ',
  JqlValidate = 'JQL_VALIDATE',
  LabelRead = 'LABEL_READ',
  LicenseRead = 'LICENSE_READ',
  /** ecosystem */
  ManageApp = 'MANAGE_APP',
  ManageDirectory = 'MANAGE_DIRECTORY',
  ManageJiraConfiguration = 'MANAGE_JIRA_CONFIGURATION',
  ManageJiraDataProvider = 'MANAGE_JIRA_DATA_PROVIDER',
  ManageJiraProject = 'MANAGE_JIRA_PROJECT',
  ManageJiraWebhook = 'MANAGE_JIRA_WEBHOOK',
  /** identity */
  ManageOrg = 'MANAGE_ORG',
  ManageOrgPublicApis = 'MANAGE_ORG_PUBLIC_APIS',
  ManageServicedeskCustomer = 'MANAGE_SERVICEDESK_CUSTOMER',
  /** platform */
  MigrateConfluence = 'MIGRATE_CONFLUENCE',
  NotificationSchemeRead = 'NOTIFICATION_SCHEME_READ',
  NotificationSend = 'NOTIFICATION_SEND',
  PermissionDelete = 'PERMISSION_DELETE',
  PermissionRead = 'PERMISSION_READ',
  PermissionSchemeDelete = 'PERMISSION_SCHEME_DELETE',
  PermissionSchemeRead = 'PERMISSION_SCHEME_READ',
  PermissionSchemeWrite = 'PERMISSION_SCHEME_WRITE',
  PermissionWrite = 'PERMISSION_WRITE',
  PriorityRead = 'PRIORITY_READ',
  ProjectAvatarDelete = 'PROJECT_AVATAR_DELETE',
  ProjectAvatarRead = 'PROJECT_AVATAR_READ',
  ProjectAvatarWrite = 'PROJECT_AVATAR_WRITE',
  ProjectCategoryDelete = 'PROJECT_CATEGORY_DELETE',
  ProjectCategoryRead = 'PROJECT_CATEGORY_READ',
  ProjectCategoryWrite = 'PROJECT_CATEGORY_WRITE',
  ProjectComponentDelete = 'PROJECT_COMPONENT_DELETE',
  ProjectComponentRead = 'PROJECT_COMPONENT_READ',
  ProjectComponentWrite = 'PROJECT_COMPONENT_WRITE',
  ProjectDelete = 'PROJECT_DELETE',
  ProjectEmailRead = 'PROJECT_EMAIL_READ',
  ProjectEmailWrite = 'PROJECT_EMAIL_WRITE',
  ProjectFeatureRead = 'PROJECT_FEATURE_READ',
  ProjectFeatureWrite = 'PROJECT_FEATURE_WRITE',
  ProjectPropertyDelete = 'PROJECT_PROPERTY_DELETE',
  ProjectPropertyRead = 'PROJECT_PROPERTY_READ',
  ProjectPropertyWrite = 'PROJECT_PROPERTY_WRITE',
  ProjectRead = 'PROJECT_READ',
  ProjectRoleDelete = 'PROJECT_ROLE_DELETE',
  ProjectRoleRead = 'PROJECT_ROLE_READ',
  ProjectRoleWrite = 'PROJECT_ROLE_WRITE',
  ProjectTypeRead = 'PROJECT_TYPE_READ',
  ProjectVersionDelete = 'PROJECT_VERSION_DELETE',
  ProjectVersionRead = 'PROJECT_VERSION_READ',
  ProjectVersionWrite = 'PROJECT_VERSION_WRITE',
  ProjectWrite = 'PROJECT_WRITE',
  /** bitbucket_repository_access_token */
  PullRequest = 'PULL_REQUEST',
  PullRequestWrite = 'PULL_REQUEST_WRITE',
  ReadAccount = 'READ_ACCOUNT',
  ReadCompassAttentionItem = 'READ_COMPASS_ATTENTION_ITEM',
  ReadCompassComponent = 'READ_COMPASS_COMPONENT',
  ReadCompassEvent = 'READ_COMPASS_EVENT',
  ReadCompassMetric = 'READ_COMPASS_METRIC',
  ReadCompassScorecard = 'READ_COMPASS_SCORECARD',
  ReadConfluenceAttachment = 'READ_CONFLUENCE_ATTACHMENT',
  ReadConfluenceAuditLog = 'READ_CONFLUENCE_AUDIT_LOG',
  ReadConfluenceBlogpost = 'READ_CONFLUENCE_BLOGPOST',
  ReadConfluenceComment = 'READ_CONFLUENCE_COMMENT',
  ReadConfluenceConfiguration = 'READ_CONFLUENCE_CONFIGURATION',
  ReadConfluenceContentAnalytics = 'READ_CONFLUENCE_CONTENT_ANALYTICS',
  ReadConfluenceContentMetadata = 'READ_CONFLUENCE_CONTENT_METADATA',
  ReadConfluenceContentPermission = 'READ_CONFLUENCE_CONTENT_PERMISSION',
  ReadConfluenceContentProperty = 'READ_CONFLUENCE_CONTENT_PROPERTY',
  ReadConfluenceContentRestriction = 'READ_CONFLUENCE_CONTENT_RESTRICTION',
  ReadConfluenceCustomContent = 'READ_CONFLUENCE_CUSTOM_CONTENT',
  ReadConfluenceGroup = 'READ_CONFLUENCE_GROUP',
  ReadConfluenceInlineTask = 'READ_CONFLUENCE_INLINE_TASK',
  ReadConfluenceLabel = 'READ_CONFLUENCE_LABEL',
  ReadConfluencePage = 'READ_CONFLUENCE_PAGE',
  ReadConfluenceRelation = 'READ_CONFLUENCE_RELATION',
  ReadConfluenceSpace = 'READ_CONFLUENCE_SPACE',
  ReadConfluenceSpacePermission = 'READ_CONFLUENCE_SPACE_PERMISSION',
  ReadConfluenceSpaceProperty = 'READ_CONFLUENCE_SPACE_PROPERTY',
  ReadConfluenceSpaceSetting = 'READ_CONFLUENCE_SPACE_SETTING',
  ReadConfluenceTemplate = 'READ_CONFLUENCE_TEMPLATE',
  ReadConfluenceUser = 'READ_CONFLUENCE_USER',
  ReadConfluenceUserProperty = 'READ_CONFLUENCE_USER_PROPERTY',
  ReadConfluenceWatcher = 'READ_CONFLUENCE_WATCHER',
  ReadContainer = 'READ_CONTAINER',
  /**
   * jira-servicedesk - granular
   * Each JSM Mutation and Query should have one or more of these in an `@scope` tag and one of the non-granular scopes above.
   * You can mix them with Jira scopes if needed.
   */
  ReadCustomer = 'READ_CUSTOMER',
  ReadDesign = 'READ_DESIGN',
  /**
   * jira - non granular
   * Please add a granular scope as well.
   */
  ReadJiraUser = 'READ_JIRA_USER',
  ReadJiraWork = 'READ_JIRA_WORK',
  /**
   * jsw scopes
   * Note - JSW does not have non granular scopes so it does not need two scope tags like JSM/Jira
   */
  ReadJswBoardScope = 'READ_JSW_BOARD_SCOPE',
  ReadJswBoardScopeAdmin = 'READ_JSW_BOARD_SCOPE_ADMIN',
  ReadJswBuild = 'READ_JSW_BUILD',
  ReadJswDeployment = 'READ_JSW_DEPLOYMENT',
  ReadJswEpic = 'READ_JSW_EPIC',
  ReadJswFeatureFlag = 'READ_JSW_FEATURE_FLAG',
  ReadJswIssue = 'READ_JSW_ISSUE',
  ReadJswRemoteLink = 'READ_JSW_REMOTE_LINK',
  ReadJswSourceCode = 'READ_JSW_SOURCE_CODE',
  ReadJswSprint = 'READ_JSW_SPRINT',
  ReadKnowledgebase = 'READ_KNOWLEDGEBASE',
  ReadMe = 'READ_ME',
  /** Mercury */
  ReadMercury = 'READ_MERCURY',
  /** notification-log */
  ReadNotifications = 'READ_NOTIFICATIONS',
  ReadOrganization = 'READ_ORGANIZATION',
  ReadOrganizationProperty = 'READ_ORGANIZATION_PROPERTY',
  ReadOrganizationUser = 'READ_ORGANIZATION_USER',
  ReadQueue = 'READ_QUEUE',
  ReadRequest = 'READ_REQUEST',
  ReadRequesttype = 'READ_REQUESTTYPE',
  ReadRequesttypeProperty = 'READ_REQUESTTYPE_PROPERTY',
  ReadRequestAction = 'READ_REQUEST_ACTION',
  ReadRequestApproval = 'READ_REQUEST_APPROVAL',
  ReadRequestAttachment = 'READ_REQUEST_ATTACHMENT',
  ReadRequestComment = 'READ_REQUEST_COMMENT',
  ReadRequestFeedback = 'READ_REQUEST_FEEDBACK',
  ReadRequestNotification = 'READ_REQUEST_NOTIFICATION',
  ReadRequestParticipant = 'READ_REQUEST_PARTICIPANT',
  ReadRequestSla = 'READ_REQUEST_SLA',
  ReadRequestStatus = 'READ_REQUEST_STATUS',
  ReadServicedesk = 'READ_SERVICEDESK',
  ReadServicedeskCustomer = 'READ_SERVICEDESK_CUSTOMER',
  ReadServicedeskOrganization = 'READ_SERVICEDESK_ORGANIZATION',
  ReadServicedeskProperty = 'READ_SERVICEDESK_PROPERTY',
  /**
   * jira-servicedesk - non-granular
   * Please add a granular scope as well.
   */
  ReadServicedeskRequest = 'READ_SERVICEDESK_REQUEST',
  /** teams */
  ReadTeam = 'READ_TEAM',
  ReadTeamMembers = 'READ_TEAM_MEMBERS',
  ReadTownsquareComment = 'READ_TOWNSQUARE_COMMENT',
  ReadTownsquareGoal = 'READ_TOWNSQUARE_GOAL',
  /** townsquare (Atlas) */
  ReadTownsquareProject = 'READ_TOWNSQUARE_PROJECT',
  ReadTownsquareWorkspace = 'READ_TOWNSQUARE_WORKSPACE',
  ResolutionRead = 'RESOLUTION_READ',
  ScreenableFieldDelete = 'SCREENABLE_FIELD_DELETE',
  ScreenableFieldRead = 'SCREENABLE_FIELD_READ',
  ScreenableFieldWrite = 'SCREENABLE_FIELD_WRITE',
  ScreenDelete = 'SCREEN_DELETE',
  ScreenFieldRead = 'SCREEN_FIELD_READ',
  ScreenRead = 'SCREEN_READ',
  ScreenSchemeDelete = 'SCREEN_SCHEME_DELETE',
  ScreenSchemeRead = 'SCREEN_SCHEME_READ',
  ScreenSchemeWrite = 'SCREEN_SCHEME_WRITE',
  ScreenTabDelete = 'SCREEN_TAB_DELETE',
  ScreenTabRead = 'SCREEN_TAB_READ',
  ScreenTabWrite = 'SCREEN_TAB_WRITE',
  ScreenWrite = 'SCREEN_WRITE',
  StatusRead = 'STATUS_READ',
  StorageApp = 'STORAGE_APP',
  /** trello */
  TrelloAtlassianExternal = 'TRELLO_ATLASSIAN_EXTERNAL',
  UserColumnsRead = 'USER_COLUMNS_READ',
  UserConfigurationDelete = 'USER_CONFIGURATION_DELETE',
  UserConfigurationRead = 'USER_CONFIGURATION_READ',
  UserConfigurationWrite = 'USER_CONFIGURATION_WRITE',
  UserPropertyDelete = 'USER_PROPERTY_DELETE',
  UserPropertyRead = 'USER_PROPERTY_READ',
  UserPropertyWrite = 'USER_PROPERTY_WRITE',
  UserRead = 'USER_READ',
  ViewUserprofile = 'VIEW_USERPROFILE',
  WebhookDelete = 'WEBHOOK_DELETE',
  WebhookRead = 'WEBHOOK_READ',
  WebhookWrite = 'WEBHOOK_WRITE',
  WorkflowDelete = 'WORKFLOW_DELETE',
  WorkflowPropertyDelete = 'WORKFLOW_PROPERTY_DELETE',
  WorkflowPropertyRead = 'WORKFLOW_PROPERTY_READ',
  WorkflowPropertyWrite = 'WORKFLOW_PROPERTY_WRITE',
  WorkflowRead = 'WORKFLOW_READ',
  WorkflowSchemeDelete = 'WORKFLOW_SCHEME_DELETE',
  WorkflowSchemeRead = 'WORKFLOW_SCHEME_READ',
  WorkflowSchemeWrite = 'WORKFLOW_SCHEME_WRITE',
  WorkflowWrite = 'WORKFLOW_WRITE',
  WriteCompassComponent = 'WRITE_COMPASS_COMPONENT',
  WriteCompassEvent = 'WRITE_COMPASS_EVENT',
  WriteCompassMetric = 'WRITE_COMPASS_METRIC',
  WriteCompassScorecard = 'WRITE_COMPASS_SCORECARD',
  WriteConfluenceAttachment = 'WRITE_CONFLUENCE_ATTACHMENT',
  WriteConfluenceAuditLog = 'WRITE_CONFLUENCE_AUDIT_LOG',
  WriteConfluenceBlogpost = 'WRITE_CONFLUENCE_BLOGPOST',
  WriteConfluenceComment = 'WRITE_CONFLUENCE_COMMENT',
  WriteConfluenceConfiguration = 'WRITE_CONFLUENCE_CONFIGURATION',
  WriteConfluenceContentProperty = 'WRITE_CONFLUENCE_CONTENT_PROPERTY',
  WriteConfluenceContentRestriction = 'WRITE_CONFLUENCE_CONTENT_RESTRICTION',
  WriteConfluenceCustomContent = 'WRITE_CONFLUENCE_CUSTOM_CONTENT',
  WriteConfluenceGroup = 'WRITE_CONFLUENCE_GROUP',
  WriteConfluenceInlineTask = 'WRITE_CONFLUENCE_INLINE_TASK',
  WriteConfluenceLabel = 'WRITE_CONFLUENCE_LABEL',
  WriteConfluencePage = 'WRITE_CONFLUENCE_PAGE',
  WriteConfluenceRelation = 'WRITE_CONFLUENCE_RELATION',
  WriteConfluenceSpace = 'WRITE_CONFLUENCE_SPACE',
  WriteConfluenceSpacePermission = 'WRITE_CONFLUENCE_SPACE_PERMISSION',
  WriteConfluenceSpaceProperty = 'WRITE_CONFLUENCE_SPACE_PROPERTY',
  WriteConfluenceSpaceSetting = 'WRITE_CONFLUENCE_SPACE_SETTING',
  WriteConfluenceTemplate = 'WRITE_CONFLUENCE_TEMPLATE',
  WriteConfluenceUserProperty = 'WRITE_CONFLUENCE_USER_PROPERTY',
  WriteConfluenceWatcher = 'WRITE_CONFLUENCE_WATCHER',
  WriteContainer = 'WRITE_CONTAINER',
  WriteCustomer = 'WRITE_CUSTOMER',
  WriteDesign = 'WRITE_DESIGN',
  WriteJiraWork = 'WRITE_JIRA_WORK',
  WriteJswBoardScope = 'WRITE_JSW_BOARD_SCOPE',
  WriteJswBoardScopeAdmin = 'WRITE_JSW_BOARD_SCOPE_ADMIN',
  WriteJswBuild = 'WRITE_JSW_BUILD',
  WriteJswDeployment = 'WRITE_JSW_DEPLOYMENT',
  WriteJswEpic = 'WRITE_JSW_EPIC',
  WriteJswFeatureFlag = 'WRITE_JSW_FEATURE_FLAG',
  WriteJswIssue = 'WRITE_JSW_ISSUE',
  WriteJswRemoteLink = 'WRITE_JSW_REMOTE_LINK',
  WriteJswSourceCode = 'WRITE_JSW_SOURCE_CODE',
  WriteJswSprint = 'WRITE_JSW_SPRINT',
  WriteMercury = 'WRITE_MERCURY',
  WriteNotifications = 'WRITE_NOTIFICATIONS',
  WriteOrganization = 'WRITE_ORGANIZATION',
  WriteOrganizationProperty = 'WRITE_ORGANIZATION_PROPERTY',
  WriteOrganizationUser = 'WRITE_ORGANIZATION_USER',
  WriteRequest = 'WRITE_REQUEST',
  WriteRequesttype = 'WRITE_REQUESTTYPE',
  WriteRequesttypeProperty = 'WRITE_REQUESTTYPE_PROPERTY',
  WriteRequestApproval = 'WRITE_REQUEST_APPROVAL',
  WriteRequestAttachment = 'WRITE_REQUEST_ATTACHMENT',
  WriteRequestComment = 'WRITE_REQUEST_COMMENT',
  WriteRequestFeedback = 'WRITE_REQUEST_FEEDBACK',
  WriteRequestNotification = 'WRITE_REQUEST_NOTIFICATION',
  WriteRequestParticipant = 'WRITE_REQUEST_PARTICIPANT',
  WriteRequestStatus = 'WRITE_REQUEST_STATUS',
  WriteServicedesk = 'WRITE_SERVICEDESK',
  WriteServicedeskCustomer = 'WRITE_SERVICEDESK_CUSTOMER',
  WriteServicedeskOrganization = 'WRITE_SERVICEDESK_ORGANIZATION',
  WriteServicedeskProperty = 'WRITE_SERVICEDESK_PROPERTY',
  WriteServicedeskRequest = 'WRITE_SERVICEDESK_REQUEST',
  WriteTownsquareGoal = 'WRITE_TOWNSQUARE_GOAL',
  WriteTownsquareProject = 'WRITE_TOWNSQUARE_PROJECT',
  WriteTownsquareRelationship = 'WRITE_TOWNSQUARE_RELATIONSHIP'
}

/** Metadata on any analytics related fields, these do not affect the search */
export type SearchAnalyticsInput = {
  queryVersion?: InputMaybe<Scalars['Int']['input']>;
  searchReferrerId?: InputMaybe<Scalars['String']['input']>;
  searchSessionId?: InputMaybe<Scalars['String']['input']>;
  /** The product which is running the experience e.g. confluence. */
  sourceProduct?: InputMaybe<Scalars['String']['input']>;
};

export type SearchBoardFilter = {
  negateProjectFilter?: InputMaybe<Scalars['Boolean']['input']>;
  projectARI?: InputMaybe<Scalars['ID']['input']>;
  userARI?: InputMaybe<Scalars['ID']['input']>;
};

export enum SearchBoardProductType {
  Business = 'BUSINESS',
  Software = 'SOFTWARE'
}

export type SearchCommonFilter = {
  /** Search for only entities that have match the date range for the specified field */
  range?: InputMaybe<SearchCommonRangeFilter>;
};

export type SearchCommonRangeFilter = {
  /** Created date filter */
  created?: InputMaybe<SearchCommonRangeFilterFields>;
  /** Last modified date filter */
  lastModified?: InputMaybe<SearchCommonRangeFilterFields>;
};

export type SearchCommonRangeFilterFields = {
  /** Specify the timestamp that the field should be greater than */
  gt?: InputMaybe<Scalars['String']['input']>;
  /** Specify the timestamp that the field should be less than */
  lt?: InputMaybe<Scalars['String']['input']>;
};

export enum SearchConfluenceDocumentStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export type SearchConfluenceFilter = {
  /** Id of the pages which must be parent of the result. */
  ancestorIdsFilter?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Space or Page ARI under which the search will have to be made. Includes the space or page itself. Maps to Containers filter. */
  containerARIs?: InputMaybe<Array<Scalars['String']['input']>>;
  containerStatus?: InputMaybe<Array<InputMaybe<SearchContainerStatus>>>;
  /** Confluence document status */
  contentStatuses?: InputMaybe<Array<SearchConfluenceDocumentStatus>>;
  /** AccountIds of the users. */
  contributorsFilter?: InputMaybe<Array<Scalars['String']['input']>>;
  /** AccountIds of the users. */
  creatorsFilter?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for Verified pages or blogposts */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Labels which must be present on the page or blogpost. */
  labelsFilter?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for pages owned by particular users. The values should be Atlassian Account IDs. */
  owners?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for pages or blogposts with a specific page status */
  pageStatus?: InputMaybe<Array<Scalars['String']['input']>>;
  range?: InputMaybe<Array<InputMaybe<SearchConfluenceRangeFilter>>>;
  /** Space keys from which the results are desired. */
  spacesFilter?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for only entities that have a title that contains the given query */
  titleMatchOnly?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum SearchConfluenceRangeField {
  Created = 'CREATED',
  Lastmodified = 'LASTMODIFIED'
}

export type SearchConfluenceRangeFilter = {
  /** The field to use to calculate the range */
  field: SearchConfluenceRangeField;
  /** Specify the timestamp that the field should be greater than */
  gt?: InputMaybe<Scalars['String']['input']>;
  /** Specify the timestamp that the field should be less than */
  lt?: InputMaybe<Scalars['String']['input']>;
};

export enum SearchContainerStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT'
}

/** Context for the search experiment */
export type SearchExperimentContextInput = {
  /** experimentId to override the default experimentId for scraping purposes */
  experimentId?: InputMaybe<Scalars['String']['input']>;
  /** Context for Aggregator's experimentation, including L3 and pre-query phase */
  experimentLayers?: InputMaybe<Array<InputMaybe<SearchExperimentLayer>>>;
};

export type SearchExperimentLayer = {
  /** ID for the variant/algorithm used for ranking layer, e.g. cherry for L1. */
  layerId?: InputMaybe<Scalars['String']['input']>;
  /** ID for the Statsig layer */
  name?: InputMaybe<Scalars['String']['input']>;
  /** ID for shadowing - currently used for L1 and L2 layers only. */
  shadowId?: InputMaybe<Scalars['String']['input']>;
};

export type SearchExternalContainerFilter = {
  /** The container type */
  type: Scalars['String']['input'];
  /** The list of containers */
  values: Array<Scalars['String']['input']>;
};

export type SearchExternalContentFormatFilter = {
  /** The content format type */
  type: Scalars['String']['input'];
  /** The content formats */
  values: Array<Scalars['String']['input']>;
};

export type SearchExternalDepthFilter = {
  /** The depth values */
  depth: Scalars['Int']['input'];
  /** The depth type */
  type: Scalars['String']['input'];
};

export type SearchExternalFilter = {
  /** The list of containers */
  containers?: InputMaybe<Array<InputMaybe<SearchExternalContainerFilter>>>;
  /** The external content format filters */
  contentFormats?: InputMaybe<Array<InputMaybe<SearchExternalContentFormatFilter>>>;
  /** The depth of search */
  depth?: InputMaybe<Array<InputMaybe<SearchExternalDepthFilter>>>;
};

/** Filters to apply to a search */
export type SearchFilterInput = {
  /** Common filters that apply to all products */
  commonFilters?: InputMaybe<SearchCommonFilter>;
  /** Confluence specific filters */
  confluenceFilters?: InputMaybe<SearchConfluenceFilter>;
  /** ATI strings of which entities to search for */
  entities: Array<Scalars['String']['input']>;
  /** External filters */
  externalFilters?: InputMaybe<SearchExternalFilter>;
  /** Jira Board filters */
  jiraFilters?: InputMaybe<SearchJiraFilter>;
  /** ARIs of which workspaces, cloudIds or orgs to search in */
  locations: Array<Scalars['String']['input']>;
  /** Third party search filters */
  thirdPartyFilters?: InputMaybe<SearchThirdPartyFilter>;
};

export enum SearchIssueStatusCategory {
  Done = 'DONE',
  Open = 'OPEN'
}

export type SearchJiraFilter = {
  /**  boardFilter can have at most one element only - multiple project ARI's to filter by are not supported */
  boardFilter?: InputMaybe<SearchBoardFilter>;
  issueFilter?: InputMaybe<SearchJiraIssueFilter>;
  projectFilter?: InputMaybe<SearchJiraProjectFilter>;
};

export type SearchJiraIssueFilter = {
  /** Account ARIs of the issue assignees. */
  assigneeARIs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Project ARIs the issues reside in. */
  projectARIs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Account ARIs of the issue reporters. */
  reporterARIs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The status category the issue is currently in. */
  statusCategories?: InputMaybe<Array<SearchIssueStatusCategory>>;
};

export type SearchJiraProjectFilter = {
  projectType?: InputMaybe<SearchProjectType>;
};

export enum SearchProjectType {
  Business = 'business',
  ProductDiscovery = 'product_discovery',
  ServiceDesk = 'service_desk',
  Software = 'software'
}

/** Filters to apply to recent query */
export type SearchRecentFilterInput = {
  /** ATI strings of which entities to search for */
  entities: Array<Scalars['String']['input']>;
  /** ARIs of which workspaces, cloudIds or orgs to search in */
  locations: Array<Scalars['String']['input']>;
};

export enum SearchResultType {
  Attachment = 'attachment',
  Blogpost = 'blogpost',
  Board = 'board',
  Comment = 'comment',
  Component = 'component',
  Dashboard = 'dashboard',
  Database = 'database',
  Document = 'document',
  Embed = 'embed',
  Filter = 'filter',
  Folder = 'folder',
  Goal = 'goal',
  Issue = 'issue',
  Learning = 'learning',
  Message = 'message',
  Page = 'page',
  Plan = 'plan',
  Presentation = 'presentation',
  Project = 'project',
  Question = 'question',
  Repository = 'repository',
  Space = 'space',
  Spreadsheet = 'spreadsheet',
  Tag = 'tag',
  Unrecognised = 'unrecognised',
  Whiteboard = 'whiteboard'
}

/** Fields used to sort the query */
export type SearchSortInput = {
  /** Name of the document field on which to sort. May be a computed field such as "_score". */
  field: Scalars['String']['input'];
  /**
   * Field to sort by if a content property was specified in the field section. This is ignored if the field is not
   * a content property.
   */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Order to sort the result by. */
  order: SearchSortOrder;
};

/** SearchSortOrder describes the sorting order of the query. */
export enum SearchSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type SearchThirdPartyFilter = {
  /** Search for only entities that have the integration ids specified */
  integrations?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Search for only entities that have match the date range for the specified field */
  range?: InputMaybe<Array<InputMaybe<SearchThirdPartyRangeFilter>>>;
  /** Search for only entities that have the subtypes specified */
  subtypes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Search for only entities that have the types specified */
  thirdPartyTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for only entities that have a title that contains the given query */
  titleMatchOnly?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum SearchThirdPartyRangeField {
  Created = 'CREATED',
  Lastmodified = 'LASTMODIFIED'
}

export type SearchThirdPartyRangeFilter = {
  /** The field to use to calculate the range */
  field: SearchThirdPartyRangeField;
  /** Specify the timestamp that the field should be greater than */
  gt?: InputMaybe<Scalars['String']['input']>;
  /** Specify the timestamp that the field should be less than */
  lt?: InputMaybe<Scalars['String']['input']>;
};

export type SetAppEnvironmentVariableInput = {
  environment: AppEnvironmentInput;
  /** The input identifying the environment variable to insert */
  environmentVariable: AppEnvironmentVariableInput;
};

export type SetAppStoredCustomEntityMutationInput = {
  /** The ARI to store this entity within */
  contextAri: Scalars['ID']['input'];
  /** Specify the entity name for custom schema */
  entityName: Scalars['String']['input'];
  /** The identifier for the entity */
  key: Scalars['ID']['input'];
  /**
   * Entities may be up to ${maxValidContentLength} bytes long. Note that size within ESS may differ from
   * the size of the entity sent to this service. The entity size is counted within this service.
   */
  value: Scalars['JSON']['input'];
};

export type SetAppStoredEntityMutationInput = {
  /** The ARI to store this entity within */
  contextAri: Scalars['ID']['input'];
  /** Specify whether value should be encrypted */
  encrypted?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The identifier for the entity
   *
   * Keys must be between 1-100 characters long and must match the following pattern /^[a-zA-Z0-9:._\s-]+$/
   */
  key: Scalars['ID']['input'];
  /**
   * Entities may be up to 2000 bytes long. Note that size within ESS may differ from
   * the size of the entity sent to this service. The entity size is counted within this service.
   */
  value: Scalars['JSON']['input'];
};

export type SetBoardEstimationTypeInput = {
  estimationType: Scalars['String']['input'];
  featureId: Scalars['String']['input'];
};

export type SetCardColorStrategyInput = {
  boardId: Scalars['ID']['input'];
  strategy: Scalars['String']['input'];
};

export type SetColumnLimitInput = {
  boardId: Scalars['ID']['input'];
  columnId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type SetColumnNameInput = {
  boardId: Scalars['ID']['input'];
  columnId: Scalars['ID']['input'];
  columnName: Scalars['String']['input'];
};

/** Estimation Mutation */
export type SetEstimationTypeInput = {
  boardId: Scalars['ID']['input'];
  estimationType: Scalars['String']['input'];
};

export type SetExternalAuthCredentialsInput = {
  /** An object representing the credentials to set */
  credentials: ExternalAuthCredentialsInput;
  /** The input identifying what environment to set credentials for */
  environment: AppEnvironmentInput;
  /** The key for the service we're setting the credentials for (must already exist via previous deployment) */
  serviceKey: Scalars['String']['input'];
};

export type SetIssueMediaVisibilityInput = {
  boardId: Scalars['ID']['input'];
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SetPolarisSelectedDeliveryProjectInput = {
  projectId: Scalars['ID']['input'];
  selectedDeliveryProjectId: Scalars['ID']['input'];
};

export type SetPolarisSnippetPropertiesConfigInput = {
  /** Config */
  config?: InputMaybe<Scalars['JSON']['input']>;
  /** Snippet group id */
  groupId: Scalars['String']['input'];
  /** OauthClientId of CaaS app */
  oauthClientId: Scalars['String']['input'];
  /** project ARI */
  project: Scalars['ID']['input'];
};

/** Swimlane Mutations */
export type SetSwimlaneStrategyInput = {
  boardId: Scalars['ID']['input'];
  strategy: SwimlaneStrategy;
};

/** The kind of action that was performed and caused or contributed to an alert */
export enum ShepherdActionType {
  Activate = 'ACTIVATE',
  Archive = 'ARCHIVE',
  Crawl = 'CRAWL',
  Create = 'CREATE',
  Deactivate = 'DEACTIVATE',
  Delete = 'DELETE',
  Download = 'DOWNLOAD',
  Export = 'EXPORT',
  Grant = 'GRANT',
  Install = 'INSTALL',
  Login = 'LOGIN',
  LoginAs = 'LOGIN_AS',
  Publish = 'PUBLISH',
  Read = 'READ',
  Revoke = 'REVOKE',
  Search = 'SEARCH',
  Uninstall = 'UNINSTALL',
  Update = 'UPDATE'
}

/** Contextual information about the activity that originated the alert. */
export type ShepherdActivityHighlightInput = {
  /** What kind of action is relevant */
  action?: InputMaybe<ShepherdActionType>;
  /** Who has done it (AAID) */
  actor?: InputMaybe<Scalars['ID']['input']>;
  /** Information about a user's session when they login. */
  actorSessionInfo?: InputMaybe<ShepherdActorSessionInfoInput>;
  /** The Streamhub event id's of the events corresponding to the alert. In some cases, these are the same as the audit log event id's */
  eventIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Representation of numerical data distribution about the alert. */
  histogram?: InputMaybe<Array<InputMaybe<ShepherdHistogramBucketInput>>>;
  /**
   * The resources that were acted upon to trigger the alert along with the time of action corresponding to each ARI.
   * Typically used when Streamhub or Audit Log eventIds are not available (e.g, analytics based detections).
   */
  resourceEvents?: InputMaybe<Array<ShepherdResourceEventInput>>;
  /** What resource was acted on */
  subject?: InputMaybe<ShepherdSubjectInput>;
  /** When did this occur (instant or interval)? */
  time: ShepherdTimeInput;
};

export enum ShepherdActorOrgStatus {
  Active = 'ACTIVE',
  Deactivated = 'DEACTIVATED',
  Suspended = 'SUSPENDED'
}

export type ShepherdActorSessionInfoInput = {
  /** Which authentication factors were used to login (SAML, password, social, etc.) */
  authFactors: Array<Scalars['String']['input']>;
  /** IP address from which the user created the session */
  ipAddress: Scalars['String']['input'];
  /** ID of the unique session */
  sessionId: Scalars['String']['input'];
  /** User agent of the session (browser, OS, etc.) */
  userAgent: Scalars['String']['input'];
};

export enum ShepherdAlertAction {
  AddLabel = 'ADD_LABEL',
  Redact = 'REDACT',
  Restrict = 'RESTRICT',
  UpdateDataClassification = 'UPDATE_DATA_CLASSIFICATION'
}

export enum ShepherdAlertDetectionCategory {
  Data = 'DATA',
  Threat = 'THREAT'
}

export enum ShepherdAlertStatus {
  InProgress = 'IN_PROGRESS',
  Triaged = 'TRIAGED',
  TriagedExpectedActivity = 'TRIAGED_EXPECTED_ACTIVITY',
  TriagedTruePositive = 'TRIAGED_TRUE_POSITIVE',
  Untriaged = 'UNTRIAGED'
}

export enum ShepherdAlertTemplateType {
  AddedConfluenceGlobalPermission = 'ADDED_CONFLUENCE_GLOBAL_PERMISSION',
  AddedConfluenceSpacePermission = 'ADDED_CONFLUENCE_SPACE_PERMISSION',
  AddedDomain = 'ADDED_DOMAIN',
  AddedJiraGlobalPermission = 'ADDED_JIRA_GLOBAL_PERMISSION',
  AddedOrgadmin = 'ADDED_ORGADMIN',
  BitbucketRepositoryPrivacy = 'BITBUCKET_REPOSITORY_PRIVACY',
  BitbucketWorkspacePrivacy = 'BITBUCKET_WORKSPACE_PRIVACY',
  ClassificationLevelArchived = 'CLASSIFICATION_LEVEL_ARCHIVED',
  ClassificationLevelPublished = 'CLASSIFICATION_LEVEL_PUBLISHED',
  ConfluenceCustomDetection = 'CONFLUENCE_CUSTOM_DETECTION',
  ConfluenceDataDiscovery = 'CONFLUENCE_DATA_DISCOVERY',
  ConfluenceDataDiscoveryAtlassianToken = 'CONFLUENCE_DATA_DISCOVERY_ATLASSIAN_TOKEN',
  ConfluenceDataDiscoveryAuTfn = 'CONFLUENCE_DATA_DISCOVERY_AU_TFN',
  ConfluenceDataDiscoveryAwsKeys = 'CONFLUENCE_DATA_DISCOVERY_AWS_KEYS',
  ConfluenceDataDiscoveryCreditCard = 'CONFLUENCE_DATA_DISCOVERY_CREDIT_CARD',
  ConfluenceDataDiscoveryCrypto = 'CONFLUENCE_DATA_DISCOVERY_CRYPTO',
  ConfluenceDataDiscoveryIban = 'CONFLUENCE_DATA_DISCOVERY_IBAN',
  ConfluenceDataDiscoveryJwtKey = 'CONFLUENCE_DATA_DISCOVERY_JWT_KEY',
  ConfluenceDataDiscoveryPassword = 'CONFLUENCE_DATA_DISCOVERY_PASSWORD',
  ConfluenceDataDiscoveryPrivateKey = 'CONFLUENCE_DATA_DISCOVERY_PRIVATE_KEY',
  ConfluenceDataDiscoveryUsSsn = 'CONFLUENCE_DATA_DISCOVERY_US_SSN',
  ConfluencePageCrawling = 'CONFLUENCE_PAGE_CRAWLING',
  ConfluencePageExports = 'CONFLUENCE_PAGE_EXPORTS',
  ConfluenceSiteBackupDownloaded = 'CONFLUENCE_SITE_BACKUP_DOWNLOADED',
  ConfluenceSpaceExports = 'CONFLUENCE_SPACE_EXPORTS',
  ConfluenceSuspiciousSearch = 'CONFLUENCE_SUSPICIOUS_SEARCH',
  CreatedAuthPolicy = 'CREATED_AUTH_POLICY',
  CreatedMobileAppPolicy = 'CREATED_MOBILE_APP_POLICY',
  CreatedPolicy = 'CREATED_POLICY',
  CreatedSamlConfig = 'CREATED_SAML_CONFIG',
  CreatedTunnel = 'CREATED_TUNNEL',
  CreatedUserProvisioning = 'CREATED_USER_PROVISIONING',
  DataSecurityPolicyActivated = 'DATA_SECURITY_POLICY_ACTIVATED',
  DataSecurityPolicyDeactivated = 'DATA_SECURITY_POLICY_DEACTIVATED',
  DataSecurityPolicyDeleted = 'DATA_SECURITY_POLICY_DELETED',
  DataSecurityPolicyUpdated = 'DATA_SECURITY_POLICY_UPDATED',
  Default = 'DEFAULT',
  DeletedAuthPolicy = 'DELETED_AUTH_POLICY',
  DeletedDomain = 'DELETED_DOMAIN',
  DeletedMobileAppPolicy = 'DELETED_MOBILE_APP_POLICY',
  DeletedPolicy = 'DELETED_POLICY',
  DeletedTunnel = 'DELETED_TUNNEL',
  EcosystemAuditLogInstallationCreated = 'ECOSYSTEM_AUDIT_LOG_INSTALLATION_CREATED',
  EcosystemAuditLogInstallationDeleted = 'ECOSYSTEM_AUDIT_LOG_INSTALLATION_DELETED',
  EcosystemAuditLogUserGrantCreated = 'ECOSYSTEM_AUDIT_LOG_USER_GRANT_CREATED',
  EducationalAlert = 'EDUCATIONAL_ALERT',
  EnableScimSync = 'ENABLE_SCIM_SYNC',
  ExportedOrgeventscsv = 'EXPORTED_ORGEVENTSCSV',
  GrantAssignedJiraPermissionScheme = 'GRANT_ASSIGNED_JIRA_PERMISSION_SCHEME',
  IdentityPasswordResetCompletedUser = 'IDENTITY_PASSWORD_RESET_COMPLETED_USER',
  ImpossibleTravel = 'IMPOSSIBLE_TRAVEL',
  InitiatedGsyncConnection = 'INITIATED_GSYNC_CONNECTION',
  JiraCustomDetection = 'JIRA_CUSTOM_DETECTION',
  JiraDataDiscoveryAtlassianToken = 'JIRA_DATA_DISCOVERY_ATLASSIAN_TOKEN',
  JiraDataDiscoveryAuTfn = 'JIRA_DATA_DISCOVERY_AU_TFN',
  JiraDataDiscoveryAwsKeys = 'JIRA_DATA_DISCOVERY_AWS_KEYS',
  JiraDataDiscoveryCreditCard = 'JIRA_DATA_DISCOVERY_CREDIT_CARD',
  JiraDataDiscoveryCrypto = 'JIRA_DATA_DISCOVERY_CRYPTO',
  JiraDataDiscoveryIban = 'JIRA_DATA_DISCOVERY_IBAN',
  JiraDataDiscoveryJwtKey = 'JIRA_DATA_DISCOVERY_JWT_KEY',
  JiraDataDiscoveryPassword = 'JIRA_DATA_DISCOVERY_PASSWORD',
  JiraDataDiscoveryPrivateKey = 'JIRA_DATA_DISCOVERY_PRIVATE_KEY',
  JiraDataDiscoveryUsSsn = 'JIRA_DATA_DISCOVERY_US_SSN',
  JiraIssueCrawling = 'JIRA_ISSUE_CRAWLING',
  LoginFromMaliciousIpAddress = 'LOGIN_FROM_MALICIOUS_IP_ADDRESS',
  LoginFromTorExitNode = 'LOGIN_FROM_TOR_EXIT_NODE',
  OrgLoggedInAsUser = 'ORG_LOGGED_IN_AS_USER',
  ProjectClassificationLevelDecreased = 'PROJECT_CLASSIFICATION_LEVEL_DECREASED',
  ProjectClassificationLevelIncreased = 'PROJECT_CLASSIFICATION_LEVEL_INCREASED',
  RotateScimDirectoryToken = 'ROTATE_SCIM_DIRECTORY_TOKEN',
  SpaceClassificationLevelDecreased = 'SPACE_CLASSIFICATION_LEVEL_DECREASED',
  SpaceClassificationLevelIncreased = 'SPACE_CLASSIFICATION_LEVEL_INCREASED',
  TestAlert = 'TEST_ALERT',
  TokenCreated = 'TOKEN_CREATED',
  TokenRevoked = 'TOKEN_REVOKED',
  UpdatedAuthPolicy = 'UPDATED_AUTH_POLICY',
  UpdatedMobileAppPolicy = 'UPDATED_MOBILE_APP_POLICY',
  UpdatedPolicy = 'UPDATED_POLICY',
  UpdatedSamlConfig = 'UPDATED_SAML_CONFIG',
  UserAddedToBeacon = 'USER_ADDED_TO_BEACON',
  UserGrantedRole = 'USER_GRANTED_ROLE',
  UserRemovedFromBeacon = 'USER_REMOVED_FROM_BEACON',
  UserRevokedRole = 'USER_REVOKED_ROLE',
  VerifiedDomainVerification = 'VERIFIED_DOMAIN_VERIFICATION'
}

export enum ShepherdAtlassianProduct {
  AdminHub = 'ADMIN_HUB',
  Bitbucket = 'BITBUCKET',
  Confluence = 'CONFLUENCE',
  GuardDetect = 'GUARD_DETECT',
  JiraSoftware = 'JIRA_SOFTWARE',
  Marketplace = 'MARKETPLACE'
}

export enum ShepherdClassificationLevelColor {
  Blue = 'BLUE',
  BlueBold = 'BLUE_BOLD',
  Green = 'GREEN',
  Grey = 'GREY',
  Lime = 'LIME',
  Navy = 'NAVY',
  None = 'NONE',
  Orange = 'ORANGE',
  Purple = 'PURPLE',
  Red = 'RED',
  RedBold = 'RED_BOLD',
  Teal = 'TEAL',
  Yellow = 'YELLOW'
}

export enum ShepherdClassificationStatus {
  Archived = 'ARCHIVED',
  Draft = 'DRAFT',
  Published = 'PUBLISHED'
}

/** ##### Input ###### */
export type ShepherdCreateAlertInput = {
  assignee?: InputMaybe<Scalars['ID']['input']>;
  /** Cloud ID (aka site ID). Required if neither orgId nor workspaceId are provided. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  customDetectionHighlight?: InputMaybe<ShepherdCustomDetectionHighlightInput>;
  /** A highlight contains contextual information produced by the detection that created the alert. */
  highlight?: InputMaybe<ShepherdHighlightInput>;
  /** Organization ID. Required if neither orgId nor cloudId are provided. */
  orgId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<ShepherdAlertStatus>;
  template?: InputMaybe<ShepherdAlertTemplateType>;
  title: Scalars['String']['input'];
  /** Beacon workspace ID. Required if neither orgId nor cloudId are provided. */
  workspaceId?: InputMaybe<Scalars['ID']['input']>;
};

export type ShepherdCreateExampleAlertInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  orgId?: InputMaybe<Scalars['ID']['input']>;
};

export type ShepherdCreateSlackInput = {
  authToken: Scalars['String']['input'];
  callbackURL: Scalars['URL']['input'];
  channelId: Scalars['String']['input'];
  status: ShepherdSubscriptionStatus;
  teamId: Scalars['String']['input'];
};

export type ShepherdCreateWebhookInput = {
  authHeader?: InputMaybe<Scalars['String']['input']>;
  callbackURL: Scalars['URL']['input'];
  destinationType?: InputMaybe<ShepherdWebhookDestinationType>;
  status?: InputMaybe<ShepherdSubscriptionStatus>;
  /** DEPRECATED: Use destinationType instead. */
  type?: InputMaybe<ShepherdWebhookType>;
};

export type ShepherdCustomDetectionHighlightInput = {
  customDetectionId: Scalars['ID']['input'];
  matchedRules?: InputMaybe<Array<InputMaybe<ShepherdCustomScanningStringMatchRuleInput>>>;
};

export enum ShepherdCustomScanningMatchType {
  Regex = 'REGEX',
  String = 'STRING',
  Word = 'WORD'
}

/** GraphQL doesn't allow unions in input types so this is to allow for different rule types in the future. */
export type ShepherdCustomScanningRuleInput = {
  stringMatch?: InputMaybe<ShepherdCustomScanningStringMatchRuleInput>;
};

/** Input type for a rule to match against content. Contains a term an whether it's a string match or word match. */
export type ShepherdCustomScanningStringMatchRuleInput = {
  matchType: ShepherdCustomScanningMatchType;
  term: Scalars['String']['input'];
};

export enum ShepherdDetectionScanningFrequency {
  RealTime = 'REAL_TIME',
  Scheduled = 'SCHEDULED'
}

export type ShepherdDetectionSettingSetValueEntryInput = {
  key: Scalars['String']['input'];
  scanningRules?: InputMaybe<Array<ShepherdCustomScanningRuleInput>>;
};

export type ShepherdDetectionSettingSetValueInput = {
  /** Update a boolean setting. */
  booleanValue?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * A list of mapped entries.
   * For exclusions: add all scanningRules items to the setting.
   */
  entries?: InputMaybe<Array<ShepherdDetectionSettingSetValueEntryInput>>;
  /**
   * A list of string values.
   * For exclusions: add all ARIs to the setting.
   */
  stringValues?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Update the threshold value for the setting. */
  thresholdValue?: InputMaybe<ShepherdRateThresholdValue>;
};

/**
 * A highlight contains contextual information produced by the detection that created the alert.
 * One field is required and only one can be informed at a time.
 */
export type ShepherdHighlightInput = {
  /** Information about the activity that originated the alert */
  activityHighlight?: InputMaybe<ShepherdActivityHighlightInput>;
  customDetectionHighlight?: InputMaybe<ShepherdCustomDetectionHighlightInput>;
};

export type ShepherdHistogramBucketInput = {
  /** Name of the bucket that contributes to the signal histogram */
  name: Scalars['String']['input'];
  /** Numerical representation of the bucket value */
  value: Scalars['Int']['input'];
};

export type ShepherdLinkedResourceInput = {
  id: Scalars['ID']['input'];
  url?: InputMaybe<Scalars['String']['input']>;
};

export enum ShepherdLoginDeviceType {
  Computer = 'COMPUTER',
  Console = 'CONSOLE',
  Embedded = 'EMBEDDED',
  Mobile = 'MOBILE',
  SmartTv = 'SMART_TV',
  Tablet = 'TABLET',
  Wearable = 'WEARABLE'
}

/** #### Types: Mutation ##### */
export enum ShepherdMutationErrorType {
  BadRequest = 'BAD_REQUEST',
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  NoProductAccess = 'NO_PRODUCT_ACCESS',
  Unauthorized = 'UNAUTHORIZED'
}

/** #### Types: Query ##### */
export enum ShepherdQueryErrorType {
  BadRequest = 'BAD_REQUEST',
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  NoProductAccess = 'NO_PRODUCT_ACCESS',
  Unauthorized = 'UNAUTHORIZED'
}

/** A rate type detection has 3 modes, LOW will produce the most alerts, HIGH will product the least alerts */
export enum ShepherdRateThresholdValue {
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM'
}

export enum ShepherdRedactedContentStatus {
  Redacted = 'REDACTED',
  RedactionFailed = 'REDACTION_FAILED',
  RedactionPending = 'REDACTION_PENDING'
}

/** Input used when redacting content */
export type ShepherdRedactionInput = {
  /** The alert ARI that the redaction is associated with */
  alertId: Scalars['ID']['input'];
  /** The list of `contentId`s to redact. `contentId`s should be taken from `ShepherdAlertSnippet` objects. */
  redactions: Array<Scalars['ID']['input']>;
  /** Whether or not to delete previous versions that contain the redacted content */
  removeHistory: Scalars['Boolean']['input'];
  /** The creation timestamp for the version of the document that is intended to be redacted */
  timestamp: Scalars['String']['input'];
};

export enum ShepherdRedactionStatus {
  Failed = 'FAILED',
  PartiallyRedacted = 'PARTIALLY_REDACTED',
  Pending = 'PENDING',
  Redacted = 'REDACTED'
}

export enum ShepherdRemediationActionType {
  AnonAccessDspRemediation = 'ANON_ACCESS_DSP_REMEDIATION',
  ApplyClassificationRemediation = 'APPLY_CLASSIFICATION_REMEDIATION',
  AppsAccessDspRemediation = 'APPS_ACCESS_DSP_REMEDIATION',
  ArchiveRestoreClassificationRemediation = 'ARCHIVE_RESTORE_CLASSIFICATION_REMEDIATION',
  BlockchainExplorerRemediation = 'BLOCKCHAIN_EXPLORER_REMEDIATION',
  BlockIpAllowlistRemediation = 'BLOCK_IP_ALLOWLIST_REMEDIATION',
  ClassificationLevelChangeRemediation = 'CLASSIFICATION_LEVEL_CHANGE_REMEDIATION',
  ConfluenceAnonAccessRemediation = 'CONFLUENCE_ANON_ACCESS_REMEDIATION',
  DeleteDataRemediation = 'DELETE_DATA_REMEDIATION',
  DeleteFilesRemediation = 'DELETE_FILES_REMEDIATION',
  EditCustomDetectionRemediation = 'EDIT_CUSTOM_DETECTION_REMEDIATION',
  ExcludePageRemediation = 'EXCLUDE_PAGE_REMEDIATION',
  ExcludeUserRemediation = 'EXCLUDE_USER_REMEDIATION',
  ExportsDspRemediation = 'EXPORTS_DSP_REMEDIATION',
  ExportDspRemediation = 'EXPORT_DSP_REMEDIATION',
  ExportSpacePermissionsRemediation = 'EXPORT_SPACE_PERMISSIONS_REMEDIATION',
  JiraGlobalPermissionsRemediation = 'JIRA_GLOBAL_PERMISSIONS_REMEDIATION',
  KeyOwnerRemediation = 'KEY_OWNER_REMEDIATION',
  LimitJiraPermissionsRemediation = 'LIMIT_JIRA_PERMISSIONS_REMEDIATION',
  ManageAppsRemediation = 'MANAGE_APPS_REMEDIATION',
  ManageDomainRemediation = 'MANAGE_DOMAIN_REMEDIATION',
  ManageDspRemediation = 'MANAGE_DSP_REMEDIATION',
  PublicAccessDspRemediation = 'PUBLIC_ACCESS_DSP_REMEDIATION',
  ResetAccountPasswordRemediation = 'RESET_ACCOUNT_PASSWORD_REMEDIATION',
  RestoreAccessRemediation = 'RESTORE_ACCESS_REMEDIATION',
  RestrictPageAutomationRemediation = 'RESTRICT_PAGE_AUTOMATION_REMEDIATION',
  ReviewAccessRemediation = 'REVIEW_ACCESS_REMEDIATION',
  ReviewApiKeysRemediation = 'REVIEW_API_KEYS_REMEDIATION',
  ReviewApiTokensRemediation = 'REVIEW_API_TOKENS_REMEDIATION',
  ReviewAuditLogRemediation = 'REVIEW_AUDIT_LOG_REMEDIATION',
  ReviewAuthPolicyRemediation = 'REVIEW_AUTH_POLICY_REMEDIATION',
  ReviewGsyncRemediation = 'REVIEW_GSYNC_REMEDIATION',
  ReviewIpAllowlistRemediation = 'REVIEW_IP_ALLOWLIST_REMEDIATION',
  ReviewIssueRemediation = 'REVIEW_ISSUE_REMEDIATION',
  ReviewMobileAppPolicyRemediation = 'REVIEW_MOBILE_APP_POLICY_REMEDIATION',
  ReviewOtherAuthPoliciesRemediation = 'REVIEW_OTHER_AUTH_POLICIES_REMEDIATION',
  ReviewOtherIpAllowlistRemediation = 'REVIEW_OTHER_IP_ALLOWLIST_REMEDIATION',
  ReviewPageRemediation = 'REVIEW_PAGE_REMEDIATION',
  ReviewSamlRemediation = 'REVIEW_SAML_REMEDIATION',
  ReviewScimRemediation = 'REVIEW_SCIM_REMEDIATION',
  ReviewTunnelsConfigurationRemediation = 'REVIEW_TUNNELS_CONFIGURATION_REMEDIATION',
  ReviewTunnelsRemediation = 'REVIEW_TUNNELS_REMEDIATION',
  RevokeAccessRemediation = 'REVOKE_ACCESS_REMEDIATION',
  RevokeApiKeyRemediation = 'REVOKE_API_KEY_REMEDIATION',
  RevokeApiTokensRemediation = 'REVOKE_API_TOKENS_REMEDIATION',
  SpacePermissionsRemediation = 'SPACE_PERMISSIONS_REMEDIATION',
  SuspendActorRemediation = 'SUSPEND_ACTOR_REMEDIATION',
  SuspendSubjectRemediation = 'SUSPEND_SUBJECT_REMEDIATION',
  TurnOffJiraPermissionsRemediation = 'TURN_OFF_JIRA_PERMISSIONS_REMEDIATION',
  TwoStepPolicyRemediation = 'TWO_STEP_POLICY_REMEDIATION',
  ViewSpacePermissionsRemediation = 'VIEW_SPACE_PERMISSIONS_REMEDIATION'
}

export type ShepherdResourceEventInput = {
  /** Name resource ARI of the event */
  ari: Scalars['String']['input'];
  /** The DateTime of the event */
  time: Scalars['DateTime']['input'];
};

export enum ShepherdSearchOrigin {
  AdvancedSearch = 'ADVANCED_SEARCH',
  Ai = 'AI',
  QuickSearch = 'QUICK_SEARCH'
}

/** The resource was acted on */
export type ShepherdSubjectInput = {
  /** ARI of the resource acted on */
  ari?: InputMaybe<Scalars['String']['input']>;
  /** ATI with type of resource or group of resources, when a specific resource cannot be referenced directly. */
  ati?: InputMaybe<Scalars['String']['input']>;
  /** ARI of where it happened. An ARI pointing to an org, site, or other type of container. */
  containerAri: Scalars['String']['input'];
};

export type ShepherdSubscriptionCreateInput = {
  slack?: InputMaybe<ShepherdCreateSlackInput>;
  webhook?: InputMaybe<ShepherdCreateWebhookInput>;
};

export type ShepherdSubscriptionDeleteInput = {
  hardDelete?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents Subscriptions in the Shepherd system. */
export enum ShepherdSubscriptionStatus {
  Active = 'ACTIVE',
  Error = 'ERROR',
  Inactive = 'INACTIVE'
}

export type ShepherdSubscriptionUpdateInput = {
  slack?: InputMaybe<ShepherdUpdateSlackInput>;
  webhook?: InputMaybe<ShepherdUpdateWebhookInput>;
};

/** Time or interval */
export type ShepherdTimeInput = {
  /** When present, indicates a ShepherdInterval should be created, otherwise ShepherdInstant will be created. */
  end?: InputMaybe<Scalars['DateTime']['input']>;
  /** The DateTime for the ShepherdInstant (when only `start` is specified) or ShepherdInterval (when `end` is also specified) */
  start: Scalars['DateTime']['input'];
};

export type ShepherdUnlinkAlertResourcesInput = {
  unlinkResources?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type ShepherdUpdateAlertInput = {
  assignee?: InputMaybe<Scalars['ID']['input']>;
  linkedResources?: InputMaybe<Array<ShepherdLinkedResourceInput>>;
  status?: InputMaybe<ShepherdAlertStatus>;
};

export type ShepherdUpdateSlackInput = {
  authToken?: InputMaybe<Scalars['String']['input']>;
  callbackURL?: InputMaybe<Scalars['URL']['input']>;
  channelId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ShepherdSubscriptionStatus>;
  teamId?: InputMaybe<Scalars['String']['input']>;
};

export type ShepherdUpdateWebhookInput = {
  authHeader?: InputMaybe<Scalars['String']['input']>;
  callbackURL?: InputMaybe<Scalars['URL']['input']>;
  destinationType?: InputMaybe<ShepherdWebhookDestinationType>;
  status?: InputMaybe<ShepherdSubscriptionStatus>;
  /** DEPRECATED: Use destinationType instead. */
  type?: InputMaybe<ShepherdWebhookType>;
};

/** Represents the possible vortexMode values for a workspace. */
export enum ShepherdVortexModeStatus {
  Disabled = 'DISABLED',
  Enabled = 'ENABLED'
}

/** Represents type of Webhook payload */
export enum ShepherdWebhookDestinationType {
  Default = 'DEFAULT',
  MicrosoftTeams = 'MICROSOFT_TEAMS'
}

/**
 * Represents type of Webhook
 * DEPRECATED: Use destinationType instead.
 */
export enum ShepherdWebhookType {
  Custom = 'CUSTOM',
  MicrosoftTeams = 'MICROSOFT_TEAMS',
  Slack = 'SLACK'
}

export type ShepherdWorkspaceCreateCustomDetectionInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  products: Array<ShepherdAtlassianProduct>;
  rules: Array<ShepherdCustomScanningRuleInput>;
  title: Scalars['String']['input'];
};

export type ShepherdWorkspaceSettingUpdateInput = {
  detectionId: Scalars['ID']['input'];
  settingId: Scalars['ID']['input'];
  value: ShepherdWorkspaceSettingValueInput;
};

/**
 * Contains the setting value for a detection
 * While we currently only have one detection type (threshold), if we add more in the future there would be more fields
 * on this type, only one of which should be populated at a time.
 */
export type ShepherdWorkspaceSettingValueInput = {
  confluenceEnabledValue?: InputMaybe<Scalars['Boolean']['input']>;
  enabledValue?: InputMaybe<Scalars['Boolean']['input']>;
  jiraEnabledValue?: InputMaybe<Scalars['Boolean']['input']>;
  thresholdValue?: InputMaybe<ShepherdRateThresholdValue>;
};

/**
 * Input used to update a custom detection. Any optional field that is left empty (i.e. null or undefined) will leave the
 * previous value unchanged.
 */
export type ShepherdWorkspaceUpdateCustomDetectionInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  products?: InputMaybe<Array<ShepherdAtlassianProduct>>;
  rules?: InputMaybe<Array<ShepherdCustomScanningRuleInput>>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ShepherdWorkspaceUpdateInput = {
  shouldOnboard: Scalars['Boolean']['input'];
};

/**
 * Provides context about who and where the recommendation or request is being made. The context determines:
 *   1. The search space (e.g. the set of users that are eligible to be recommended).
 *   2. The model that will be applied to the search results.
 *   3. The input feature values that are piped into the prediction model to generate the ranking score. The model used
 *      determines which context fields are used for prediction (see
 *      [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model)).
 */
export type SmartsContext = {
  /** Any additional context to be passed to the model. */
  additionalContextList?: InputMaybe<Array<SmartsKeyValue>>;
  /**
   * The ID of the container for which the recommendation is being made.
   *
   * A container is analogous to entities such as a Jira Project or Confluence Space. Depending on the model, it is either
   * optional or can be used as an input to provide more specific recommendations.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  containerId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the object for which the recommendation is being made.
   *
   * An object is analogous to entities such as a Jira Issue or Confluence Page.
   */
  objectId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The product for which the recommendation is being made.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  product?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the tenant for which the recommendation is being made. Analogous to siteId/cloudId optional context fields.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  tenantId: Scalars['String']['input'];
  /**
   * The ID (AAID) of the user for whom the recommendation is being made. Can be set to 'context', upon which it will use
   * the requesting user's ID.
   */
  userId: Scalars['String']['input'];
};

export type SmartsFieldContext = {
  /**
   * List of field keys and values to be passed for prediction.
   * e.g. [{"key": "15615", "value": "xpsearch-aggregator"}]
   */
  additionalContextList?: InputMaybe<Array<SmartsKeyValue>>;
  /**
   * The ID of the container for which the recommendation is being made.
   *
   * A container is analogous to entities such as a Jira Project. Depending on the model, it is either
   * optional or can be used as an input to provide more specific recommendations.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  containerId?: InputMaybe<Scalars['String']['input']>;
  /**
   * This is the identifier for the field that recommendations are to be provided for.
   * Valid values are: labels, components, versions and fixVersions
   */
  fieldId: Scalars['String']['input'];
  /**
   * The ID of the object for which the recommendation is being made.
   *
   * An object is analogous to entities such as a Jira Issue.
   */
  objectId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The product for which the recommendation is being made.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  product?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the tenant for which the recommendation is being made. Analogous to siteId/cloudId optional context fields.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  tenantId: Scalars['String']['input'];
  /**
   * The UserId (AAID) for which the recommendation is being made. Can be set to 'context'
   * if calling from Stargate, upon which it will use the requesting user's ID. Can be set to an empty
   * string '' for anonymous use cases.
   */
  userId: Scalars['String']['input'];
};

export type SmartsKeyValue = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** Provides information about the requester, for model selection and monitoring. */
export type SmartsModelRequestParams = {
  /**
   * This is some identifying information about the caller. It can be the microservice ID, AK package, etc.
   *
   * We use this internally for metrics and analytics. Please use a descriptive caller so we can easily locate your
   * consumer.
   */
  caller: Scalars['String']['input'];
  /**
   * The experience being used; used for selecting a model.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  experience: Scalars['String']['input'];
};

export type SmartsRecommendationsFieldQuery = {
  /**
   * Provides context about who and where the recommendation or collaboration graph request is
   * being made. The context determines: 1. The search space (e.g. the set of users that are eligible
   * to be recommended; 2. The model that will be applied to the search results. 3. the input feature values that are
   * piped into the prediction model to generate the ranking score. The model used determines which context fields
   * are used for prediction (see DAC: Choosing a model).
   */
  context: SmartsFieldContext;
  /**
   * The maximum number of nearby entities that should be returned.
   *
   * Defaults to 100. If provided, must be in the range [1,500].
   */
  maxNumberOfResults?: InputMaybe<Scalars['Int']['input']>;
  /**
   * Provides information about the requester, for model selection and monitoring.
   * Valid values for the experience field are: JiraFields, JiraLabels and JiraComponents
   */
  modelRequestParams: SmartsModelRequestParams;
  /**
   * The ID (AtlassianID) of the user who is making the request. Used to perform permission checks and hydration.
   *
   * If the `requestingUserId` is set to the string 'context', Collaboration Graph will use the `requestingUserId` from
   * headers.
   */
  requestingUserId: Scalars['String']['input'];
  /** The unique identifier for the session. */
  sessionId?: InputMaybe<Scalars['String']['input']>;
};

export type SmartsRecommendationsQuery = {
  /**
   * Provides context about who and where the recommendation or collaboration graph request is
   * being made. The context determines: 1. The search space (e.g. the set of users that are eligible
   * to be recommended; 2. The model that will be applied to the search results. 3. the input feature values that are
   * piped into the prediction model to generate the ranking score. The model used determines which context fields
   * are used for prediction (see DAC: Choosing a model).
   */
  context: SmartsContext;
  /**
   * The maximum number of nearby entities that should be returned.
   *
   * Defaults to 100. If provided, must be in the range [1,500].
   */
  maxNumberOfResults?: InputMaybe<Scalars['Int']['input']>;
  /** Provides information about the requester, for model selection and monitoring. */
  modelRequestParams: SmartsModelRequestParams;
  /**
   * The ID (AtlassianID) of the user who is making the request. Used to perform permission checks and hydration.
   *
   * If the `requestingUserId` is set to the string 'context', Collaboration Graph will use the `requestingUserId` from
   * headers.
   */
  requestingUserId: Scalars['String']['input'];
  /** The unique identifier for the session. */
  sessionId?: InputMaybe<Scalars['String']['input']>;
};

export type SoftwareCardsDestination = {
  destination?: InputMaybe<SoftwareCardsDestinationEnum>;
  sprintId?: InputMaybe<Scalars['ID']['input']>;
};

export enum SoftwareCardsDestinationEnum {
  Backlog = 'BACKLOG',
  ExistingSprint = 'EXISTING_SPRINT',
  NewSprint = 'NEW_SPRINT'
}

/** The sort direction of the collection */
export enum SortDirection {
  /** Sort in ascending order */
  Asc = 'ASC',
  /** Sort in descending order */
  Desc = 'DESC'
}

export enum SortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type SplitIssueInput = {
  newIssues: Array<InputMaybe<NewSplitIssueRequest>>;
  originalIssue: OriginalSplitIssue;
};

export enum SprintReportsEstimationStatisticType {
  IssueCount = 'ISSUE_COUNT',
  OriginalEstimate = 'ORIGINAL_ESTIMATE',
  StoryPoints = 'STORY_POINTS'
}

export enum SprintState {
  Active = 'ACTIVE',
  Closed = 'CLOSED',
  Future = 'FUTURE'
}

/** Start sprint */
export type StartSprintInput = {
  boardId: Scalars['ID']['input'];
  endDate: Scalars['String']['input'];
  goal?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  sprintId: Scalars['ID']['input'];
  startDate: Scalars['String']['input'];
};

export type SupportRequestAddCommentInput = {
  /** unique key/id of the request ticket */
  issueKey: Scalars['String']['input'];
  /** The comment message in wiki markup format (Jira format). */
  message: Scalars['String']['input'];
};

export type SupportRequestAdditionalTicketData = {
  /** operation that should be done for the new ticket example: PROBLEM_TICKET_CREATION */
  operationType?: InputMaybe<Scalars['String']['input']>;
  /** parent issue id or key of the ticket that should be newly created */
  parentIssueIdOrKey?: InputMaybe<Scalars['String']['input']>;
};

export type SupportRequestContextSetNotificationInput = {
  /** unique key/id of the request ticket */
  requestKey: Scalars['String']['input'];
  status: Scalars['Boolean']['input'];
};

/** Enum that specify the data type of the field. */
export enum SupportRequestFieldDataType {
  Boolean = 'BOOLEAN',
  Date = 'DATE',
  Number = 'NUMBER',
  String = 'STRING'
}

export type SupportRequestMigrationTaskInput = {
  /** comment to be added on task. This can be null when completed is false i.e marking a task incomplete from complete */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** task status */
  completedByPartner: Scalars['Boolean']['input'];
  /** unique key/id of the request ticket */
  requestKey: Scalars['String']['input'];
  /** task name to be updated */
  taskName: Scalars['String']['input'];
};

/** Query parameter for how this user has access to the request, e.g. they were the reporter or added as a participant. */
export enum SupportRequestNamedContactOperation {
  Add = 'ADD',
  Remove = 'REMOVE'
}

export type SupportRequestOrganizationsInput = {
  /** List of request participants. */
  orgIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** unique key/id of the request ticket */
  requestKey: Scalars['String']['input'];
};

export type SupportRequestParticipantsInput = {
  aaids?: InputMaybe<Array<Scalars['String']['input']>>;
  /** list of request participants username */
  gsacUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** unique key/id of the request ticket */
  requestKey: Scalars['String']['input'];
};

/** Query parameter for how this user has access to the request, e.g. they were the reporter or added as a participant. */
export enum SupportRequestQueryOwnership {
  Participant = 'PARTICIPANT',
  Reporter = 'REPORTER'
}

/** The general category for the status of the ticket. */
export enum SupportRequestQueryStatusCategory {
  Done = 'DONE',
  Open = 'OPEN'
}

/** The general category for the status of the ticket. */
export enum SupportRequestStatusCategory {
  Done = 'DONE',
  InProgress = 'IN_PROGRESS',
  Open = 'OPEN'
}

export type SupportRequestTicketFields = {
  /** Specifies the datatype of field */
  dataType: SupportRequestFieldDataType;
  /** custom field id */
  fieldId: Scalars['Long']['input'];
  /** value of the field */
  fieldValue: Scalars['String']['input'];
};

export type SupportRequestTransitionInput = {
  /** The comment message in wiki markup format (Jira format). */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** unique key/id of the request ticket */
  requestKey: Scalars['String']['input'];
  /** transition Id of from workflow */
  transitionId: Scalars['ID']['input'];
};

export type SupportRequestUpdateFieldInput = {
  /** Unique Id of the field, for example description, custom_field_1234 */
  id: Scalars['String']['input'];
  /** The public facing value of the field. */
  value: Scalars['String']['input'];
};

export type SupportRequestUpdateInput = {
  /** Experience fields might vary for personas. */
  experienceFields?: InputMaybe<Array<SupportRequestUpdateFieldInput>>;
  /** The unique identifier for this request. It will make it unique across multiple systems, for example 'GSAC-CA-1000' for GSAC requests. */
  requestKey: Scalars['ID']['input'];
};

/**  The supported usertype of user in system */
export enum SupportRequestUserType {
  Customer = 'CUSTOMER',
  Partner = 'PARTNER'
}

/** How to group cards on the board into swimlanes */
export enum SwimlaneStrategy {
  Assignee = 'ASSIGNEE',
  Issuechildren = 'ISSUECHILDREN',
  Issueparent = 'ISSUEPARENT',
  None = 'NONE'
}

/** Member filter used as input on team search filter */
export type TeamMembershipFilter = {
  /** List of members AccountIDs */
  memberIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** The roles that a member can have within a team */
export enum TeamMembershipRole {
  /** A team member with administrative permissions */
  Admin = 'ADMIN',
  /** A regular team member */
  Regular = 'REGULAR'
}

/** The settings which a team can have describing how members are added to the team */
export enum TeamMembershipSettings {
  /** Membership is externally defined (not yet supported) */
  External = 'EXTERNAL',
  /** Members may invite others to join the team */
  MemberInvite = 'MEMBER_INVITE',
  /** Anyone may join */
  Open = 'OPEN'
}

/** The states that a member can have within a team */
export enum TeamMembershipState {
  /** A member who was previously a full member of the team, but has been removed or has left the team */
  Alumni = 'ALUMNI',
  /** A full member of the team */
  FullMember = 'FULL_MEMBER',
  /** A member who has requested to join the team and is pending approval */
  RequestingToJoin = 'REQUESTING_TO_JOIN'
}

export enum TeamRole {
  TeamsAdmin = 'TEAMS_ADMIN',
  TeamsObserver = 'TEAMS_OBSERVER',
  TeamsUser = 'TEAMS_USER'
}

/** Enum representing the search fields for teams. */
export enum TeamSearchField {
  /** Search by team description */
  Description = 'DESCRIPTION',
  /** Search by team name */
  Name = 'NAME'
}

/** Team filter used as input on team search */
export type TeamSearchFilter = {
  /** Team Membership Filter, optional */
  membership?: InputMaybe<TeamMembershipFilter>;
  /** String query to search, optional */
  query?: InputMaybe<Scalars['String']['input']>;
};

/** Team sort used as input on team search */
export type TeamSort = {
  /** Team sort field */
  field: TeamSortField;
  /** Team sort order */
  order?: InputMaybe<TeamSortOrder>;
};

/** Team sort fields */
export enum TeamSortField {
  /** Team name field */
  DisplayName = 'DISPLAY_NAME',
  /** Identifier Team field */
  Id = 'ID',
  /** Team state field */
  State = 'STATE'
}

/** Team Sort Order */
export enum TeamSortOrder {
  /** Ascendant order */
  Asc = 'ASC',
  /** Descendent order */
  Desc = 'DESC'
}

/** The states that a team can have */
export enum TeamState {
  /** The team is currently active */
  Active = 'ACTIVE',
  /** The team has been disbanded and is currently inactive */
  Disbanded = 'DISBANDED',
  /** All members of the team have been deleted */
  Purged = 'PURGED'
}

/** The states that a team can have */
export enum TeamStateV2 {
  /** The team is currently active */
  Active = 'ACTIVE',
  /** All members of the team have been deleted */
  Purged = 'PURGED'
}

/** The input for a Third Party Repository */
export type ThirdPartyRepositoryInput = {
  /** Avatar details for the third party repository. */
  avatar?: InputMaybe<AvatarInput>;
  /** The ID of the third party repository. */
  id: Scalars['ID']['input'];
  /** The name of the third party repository. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the third party repository. */
  webUrl?: InputMaybe<Scalars['String']['input']>;
};

export type ToggleBoardFeatureInput = {
  enabled: Scalars['Boolean']['input'];
  featureId: Scalars['String']['input'];
};

export type ToolchainAssociateContainerInput = {
  containerId: Scalars['ID']['input'];
  jiraProjectId: Scalars['ID']['input'];
  workspaceId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * #########################
 *  Mutation Inputs
 * #########################
 */
export type ToolchainAssociateContainersInput = {
  associations: Array<ToolchainAssociateContainerInput>;
  cloudId: Scalars['ID']['input'];
  providerId: Scalars['ID']['input'];
  providerType?: InputMaybe<ToolchainProviderType>;
};

export enum ToolchainAssociateEntitiesErrorCode {
  /** The entity identified by the given URL was rejected */
  EntityRejected = 'ENTITY_REJECTED',
  /** The given URL is invalid */
  EntityUrlInvalid = 'ENTITY_URL_INVALID',
  /** You do not have permission to fetch the Entity */
  ProviderEntityFetchForbidden = 'PROVIDER_ENTITY_FETCH_FORBIDDEN',
  /** The entity identified by the given URL does not exist */
  ProviderEntityNotFound = 'PROVIDER_ENTITY_NOT_FOUND',
  /** An unexpected provider error occurred */
  ProviderError = 'PROVIDER_ERROR',
  /** The given URL is not supported by the provider */
  ProviderInputInvalid = 'PROVIDER_INPUT_INVALID'
}

export type ToolchainAssociateEntitiesInput = {
  associations: Array<ToolchainAssociateEntityInput>;
  cloudId: Scalars['ID']['input'];
  providerId: Scalars['ID']['input'];
  providerType?: InputMaybe<ToolchainProviderType>;
};

export type ToolchainAssociateEntityInput = {
  fromId: Scalars['ID']['input'];
  toEntityUrl: Scalars['URL']['input'];
};

export enum ToolchainCheckAuthErrorCode {
  /** An unexpected provider error occurred or authentication type is not implemented */
  ProviderError = 'PROVIDER_ERROR'
}

export enum ToolchainCreateContainerErrorCode {
  /** The container already exists */
  ProviderContainerAlreadyExists = 'PROVIDER_CONTAINER_ALREADY_EXISTS',
  /** You do not have permission to create the container */
  ProviderContainerCreateForbidden = 'PROVIDER_CONTAINER_CREATE_FORBIDDEN',
  /** An unexpected provider error occurred */
  ProviderError = 'PROVIDER_ERROR',
  /** The input provided is invalid */
  ProviderInputInvalid = 'PROVIDER_INPUT_INVALID',
  /** The given workspace doesn't exist */
  ProviderWorkspaceNotFound = 'PROVIDER_WORKSPACE_NOT_FOUND'
}

/** Either both `cloudId` and 'providerId', or 'workspaceId' must be specified. */
export type ToolchainCreateContainerInput = {
  cloudId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  providerId?: InputMaybe<Scalars['ID']['input']>;
  providerType?: InputMaybe<ToolchainProviderType>;
  type?: InputMaybe<Scalars['String']['input']>;
  workspaceId?: InputMaybe<Scalars['ID']['input']>;
};

export type ToolchainDisassociateContainerInput = {
  containerId: Scalars['ID']['input'];
  jiraProjectId: Scalars['ID']['input'];
};

export type ToolchainDisassociateContainersInput = {
  cloudId: Scalars['ID']['input'];
  disassociations: Array<ToolchainDisassociateContainerInput>;
  providerId: Scalars['ID']['input'];
  providerType?: InputMaybe<ToolchainProviderType>;
};

export enum ToolchainDisassociateEntitiesErrorCode {
  /** The association is unknown */
  UnknownAssociation = 'UNKNOWN_ASSOCIATION'
}

export type ToolchainDisassociateEntitiesInput = {
  cloudId: Scalars['ID']['input'];
  disassociations: Array<ToolchainDisassociateEntityInput>;
  providerId: Scalars['ID']['input'];
  providerType?: InputMaybe<ToolchainProviderType>;
};

export type ToolchainDisassociateEntityInput = {
  fromId: Scalars['ID']['input'];
  toEntityId: Scalars['ID']['input'];
};

/**
 * Type of a data-depot provider.
 * A provider may belongs to multiple types (e.g an connect-app can send both build and deployment info).
 */
export enum ToolchainProviderType {
  Build = 'BUILD',
  Deployment = 'DEPLOYMENT',
  Design = 'DESIGN',
  DevopsComponents = 'DEVOPS_COMPONENTS',
  DevInfo = 'DEV_INFO',
  Documentation = 'DOCUMENTATION',
  FeatureFlag = 'FEATURE_FLAG',
  Operations = 'OPERATIONS',
  RemoteLinks = 'REMOTE_LINKS',
  Security = 'SECURITY'
}

export enum ToolchainSyncState {
  Complete = 'COMPLETE',
  Error = 'ERROR',
  InProgress = 'IN_PROGRESS'
}

export enum ToolchainWorkspaceConnectionErrorCode {
  ProviderActionError = 'PROVIDER_ACTION_ERROR',
  ProviderNotSupported = 'PROVIDER_NOT_SUPPORTED'
}

export type TownsquareArchiveGoalInput = {
  id: Scalars['String']['input'];
};

export type TownsquareCreateGoalInput = {
  /**  Site ARI in the form of `ari:cloud:townsquare::site/{siteId}` */
  containerId: Scalars['String']['input'];
  goalTypeAri?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  owner?: InputMaybe<Scalars['String']['input']>;
  parentGoalAri?: InputMaybe<Scalars['String']['input']>;
  targetDate?: InputMaybe<TownsquareTargetDateInput>;
};

export type TownsquareCreateRelationshipsInput = {
  relationships: Array<TownsquareRelationshipInput>;
};

export type TownsquareDeleteRelationshipsInput = {
  relationships: Array<TownsquareRelationshipInput>;
};

export type TownsquareEditGoalInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  owner?: InputMaybe<Scalars['String']['input']>;
  targetDate?: InputMaybe<TownsquareTargetDateInput>;
};

export type TownsquareEditGoalTypeInput = {
  goalTypeAri: Scalars['String']['input'];
  state?: InputMaybe<TownsquareGoalTypeState>;
};

export enum TownsquareGoalIconAppearance {
  AtRisk = 'AT_RISK',
  Default = 'DEFAULT',
  OffTrack = 'OFF_TRACK',
  OnTrack = 'ON_TRACK'
}

export enum TownsquareGoalSortEnum {
  CreationDateAsc = 'CREATION_DATE_ASC',
  CreationDateDesc = 'CREATION_DATE_DESC',
  HierarchyAsc = 'HIERARCHY_ASC',
  HierarchyDesc = 'HIERARCHY_DESC',
  HierarchyLevelAsc = 'HIERARCHY_LEVEL_ASC',
  HierarchyLevelDesc = 'HIERARCHY_LEVEL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatestUpdateDateAsc = 'LATEST_UPDATE_DATE_ASC',
  LatestUpdateDateDesc = 'LATEST_UPDATE_DATE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  ProjectCountAsc = 'PROJECT_COUNT_ASC',
  ProjectCountDesc = 'PROJECT_COUNT_DESC',
  ScoreAsc = 'SCORE_ASC',
  ScoreDesc = 'SCORE_DESC',
  TargetDateAsc = 'TARGET_DATE_ASC',
  TargetDateDesc = 'TARGET_DATE_DESC',
  WatchingAsc = 'WATCHING_ASC',
  WatchingDesc = 'WATCHING_DESC'
}

export enum TownsquareGoalStateValue {
  Archived = 'archived',
  AtRisk = 'at_risk',
  Cancelled = 'cancelled',
  Done = 'done',
  OffTrack = 'off_track',
  OnTrack = 'on_track',
  Paused = 'paused',
  Pending = 'pending'
}

export enum TownsquareGoalTypeIconKey {
  Goal = 'GOAL',
  KeyResult = 'KEY_RESULT',
  Objective = 'OBJECTIVE'
}

export enum TownsquareGoalTypeState {
  Disabled = 'DISABLED',
  Enabled = 'ENABLED'
}

export enum TownsquareProjectSortEnum {
  CreationDateAsc = 'CREATION_DATE_ASC',
  CreationDateDesc = 'CREATION_DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatestUpdateDateAsc = 'LATEST_UPDATE_DATE_ASC',
  LatestUpdateDateDesc = 'LATEST_UPDATE_DATE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  StartDateAsc = 'START_DATE_ASC',
  StartDateDesc = 'START_DATE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TargetDateAsc = 'TARGET_DATE_ASC',
  TargetDateDesc = 'TARGET_DATE_DESC',
  WatchingAsc = 'WATCHING_ASC',
  WatchingDesc = 'WATCHING_DESC'
}

export enum TownsquareProjectStateValue {
  Archived = 'archived',
  AtRisk = 'at_risk',
  Cancelled = 'cancelled',
  Done = 'done',
  OffTrack = 'off_track',
  OnTrack = 'on_track',
  Paused = 'paused',
  Pending = 'pending'
}

/**
 * These are the currently supported relationships. The relationships are directional in the ARI Graph Store, so the order of "from" and "to" does matter.
 *
 *
 * | From           |   | To         |
 * |----------------|---|------------|
 * | Atlas Project  | â†’ | Jira Issue |
 * | Jira Issue     | â†’ | Atlas Goal |
 */
export type TownsquareRelationshipInput = {
  from: Scalars['String']['input'];
  to: Scalars['String']['input'];
};

export type TownsquareSetParentGoalInput = {
  goalAri: Scalars['String']['input'];
  parentGoalAri?: InputMaybe<Scalars['String']['input']>;
};

export type TownsquareTargetDateInput = {
  confidence?: InputMaybe<TownsquareTargetDateType>;
  date?: InputMaybe<Scalars['Date']['input']>;
};

export enum TownsquareTargetDateType {
  Day = 'DAY',
  Month = 'MONTH',
  Quarter = 'QUARTER'
}

export type TransitionFilter = {
  from: Scalars['String']['input'];
  to: Scalars['String']['input'];
};

/** Filter input for TrelloBoard.members */
export type TrelloBoardMembershipFilterInput = {
  /** Returns the board membership that matches this member ID, if any. */
  memberId?: InputMaybe<Scalars['ID']['input']>;
  /** Returned board memberships will have only this type */
  type?: InputMaybe<TrelloBoardMembershipType>;
};

/** Membership types for a TrelloBoard */
export enum TrelloBoardMembershipType {
  /**
   * Privileged membership type. Can edit board settings,
   * and add/remove board members.
   */
  Admin = 'ADMIN',
  /** Standard membership type.  Can view as well as edit board content. */
  Normal = 'NORMAL',
  /**
   * This membership type is either view-only, or view + comment and react
   * depending on board settings.
   */
  Observer = 'OBSERVER'
}

/** Filters to apply when querying board powerUps. */
export type TrelloBoardPowerUpFilterInput = {
  /**
   * Only powerUps of the specified access visibility will be returned.
   * If not included, it'll return all powerUps.
   *
   * Use 'all' to return both private and shared powerUps.
   */
  access?: InputMaybe<Scalars['String']['input']>;
};

/** TrelloCardCover brightness */
export enum TrelloCardCoverBrightness {
  Dark = 'DARK',
  Light = 'LIGHT'
}

/** TrelloCardCover color */
export enum TrelloCardCoverColor {
  Black = 'BLACK',
  Blue = 'BLUE',
  Green = 'GREEN',
  Lime = 'LIME',
  Orange = 'ORANGE',
  Pink = 'PINK',
  Purple = 'PURPLE',
  Red = 'RED',
  Sky = 'SKY',
  Yellow = 'YELLOW'
}

/** TrelloCardCover size */
export enum TrelloCardCoverSize {
  Full = 'FULL',
  Normal = 'NORMAL'
}

/** TrelloCard external sources, from which cards can be generated */
export enum TrelloCardExternalSource {
  Email = 'EMAIL'
}

/** Special TrelloCard roles */
export enum TrelloCardRole {
  Board = 'BOARD',
  Link = 'LINK',
  Mirror = 'MIRROR',
  Separator = 'SEPARATOR'
}

/** Specifies which cards to return in a list. */
export type TrelloListCardFilterInput = {
  /**
   * If true, returns only closed cards in the list.
   * If false , it'll return only open cards in the list.
   * If ommitted, it'll return all cards in the list.
   */
  closed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Filters to apply when querying lists. */
export type TrelloListFilterInput = {
  /** Only lists that have this closed property will be included */
  closed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Filter to apply to a member's workspaces. */
export type TrelloMemberWorkspaceFilter = {
  /** The workspace membership type to filter by. */
  membershipType: TrelloWorkspaceMembershipType;
  /** The workspace's tier to filter by. */
  tier: TrelloWorkspaceTier;
};

/** Status of the event (confirmed/tentative/cancelled) */
export enum TrelloPlannerCalendarEventStatus {
  Cancelled = 'CANCELLED',
  Confirmed = 'CONFIRMED',
  Tentative = 'TENTATIVE'
}

/** Visibility of the event (public/private) */
export enum TrelloPlannerCalendarEventVisibility {
  Default = 'DEFAULT',
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

/** The input filters for fetching events */
export type TrelloPlannerCalendarEventsFilter = {
  end: Scalars['DateTime']['input'];
  start: Scalars['DateTime']['input'];
};

/** TrelloPowerUpData visibility */
export enum TrelloPowerUpDataAccess {
  Private = 'PRIVATE',
  Shared = 'SHARED'
}

/** Filters to apply when querying powerUpData. */
export type TrelloPowerUpDataFilterInput = {
  /**
   * Only powerUpData of the specified access visibility will be returned.
   * If not included, it'll return all powerUpData.
   *
   * Use 'all' to return both private and shared powerUpData.
   *
   * See TrelloPowerUpDataAccess for enumeration of valid values for access.
   */
  access?: InputMaybe<Scalars['String']['input']>;
  /**
   * Filter powerUpData on specified powerUps.
   *
   * - powerUpData will be excluded if they are from a powerUp not in the provided list.
   * - A missing list means powerUpData for all powerUps will be returned.
   */
  powerUps?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** TrelloPowerUpData scope */
export enum TrelloPowerUpDataScope {
  Board = 'BOARD',
  Card = 'CARD',
  Organization = 'ORGANIZATION'
}

/** Arguments passed into removeMemberFromWorkspace mutation */
export type TrelloRemoveMemberFromWorkspaceInput = {
  userId: Scalars['ID']['input'];
  workspaceId: Scalars['ID']['input'];
};

/** The underlying Calendar providers that Planner supports */
export enum TrelloSupportedPlannerProviders {
  Google = 'GOOGLE'
}

/** Filters to apply when querying the Template Gallery. */
export type TrelloTemplateGalleryFilterInput = {
  /**
   * Only templates of this category will be included. If not included, it'll
   * return all categories.
   *
   * See TrelloTemplateGalleryCategory.key for valid categories.
   */
  category?: InputMaybe<Scalars['String']['input']>;
  /**
   * Desired language of the Template Gallery.
   *
   * See TrelloTemplateGalleryLanguage.language for valid and enabled languages.
   */
  language: Scalars['String']['input'];
  /**
   * Filter templates based on supported Power-Ups.
   *
   * - Templates will be excluded if they use a Power-Up not in the provided list.
   * - A missing or empty list means include all templates.
   */
  supportedPowerUps?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Arguments passed into the update board name mutation */
export type TrelloUpdateBoardNameInput = {
  boardId: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Membership types for a TrelloWorkspace */
export enum TrelloWorkspaceMembershipType {
  /**
   * Privileged membership type. Can edit workspace settings,
   * add and remove members
   */
  Admin = 'ADMIN',
  /** Standard membership type */
  Normal = 'NORMAL'
}

/** Product tiers for a TrelloWorkspace */
export enum TrelloWorkspaceTier {
  /** Includes all non-free workspaces (i.e. Standard, Premium, Enterprise) */
  Paid = 'PAID'
}

export type TunnelDefinitionsInput = {
  customUI?: InputMaybe<Array<InputMaybe<CustomUiTunnelDefinitionInput>>>;
  /** The URL to tunnel FaaS calls to */
  faasTunnelUrl?: InputMaybe<Scalars['URL']['input']>;
};

export type UnassignIssueParentInput = {
  boardId: Scalars['ID']['input'];
  issueIds: Array<Scalars['ID']['input']>;
};

export type UnifiedProfileInput = {
  bio?: InputMaybe<Scalars['String']['input']>;
  company?: InputMaybe<Scalars['String']['input']>;
  forumsId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  learnId?: InputMaybe<Scalars['String']['input']>;
  linkedinUrl?: InputMaybe<Scalars['String']['input']>;
  location?: InputMaybe<Scalars['String']['input']>;
  parentAccountInternalId?: InputMaybe<Scalars['String']['input']>;
  products?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Scalars['String']['input']>;
  unifiedProfileInternalId?: InputMaybe<Scalars['String']['input']>;
  unifiedProfileUsername?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['String']['input']>;
  websiteUrl?: InputMaybe<Scalars['String']['input']>;
  xUrl?: InputMaybe<Scalars['String']['input']>;
  youtubeUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Handles detaching a dataManager from a Component */
export type UnlinkExternalSourceInput = {
  cloudId: Scalars['ID']['input'];
  /** The ID of the Forge App being uninstalled */
  ecosystemAppId: Scalars['ID']['input'];
  /** The external source name of any ExternalAliases to be removed */
  externalSource: Scalars['String']['input'];
};

export type UpdateAppContributorRoleInput = {
  appId: Scalars['ID']['input'];
  updates: Array<UpdateAppContributorRolePayload>;
};

export type UpdateAppContributorRolePayload = {
  accountId: Scalars['ID']['input'];
  add: Array<InputMaybe<AppContributorRole>>;
  remove: Array<InputMaybe<AppContributorRole>>;
};

export type UpdateAppDetailsInput = {
  appId: Scalars['ID']['input'];
  avatarFileId?: InputMaybe<Scalars['String']['input']>;
  contactLink?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  privacyPolicy?: InputMaybe<Scalars['String']['input']>;
};

/** Input payload for enrolling scopes to an app environment */
export type UpdateAppHostServiceScopesInput = {
  /** A unique Id representing the app */
  appId: Scalars['ID']['input'];
  /** The key of the app's environment to enrol the scopes */
  environmentKey: Scalars['String']['input'];
  /** The scopes this app will be enrolled to after the request succeeds */
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The Id of the service for which the scopes belong to */
  serviceId: Scalars['ID']['input'];
};

export type UpdateAppOwnershipInput = {
  appAri: Scalars['String']['input'];
  newOwner: Scalars['String']['input'];
};

/** Input payload for updating an Atlassian OAuth Client mutation */
export type UpdateAtlassianOAuthClientInput = {
  callbacks?: InputMaybe<Array<Scalars['String']['input']>>;
  clientID: Scalars['ID']['input'];
  refreshToken?: InputMaybe<RefreshTokenInput>;
};

/** Accepts input to update a data manager on a component. */
export type UpdateCompassComponentDataManagerMetadataInput = {
  /** The ID of the component to update a data manager on. */
  componentId: Scalars['ID']['input'];
  /** A URL of the external source of the component's data. */
  externalSourceURL?: InputMaybe<Scalars['URL']['input']>;
  /** Details about the last sync event to this component. */
  lastSyncEvent?: InputMaybe<ComponentSyncEventInput>;
};

/** Accepts input for updating an existing component. */
export type UpdateCompassComponentInput = {
  /** The extended description details associated to the component. */
  componentDescriptionDetails?: InputMaybe<CompassComponentDescriptionDetailsInput>;
  /** A collection of custom fields for storing data about the component. */
  customFields?: InputMaybe<Array<CompassCustomFieldInput>>;
  /** The description of the component. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** A collection of fields for storing data about the component. */
  fields?: InputMaybe<Array<UpdateCompassFieldInput>>;
  /** The ID of the component being updated. */
  id: Scalars['ID']['input'];
  /** The name of the component. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The unique identifier (ID) of the team that owns the component. */
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  /** The state of the component. */
  state?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for updating a component link. */
export type UpdateCompassComponentLinkInput = {
  /** The ID for the component to update the link. */
  componentId: Scalars['ID']['input'];
  /** The link to be updated for the component. */
  link: UpdateCompassLinkInput;
};

/** Accepts input for updating an existing component's type. */
export type UpdateCompassComponentTypeInput = {
  id: Scalars['ID']['input'];
  type?: InputMaybe<CompassComponentType>;
  typeId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input to update the metadata for a component type. */
export type UpdateCompassComponentTypeMetadataInput = {
  /** The description of the component type. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The icon key of the component type. */
  iconKey?: InputMaybe<Scalars['String']['input']>;
  /** The ID((ARI) of the component type being updated. */
  id: Scalars['ID']['input'];
  /** The name of the component type. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input to update a field. */
export type UpdateCompassFieldInput = {
  /** The ID of the field definition. */
  definition: Scalars['ID']['input'];
  /** The value of the field. */
  value: CompassFieldValueInput;
};

export type UpdateCompassFreeformUserDefinedParameterInput = {
  /** The value that will be used if the user does not provide a value. */
  defaultValue?: InputMaybe<Scalars['String']['input']>;
  /** The description of the parameter. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The id of the parameter to update */
  id: Scalars['ID']['input'];
  /** The name of the parameter. */
  name: Scalars['String']['input'];
};

/** Accepts input to a update a scorecard criterion representing the presence of a description. */
export type UpdateCompassHasDescriptionScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to update a scorecard criterion representing the presence of a field, for example, 'Has Tier'. */
export type UpdateCompassHasFieldScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID for the field definition which is the target of a relationship. */
  fieldDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** ID of the scorecard criteria to update */
  id: Scalars['ID']['input'];
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to update a scorecard criterion representing the presence of a link, for example, 'Has Repository' or 'Has Documentation'. */
export type UpdateCompassHasLinkScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the scorecard criteria to update */
  id: Scalars['ID']['input'];
  /** The type of link, for example, 'Repository' if 'Has Repository'. */
  linkType?: InputMaybe<CompassLinkType>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The comparison operation to be performed. */
  textComparator?: InputMaybe<CompassCriteriaTextComparatorOptions>;
  /** The value that the field is compared to. */
  textComparatorValue?: InputMaybe<Scalars['String']['input']>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to update a scorecard criterion checking the value of a specified metric ID. */
export type UpdateCompassHasMetricValueCriteriaInput = {
  /** Automatically create metric sources for the custom metric definition associated with this criterion */
  automaticallyCreateMetricSources?: InputMaybe<Scalars['Boolean']['input']>;
  /** The comparison operation to be performed between the metric and comparator value. */
  comparator?: InputMaybe<CompassCriteriaNumberComparatorOptions>;
  /** The threshold value that the metric is compared to. */
  comparatorValue?: InputMaybe<Scalars['Float']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the scorecard criteria to update */
  id: Scalars['ID']['input'];
  /** The ID of the component metric to check the value of. */
  metricDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to a update a scorecard criterion representing the presence of an owner. */
export type UpdateCompassHasOwnerScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts details of the link to be updated. */
export type UpdateCompassLinkInput = {
  /** The unique identifier (ID) of the link. */
  id: Scalars['ID']['input'];
  /** The name of the link. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The type of the link. */
  type?: InputMaybe<CompassLinkType>;
  /** The URL of the link. */
  url?: InputMaybe<Scalars['URL']['input']>;
};

export type UpdateCompassScorecardCriteriaInput = {
  hasCustomBooleanValue?: InputMaybe<CompassUpdateHasCustomBooleanFieldScorecardCriteriaInput>;
  hasCustomMultiSelectValue?: InputMaybe<CompassUpdateHasCustomMultiSelectFieldScorecardCriteriaInput>;
  hasCustomNumberValue?: InputMaybe<CompassUpdateHasCustomNumberFieldScorecardCriteriaInput>;
  hasCustomSingleSelectValue?: InputMaybe<CompassUpdateHasCustomSingleSelectFieldScorecardCriteriaInput>;
  hasCustomTextValue?: InputMaybe<CompassUpdateHasCustomTextFieldScorecardCriteriaInput>;
  hasDescription?: InputMaybe<UpdateCompassHasDescriptionScorecardCriteriaInput>;
  hasField?: InputMaybe<UpdateCompassHasFieldScorecardCriteriaInput>;
  hasLink?: InputMaybe<UpdateCompassHasLinkScorecardCriteriaInput>;
  hasMetricValue?: InputMaybe<UpdateCompassHasMetricValueCriteriaInput>;
  hasOwner?: InputMaybe<UpdateCompassHasOwnerScorecardCriteriaInput>;
};

export type UpdateCompassScorecardInput = {
  componentCreationTimeFilter?: InputMaybe<CompassComponentCreationTimeFilterInput>;
  componentLabelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  componentLifecycleStages?: InputMaybe<CompassLifecycleFilterInput>;
  componentOwnerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  componentTierValues?: InputMaybe<Array<Scalars['String']['input']>>;
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  createCriteria?: InputMaybe<Array<CreateCompassScorecardCriteriaInput>>;
  deleteCriteria?: InputMaybe<Array<DeleteCompassScorecardCriteriaInput>>;
  description?: InputMaybe<Scalars['String']['input']>;
  importance?: InputMaybe<CompassScorecardImportance>;
  isDeactivationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  repositoryValues?: InputMaybe<CompassRepositoryValueInput>;
  scoringStrategyType?: InputMaybe<CompassScorecardScoringStrategyType>;
  updateCriteria?: InputMaybe<Array<UpdateCompassScorecardCriteriaInput>>;
};

export type UpdateCompassUserDefinedParameterInput = {
  /** Input to update a freeform parameter. */
  freeformField?: InputMaybe<UpdateCompassFreeformUserDefinedParameterInput>;
};

/** The input sent when updating user defined parameters. */
export type UpdateCompassUserDefinedParametersInput = {
  /** The component id associated with the parameters. */
  componentId: Scalars['ID']['input'];
  /** The new parameter definitions to create for the component. */
  createParameters?: InputMaybe<Array<CreateCompassUserDefinedParameterInput>>;
  /** The existing parameter definitions to delete for the component. */
  deleteParameters?: InputMaybe<Array<DeleteCompassUserDefinedParameterInput>>;
  /** The existing parameter definitions to update for the component. */
  updateParameters?: InputMaybe<Array<UpdateCompassUserDefinedParameterInput>>;
};

/**
 * ###################################################################################################################
 *  COMPASS API SPEC
 * ###################################################################################################################
 */
export type UpdateComponentApiInput = {
  componentId: Scalars['String']['input'];
  defaultTag?: InputMaybe<Scalars['String']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  repo?: InputMaybe<CompassComponentApiRepoUpdate>;
  status?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateComponentApiUploadInput = {
  componentId: Scalars['ID']['input'];
  effectiveAt: Scalars['String']['input'];
  shouldDereference?: InputMaybe<Scalars['Boolean']['input']>;
  tags: Array<Scalars['String']['input']>;
  uploadId: Scalars['ID']['input'];
};

/**
 * Updates a custom filter with the given id in the board with the given boardId.
 * The update will update the entire filter (ie. not a partial update)
 */
export type UpdateCustomFilterInput = {
  boardId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  jql: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

/** The request input for updating relationship properties */
export type UpdateDevOpsContainerRelationshipEntityPropertiesInput = {
  /** The ARI of the relationship entity */
  id: Scalars['ID']['input'];
  properties: Array<DevOpsContainerRelationshipEntityPropertyInput>;
};

/** The request input for updating a relationship between a DevOps Service and Jira Project */
export type UpdateDevOpsServiceAndJiraProjectRelationshipInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  /** The DevOps Graph Service_And_Jira_Project relationship ARI */
  id: Scalars['ID']['input'];
  /**
   * The revision that must be provided when updating a relationship between DevOps Service and Jira Project to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID']['input'];
};

/** The request input for updating a relationship between a DevOps Service and an Opsgenie Team */
export type UpdateDevOpsServiceAndOpsgenieTeamRelationshipInput = {
  /** The new description assigned to the relationship. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The DevOps Graph Service_And_Opsgenie_Team relationship ARI */
  id: Scalars['ID']['input'];
  /**
   * The revision that must be provided when updating a relationship between DevOps Service and Opsgenie Team to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID']['input'];
};

/** The request input for updating a relationship between a DevOps Service and a Repository */
export type UpdateDevOpsServiceAndRepositoryRelationshipInput = {
  /** The description of the relationship */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ARI of the relationship */
  id: Scalars['ID']['input'];
  /**
   * The revision that must be provided when updating a relationship between DevOps Service and a Repository to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID']['input'];
};

/** The request input for updating DevOps Service Entity Properties */
export type UpdateDevOpsServiceEntityPropertiesInput = {
  /** The ARI of the DevOps Service */
  id: Scalars['ID']['input'];
  properties: Array<DevOpsServiceEntityPropertyInput>;
};

/** The request input for updating a DevOps Service */
export type UpdateDevOpsServiceInput = {
  /** The ID of the DevOps Service in Compass */
  compassId?: InputMaybe<Scalars['ID']['input']>;
  /** The revision of the DevOps Service in Compass */
  compassRevision?: InputMaybe<Scalars['Int']['input']>;
  /** The new description assigned to the DevOps Service */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The DevOps Service ARI */
  id: Scalars['ID']['input'];
  /** The new name assigned to the DevOps Service */
  name: Scalars['String']['input'];
  /** The properties of the DevOps Service to be updated */
  properties?: InputMaybe<Array<DevOpsServiceEntityPropertyInput>>;
  /**
   * The revision that must be provided when updating a DevOps Service to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID']['input'];
  /** The id of the Tier assigned to the Service */
  serviceTier: Scalars['ID']['input'];
  /** The id of the Service Type assigned to the Service */
  serviceType?: InputMaybe<Scalars['ID']['input']>;
};

/** The request input for updating a DevOps Service Relationship */
export type UpdateDevOpsServiceRelationshipInput = {
  /** The description of the DevOps Service Relationship */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The DevOps Service Relationship ARI */
  id: Scalars['ID']['input'];
  /**
   * The revision that must be provided when updating a DevOps Service Relationship to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID']['input'];
};

export type UpdateDeveloperLogAccessInput = {
  /** AppId as ARI */
  appId: Scalars['ID']['input'];
  /** An array of context ARIs */
  contextIds: Array<Scalars['ID']['input']>;
  /** App environment */
  environmentType: AppEnvironmentType;
  /** Boolean representing whether access should be granted or not */
  shouldHaveAccess: Scalars['Boolean']['input'];
};

export type UpdateJiraProjectAndOpsgenieTeamRelationshipInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  revision: Scalars['ID']['input'];
};

/** The request input for updating a relationship between a Jira project and a repository */
export type UpdateJiraProjectAndRepositoryRelationshipInput = {
  /** An optional description of the relationship */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The relationship ARI */
  id: Scalars['ID']['input'];
  /** Database object revision ID created for the relationship */
  revision: Scalars['ID']['input'];
  /**
   * The third party repository details.
   * This parameter should be null when the relationship involves a Bitbucket repository.
   * When updating third party repository details, the repository ID must stay consistent with the original relationship.
   */
  thirdPartyRepository?: InputMaybe<ThirdPartyRepositoryInput>;
};

export type UpdatePolarisCommentInput = {
  content?: InputMaybe<Scalars['JSON']['input']>;
  delete?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
};

export type UpdatePolarisIdeaInput = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  lastCommentsViewedTimestamp?: InputMaybe<Scalars['String']['input']>;
  lastInsightsViewedTimestamp?: InputMaybe<Scalars['String']['input']>;
};

export type UpdatePolarisIdeaTemplateInput = {
  color?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  emoji?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  project: Scalars['ID']['input'];
  /**
   * Template in ADF format.  See
   * https://developer.atlassian.com/platform/atlassian-document-format/
   */
  template?: InputMaybe<Scalars['JSON']['input']>;
  title: Scalars['String']['input'];
};

export type UpdatePolarisInsightInput = {
  description?: InputMaybe<Scalars['JSON']['input']>;
  snippets?: InputMaybe<Array<UpdatePolarisSnippetInput>>;
};

export type UpdatePolarisMatrixAxis = {
  dimension: Scalars['String']['input'];
  field: Scalars['ID']['input'];
  fieldOptions?: InputMaybe<Array<PolarisGroupValueInput>>;
  reversed?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UpdatePolarisMatrixConfig = {
  axes?: InputMaybe<Array<UpdatePolarisMatrixAxis>>;
};

export type UpdatePolarisPlayContribution = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  /**  the extent of the contribution (null=drop value) */
  comment?: InputMaybe<Scalars['ID']['input']>;
  /**  the comment (null=drop value, which is not permitted; delete the contribution if needed) */
  content?: InputMaybe<Scalars['JSON']['input']>;
};

export type UpdatePolarisPlayInput = {
  id: Scalars['ID']['input'];
  parameters?: InputMaybe<Scalars['JSON']['input']>;
};

export type UpdatePolarisSnippetInput = {
  /** Data in JSON format. It will be validated with JSON schema of Polaris Insights Data format. */
  data?: InputMaybe<Scalars['JSON']['input']>;
  deleteProperties?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * The client can specify either a specific snippet id, or an
   * oauthClientId.  In the latter case, we will create a snippet on
   * this data point (nee insight) if one doesn't exist already, and it
   * is an error for there to be more than one snippet with the same
   * oauthClientId.
   */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** OauthClientId of CaaS app */
  oauthClientId?: InputMaybe<Scalars['String']['input']>;
  setProperties?: InputMaybe<Scalars['JSON']['input']>;
  /** Snippet url that is source of data */
  url?: InputMaybe<Scalars['String']['input']>;
};

export type UpdatePolarisTermsConsentInput = {
  /** Cloud ID where the terms were displayed to the user */
  cloudID: Scalars['String']['input'];
  /** The text accepted by user as terms of service */
  displayedText: Scalars['String']['input'];
  /** Country code for the user locale */
  locale: Scalars['String']['input'];
  /** Has the user granted general marketing consent */
  marketingConsent: Scalars['Boolean']['input'];
  /** URL visited by user when terms of service were accepted */
  url: Scalars['URL']['input'];
};

export type UpdatePolarisTimelineConfig = {
  dueDateField?: InputMaybe<Scalars['ID']['input']>;
  endTimestamp?: InputMaybe<Scalars['String']['input']>;
  mode?: InputMaybe<PolarisTimelineMode>;
  startDateField?: InputMaybe<Scalars['ID']['input']>;
  startTimestamp?: InputMaybe<Scalars['String']['input']>;
  summaryCardField?: InputMaybe<Scalars['ID']['input']>;
};

export type UpdatePolarisViewInput = {
  /**  view emoji */
  description?: InputMaybe<Scalars['JSON']['input']>;
  /**  the name of the view */
  emoji?: InputMaybe<Scalars['String']['input']>;
  enabledAutoSave?: InputMaybe<Scalars['Boolean']['input']>;
  /**  table column sizes per field */
  fieldRollups?: InputMaybe<Array<PolarisViewFieldRollupInput>>;
  /**  rollup type per field */
  fields?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**  a field to sort by */
  filter?: InputMaybe<Array<PolarisViewFilterInput>>;
  /**  the table columns list of fields (table viz) or fields to show */
  groupBy?: InputMaybe<Scalars['ID']['input']>;
  /**  what field to group by (board viz) */
  groupValues?: InputMaybe<Array<PolarisGroupValueInput>>;
  /**  view filter congfiguration */
  hidden?: InputMaybe<Array<Scalars['ID']['input']>>;
  hideEmptyColumns?: InputMaybe<Scalars['Boolean']['input']>;
  hideEmptyGroups?: InputMaybe<Scalars['Boolean']['input']>;
  /**  description of the view */
  jql?: InputMaybe<Scalars['String']['input']>;
  lastCommentsViewedTimestamp?: InputMaybe<Scalars['String']['input']>;
  /**  fields that are included in view but hidden */
  lastViewedTimestamp?: InputMaybe<Scalars['String']['input']>;
  layoutType?: InputMaybe<PolarisViewLayoutType>;
  matrixConfig?: InputMaybe<UpdatePolarisMatrixConfig>;
  /**  view to update, if this is an UPDATE operation */
  name?: InputMaybe<Scalars['String']['input']>;
  /**  what are the (ordered) vertical grouping values */
  sort?: InputMaybe<Array<PolarisSortFieldInput>>;
  sortMode?: InputMaybe<PolarisViewSortMode>;
  /**  just the user filtering part of the JQL */
  tableColumnSizes?: InputMaybe<Array<PolarisViewTableColumnSizeInput>>;
  timelineConfig?: InputMaybe<UpdatePolarisTimelineConfig>;
  /**  the JQL (sets filter and sorting) */
  userJql?: InputMaybe<Scalars['String']['input']>;
  /**  what are the (ordered) grouping values */
  verticalGroupBy?: InputMaybe<Scalars['ID']['input']>;
  /**  what field to vertical group by (board viz) */
  verticalGroupValues?: InputMaybe<Array<PolarisGroupValueInput>>;
  view?: InputMaybe<Scalars['ID']['input']>;
  whiteboardConfig?: InputMaybe<UpdatePolarisWhiteboardConfig>;
};

export type UpdatePolarisViewRankInput = {
  container?: InputMaybe<Scalars['ID']['input']>;
  /**  new container if needed */
  rank: Scalars['Int']['input'];
};

export type UpdatePolarisViewSetInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  viewSet: Scalars['ID']['input'];
};

export type UpdatePolarisWhiteboardConfig = {
  id: Scalars['ID']['input'];
};

export type UpdateUserInstallationRulesInput = {
  cloudId: Scalars['ID']['input'];
  rule: UserInstallationRuleValue;
};

export type UserAuthTokenForExtensionInput = {
  /**
   * List of ARI's, this should be the same as passed to `InvokeExtensionInput`.
   * The most specific context is extracted and passed to outbound-auth to support
   * access narrowing (Tenant Isolation)
   *
   * *Important:* this should start with the most specific context as the
   * most specific extension will be the selected extension.
   */
  contextIds: Array<Scalars['ID']['input']>;
  extensionId: Scalars['ID']['input'];
};

export enum UserInstallationRuleValue {
  Allow = 'allow',
  Deny = 'deny'
}

export enum VirtualAgentConversationActionType {
  AiAnswered = 'AI_ANSWERED',
  Matched = 'MATCHED',
  Unhandled = 'UNHANDLED'
}

export enum VirtualAgentConversationChannel {
  HelpCenter = 'HELP_CENTER',
  JsmPortal = 'JSM_PORTAL',
  MsTeams = 'MS_TEAMS',
  Slack = 'SLACK'
}

export enum VirtualAgentConversationCsatOptionType {
  CsatOption_1 = 'CSAT_OPTION_1',
  CsatOption_2 = 'CSAT_OPTION_2',
  CsatOption_3 = 'CSAT_OPTION_3',
  CsatOption_4 = 'CSAT_OPTION_4',
  CsatOption_5 = 'CSAT_OPTION_5'
}

export enum VirtualAgentConversationState {
  Closed = 'CLOSED',
  Escalated = 'ESCALATED',
  Open = 'OPEN',
  Resolved = 'RESOLVED'
}

export type VirtualAgentConversationsFilter = {
  /** Filter by action type(s) */
  actions?: InputMaybe<Array<VirtualAgentConversationActionType>>;
  /** Filter by channel */
  channels?: InputMaybe<Array<VirtualAgentConversationChannel>>;
  /** Filter by csat score(s) */
  csatOptions?: InputMaybe<Array<VirtualAgentConversationCsatOptionType>>;
  /** The end date of a period to filter conversations */
  endDate: Scalars['DateTime']['input'];
  /** The start date of a period to filter conversations */
  startDate: Scalars['DateTime']['input'];
  /** Filter by state(s) */
  states?: InputMaybe<Array<VirtualAgentConversationState>>;
};

export type VirtualAgentCreateChatChannelInput = {
  /** Specify whether the channel is triage channel or not */
  isTriageChannel: Scalars['Boolean']['input'];
  /** Specify whether the channel is virtual agent test channel or not */
  isVirtualAgentTestChannel: Scalars['Boolean']['input'];
};

/** Accepts input for creating a VirtualAgent Configuration. */
export type VirtualAgentCreateConfigurationInput = {
  /** Get the Virtual Agent's default request type id. */
  defaultJiraRequestTypeId?: InputMaybe<Scalars['String']['input']>;
  /** A configuration on the Virtual Agent which indicates if the Bot will reply to help seeker messages or not. */
  respondToQueries?: InputMaybe<Scalars['Boolean']['input']>;
};

export type VirtualAgentCreateIntentRuleProjectionInput = {
  /** Message that helpseekers use to confirm that this intent rule should be executed */
  confirmationMessage?: InputMaybe<Scalars['String']['input']>;
  /** The description of the intent */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the intent */
  name: Scalars['String']['input'];
  /** A list of question text to be created along with the intent */
  questions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Short message used by helpseekers to select this intent rule from a list of other intent rules */
  suggestionButtonText?: InputMaybe<Scalars['String']['input']>;
  /** Intent template id from which this intent is based on */
  templateId?: InputMaybe<Scalars['String']['input']>;
  /** The type of intent template from which this intent is based on */
  templateType?: InputMaybe<VirtualAgentIntentTemplateType>;
};

export type VirtualAgentFlowEditorAction = {
  /** type of the action */
  actionType: Scalars['String']['input'];
  /** payload of the action */
  payload: Scalars['JSON']['input'];
};

export type VirtualAgentFlowEditorActionInput = {
  /** stream of actions that need to performed on the flow editor */
  actions: Array<VirtualAgentFlowEditorAction>;
  /** Json representation of the flow editor */
  jsonRepresentation: Scalars['String']['input'];
};

export type VirtualAgentFlowEditorInput = {
  /** The group that the flow belongs to */
  group?: InputMaybe<Scalars['String']['input']>;
  /** Json representation of the flow editor */
  jsonRepresentation: Scalars['String']['input'];
  /** Display name of the flow editor */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input query to fetch Intent Rules */
export type VirtualAgentIntentRuleProjectionsFilter = {
  /** The Virtual Agent Configuration that should be used to filter Intent Rules */
  virtualAgentConfigurationId: Scalars['ID']['input'];
};

export enum VirtualAgentIntentTemplateType {
  Discovered = 'DISCOVERED',
  Shared = 'SHARED',
  Standard = 'STANDARD'
}

export type VirtualAgentUpdateAiAnswerForSlackChannelInput = {
  /** Specify whether ai answers is enabled on the channel */
  isAiResponsesChannel: Scalars['Boolean']['input'];
  /** Halp Id of the channel document */
  slackChannelId: Scalars['String']['input'];
};

export type VirtualAgentUpdateChatChannelInput = {
  /** Halp Id of the channel document */
  halpChannelId: Scalars['String']['input'];
  /** Specify whether smart answer is enabled on the channel */
  isAiResponsesChannel?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify whether the channel is connected to virtual agent or not */
  isVirtualAgentChannel: Scalars['Boolean']['input'];
};

/** Accepts input for updating an existing VirtualAgent Configuration. */
export type VirtualAgentUpdateConfigurationInput = {
  /** The ID of the default request type used when the virtual agent escalates and creates a Jira Service Management request */
  defaultJiraRequestTypeId?: InputMaybe<Scalars['String']['input']>;
  /** Whether AI answers is enabled */
  isAiResponsesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The configuration which determines if Virtual Agent will respond to Help Seeker queries. */
  respondToQueries?: InputMaybe<Scalars['Boolean']['input']>;
};

export type VirtualAgentUpdateIntentRuleProjectionInput = {
  /** Message that helpseekers use to confirm that this intent rule should be executed */
  confirmationMessage?: InputMaybe<Scalars['String']['input']>;
  /** A new description for the intent */
  description?: InputMaybe<Scalars['String']['input']>;
  /** A boolean flag which defines if an underlying Intent is enabled for this VirtualAgent or not */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the intent */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Short message used to represent this intent rule to helpseekers among a list of other intent rules */
  suggestionButtonText?: InputMaybe<Scalars['String']['input']>;
};

export type VirtualAgentUpdateIntentRuleProjectionQuestionsInput = {
  /** Questions to be added to the intent rule */
  addedQuestions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Message that helpseekers use to confirm that this intent rule should be executed */
  confirmationMessage?: InputMaybe<Scalars['String']['input']>;
  /** Questions to be deleted */
  deletedQuestions?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The description for an intent */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the intent */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Short message used by helpseekers to select this intent rule from a list of other intent rules */
  suggestionButtonText?: InputMaybe<Scalars['String']['input']>;
  /** Questions to be updated */
  updatedQuestions?: InputMaybe<Array<VirtualAgentUpdatedQuestionInput>>;
};

export type VirtualAgentUpdatedQuestionInput = {
  /** Id of the question to be updated */
  id: Scalars['ID']['input'];
  /** Text of the question to be updated */
  question: Scalars['String']['input'];
};

export type WebTriggerUrlInput = {
  /** Id of the application */
  appId: Scalars['ID']['input'];
  /**
   * context in which function should run, usually a site context.
   * E.g.: ari:cloud:jira::site/{siteId}
   */
  contextId: Scalars['ID']['input'];
  /** Environment id of the application */
  envId: Scalars['ID']['input'];
  /** Web trigger module key */
  triggerKey: Scalars['String']['input'];
};

export enum WorkSuggestionsAction {
  Remove = 'REMOVE',
  Snooze = 'SNOOZE'
}

/** Input for the mutation operations (snooze and remove). */
export type WorkSuggestionsActionInput = {
  /** Cloud id */
  cloudId: Scalars['ID']['input'];
  /** Work Suggestion id */
  taskId: Scalars['String']['input'];
};

export enum WorkSuggestionsApprovalStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  Unapproved = 'UNAPPROVED',
  Unknown = 'UNKNOWN'
}

export enum WorkSuggestionsAutoDevJobState {
  Cancelled = 'CANCELLED',
  CodeGenerating = 'CODE_GENERATING',
  CodeGenerationFail = 'CODE_GENERATION_FAIL',
  CodeGenerationReady = 'CODE_GENERATION_READY',
  CodeGenerationSuccess = 'CODE_GENERATION_SUCCESS',
  Created = 'CREATED',
  PlanGenerating = 'PLAN_GENERATING',
  PlanGenerationFail = 'PLAN_GENERATION_FAIL',
  PlanGenerationSuccess = 'PLAN_GENERATION_SUCCESS',
  PullrequestCreating = 'PULLREQUEST_CREATING',
  PullrequestCreationFail = 'PULLREQUEST_CREATION_FAIL',
  PullrequestCreationSuccess = 'PULLREQUEST_CREATION_SUCCESS',
  Unknown = 'UNKNOWN'
}

/** projectAri is always required, but sprintAri can also be specified */
export type WorkSuggestionsContextAri = {
  projectAri: Scalars['ID']['input'];
  sprintAri?: InputMaybe<Scalars['ID']['input']>;
};

export enum WorkSuggestionsEnvironmentType {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type WorkSuggestionsInput = {
  /** The target audience for the suggestions */
  targetAudience?: InputMaybe<WorkSuggestionsTargetAudience>;
};

/** Input for the mutation operations (save user profile). */
export type WorkSuggestionsSaveUserProfileInput = {
  /** Cloud id */
  cloudId: Scalars['ID']['input'];
  /** isUpdate */
  isUpdate: Scalars['Boolean']['input'];
  /** Persona */
  persona?: InputMaybe<WorkSuggestionsUserPersona>;
  /** Project ARIs */
  projectAris: Array<Scalars['ID']['input']>;
};

export enum WorkSuggestionsTargetAudience {
  /** The target audience for individual suggestions */
  Me = 'ME',
  /** The target audience for team suggestions */
  Team = 'TEAM'
}

/**
 * Persona for the user profile.
 * For example: DEVELOPER
 */
export enum WorkSuggestionsUserPersona {
  Developer = 'DEVELOPER'
}

export enum WorkSuggestionsVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum SourceBillingType {
  Ccp = 'CCP',
  Hams = 'HAMS'
}

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = { __typename?: 'Query', me: { __typename?: 'AuthenticationContext', user?: { __typename?: 'AppUser', accountId: string, name: string, picture: any } | { __typename?: 'AtlassianAccountUser', accountId: string, name: string, picture: any } | { __typename?: 'CustomerUser', accountId: string, name: string, picture: any } | null } };

export type MyNotificationsQueryVariables = Exact<{
  readState?: InputMaybe<InfluentsNotificationReadState>;
  first?: InputMaybe<Scalars['Int']['input']>;
}>;


export type MyNotificationsQuery = { __typename?: 'Query', notifications?: { __typename?: 'InfluentsNotificationQuery', unseenNotificationCount: number, notificationFeed: { __typename?: 'InfluentsNotificationFeedConnection', pageInfo: { __typename?: 'InfluentsNotificationPageInfo', hasNextPage: boolean }, nodes: Array<(
        { __typename?: 'InfluentsNotificationHeadItem' }
        & { ' $fragmentRefs'?: { 'AtlassianNotificationFragment': AtlassianNotificationFragment } }
      )> } } | null };

export type MarkAsReadMutationVariables = Exact<{
  notificationIDs: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type MarkAsReadMutation = { __typename?: 'Mutation', notifications?: { __typename?: 'InfluentsNotificationMutation', markNotificationsByIdsAsRead?: string | null } | null };

export type MarkAsUnreadMutationVariables = Exact<{
  notificationIDs: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type MarkAsUnreadMutation = { __typename?: 'Mutation', notifications?: { __typename?: 'InfluentsNotificationMutation', markNotificationsByIdsAsUnread?: string | null } | null };

export type AtlassianNotificationFragment = { __typename?: 'InfluentsNotificationHeadItem', groupId: string, headNotification: (
    { __typename?: 'InfluentsNotificationItem' }
    & { ' $fragmentRefs'?: { 'AtlassianHeadNotificationFragment': AtlassianHeadNotificationFragment } }
  ) } & { ' $fragmentName'?: 'AtlassianNotificationFragment' };

export type AtlassianHeadNotificationFragment = { __typename?: 'InfluentsNotificationItem', notificationId: string, timestamp: any, readState: InfluentsNotificationReadState, category: InfluentsNotificationCategory, content: { __typename?: 'InfluentsNotificationContent', type: string, message: string, url?: string | null, entity?: { __typename?: 'InfluentsNotificationEntity', title?: string | null, iconUrl?: string | null, url?: string | null } | null, path?: Array<{ __typename?: 'InfluentsNotificationPath', title?: string | null, iconUrl?: string | null, url?: string | null }> | null, actor: { __typename?: 'InfluentsNotificationActor', displayName?: string | null, avatarURL?: string | null } }, analyticsAttributes?: Array<{ __typename?: 'InfluentsNotificationAnalyticsAttribute', key?: string | null, value?: string | null }> | null } & { ' $fragmentName'?: 'AtlassianHeadNotificationFragment' };

export class TypedDocumentString<TResult, TVariables>
  extends String
  implements DocumentTypeDecoration<TResult, TVariables>
{
  __apiType?: DocumentTypeDecoration<TResult, TVariables>['__apiType'];

  constructor(private value: string, public __meta__?: Record<string, any>) {
    super(value);
  }

  toString(): string & DocumentTypeDecoration<TResult, TVariables> {
    return this.value;
  }
}
export const AtlassianHeadNotificationFragmentDoc = new TypedDocumentString(`
    fragment AtlassianHeadNotification on InfluentsNotificationItem {
  notificationId
  timestamp
  readState
  category
  content {
    type
    message
    url
    entity {
      title
      iconUrl
      url
    }
    path {
      title
      iconUrl
      url
    }
    actor {
      displayName
      avatarURL
    }
  }
  analyticsAttributes {
    key
    value
  }
}
    `, {"fragmentName":"AtlassianHeadNotification"}) as unknown as TypedDocumentString<AtlassianHeadNotificationFragment, unknown>;
export const AtlassianNotificationFragmentDoc = new TypedDocumentString(`
    fragment AtlassianNotification on InfluentsNotificationHeadItem {
  groupId
  headNotification {
    ...AtlassianHeadNotification
  }
}
    fragment AtlassianHeadNotification on InfluentsNotificationItem {
  notificationId
  timestamp
  readState
  category
  content {
    type
    message
    url
    entity {
      title
      iconUrl
      url
    }
    path {
      title
      iconUrl
      url
    }
    actor {
      displayName
      avatarURL
    }
  }
  analyticsAttributes {
    key
    value
  }
}`, {"fragmentName":"AtlassianNotification"}) as unknown as TypedDocumentString<AtlassianNotificationFragment, unknown>;
export const MeDocument = new TypedDocumentString(`
    query Me {
  me {
    user {
      accountId
      name
      picture
    }
  }
}
    `) as unknown as TypedDocumentString<MeQuery, MeQueryVariables>;
export const MyNotificationsDocument = new TypedDocumentString(`
    query MyNotifications($readState: InfluentsNotificationReadState, $first: Int) {
  notifications {
    unseenNotificationCount
    notificationFeed(
      flat: true
      first: $first
      filter: {readStateFilter: $readState}
    ) {
      pageInfo {
        hasNextPage
      }
      nodes {
        ...AtlassianNotification
      }
    }
  }
}
    fragment AtlassianNotification on InfluentsNotificationHeadItem {
  groupId
  headNotification {
    ...AtlassianHeadNotification
  }
}
fragment AtlassianHeadNotification on InfluentsNotificationItem {
  notificationId
  timestamp
  readState
  category
  content {
    type
    message
    url
    entity {
      title
      iconUrl
      url
    }
    path {
      title
      iconUrl
      url
    }
    actor {
      displayName
      avatarURL
    }
  }
  analyticsAttributes {
    key
    value
  }
}`) as unknown as TypedDocumentString<MyNotificationsQuery, MyNotificationsQueryVariables>;
export const MarkAsReadDocument = new TypedDocumentString(`
    mutation MarkAsRead($notificationIDs: [String!]!) {
  notifications {
    markNotificationsByIdsAsRead(ids: $notificationIDs)
  }
}
    `) as unknown as TypedDocumentString<MarkAsReadMutation, MarkAsReadMutationVariables>;
export const MarkAsUnreadDocument = new TypedDocumentString(`
    mutation MarkAsUnread($notificationIDs: [String!]!) {
  notifications {
    markNotificationsByIdsAsUnread(ids: $notificationIDs)
  }
}
    `) as unknown as TypedDocumentString<MarkAsUnreadMutation, MarkAsUnreadMutationVariables>;