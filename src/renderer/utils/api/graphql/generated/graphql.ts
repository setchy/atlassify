import type { DocumentTypeDecoration } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  AppStorageEntityValue: { input: any; output: any; }
  AppStoredCustomEntityFieldValue: { input: any; output: any; }
  AppStoredEntityFieldValue: { input: any; output: any; }
  BigDecimal: { input: any; output: any; }
  CardPaletteColor: { input: any; output: any; }
  CardTypeHierarchyLevelType: { input: any; output: any; }
  Date: { input: any; output: any; }
  DateTime: { input: any; output: any; }
  JSDependency: { input: any; output: any; }
  JSON: { input: any; output: any; }
  KitsuneADF: { input: any; output: any; }
  Long: { input: any; output: any; }
  MercuryJSONString: { input: any; output: any; }
  SoftwareBoardFeatureKey: { input: any; output: any; }
  SoftwareBoardPermission: { input: any; output: any; }
  SprintScopeChangeEventType: { input: any; output: any; }
  TrelloCardPosition: { input: any; output: any; }
  TrelloShortLink: { input: any; output: any; }
  URL: { input: any; output: any; }
  UUID: { input: any; output: any; }
  Upload: { input: any; output: any; }
};

export type AvpAddDashboardElementInput = {
  canvasRowId: Scalars['ID']['input'];
  dashboardAri: Scalars['ID']['input'];
  /**
   * The index in the row's elements array where the new element will be added.  Any existing elements with an index
   * greater than or equal to this index will be shifted to the right. If 0, the element will be inserted at the start of
   * the row.
   */
  insertIndex?: InputMaybe<Scalars['Int']['input']>;
};

export type AvpAddDashboardRowInput = {
  dashboardAri: Scalars['ID']['input'];
  /** The height of the row. If not specified, then the height will be medium. */
  height?: InputMaybe<AvpCanvasRowHeight>;
  /**
   * The number of empty elements/slots to include in the new row.  Maximum of 4 allowed, minimum 1.
   * If not specified, then will default to 3 elements.
   */
  numElements?: InputMaybe<Scalars['Int']['input']>;
  /** The index where the row should be added. If not specified, then the row will be added to the end of the dashboard. */
  rowIndex?: InputMaybe<Scalars['Int']['input']>;
};

export enum AvpCanvasRowHeight {
  Large = 'large',
  Medium = 'medium',
  Small = 'small',
  Xlarge = 'xlarge',
  Xsmall = 'xsmall'
}

/** Input for creating or updating the client (new viz) settings of a chart */
export type AvpChartClientSettingsInput = {
  options?: InputMaybe<Array<AvpChartSettingInput>>;
  type?: InputMaybe<Scalars['String']['input']>;
};

/** Input for creating or updating the settings or metadata of a chart */
export type AvpChartConfigInput = {
  clientSettings?: InputMaybe<AvpChartClientSettingsInput>;
  /** Data fetch strategy. Use STATIC when embedding data in vizConfig.data, DYNAMIC when data comes from external sources. */
  dataFetchStrategy?: InputMaybe<AvpDataFetchStrategy>;
  /** Chart settings used by Atlassian Analytics charts */
  settings?: InputMaybe<Array<AvpChartSettingInput>>;
  /** Visualization configuration input for charts. Used to embed chart data or configure dynamic data fetching. */
  vizConfig?: InputMaybe<AvpVizConfigInput>;
};

/** Input for creating or editing a chart */
export type AvpChartInput = {
  chartConfig?: InputMaybe<AvpChartConfigInput>;
  chartType?: InputMaybe<Scalars['String']['input']>;
  /** If chart is a control, this is the ID of the associated env var, else null. */
  envVarId?: InputMaybe<Scalars['ID']['input']>;
  /** Optional chart ID. If not provided, a new UUID will be generated. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The data pipeline that powers this chart */
  pipeline?: InputMaybe<AvpChartPipelineInput>;
  templateChartId?: InputMaybe<Scalars['String']['input']>;
};

/** Input for creating or updating a chart's data pipeline */
export type AvpChartPipelineInput = {
  /** Unique identifier for the pipeline */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Visual representation of the pipeline flow */
  nodes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** List of queries/datasets that make up the pipeline */
  queries?: InputMaybe<Array<AvpChartPipelineQueryInput>>;
};

/** Dimension configuration for queries */
export type AvpChartPipelineQueryDimensionInput = {
  /** Bucketing function (e.g., group, date_trunc) */
  bucketFunction?: InputMaybe<Scalars['String']['input']>;
  /** Database column name */
  columnName?: InputMaybe<Scalars['String']['input']>;
  /** Human-readable label */
  label: Scalars['String']['input'];
  /** Additional operands for dimension configuration */
  operands: Array<Scalars['String']['input']>;
  /** Data type of pivot column */
  pivotColumnFieldType?: InputMaybe<Scalars['String']['input']>;
  /** Pivot column name for cross-tabulation */
  pivotColumnName?: InputMaybe<Scalars['String']['input']>;
  /** Database schema name */
  schemaName?: InputMaybe<Scalars['String']['input']>;
  /** Sort direction (1 for ASC, -1 for DESC) */
  sortDir?: InputMaybe<Scalars['Int']['input']>;
  /** Database table name */
  tableName?: InputMaybe<Scalars['String']['input']>;
};

/** Filter configuration for queries (Query filter input for Atlassian Analytics and AA-embed dashboards) */
export type AvpChartPipelineQueryFilterInput = {
  /** Auto-generated environment variable ID */
  autoEnvVarId?: InputMaybe<Scalars['ID']['input']>;
  /** Whether auto env var was removed */
  autoEnvVarRemoved?: InputMaybe<Scalars['Boolean']['input']>;
  /** Database column name */
  columnName?: InputMaybe<Scalars['String']['input']>;
  /** Comparison operator (e.g., equals, not_like, in) */
  comparison: Scalars['String']['input'];
  /** Filter group number for logical grouping */
  group?: InputMaybe<Scalars['Int']['input']>;
  /** Whether this is an auto-generated filter */
  isAuto?: InputMaybe<Scalars['Boolean']['input']>;
  /** Human-readable label */
  label: Scalars['String']['input'];
  /** Values to compare against */
  operands: Array<Scalars['String']['input']>;
  /** Data type of pivot column */
  pivotColumnFieldType?: InputMaybe<Scalars['String']['input']>;
  /** Pivot column name for cross-tabulation */
  pivotColumnName?: InputMaybe<Scalars['String']['input']>;
  /** Database schema name */
  schemaName?: InputMaybe<Scalars['String']['input']>;
  /** Database table name */
  tableName?: InputMaybe<Scalars['String']['input']>;
};

/** Input for a single query/dataset in the pipeline */
export type AvpChartPipelineQueryInput = {
  /** External datasource identifier (if applicable) */
  datasourceId?: InputMaybe<Scalars['String']['input']>;
  /** Configuration for data source connection */
  datasourceLocator: AvpDatasourceLocatorInput;
  /** Query dimensions configuration */
  dimensions?: InputMaybe<Array<AvpChartPipelineQueryDimensionInput>>;
  /** Logic for combining filters */
  filterLogic?: InputMaybe<Scalars['String']['input']>;
  /** Query filters configuration */
  filters?: InputMaybe<Array<AvpChartPipelineQueryFilterInput>>;
  /** Unique identifier for the query */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Whether this query is manually defined or auto-generated */
  isManual?: InputMaybe<Scalars['Boolean']['input']>;
  /** Array of dataset joins for complex queries */
  joins?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Maximum number of rows to return */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Query measures configuration */
  measures?: InputMaybe<Array<AvpChartPipelineQueryMeasureInput>>;
  /** Metrics-based query configuration */
  metricsConfiguration?: InputMaybe<AvpMetricsConfigurationInput>;
  /** Human-readable name for the query */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Raw SQL query string */
  sql?: InputMaybe<Scalars['String']['input']>;
};

/** Measure configuration for queries */
export type AvpChartPipelineQueryMeasureInput = {
  /** Aggregation function (e.g., count, sum, avg) */
  aggregationFunction?: InputMaybe<Scalars['String']['input']>;
  /** Database column name */
  columnName?: InputMaybe<Scalars['String']['input']>;
  /** Human-readable label */
  label: Scalars['String']['input'];
  /** Data type of pivot column */
  pivotColumnFieldType?: InputMaybe<Scalars['String']['input']>;
  /** Pivot column name for cross-tabulation */
  pivotColumnName?: InputMaybe<Scalars['String']['input']>;
  /** Database schema name */
  schemaName?: InputMaybe<Scalars['String']['input']>;
  /** Sort direction (1 for ASC, -1 for DESC) */
  sortDir?: InputMaybe<Scalars['Int']['input']>;
  /** Database table name */
  tableName?: InputMaybe<Scalars['String']['input']>;
};

/** Input for creating a chart setting as a key/value pair */
export type AvpChartSettingInput = {
  /**
   * JSON representation of value object.
   * May be a simple string (in quotes), a complex object, or any other JSON value.
   */
  jsonValue?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

export type AvpClearChartsInRowInput = {
  dashboardAri: Scalars['ID']['input'];
  rowId: Scalars['ID']['input'];
};

export type AvpCloneChartInput = {
  /**
   * The ID of the canvas element slot in which to place the chart.
   * If null, then the chart will be added to the first empty element on the dashboard.
   * If there are no empty elements, then the chart will be added to a new row on the dashboard.
   */
  canvasElementId?: InputMaybe<Scalars['ID']['input']>;
  /** The ARI of the standalone chart to copy to the dashboard */
  chartAri: Scalars['ID']['input'];
  /** The ARI of the target dashboard to copy the chart to */
  dashboardAri: Scalars['ID']['input'];
};

export type AvpCopyChartInput = {
  chartAri: Scalars['ID']['input'];
};

export type AvpCopyDashboardRowInput = {
  dashboardAri: Scalars['ID']['input'];
  rowId: Scalars['ID']['input'];
};

export type AvpCreateChartInput = {
  /**
   * The ID of the canvas element slot in which to create the new chart.
   * If null, then the chart will be added to the first empty element on the dashboard.
   * If there are no empty elements, then the chart will be added to a new row on the dashboard.
   */
  canvasElementId?: InputMaybe<Scalars['ID']['input']>;
  chart: AvpChartInput;
  /** The ARI of the dashboard on which to create the new chart */
  dashboardAri: Scalars['ID']['input'];
};

export type AvpCreateDashboardFilterInput = {
  /** The ARI of the dashboard on which to create the new filter */
  dashboardAri: Scalars['ID']['input'];
  /** The filter configuration to create a dashboard-level filter */
  filter: AvpDashboardFilterInput;
};

export type AvpCreateDashboardFromTemplateInput = {
  cloudId: Scalars['ID']['input'];
  dashboard: AvpDashboardTemplateInput;
  /** The permissions configuration for the dashboard, defaults to MANAGE */
  dashboardPermissionType?: InputMaybe<AvpDashboardPermissionType>;
  workspaceId: Scalars['ID']['input'];
};

export type AvpCreateDashboardInput = {
  cloudId: Scalars['ID']['input'];
  /**  the container where the dashboard lives, e.g. a Jira project.  Currently only Jira project ARIs are supported. */
  containerAri?: InputMaybe<Scalars['ID']['input']>;
  dashboard: AvpDashboardInput;
  /** The permissions configuration for the dashboard, defaults to MANAGE */
  dashboardPermissionType?: InputMaybe<AvpDashboardPermissionType>;
  /**  identifier of the AVP consumer which owns the dashboard, e.g. for limiting the dashboard list to relevant dashboards. */
  integrationId?: InputMaybe<AvpIntegrationId>;
  workspaceId: Scalars['ID']['input'];
};

export type AvpCreateStandaloneChartInput = {
  chart: AvpChartInput;
  cloudId: Scalars['ID']['input'];
  /** The container where the dashboard wrapper lives, e.g. a Jira project. Currently only Jira project ARIs are supported. */
  containerAri?: InputMaybe<Scalars['ID']['input']>;
  /** Identifier of the AVP consumer which owns the dashboard wrapper, e.g. for limiting the dashboard list to relevant dashboards. */
  integrationId?: InputMaybe<AvpIntegrationId>;
  /** The workspace ID (activation ID). If not provided, defaults to the Rovo activation ID for the given cloudId. */
  workspaceId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * Configuration for creating a dashboard-level variable. Unlike a filter, the env var representing
 * the variable does not have its own chart.
 * When a variable is created, no charts are auto-updated with the value; we currently only support
 * BYOD platform which requires external handling of connecting the variable to charts.
 */
export type AvpCreateVariableInput = {
  /** The ARI of the dashboard which should have the new variable */
  dashboardAri: Scalars['ID']['input'];
  /** The data configuration to create a dashboard-level variable */
  variable: AvpVariableInput;
};

/** Filter configuration for creating a dashboard-level filter, made up of an env var and a chart */
export type AvpDashboardFilterInput = {
  /** The type of filter to create; must be one of the values in EnvVarChartType */
  chartType?: InputMaybe<Scalars['String']['input']>;
  /** The default values of the filter */
  defaultValues?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A single object that contains the Hot Tier product context (e.g., jira, devops); this data will be stored in an array on the EnvVar */
  hotTierFilterConfig?: InputMaybe<AvpHotTierFilterConfigInput>;
  /** Filter metadata as a JSON string, used by BYOD filters. */
  metadata?: InputMaybe<Scalars['String']['input']>;
  /** The name of the filter, unique within the dashboard */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type AvpDashboardInput = {
  category?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  settings?: InputMaybe<AvpDashboardSettingsInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export enum AvpDashboardPermissionType {
  /** Only specific users can view and edit the dashboard (those granted individual access) */
  Closed = 'CLOSED',
  /** Anyone can view and edit the dashboard */
  Manage = 'MANAGE',
  /** Anyone can view the dashboard, but only some can edit (those granted individual access) */
  Read = 'READ'
}

export type AvpDashboardSettingsInput = {
  /** If true, convert dates and times to viewer's local time zone */
  allowTzOverride?: InputMaybe<Scalars['Boolean']['input']>;
  /** If true, show UI elements allowing the user to refresh one or more charts */
  allowViewerRefresh?: InputMaybe<Scalars['Boolean']['input']>;
  /** If true, automatically update dashboard when a control's value changes */
  autoApplyVars?: InputMaybe<Scalars['Boolean']['input']>;
  /** Chart data refresh interval, in seconds */
  autoRefreshInterval?: InputMaybe<Scalars['Int']['input']>;
  /** How long dashboard data should be considered up to date, in seconds */
  cacheDuration?: InputMaybe<Scalars['Int']['input']>;
  /** Method of refreshing dashboard data automatically */
  refreshMethod?: InputMaybe<AvpRefreshMethod>;
  /** If true, users can create email subscriptions for this dashboard */
  subscriptionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The configured timezone of the dashboard */
  timezone?: InputMaybe<Scalars['String']['input']>;
};

export enum AvpDashboardStatus {
  Active = 'ACTIVE',
  Archived = 'ARCHIVED',
  Trashed = 'TRASHED'
}

export enum AvpDashboardStatusAction {
  Archive = 'ARCHIVE',
  Restore = 'RESTORE',
  Trash = 'TRASH'
}

export type AvpDashboardTemplateInput = {
  /**  the container where the dashboard lives, e.g. a Jira project.  Currently only Jira project ARIs are supported. */
  containerAri?: InputMaybe<Scalars['ID']['input']>;
  fromTemplate: Scalars['String']['input'];
  /**  identifier of the AVP consumer which owns the dashboard, e.g. for limiting the dashboard list to relevant dashboards. */
  integrationId?: InputMaybe<AvpIntegrationId>;
  productWorkspaceList?: InputMaybe<Array<AvpProductWorkspaceMapEntry>>;
  /**  template placeholder replacements mapping placeholder names to their replacement values (ARIs) */
  templatePlaceholderReplacements?: InputMaybe<Array<AvpTemplatePlaceholderReplacement>>;
  templateVersion?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * Data fetch strategy for chart visualization.
 * Determines whether chart data is embedded in the chart configuration or fetched dynamically at runtime.
 */
export enum AvpDataFetchStrategy {
  /** Data is fetched dynamically from an external source (e.g., data pipeline) at runtime. The vizConfig.data field is not used. */
  Dynamic = 'DYNAMIC',
  /** Data is embedded in the chart configuration (vizConfig.data). The data array must be provided and will be validated based on the accessor type. */
  Static = 'STATIC'
}

/** Data source locator configuration */
export type AvpDatasourceLocatorInput = {
  datasourceId?: InputMaybe<Scalars['String']['input']>;
  /** Type of data source (e.g., HotTier) */
  dstype: Scalars['String']['input'];
  /** Workspace identifier */
  workspaceId: Scalars['String']['input'];
};

export type AvpDeleteChartInput = {
  /** The ARI of the chart to delete */
  chartAri: Scalars['ID']['input'];
};

/** Filter configuration for deleting a dashboard-level filter */
export type AvpDeleteDashboardFilterInput = {
  /** The ARI of the dashboard on which to delete the filter */
  dashboardAri: Scalars['ID']['input'];
  /** The name of the filter to delete, unique within the dashboard */
  name: Scalars['String']['input'];
};

/** Input for deleting a dashboard-level variable. */
export type AvpDeleteVariableInput = {
  /** The ARI of the dashboard on which to delete the variable */
  dashboardAri: Scalars['ID']['input'];
  /** The name of the variable to delete, unique within the dashboard */
  name: Scalars['String']['input'];
};

export enum AvpEnvVarDataType {
  Boolean = 'BOOLEAN',
  Date = 'DATE',
  Datetime = 'DATETIME',
  DateRange = 'DATE_RANGE',
  Number = 'NUMBER',
  NumberRange = 'NUMBER_RANGE',
  Text = 'TEXT'
}

export type AvpFilterEnvVarInput = {
  /** The default values (optional - only include if updating) */
  defaultValues?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** The ID of the env var (optional - can use name for identification instead) */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Filter metadata as a JSON string (optional - only include if updating) */
  metadata?: InputMaybe<Scalars['String']['input']>;
  /** The name of the env var (required for identification if ID not provided) */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type AvpGetDashboardTemplatesInput = {
  cloudId: Scalars['ID']['input'];
  /**  optional filter to only return templates for a specific product, e.g. "jira", "confluence" */
  productKey?: InputMaybe<Scalars['String']['input']>;
  workspaceId: Scalars['ID']['input'];
};

/** The Hot Tier product context (e.g., jira, devops) to represent the filter data source; data will be stored in an array on the EnvVar */
export type AvpHotTierFilterConfigInput = {
  datasourceLocator?: InputMaybe<AvpDatasourceLocatorInput>;
  dimension?: InputMaybe<Scalars['String']['input']>;
  product?: InputMaybe<Scalars['String']['input']>;
  semanticModel?: InputMaybe<Scalars['String']['input']>;
};

export enum AvpIntegrationId {
  JiraSummaryPage = 'JIRA_SUMMARY_PAGE',
  JsmAssets = 'JSM_ASSETS',
  JsmSummaryPage = 'JSM_SUMMARY_PAGE',
  Townsquare = 'TOWNSQUARE'
}

/** Dimension configuration for metrics */
export type AvpMetricsConfigurationDimensionInput = {
  /** Name of the dimension */
  name: Scalars['String']['input'];
  /** Type of dimension (e.g., categorical, temporal) */
  type: Scalars['String']['input'];
};

/** Filter configuration for metrics */
export type AvpMetricsConfigurationFilterInput = {
  /** Comparison operator */
  comparison: Scalars['String']['input'];
  /** Dimension to filter on */
  dimension: Scalars['String']['input'];
  /** Values to filter by */
  operands: Array<Scalars['String']['input']>;
  /** Product context (e.g., jira, devops) */
  product: Scalars['String']['input'];
};

/** Metrics-based query configuration */
export type AvpMetricsConfigurationInput = {
  /** Metric dimensions configuration */
  dimensions?: InputMaybe<Array<AvpMetricsConfigurationDimensionInput>>;
  /** Metric filters configuration */
  filters?: InputMaybe<Array<AvpMetricsConfigurationFilterInput>>;
  /** Granularity for time-based metrics */
  granularity?: InputMaybe<Scalars['String']['input']>;
  /** List of metrics to query */
  metrics?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search conditions for metrics */
  searchCondition?: InputMaybe<Scalars['String']['input']>;
  /** Workspace ID for metrics context */
  workspaceId?: InputMaybe<Scalars['String']['input']>;
};

export type AvpMoveCanvasElementInput = {
  dashboardAri: Scalars['ID']['input'];
  sourceElementId: Scalars['ID']['input'];
  sourceRowId: Scalars['ID']['input'];
  targetElementIndex: Scalars['Int']['input'];
  targetRowId: Scalars['ID']['input'];
};

export type AvpMoveCanvasElementToNewRowInput = {
  dashboardAri: Scalars['ID']['input'];
  sourceElementId: Scalars['ID']['input'];
  sourceRowId: Scalars['ID']['input'];
  targetRowIndex: Scalars['Int']['input'];
};

export type AvpMoveDashboardRowInput = {
  dashboardAri: Scalars['ID']['input'];
  sourceRowId: Scalars['ID']['input'];
  targetRowIndex: Scalars['Int']['input'];
};

export type AvpProductWorkspaceMapEntry = {
  product: Scalars['String']['input'];
  workspaceId: Scalars['ID']['input'];
};

export enum AvpRefreshMethod {
  /** Refresh chart data periodically */
  RefreshAuto = 'REFRESH_AUTO',
  /** Refreshes chart data when dashboard is first opened in a tab */
  RefreshLoad = 'REFRESH_LOAD',
  /** Only refresh chart data manually */
  RefreshManual = 'REFRESH_MANUAL',
  /** Refreshes chart data periodically, when dashboard is open in the active tab */
  RefreshSmart = 'REFRESH_SMART'
}

export type AvpRemoveDashboardElementInput = {
  canvasElementId: Scalars['ID']['input'];
  dashboardAri: Scalars['ID']['input'];
};

export type AvpRemoveDashboardRowInput = {
  dashboardAri: Scalars['ID']['input'];
  rowId: Scalars['ID']['input'];
};

export type AvpTemplatePlaceholderReplacement = {
  placeholderName: Scalars['String']['input'];
  replacementValue: Scalars['String']['input'];
};

export type AvpToggleCanvasElementExpandedInput = {
  dashboardAri: Scalars['ID']['input'];
  elementId: Scalars['ID']['input'];
};

export type AvpUpdateChartInput = {
  chart: AvpChartInput;
  /** the ARI of the chart to update */
  chartAri: Scalars['ID']['input'];
};

/**
 * Filter configuration for updating a dashboard-level filter. Currently only supports updating
 * the env var fields default values and metadata, and does not update any data for connected charts.
 */
export type AvpUpdateDashboardFilterInput = {
  /** The ARI of the dashboard which has the filter to update */
  dashboardAri: Scalars['ID']['input'];
  /** The filter configuration to update a dashboard-level filter */
  envVar: AvpFilterEnvVarInput;
};

export type AvpUpdateDashboardInput = {
  dashboard: AvpDashboardInput;
  dashboardAri: Scalars['ID']['input'];
};

export type AvpUpdateDashboardResourcePermissionInput = {
  dashboardId: Scalars['ID']['input'];
  permissionType: AvpDashboardPermissionType;
};

export type AvpUpdateDashboardRowHeightInput = {
  dashboardAri: Scalars['ID']['input'];
  height: AvpCanvasRowHeight;
  rowId: Scalars['ID']['input'];
};

export type AvpUpdateDashboardRowNumElementsInput = {
  dashboardAri: Scalars['ID']['input'];
  numElements: Scalars['Int']['input'];
  rowId: Scalars['ID']['input'];
};

export type AvpUpdateDashboardStatusInput = {
  action: AvpDashboardStatusAction;
  dashboardAris: Array<Scalars['ID']['input']>;
};

/**
 * Filter configuration for updating a dashboard-level variable. Currently only supports updating
 * the env var fields default values and metadata, and does not update any data for connected charts.
 */
export type AvpUpdateVariableInput = {
  /** The ARI of the dashboard which has the variable to update */
  dashboardAri: Scalars['ID']['input'];
  /** The variable configuration to update a dashboard-level variable */
  envVar: AvpVariableEnvVarInput;
};

export type AvpVariableEnvVarInput = {
  /** The default values (optional - only include if updating) */
  defaultValues?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Variable metadata as a JSON string (optional - only include if updating) */
  metadata?: InputMaybe<Scalars['String']['input']>;
  /** The name of the env var (required for identification until we support using ID) */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type AvpVariableInput = {
  /** The data type of the variable (Optional; defaults to TEXT if not provided) */
  dataType?: InputMaybe<AvpEnvVarDataType>;
  /** The default values of the variable; supports both single values and lists */
  defaultValues?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A single object that contains the Hot Tier product context (e.g., jira, devops); this data will be stored in an array on the EnvVar */
  hotTierFilterConfig?: InputMaybe<AvpHotTierFilterConfigInput>;
  /** The metadata of the variable */
  metadata?: InputMaybe<Scalars['String']['input']>;
  /** The name of the variable */
  name: Scalars['String']['input'];
};

/**
 * Input for visualization configuration of charts.
 * Validated against ChartSchema (anyOf by type from chartType).
 */
export type AvpVizConfigInput = {
  /** Accessors object (e.g. x, y, color for XY; label, value, color for circular). Values are AccessorInput as JSON (string, number, or object with key/timeUnit). */
  accessors?: InputMaybe<Scalars['JSON']['input']>;
  /** 2D array of chart data. */
  data: Array<Array<InputMaybe<Scalars['JSON']['input']>>>;
};

export enum AcceptableResponse {
  False = 'FALSE',
  NotApplicable = 'NOT_APPLICABLE',
  True = 'TRUE'
}

export enum AccessStatus {
  AnonymousAccess = 'ANONYMOUS_ACCESS',
  ExternalCollaboratorAccess = 'EXTERNAL_COLLABORATOR_ACCESS',
  ExternalShareAccess = 'EXTERNAL_SHARE_ACCESS',
  LicensedAdminAccess = 'LICENSED_ADMIN_ACCESS',
  LicensedUseAccess = 'LICENSED_USE_ACCESS',
  NotPermitted = 'NOT_PERMITTED',
  UnlicensedAuthenticatedAccess = 'UNLICENSED_AUTHENTICATED_ACCESS'
}

export enum AccessType {
  Edit = 'EDIT',
  View = 'VIEW'
}

/**
 * "
 * The lifecycle status of the account
 */
export enum AccountStatus {
  /** The account is an active account */
  Active = 'active',
  /** The account has been closed */
  Closed = 'closed',
  /** The account is no longer an active account */
  Inactive = 'inactive'
}

export enum AccountType {
  App = 'APP',
  Atlassian = 'ATLASSIAN',
  Customer = 'CUSTOMER',
  Unknown = 'UNKNOWN'
}

export type ActionsActionableAppsFilter = {
  /** Only an action that match this actionAri will be returned. Will be overwritten by actionId if provided. */
  byActionAri?: InputMaybe<Scalars['String']['input']>;
  /** Only an action that match this actionId will be returned. Will overwrite actionAri if provided. */
  byActionId?: InputMaybe<Scalars['String']['input']>;
  /** Types of actions to be returned. Any action that matches types in this list will be returned. */
  byActionType?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions for the given actionVerb will be returned. */
  byActionVerb?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only an action that match this actionVersion will be returned */
  byActionVersion?: InputMaybe<Scalars['String']['input']>;
  /** Only actions within apps that contain all provided scopes will be returned */
  byCaasScopes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions with the given capability will be returned. */
  byCapability?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions with the context entity will be returned. */
  byContextEntityType?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions acting on the entity property will be returned. */
  byEntityProperty?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions for the given entity types will be returned. */
  byEntityType?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions for the given forge environment ID will be returned. Actions without an extension ARI will not be returned */
  byEnvironmentId?: InputMaybe<Scalars['String']['input']>;
  /** Only actions for the given extensionAri will be returned. */
  byExtensionAri?: InputMaybe<Scalars['String']['input']>;
  /** Only actions for the specified integrations will be returned. */
  byIntegrationKey?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only actions for the given providers will be returned. */
  byProviderID?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum ActionsAuthType {
  /** actions that support THREE_LEGGED authentication can be executed with a user in context */
  ThreeLegged = 'THREE_LEGGED',
  /** actions that support TWO_LEGGED authentication can be executed without user in context */
  TwoLegged = 'TWO_LEGGED'
}

export enum ActionsCapabilityType {
  /** Actions Enabled for Agent Studio */
  AgentStudio = 'AGENT_STUDIO',
  /** Actions Enabled for AI */
  Ai = 'AI',
  /** Actions Enabled for Automation */
  Automation = 'AUTOMATION'
}

export enum ActionsConfigurationLayout {
  VerticalLayout = 'VerticalLayout'
}

export type ActionsExecuteActionFilter = {
  /** Only execute actions for given actionAri. Do not provide actionId if using actionAri */
  actionAri?: InputMaybe<Scalars['String']['input']>;
  /** Only execute actions for given actionId. Do not provide actionAri if using actionId. */
  actionId?: InputMaybe<Scalars['String']['input']>;
  /** Only execute actions for a given auth type */
  authType?: InputMaybe<Array<InputMaybe<ActionsAuthType>>>;
  /** Only execute action that matches the given ari */
  extensionAri?: InputMaybe<Scalars['String']['input']>;
  /** Only execute actions for the given first-party integration */
  integrationKey?: InputMaybe<Scalars['String']['input']>;
  /** Only execute actions for the given clients */
  oauthClientId?: InputMaybe<Scalars['String']['input']>;
  /** Only execute actions for the given providers */
  providerAri?: InputMaybe<Scalars['String']['input']>;
  /** Only execute actions for the given providerId */
  providerId?: InputMaybe<Scalars['String']['input']>;
};

export type ActionsExecuteActionInput = {
  /** Cloud ID of the site to execute action on */
  cloudId?: InputMaybe<Scalars['String']['input']>;
  /** Inputs required to execute the action */
  inputs?: InputMaybe<Scalars['JSON']['input']>;
  /** Target inputs required to identify the resource */
  target?: InputMaybe<ActionsExecuteTargetInput>;
};

export type ActionsExecuteTargetInput = {
  ari?: InputMaybe<Scalars['String']['input']>;
  ids?: InputMaybe<Scalars['JSON']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type ActivatePaywallContentInput = {
  contentIdToActivate: Scalars['ID']['input'];
  deactivationIdentifier?: InputMaybe<Scalars['String']['input']>;
};

export type ActivitiesArguments = {
  /** set of Atlassian account IDs */
  accountIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** set of Cloud IDs */
  cloudIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** set of Container IDs */
  containerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The creation time of the earliest events to be included in the result */
  earliestStart?: InputMaybe<Scalars['String']['input']>;
  /** set of Event Types */
  eventTypes?: InputMaybe<Array<ActivityEventType>>;
  /** The creation time of the latest events to be included in the result */
  latestStart?: InputMaybe<Scalars['String']['input']>;
  /** set of Object Types */
  objectTypes?: InputMaybe<Array<ActivitiesObjectType>>;
  /** set of products */
  products?: InputMaybe<Array<ActivityProduct>>;
  /** arbitrary transition filters */
  transitions?: InputMaybe<Array<ActivityTransition>>;
};

export enum ActivitiesContainerType {
  Project = 'PROJECT',
  Site = 'SITE',
  Space = 'SPACE',
  Workspace = 'WORKSPACE'
}

export type ActivitiesFilter = {
  arguments?: InputMaybe<ActivitiesArguments>;
  /** Defines relationship in-between filter arguments (AND/OR) */
  type?: InputMaybe<ActivitiesFilterType>;
};

export enum ActivitiesFilterType {
  And = 'AND',
  Or = 'OR'
}

export enum ActivitiesObjectType {
  Blogpost = 'BLOGPOST',
  Database = 'DATABASE',
  Embed = 'EMBED',
  Goal = 'GOAL',
  Issue = 'ISSUE',
  Page = 'PAGE',
  /** Refers to a townsquare project (not to be confused with a jira project) */
  Project = 'PROJECT',
  Whiteboard = 'WHITEBOARD'
}

export enum ActivityEventType {
  Assigned = 'ASSIGNED',
  Commented = 'COMMENTED',
  Created = 'CREATED',
  Edited = 'EDITED',
  Liked = 'LIKED',
  Published = 'PUBLISHED',
  Transitioned = 'TRANSITIONED',
  Unassigned = 'UNASSIGNED',
  Updated = 'UPDATED',
  Viewed = 'VIEWED'
}

export type ActivityFilter = {
  /** Set of actor ARIs whose activity should be searched. A maximum of 5 values may be provided. (ex: AAIDs) */
  actors?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** These are always AND-ed with accountIds */
  arguments?: InputMaybe<ActivityFilterArgs>;
  /** set of top-level container ARIs (ex: Cloud ID, workspace ID) */
  rootContainerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Defines relationship between the filter arguments. Default: AND */
  type?: InputMaybe<ActivitiesFilterType>;
};

export type ActivityFilterArgs = {
  /** set of Container IDs (ex: Jira project ID, Space ID, etc) */
  containerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * set of Event Types ex:
   * assigned
   * unassigned
   * viewed
   * updated
   * created
   * liked
   * transitioned
   * published
   * edited
   */
  eventTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * set of Object Types (derived from the AVI) ex:
   * issue
   * page
   * blogpost
   * whiteboard
   * database
   * embed
   * project (townsquare)
   * goal
   */
  objectTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * set of products (derived from the AVI) ex:
   * jira
   * confluence
   * townsquare
   */
  products?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum ActivityObjectType {
  Blogpost = 'BLOGPOST',
  Comment = 'COMMENT',
  Database = 'DATABASE',
  Embed = 'EMBED',
  Goal = 'GOAL',
  Issue = 'ISSUE',
  Page = 'PAGE',
  Project = 'PROJECT',
  Site = 'SITE',
  Space = 'SPACE',
  Task = 'TASK',
  Whiteboard = 'WHITEBOARD'
}

export enum ActivityProduct {
  Confluence = 'CONFLUENCE',
  Jira = 'JIRA',
  JiraBusiness = 'JIRA_BUSINESS',
  JiraOps = 'JIRA_OPS',
  JiraServiceDesk = 'JIRA_SERVICE_DESK',
  JiraSoftware = 'JIRA_SOFTWARE',
  Townsquare = 'TOWNSQUARE'
}

/**
 *  Represents arbitrary transition,
 *  e.g. in case of TRANSITIONED event type it could be `from: "inprogress" to: "done"`.
 */
export type ActivityTransition = {
  from?: InputMaybe<Scalars['String']['input']>;
  to?: InputMaybe<Scalars['String']['input']>;
};

export type AddAppContributorInput = {
  appId: Scalars['ID']['input'];
  newContributorEmail: Scalars['String']['input'];
  role: AppContributorRole;
};

export type AddBetaUserAsSiteCreatorInput = {
  cloudID: Scalars['String']['input'];
};

/** Accepts input for adding labels to a component. */
export type AddCompassComponentLabelsInput = {
  /** The ID of the component to add the labels to. */
  componentId: Scalars['ID']['input'];
  /** The collection of labels to add to the component. */
  labelNames: Array<Scalars['String']['input']>;
};

export type AddDefaultExCoSpacePermissionsInput = {
  accountIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  groupIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  groupNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  spaceKeys: Array<InputMaybe<Scalars['String']['input']>>;
};

export type AddLabelsInput = {
  contentId: Scalars['ID']['input'];
  labels: Array<LabelInput>;
};

export type AddMultipleAppContributorInput = {
  appId: Scalars['ID']['input'];
  newContributorEmails: Array<Scalars['String']['input']>;
  roles: Array<AppContributorRole>;
};

export type AddPublicLinkPermissionsInput = {
  objectId: Scalars['ID']['input'];
  objectType: PublicLinkPermissionsObjectType;
  permissions: Array<PublicLinkPermissionsType>;
};

export enum AdminAnnouncementBannerSettingsByCriteriaOrder {
  Default = 'DEFAULT',
  ScheduledEndDate = 'SCHEDULED_END_DATE',
  ScheduledStartDate = 'SCHEDULED_START_DATE',
  Visibility = 'VISIBILITY'
}

/** Filter for Apps */
export type AdminAppFilter = {
  parentId?: InputMaybe<Scalars['String']['input']>;
  parentType?: InputMaybe<AdminAppParentType>;
};

/** The type of an apps parent */
export enum AdminAppParentType {
  /**  Sited apps */
  Site = 'SITE',
  /**  Siteless apps */
  Unit = 'UNIT'
}

export enum AdminAppType {
  Atlassian = 'ATLASSIAN',
  MarketplaceApp = 'MARKETPLACE_APP'
}

/** Assign role. */
export type AdminAssignRoleInput = {
  principalId: Scalars['String']['input'];
  resourceId: Scalars['String']['input'];
  roleId: Scalars['String']['input'];
};

/** Type of authentication policy. */
export enum AdminAuthenticationPolicyType {
  Basic = 'BASIC',
  Standard = 'STANDARD'
}

/** Recursively construct queries. */
export type AdminCompound = {
  /** When compound are specified, continue to construct until only contains single types. */
  compound?: InputMaybe<Array<AdminCompound>>;
  operation: AdminOperation;
  /** When singles are specified, no more recursion. */
  single?: InputMaybe<Array<AdminSingle>>;
};

export type AdminDateFilterInput = {
  /**
   * Timestamp in ISO 8601 format to specify the start of an absolute date range.
   * absoluteFrom and/or absoluteTo is required for: searchType=BETWEEN_ABSOLUTE
   */
  absoluteFrom?: InputMaybe<Scalars['DateTime']['input']>;
  /**
   * Timestamp in ISO 8601 format to specify the end of an absolute date range.
   * absoluteFrom and/or absoluteTo is required for: searchType=BETWEEN_ABSOLUTE
   */
  absoluteTo?: InputMaybe<Scalars['DateTime']['input']>;
  /**
   * Specifies the relative start time from now for relative date ranges. Ex if timeUnit was DAYS: -5 would be for 5 days ago.
   * relativeFrom and/or relativeTo is required for: searchType=BETWEEN_RELATIVE
   */
  relativeFrom?: InputMaybe<Scalars['Int']['input']>;
  /**
   * Specifies the relative end time from now for relative date ranges. Ex if timeUnit was DAYS: -2 would be for 2 days ago.
   * relativeFrom and/or relativeTo is required for: searchType=BETWEEN_RELATIVE
   */
  relativeTo?: InputMaybe<Scalars['Int']['input']>;
  /** Required type of time-based search to perform */
  searchType: AdminTimeSearchType;
  /**
   * Unit of time for relative searches.
   * Required for: searchType=[BETWEEN_RELATIVE, GREATER_THAN, LESS_THAN]
   */
  timeUnit?: InputMaybe<AdminTimeUnit>;
  /**
   * Amount of time for relative searches. The number of units specified in timeUnit, e.g. 5 DAYS.
   * Required for: searchType=[GREATER_THAN, LESS_THAN]
   */
  value?: InputMaybe<Scalars['Int']['input']>;
};

export type AdminFieldMapping = {
  field: Scalars['String']['input'];
  path: Scalars['String']['input'];
};

export type AdminGroupStatsQueryInput = {
  /** The number of users that belong to the group. */
  includeResources?: InputMaybe<Scalars['Boolean']['input']>;
  /** The number of resources the group has roles assigned to, linked to the directories the requestor can manage. */
  includeUsers?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum AdminHttpVerbs {
  Delete = 'DELETE'
}

/** Status of identity provider SAML certificate expiration. Indicates whether the SAML configuration certificate is valid, expiring soon, or has expired. */
export enum AdminIdentityProviderPublicCertificateExpiryStatus {
  Expired = 'EXPIRED',
  ExpiringSoon = 'EXPIRING_SOON',
  Valid = 'VALID'
}

/** Type of identity provider configured for a directory. */
export enum AdminIdentityProviderType {
  ActiveDirectoryFederationServices = 'ACTIVE_DIRECTORY_FEDERATION_SERVICES',
  Auth0 = 'AUTH0',
  GoogleCloudIdentity = 'GOOGLE_CLOUD_IDENTITY',
  GoogleWorkspace = 'GOOGLE_WORKSPACE',
  Idaptive = 'IDAPTIVE',
  Jumpcloud = 'JUMPCLOUD',
  MicrosoftAzureActiveDirectory = 'MICROSOFT_AZURE_ACTIVE_DIRECTORY',
  MicrosoftAzureActiveDirectoryPreconfigured = 'MICROSOFT_AZURE_ACTIVE_DIRECTORY_PRECONFIGURED',
  Okta = 'OKTA',
  Onelogin = 'ONELOGIN',
  Other = 'OTHER',
  PingIdentity = 'PING_IDENTITY'
}

export type AdminInviteGroupInput = {
  id: Scalars['ID']['input'];
};

/**  --------------------------------------------------------------------------------------------- */
export type AdminInviteInput = {
  groupIds?: InputMaybe<Array<Scalars['String']['input']>>;
  inviteeNotificationSettings?: InputMaybe<AdminInviteeNotificationSettingsInput>;
  resourceRole?: InputMaybe<Array<AdminResourceRoleInput>>;
  users: Array<AdminInviteUserInput>;
};

export type AdminInviteUserInput = {
  email: Scalars['String']['input'];
};

export type AdminInviteeNotificationSettingsInput = {
  /**
   * Only applicable if notification is not suppressed.
   * If not specified, a default message will be sent.
   */
  message?: InputMaybe<Scalars['String']['input']>;
  /**
   * If suppress, a notification will not be sent to invitee.
   * Default is not suppressed.
   */
  suppress?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AdminLicenseGroupInput = {
  /**
   * Group ARI
   * ex: [ari:cloud:identity::group/1234-5678-9012]
   */
  groupId: Scalars['String']['input'];
  /**
   * List of Resource ARIs under the Group
   * ex: [ari:cloud:confluence::site/1234-5678-9012]
   */
  resourceIds: Array<Scalars['String']['input']>;
};

/**  --------------------------------------------------------------------------------------------- */
export type AdminLicenseInput = {
  /** List of pair of Group ARI and Resource ARIs under the Group */
  groups?: InputMaybe<Array<AdminLicenseGroupInput>>;
  /** List of Resource ARIs */
  resources?: InputMaybe<Array<AdminLicenseResourceInput>>;
};

export type AdminLicenseResourceInput = {
  /**
   * Resource ARI
   * ex: ari:cloud:confluence::site/1234-5678-9012
   */
  resourceId: Scalars['String']['input'];
};

/** Supported operations. */
export enum AdminOperation {
  And = 'AND',
  Nor = 'NOR'
}

export type AdminPrimitive = {
  field?: InputMaybe<AdminQueryableField>;
};

export type AdminQueryableField = {
  /** name can be policies/features/searchWorkspaces */
  name: Scalars['String']['input'];
  values: Array<Scalars['String']['input']>;
};

export type AdminResourceRoleInput = {
  /**
   * Unique identifier of the resource.
   * Example format: ari:cloud:bitbucket::workspace/6a09c9d3-8681-495c-9f7d-69232d220331
   */
  resourceId: Scalars['ID']['input'];
  /**
   * Unique identifier of the role.
   * Example format: atlassian/user
   */
  roleId: Scalars['ID']['input'];
};

/** Search for groups in an organization. */
export type AdminSearchGroupInput = {
  /**
   * A list of user account IDs.
   * Limits the groups to only the ones that the users in the list belong to.
   *
   * Min items: 1
   * Max items: 10
   */
  accountIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * A list of directory IDs.
   * The requester must have permissions to administer resources linked to these directories.
   *
   * Min items: 1
   * Max items: 10
   */
  directoryIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * A list of group IDs.
   *
   * Min items: 1
   * Max items: 10
   */
  groupIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Whether to include counts of different objects associated with the group. */
  groupStatsQueryInput?: InputMaybe<AdminGroupStatsQueryInput>;
  /**
   * A list of resource IDs. The resource IDs should be specified using the Atlassian Resource Identifier (ARI) format. Example ARI: ari:cloud:jira-core::site/1
   *
   * Min items: 1
   * Max items: 10
   */
  resourceIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * The list of resource owners to filter the results by. Used to identify resources using their owner to which the user has at least one role assigned to.
   *
   * Min items: 1
   * Max items: 10
   */
  resourceOwners?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * A list of role IDs. The Atlassian canonical roles are used to determine the permissions of the user against resources within the organization.
   *
   * Min items: 1
   * Max items: 10
   */
  roleIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A search term to search the name field. */
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  /**
   * The field and direction to sort the results by. Currently, only a single field can be sorted by.
   * If null, the default sorting will be used.
   *
   * Min items: 1
   * Max items: 1
   */
  sortBy?: InputMaybe<Array<AdminSortBy>>;
};

export type AdminSearchUserInput = {
  /**
   * A list of user account IDs.
   * Min items: 1
   * Max items: 10
   */
  accountIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * The lifecycle status of the account.
   * Min items: 1
   * Max items: 3
   */
  accountStatus?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * The claim status for the user account.
   * By default, both managed and unmanaged accounts are returned.
   */
  claimStatus?: InputMaybe<Scalars['String']['input']>;
  /**
   * A list of directory IDs.
   * The requestor must have permissions to administer resources linked to these directories.
   */
  directoryIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * A list of email domains. Ex: @example.com
   * Can input the domains with or without the @ symbol
   * Min items: 1
   * Max items: 10
   */
  emailDomains?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * A list of group IDs.
   * Min items: 1
   * Max items: 10
   */
  groupIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * A list of membership statuses.
   * Min items: 1
   * Max items: 3
   */
  membershipStatus?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * A list of resource IDs.
   * The resource IDs should be specified using the Atlassian Resource Identifier (ARI) format.
   * Min items: 1
   * Max items: 10
   */
  resourceIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of role IDs. */
  roleIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A search term to search the nickname and email fields. */
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<Array<AdminSortBy>>;
  /** A list of user account statuses. */
  status?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**  --------------------------------------------------------------------------------------------- */
export type AdminSearchWorkspacesInput = {
  attributes?: InputMaybe<AdminSearchWorkspacesInputAttributes>;
  query?: InputMaybe<Array<AdminCompound>>;
  sort?: InputMaybe<Array<AdminSortBy>>;
};

export type AdminSearchWorkspacesInputAttributes = {
  /** List of bundle ids to filter workspaces by. */
  bundleIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * A list of directory IDs to filter the workspaces by.
   * If provided, only workspaces linked to these directories will be returned.
   */
  directoryIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List of plans to filter workspaces by. */
  plans?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Single query elements. */
export type AdminSingle = {
  /** Supports query by queryable fields. */
  primitive?: InputMaybe<AdminPrimitive>;
};

/** Sort by fields commonly used for search inputs. */
export type AdminSortBy = {
  /** Sort order. */
  direction: SortDirection;
  /** Name of the sort by field. */
  fieldName: Scalars['String']['input'];
};

/** Type of Single Sign-On configured for an authentication policy. */
export enum AdminSsoType {
  Google = 'GOOGLE',
  None = 'NONE',
  Saml = 'SAML'
}

/** Type of search to perform, can use with time-based filters. */
export enum AdminTimeSearchType {
  BetweenAbsolute = 'BETWEEN_ABSOLUTE',
  BetweenRelative = 'BETWEEN_RELATIVE',
  GreaterThan = 'GREATER_THAN',
  LessThan = 'LESS_THAN'
}

/** Unit of time */
export enum AdminTimeUnit {
  Day = 'DAY',
  Hour = 'HOUR',
  Minute = 'MINUTE',
  Week = 'WEEK'
}

export type AdminTokenFilters = {
  /** Filter based on token creation time */
  createdAt?: InputMaybe<AdminDateFilterInput>;
  /** Filter based on token expiration time */
  expiresAt?: InputMaybe<AdminDateFilterInput>;
  /** Filter to include revoked tokens in the results. */
  includeRevoked?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter based on token last active time */
  lastActiveAt?: InputMaybe<AdminDateFilterInput>;
  /** Filter for the IDs of the token owners */
  ownerAccountIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A full text search query to filter tokens by name or owner name/email. */
  query?: InputMaybe<Scalars['String']['input']>;
  /** Filter for the token status */
  status?: InputMaybe<AdminTokenStatus>;
};

export enum AdminTokenStatus {
  /** Status indicating that the token is allowed to be used. */
  Allowed = 'ALLOWED',
  /** Status indicating that the token has been deactivated or blocked and can no longer be used. */
  Blocked = 'BLOCKED'
}

/** Status reported by the Admin Hub API token service. */
export enum AdminTokenType {
  /** Keys generated by organization admins in admin.atlassian.com under the API keys section, typically used for service-to-service automation. */
  AdminApiKey = 'ADMIN_API_KEY',
  /** Tokens that individual users create from their personal profile page (https://id.atlassian.com/manage-profile/security/api-tokens). */
  UserApiToken = 'USER_API_TOKEN'
}

/**  --------------------------------------------------------------------------------------------- */
export type AdminUnitCreateInput = {
  name: Scalars['String']['input'];
};

export enum AdminUnitCreateStatusEnum {
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Success = 'SUCCESS'
}

export enum AdminUnitValidateNameErrorEnum {
  NameConflict = 'NAME_CONFLICT',
  NameInvalid = 'NAME_INVALID'
}

export type AdminUnitsForOrgSearchInput = {
  /** Search by Unit name */
  name: Scalars['String']['input'];
};

export type AdminUnitsForOrgSortInput = {
  /** Sort by Unit name */
  name: SortDirection;
};

/**  --------------------------------------------------------------------------------------------- */
export type AdminUserEmailInput = {
  /** The email address of the user to fetch SCIM links for */
  email: Scalars['String']['input'];
};

export type AgentStudioActionConfigurationInput = {
  /** List of actions configured for the agent perform */
  actions?: InputMaybe<Array<AgentStudioActionInput>>;
  /** Entity version of the agent, used for optimistic locking */
  etag?: InputMaybe<Scalars['String']['input']>;
};

export type AgentStudioActionInput = {
  /** Action identifier */
  actionKey: Scalars['String']['input'];
};

export type AgentStudioActorRoleInput = {
  /** The role to assign to the actor */
  role?: InputMaybe<AgentStudioAgentRole>;
  /** ARI of the user to assign to this role */
  userARI?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * The input for filtering and searching agents.
 * Note: Boolean filters (onlyMyAgents, onlyFavouriteAgents, onlyTemplateAgents, onlyEditableAgents,
 * onlyVerifiedAgents) are mutually exclusiveonly one can be true at a time.
 */
export type AgentStudioAgentQueryInput = {
  /** Include draft agents in the results. Only admins and collaborators can see draft agents. Defaults to false. */
  includeDraftAgents?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by agent name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Filter by only agents the user is able to edit */
  onlyEditableAgents?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by only favourite agents */
  onlyFavouriteAgents?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by only my agents */
  onlyMyAgents?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by only template agents */
  onlyTemplateAgents?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by only verified agents */
  onlyVerifiedAgents?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Role assigned to an actor, can only be assigned one at a time */
export enum AgentStudioAgentRole {
  Admin = 'ADMIN',
  Collaborator = 'COLLABORATOR',
  Use = 'USE'
}

export enum AgentStudioAgentType {
  /** Rovo agent type */
  Assistant = 'ASSISTANT',
  /** Service agent type */
  ServiceAgent = 'SERVICE_AGENT'
}

/** Input for specifying agent version explicitly. If not provided, defaults to latest LIVE version. */
export type AgentStudioAgentVersionInput = {
  /** Version id to retrieve. This should only be provided if no versionType is provided */
  versionId?: InputMaybe<Scalars['ID']['input']>;
  /** Version type: LIVE or DRAFT would be the valid values */
  versionType?: InputMaybe<AgentStudioAgentVersionType>;
};

/** Version type for an agent */
export enum AgentStudioAgentVersionType {
  /** Unpublished work-in-progress version (only visible to admins and collaborators) */
  Draft = 'DRAFT',
  /** Current published version (only one per agent) */
  Live = 'LIVE',
  /** Previous published versions that have been superseded by newer ones (can be promoted to LIVE) */
  Superseded = 'SUPERSEDED'
}

/** Input type for authoring team information */
export type AgentStudioAuthoringTeamInput = {
  /** The ID of the authoring team */
  authoringTeamId?: InputMaybe<Scalars['ID']['input']>;
};

export type AgentStudioBatchEvalConversationFilterInput = {
  jobRunId?: InputMaybe<Scalars['ID']['input']>;
};

export type AgentStudioConfluenceKnowledgeFilterInput = {
  /** A list of Confluence pages ARIs */
  parentFilter?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A list of Confluence space ARIs */
  spaceFilter?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum AgentStudioConversationReportPeriod {
  Daily = 'DAILY',
  Monthly = 'MONTHLY'
}

export type AgentStudioCreateAgentInput = {
  /** Configure a list of actions for the agent perform */
  actions?: InputMaybe<AgentStudioActionConfigurationInput>;
  /** Type of the agent to create */
  agentType: AgentStudioAgentType;
  /** The authoring team for this agent */
  authoringTeam?: InputMaybe<AgentStudioAuthoringTeamInput>;
  /** UGC prompt to configure Rovo agent tone */
  behaviour?: InputMaybe<Scalars['String']['input']>;
  /** Configure conversation starters to help getting a chat going */
  conversationStarters?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Default request type id for the agent */
  defaultJiraRequestTypeId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the agent */
  description?: InputMaybe<Scalars['String']['input']>;
  /** System prompt to configure Rovo agent behaviour */
  instructions?: InputMaybe<Scalars['String']['input']>;
  /** Jira project id to be linked */
  jiraProjectId?: InputMaybe<Scalars['ID']['input']>;
  /** Configure a list of knowledge sources for the agent to utilize */
  knowledgeSources?: InputMaybe<AgentStudioKnowledgeConfigurationInput>;
  /** Name of the agent */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Scenarios mapped to the agent */
  scenarios?: InputMaybe<Array<InputMaybe<AgentStudioScenarioInput>>>;
  /** Widgets to be created and linked to this agent */
  widgets?: InputMaybe<Array<InputMaybe<AgentStudioWidgetInput>>>;
};

/** Enum defining the permission modes for creating agents in Agent Studio */
export enum AgentStudioCreateAgentPermissionMode {
  /** All users can create agents - open access */
  Everyone = 'EVERYONE',
  /** No users can create agents - only organization administrators */
  NoOne = 'NO_ONE',
  /** Only selected groups can create agents - requires explicit group assignment */
  Selected = 'SELECTED'
}

/**  Input Types (public surface) */
export type AgentStudioCreateBatchEvaluationJobInput = {
  agentId: Scalars['String']['input'];
  agentVersionId: Scalars['String']['input'];
  datasetId: Scalars['String']['input'];
  judgeConfigId: Scalars['String']['input'];
  judgeMode?: InputMaybe<AgentStudioJudgeMode>;
  name: Scalars['String']['input'];
};

export type AgentStudioCreateScenarioInput = {
  /** The actions that this scenario can use */
  actions?: InputMaybe<Array<AgentStudioActionInput>>;
  /** An ID that links this scenario to a specific container */
  containerId: Scalars['ID']['input'];
  /** Instructions that are configured for this scenario to perform */
  instructions?: InputMaybe<Scalars['String']['input']>;
  /** A description of when this scenario should be invoked */
  invocationDescription?: InputMaybe<Scalars['String']['input']>;
  /** Whether the scenario is active in the current container */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the scenario has deep research enabled in the current container */
  isDeepResearchEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the scenario is default in the current container */
  isDefault?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the scenario has web search enabled in the current container */
  isWebSearchEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of knowledge sources that this scenario can use */
  knowledgeSources?: InputMaybe<AgentStudioKnowledgeConfigurationInput>;
  /** The name given to this scenario */
  name: Scalars['String']['input'];
  /** Scenario version used to migrate actions to skills */
  scenarioVersion?: InputMaybe<Scalars['Int']['input']>;
  /** A list of tools that this scenario can use */
  tools?: InputMaybe<Array<AgentStudioToolInput>>;
};

export enum AgentStudioDatasetResolution {
  Failed = 'FAILED',
  Mixed = 'MIXED',
  Resolved = 'RESOLVED',
  Unresolved = 'UNRESOLVED'
}

/** Input for duplicating an agent */
export type AgentStudioDuplicateAgentInput = {
  /** Name for the duplicated agent. If not provided, will append '- copy' to the original name. */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type AgentStudioJiraKnowledgeFilterInput = {
  /** A list of jira project ARIs */
  projectFilter?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum AgentStudioJobRunStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  Pending = 'PENDING',
  Running = 'RUNNING',
  Timeout = 'TIMEOUT'
}

export type AgentStudioJsmKnowledgeFilterInput = {
  /** A list of jsm project ARIs */
  jsmProjectFilter?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum AgentStudioJudgeMode {
  Judgeless = 'JUDGELESS',
  ReferenceBased = 'REFERENCE_BASED',
  ReferenceFree = 'REFERENCE_FREE'
}

export enum AgentStudioJudgementDecision {
  Successful = 'SUCCESSFUL',
  Unjudged = 'UNJUDGED',
  Unsuccessful = 'UNSUCCESSFUL'
}

export type AgentStudioKnowledgeConfigurationInput = {
  /** Top level toggle to enable all knowledge sources */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Entity version of the agent, used for optimistic locking */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** A list of knowledge sources */
  sources?: InputMaybe<Array<AgentStudioKnowledgeSourceInput>>;
};

export type AgentStudioKnowledgeFiltersInput = {
  /** Specific filter applicable to confluence knowledge source only */
  confluenceFilter?: InputMaybe<AgentStudioConfluenceKnowledgeFilterInput>;
  /** Specific filter applicable to jira knowledge source only */
  jiraFilter?: InputMaybe<AgentStudioJiraKnowledgeFilterInput>;
  /** Specific filter applicable to jsm knowledge source only */
  jsmFilter?: InputMaybe<AgentStudioJsmKnowledgeFilterInput>;
  /** Specific filter applicable to slack knowledge source only */
  slackFilter?: InputMaybe<AgentStudioSlackKnowledgeFilterInput>;
};

export type AgentStudioKnowledgeSourceInput = {
  /** Enable individual knowledge source */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optional filters applicable to certain knowledge types */
  filters?: InputMaybe<AgentStudioKnowledgeFiltersInput>;
  /** The type of knowledge source */
  source: Scalars['String']['input'];
};

export enum AgentStudioMessageActionStatus {
  Cancelled = 'CANCELLED',
  Errored = 'ERRORED',
  Finished = 'FINISHED',
  None = 'NONE',
  Planned = 'PLANNED',
  Started = 'STARTED'
}

/**  Batch Evaluation Types (public surface) */
export enum AgentStudioProductType {
  Csm = 'CSM',
  RovoAgents = 'ROVO_AGENTS',
  RovoServiceAgents = 'ROVO_SERVICE_AGENTS'
}

export enum AgentStudioResolutionStatus {
  Resolved = 'RESOLVED',
  Unjudged = 'UNJUDGED',
  Unresolved = 'UNRESOLVED'
}

export type AgentStudioScenarioInput = {
  actions?: InputMaybe<Array<InputMaybe<AgentStudioActionInput>>>;
  instructions?: InputMaybe<Scalars['String']['input']>;
  invocationDescription?: InputMaybe<Scalars['String']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isDeepResearchEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isDefault?: InputMaybe<Scalars['Boolean']['input']>;
  isWebSearchEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  knowledgeSources?: InputMaybe<AgentStudioKnowledgeConfigurationInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  scenarioVersion?: InputMaybe<Scalars['Int']['input']>;
  tools?: InputMaybe<Array<AgentStudioToolInput>>;
};

export type AgentStudioScenarioValidateInput = {
  /** User-supplied identifier to correlate input and output scenarios. Not persisted. */
  clientId?: InputMaybe<Scalars['String']['input']>;
  invocationDescription: Scalars['String']['input'];
  isActive: Scalars['Boolean']['input'];
  isDeepResearchEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isDefault: Scalars['Boolean']['input'];
  isEdited?: InputMaybe<Scalars['Boolean']['input']>;
  isWebSearchEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};

export type AgentStudioScenarioValidateModeInput = {
  scenarios?: InputMaybe<Array<AgentStudioScenarioValidateInput>>;
};

export type AgentStudioSetWidgetByContainerAriInput = {
  /** The agent that would respond in the widget */
  agentAri: Scalars['ID']['input'];
  /** The type of the container in which the widget will live */
  containerType?: InputMaybe<AgentStudioWidgetContainerType>;
  /** Whether the widget is enabled or not. */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AgentStudioSlackKnowledgeFilterInput = {
  /** A list of Slack channel names. Substring supported. i.e. 'general' will match '#general' */
  containerFilter?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type AgentStudioSuggestConversationStartersInput = {
  /** Description of agent to suggest conversation starters for */
  agentDescription?: InputMaybe<Scalars['String']['input']>;
  /** Instructions of agent to suggest conversation starters for */
  agentInstructions?: InputMaybe<Scalars['String']['input']>;
  /** Name of agent to suggest conversation starters for */
  agentName?: InputMaybe<Scalars['String']['input']>;
};

export enum AgentStudioToolDefinitionSource {
  ConvoAi = 'CONVO_AI',
  Forge = 'FORGE',
  IntegrationsService = 'INTEGRATIONS_SERVICE',
  McpServer = 'MCP_SERVER',
  McpTool = 'MCP_TOOL'
}

/** Used to fetch tools */
export type AgentStudioToolIdAndSource = {
  definitionSource: AgentStudioToolDefinitionSource;
  toolId: Scalars['String']['input'];
};

export type AgentStudioToolInput = {
  /** Id of the definition */
  definitionId: Scalars['String']['input'];
  /** Source of the definition */
  definitionSource: AgentStudioToolDefinitionSource;
  /** Id of the configured tool */
  toolId?: InputMaybe<Scalars['String']['input']>;
};

export enum AgentStudioToolIntegrationOwner {
  Atlassian = 'ATLASSIAN',
  Other = 'OTHER'
}

export type AgentStudioUpdateAgentDetailsInput = {
  /** The authoring team for this agent */
  authoringTeam?: InputMaybe<AgentStudioAuthoringTeamInput>;
  /** UGC prompt to configure Rovo agent tone */
  behaviour?: InputMaybe<Scalars['String']['input']>;
  /** Change the owner id */
  creatorId?: InputMaybe<Scalars['ID']['input']>;
  /** Default request type id for the agent */
  defaultJiraRequestTypeId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the agent */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Entity version of the agent, used for optimistic locking */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** System prompt to configure Rovo agent behaviour */
  instructions?: InputMaybe<Scalars['String']['input']>;
  /** Name of the agent */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type AgentStudioUpdateAgentPermissionInput = {
  /** List of actor roles to assign/remove from the agent */
  actorRoles?: InputMaybe<Array<AgentStudioActorRoleInput>>;
  /** Entity version of the agent, used for optimistic locking. Required when updating actor roles. */
  etag?: InputMaybe<Scalars['String']['input']>;
};

export type AgentStudioUpdateAgentUsePermissionSettingsInput = {
  /** Entity version of the agent, used for optimistic locking. Required when updating USE permission mode. */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** USE permission mode to set for the agent */
  mode?: InputMaybe<AgentStudioUsePermissionMode>;
};

export type AgentStudioUpdateConversationStartersInput = {
  /** Configure conversation starters */
  conversationStarters?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Entity version of the agent, used for optimistic locking */
  etag?: InputMaybe<Scalars['String']['input']>;
};

export type AgentStudioUpdateDatasetItemInput = {
  id: Scalars['ID']['input'];
  inputQuestion: Scalars['String']['input'];
};

export type AgentStudioUpdateScenarioInput = {
  /** The updated actions that this scenario can use */
  actions?: InputMaybe<Array<AgentStudioActionInput>>;
  /** An ID that links this scenario to a specific container */
  containerId: Scalars['ID']['input'];
  /** The updated user ID of the person who owns this scenario */
  creatorId?: InputMaybe<Scalars['ID']['input']>;
  /** Updated instructions configured for this scenario to perform */
  instructions?: InputMaybe<Scalars['String']['input']>;
  /** An updated description of when this scenario should be invoked */
  invocationDescription?: InputMaybe<Scalars['String']['input']>;
  /** Whether the scenario is active in the current container */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the scenario has deep research enabled in the current container */
  isDeepResearchEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the scenario is default in the current container */
  isDefault?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the scenario has web search enabled in the current container */
  isWebSearchEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** An updated list of knowledge sources that this scenario can use */
  knowledgeSources?: InputMaybe<AgentStudioKnowledgeConfigurationInput>;
  /** The updated name for this scenario */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Scenario version used to migrate actions to skills */
  scenarioVersion?: InputMaybe<Scalars['Int']['input']>;
  /** A list of tools that this scenario can use */
  tools?: InputMaybe<Array<AgentStudioToolInput>>;
};

export type AgentStudioUploadBatchEvaluationDatasetInput = {
  datasetName: Scalars['String']['input'];
  file: Scalars['Upload']['input'];
  projectId: Scalars['String']['input'];
};

/** USE permission mode for an agent */
export enum AgentStudioUsePermissionMode {
  /** This agent is open for all users to use */
  Open = 'OPEN',
  /** This agent will only be able to be used by selected users */
  Restricted = 'RESTRICTED'
}

export enum AgentStudioWidgetContainerType {
  HelpCenter = 'HELP_CENTER',
  Portal = 'PORTAL'
}

export type AgentStudioWidgetInput = {
  /** Container in which the widget will live */
  containerAri: Scalars['String']['input'];
  /** The type of container for the widget */
  containerType: AgentStudioWidgetContainerType;
  /** Whether the widget is enabled or not. */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * ============================================
 * Availability Types
 * ============================================
 */
export type AgentWorkspaceAvailabilityInput = {
  /** Filter by multiple agent IDs (optional) */
  agentIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Cloud ID (required) */
  cloudId: Scalars['ID']['input'];
  /** Page number (1-based, default: 1) */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** Number of agents to return per page (default: 10, max: 100) */
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  /** Project ID (optional) */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** Project key (optional) */
  projectKey?: InputMaybe<Scalars['String']['input']>;
  /** Filter by multiple statuses (optional) */
  statuses?: InputMaybe<Array<AgentWorkspaceAvailabilityStatus>>;
  /** Filter by multiple team IDs (optional) - only include agents belonging to these teams */
  teamIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum AgentWorkspaceAvailabilityStatus {
  Available = 'AVAILABLE',
  OnBreak = 'ON_BREAK'
}

/**
 * ============================================
 * Capacity Types
 * ============================================
 */
export type AgentWorkspaceCapacityInput = {
  /** Filter by multiple agent IDs (optional) */
  agentIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Cloud ID (required) */
  cloudId: Scalars['ID']['input'];
  /** Page number (1-based, default: 1) */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** Number of agents per page (default: 10, max: 100) */
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  /** Project key (required) */
  projectKey: Scalars['String']['input'];
  /** Filter by multiple capacity statuses (optional) */
  statuses?: InputMaybe<Array<AgentWorkspaceCapacityStatus>>;
  /** Filter by multiple team IDs (optional) */
  teamIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum AgentWorkspaceCapacityStatus {
  /** 61-80% utilization */
  High = 'HIGH',
  /** 0% utilization */
  Idle = 'IDLE',
  /** 1-60% utilization */
  Optimal = 'OPTIMAL',
  /** >80% utilization */
  Overloaded = 'OVERLOADED'
}

export type AgentWorkspaceCreateScheduleInput = {
  /** Agent IDs to assign (required) */
  agentIds: Array<Scalars['ID']['input']>;
  /** Cloud ID (required) */
  cloudId: Scalars['ID']['input'];
  /** Optional description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** When recurrence ends (optional, null = never ends) */
  effectiveUntil?: InputMaybe<Scalars['DateTime']['input']>;
  /** Shift end time in UTC (required) */
  endTime: Scalars['DateTime']['input'];
  /** Schedule name (required) */
  name: Scalars['String']['input'];
  /** Project ID (optional) */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** Project key (optional) */
  projectKey?: InputMaybe<Scalars['String']['input']>;
  /** Recurrence rule (optional, null = one-time) */
  recurrence?: InputMaybe<AgentWorkspaceRecurrenceRuleInput>;
  /** Shift start time in UTC (required) */
  startTime: Scalars['DateTime']['input'];
};

/**
 * ============================================
 * Input Types for Mutations
 * ============================================
 */
export type AgentWorkspaceCreateSkillInput = {
  assessmentIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  attributes?: InputMaybe<Scalars['JSON']['input']>;
  cloudId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  parentCatalogIds: Array<Scalars['ID']['input']>;
  proficiencyDefinitions?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum AgentWorkspaceDayOfWeek {
  Friday = 'FRIDAY',
  Monday = 'MONDAY',
  Saturday = 'SATURDAY',
  Sunday = 'SUNDAY',
  Thursday = 'THURSDAY',
  Tuesday = 'TUESDAY',
  Wednesday = 'WEDNESDAY'
}

export type AgentWorkspaceDeleteScheduleInput = {
  cloudId: Scalars['ID']['input'];
  projectId?: InputMaybe<Scalars['ID']['input']>;
  projectKey?: InputMaybe<Scalars['String']['input']>;
  scheduleId: Scalars['ID']['input'];
};

/**
 * ============================================
 * Schedule Enums
 * ============================================
 */
export enum AgentWorkspaceRecurrenceFrequency {
  Daily = 'DAILY',
  Monthly = 'MONTHLY',
  Weekly = 'WEEKLY'
}

/**
 * ============================================
 * Schedule Inputs
 * ============================================
 */
export type AgentWorkspaceRecurrenceRuleInput = {
  dayOfMonth?: InputMaybe<Scalars['Int']['input']>;
  dayOfWeekInMonth?: InputMaybe<AgentWorkspaceDayOfWeek>;
  daysOfWeek?: InputMaybe<Array<AgentWorkspaceDayOfWeek>>;
  frequency: AgentWorkspaceRecurrenceFrequency;
  interval?: InputMaybe<Scalars['Int']['input']>;
  weekOfMonth?: InputMaybe<Scalars['Int']['input']>;
};

export enum AgentWorkspaceScheduleErrorCode {
  AgentNotFound = 'AGENT_NOT_FOUND',
  AgentNotInTeam = 'AGENT_NOT_IN_TEAM',
  Forbidden = 'FORBIDDEN',
  InternalError = 'INTERNAL_ERROR',
  InvalidRecurrence = 'INVALID_RECURRENCE',
  InvalidTimeRange = 'INVALID_TIME_RANGE',
  ProjectNotFound = 'PROJECT_NOT_FOUND',
  ScheduleNotFound = 'SCHEDULE_NOT_FOUND',
  TeamNotFound = 'TEAM_NOT_FOUND',
  ValidationError = 'VALIDATION_ERROR'
}

export type AgentWorkspaceSetDefaultCapacityInput = {
  /** Cloud ID (required) */
  cloudId: Scalars['ID']['input'];
  /** Default capacity for all agents (required, must be >= 1) */
  defaultCapacity: Scalars['Int']['input'];
  /** Project key (required) */
  projectKey: Scalars['String']['input'];
};

/**
 * ============================================
 * Shift Query Types
 * ============================================
 */
export type AgentWorkspaceShiftsQueryInput = {
  /** Filter by specific agent IDs (optional) */
  agentIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Cloud ID (required) */
  cloudId: Scalars['ID']['input'];
  /** End of the time range to fetch shifts (required) */
  endTime: Scalars['DateTime']['input'];
  /** Project ID (optional) */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** Project key (optional) */
  projectKey?: InputMaybe<Scalars['String']['input']>;
  /** Start of the time range to fetch shifts (required) */
  startTime: Scalars['DateTime']['input'];
  /** Filter by specific team IDs (optional) - only include agents belonging to these teams */
  teamIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Filter input for skill queries */
export type AgentWorkspaceSkillFilter = {
  /** Filter by custom attributes */
  attributes?: InputMaybe<Scalars['JSON']['input']>;
  /** Filter by skill IDs */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filter by name (contains) */
  nameContains?: InputMaybe<Scalars['String']['input']>;
  /** Filter by parent catalog IDs */
  parentCatalogIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type AgentWorkspaceUpdateScheduleInput = {
  /** Agent IDs (required) */
  agentIds: Array<Scalars['ID']['input']>;
  /** Cloud ID (required) */
  cloudId: Scalars['ID']['input'];
  /** Optional description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** When recurrence ends (null = never ends) */
  effectiveUntil?: InputMaybe<Scalars['DateTime']['input']>;
  /** Whether schedule is active */
  enabled: Scalars['Boolean']['input'];
  /** Shift end time in UTC (required) */
  endTime: Scalars['DateTime']['input'];
  /** Schedule name (required) */
  name: Scalars['String']['input'];
  /** Project ID (optional) */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** Project key (optional) */
  projectKey?: InputMaybe<Scalars['String']['input']>;
  /** Recurrence rule (null = one-time) */
  recurrence?: InputMaybe<AgentWorkspaceRecurrenceRuleInput>;
  /** Schedule ID to update (required) */
  scheduleId: Scalars['ID']['input'];
  /** Shift start time in UTC (required) */
  startTime: Scalars['DateTime']['input'];
};

export type AgentWorkspaceUpdateSkillInput = {
  assessmentIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  attributes?: InputMaybe<Scalars['JSON']['input']>;
  cloudId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  parentCatalogIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  proficiencyDefinitions?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum AiCoreApiQuestionType {
  /** Question is created by draft. */
  DraftDocument = 'DRAFT_DOCUMENT',
  /** Question is created by knowledge base from customer. */
  KnowledgeBase = 'KNOWLEDGE_BASE'
}

/**
 * ###################################################################################################################
 *  COMPASS ALERT EVENT
 * ###################################################################################################################
 */
export enum AlertEventStatus {
  Acknowledged = 'ACKNOWLEDGED',
  Closed = 'CLOSED',
  Opened = 'OPENED',
  Snoozed = 'SNOOZED'
}

export enum AlertPriority {
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5'
}

export enum AllUpdatesFeedEventType {
  Comment = 'COMMENT',
  Create = 'CREATE',
  Edit = 'EDIT'
}

export enum AnalyticsClickEventName {
  CompanyHubLinkClicked = 'companyHubLink_clicked'
}

export enum AnalyticsCommentType {
  Inline = 'inline',
  Page = 'page'
}

export enum AnalyticsContentType {
  Blogpost = 'blogpost',
  Page = 'page'
}

export enum AnalyticsDiscoverEventName {
  CompanyHubLinkViewed = 'companyHubLink_viewed'
}

/** Events to gather analytics for */
export enum AnalyticsEventName {
  AnalyticsPageModalViewed = 'analyticsPageModal_viewed',
  AutomationRuleTrackCreated = 'automationRuleTrack_created',
  CalendarCreated = 'calendar_created',
  CommentCreated = 'comment_created',
  CompanyHubLinkClicked = 'companyHubLink_clicked',
  CompanyHubLinkViewed = 'companyHubLink_viewed',
  DatabaseCreated = 'database_created',
  DatabaseViewed = 'database_viewed',
  InspectPermissionsDialogViewed = 'inspectPermissionsDialog_viewed',
  InstanceAnalyticsViewed = 'instanceAnalytics_viewed',
  LivedocViewed = 'livedoc_viewed',
  PageAnalyticsViewed = 'pageAnalytics_viewed',
  PageCreated = 'page_created',
  PageInitialized = 'page_initialized',
  PageSnapshotted = 'page_snapshotted',
  PageUpdated = 'page_updated',
  PageViewed = 'page_viewed',
  PubliclinkPageViewed = 'publiclink_page_viewed',
  ReactionCreated = 'reaction_created',
  SpaceAnalyticsViewed = 'spaceAnalytics_viewed',
  TeamCalendarsViewed = 'teamCalendars_viewed',
  WhiteboardCreated = 'whiteboard_created',
  WhiteboardViewed = 'whiteboard_viewed'
}

/** Events to gather measure analytics for */
export enum AnalyticsMeasuresEventName {
  CurrentBlogpostCountSpacestateMeasured = 'currentBlogpostCount_spacestate_measured',
  CurrentDatabaseCountSpacestateMeasured = 'currentDatabaseCount_spacestate_measured',
  CurrentLivedocsCountSpacestateMeasured = 'currentLivedocsCount_spacestate_measured',
  CurrentPageCountSpacestateMeasured = 'currentPageCount_spacestate_measured',
  CurrentWhiteboardCountSpacestateMeasured = 'currentWhiteboardCount_spacestate_measured',
  InactivePageCountSitestateMeasured = 'inactivePageCount_sitestate_measured',
  InactivePageCountSpacestateMeasured = 'inactivePageCount_spacestate_measured',
  TotalActiveCommunalSpacesSitestateMeasured = 'totalActiveCommunalSpaces_sitestate_measured',
  TotalActivePersonalSpacesSitestateMeasured = 'totalActivePersonalSpaces_sitestate_measured',
  TotalActivePublicLinksSitestateMeasured = 'totalActivePublicLinks_sitestate_measured',
  TotalActivePublicLinksSpacestateMeasured = 'totalActivePublicLinks_spacestate_measured',
  TotalActiveSpacesSitestateMeasured = 'totalActiveSpaces_sitestate_measured',
  TotalCurrentBlogpostCountSitestateMeasured = 'totalCurrentBlogpostCount_sitestate_measured',
  TotalCurrentDatabaseCountSitestateMeasured = 'totalCurrentDatabaseCount_sitestate_measured',
  TotalCurrentLivedocsCountSitestateMeasured = 'totalCurrentLivedocsCount_sitestate_measured',
  TotalCurrentPageCountSitestateMeasured = 'totalCurrentPageCount_sitestate_measured',
  TotalCurrentWhiteboardCountSitestateMeasured = 'totalCurrentWhiteboardCount_sitestate_measured',
  TotalPagesDeactivatedOwnerSitestateMeasured = 'totalPagesDeactivatedOwner_sitestate_measured',
  TotalPagesDeactivatedOwnerSpacestateMeasured = 'totalPagesDeactivatedOwner_spacestate_measured'
}

/** Events to gather measure analytics space state */
export enum AnalyticsMeasuresSpaceEventName {
  CurrentBlogpostCountSpacestateMeasured = 'currentBlogpostCount_spacestate_measured',
  CurrentDatabaseCountSpacestateMeasured = 'currentDatabaseCount_spacestate_measured',
  CurrentLivedocsCountSpacestateMeasured = 'currentLivedocsCount_spacestate_measured',
  CurrentPageCountSpacestateMeasured = 'currentPageCount_spacestate_measured',
  CurrentWhiteboardCountSpacestateMeasured = 'currentWhiteboardCount_spacestate_measured',
  InactivePageCountSpacestateMeasured = 'inactivePageCount_spacestate_measured',
  TotalActivePublicLinksSpacestateMeasured = 'totalActivePublicLinks_spacestate_measured',
  TotalPagesDeactivatedOwnerSpacestateMeasured = 'totalPagesDeactivatedOwner_spacestate_measured'
}

/** Events to gather search analytics for */
export enum AnalyticsSearchEventName {
  AdvancedSearchResultLinkClicked = 'advancedSearchResultLink_clicked',
  AdvancedSearchResultsShown = 'advancedSearchResults_shown',
  QuickSearchRequestCompleted = 'quickSearchRequest_completed',
  QuickSearchResultSelected = 'quickSearchResult_selected'
}

/** Granularity to group events by */
export enum AnalyticsTimeseriesGranularity {
  Day = 'DAY',
  Hour = 'HOUR',
  Month = 'MONTH',
  Week = 'WEEK'
}

export type AnonymousWithPermissionsInput = {
  operations: Array<InputMaybe<OperationCheckResultInput>>;
};

/** Only used for inside the schema to mark the context for generic types */
export enum ApiContext {
  Devops = 'DEVOPS'
}

/**
 * This enum is the names of API groupings within the total Atlassian API.
 *
 * This is used by our documentation tooling to group together types and fields into logical groups
 */
export enum ApiGroup {
  Actions = 'ACTIONS',
  AdminUnit = 'ADMIN_UNIT',
  AgentStudio = 'AGENT_STUDIO',
  AppRecommendations = 'APP_RECOMMENDATIONS',
  AtlassianStudio = 'ATLASSIAN_STUDIO',
  Caas = 'CAAS',
  CloudAdmin = 'CLOUD_ADMIN',
  CollaborationGraph = 'COLLABORATION_GRAPH',
  CommerceCcp = 'COMMERCE_CCP',
  CommerceHams = 'COMMERCE_HAMS',
  CommerceSharedApi = 'COMMERCE_SHARED_API',
  Compass = 'COMPASS',
  Confluence = 'CONFLUENCE',
  ConfluenceAnalytics = 'CONFLUENCE_ANALYTICS',
  ConfluenceLegacy = 'CONFLUENCE_LEGACY',
  ConfluenceMigration = 'CONFLUENCE_MIGRATION',
  ConfluenceMutations = 'CONFLUENCE_MUTATIONS',
  ConfluencePages = 'CONFLUENCE_PAGES',
  ConfluencePageTree = 'CONFLUENCE_PAGE_TREE',
  ConfluenceSmarts = 'CONFLUENCE_SMARTS',
  ConfluenceTenant = 'CONFLUENCE_TENANT',
  ConfluenceUser = 'CONFLUENCE_USER',
  ConfluenceV2 = 'CONFLUENCE_V2',
  ContentPlatformApi = 'CONTENT_PLATFORM_API',
  CsmAi = 'CSM_AI',
  CustomerService = 'CUSTOMER_SERVICE',
  DevopsAriGraph = 'DEVOPS_ARI_GRAPH',
  DevopsContainerRelationship = 'DEVOPS_CONTAINER_RELATIONSHIP',
  DevopsService = 'DEVOPS_SERVICE',
  DevopsThirdParty = 'DEVOPS_THIRD_PARTY',
  DevopsToolchain = 'DEVOPS_TOOLCHAIN',
  FeatureReleaseQuery = 'FEATURE_RELEASE_QUERY',
  Forge = 'FORGE',
  Goals = 'GOALS',
  GuardDetect = 'GUARD_DETECT',
  Help = 'HELP',
  Identity = 'IDENTITY',
  InsightsXperienceService = 'INSIGHTS_XPERIENCE_SERVICE',
  Jira = 'JIRA',
  Papi = 'PAPI',
  Polaris = 'POLARIS',
  Projects = 'PROJECTS',
  ServiceHubAgentConfiguration = 'SERVICE_HUB_AGENT_CONFIGURATION',
  SurfacePlatform = 'SURFACE_PLATFORM',
  Teams = 'TEAMS',
  VirtualAgent = 'VIRTUAL_AGENT',
  WebTriggers = 'WEB_TRIGGERS',
  XenInvocationService = 'XEN_INVOCATION_SERVICE',
  XenLogsApi = 'XEN_LOGS_API'
}

export type AppContainerInput = {
  appId: Scalars['ID']['input'];
  containerKey: Scalars['String']['input'];
};

export type AppContainerServiceContextFilter = {
  type: AppContainerServiceContextFilterType;
  value: Scalars['String']['input'];
};

export enum AppContainerServiceContextFilterType {
  /**
   * Filters app container services by the specified context.
   * Expected value format is "<icId>:<region>"
   */
  ShardContext = 'SHARD_CONTEXT'
}

export enum AppContributorRole {
  Admin = 'ADMIN',
  Deployer = 'DEPLOYER',
  Developer = 'DEVELOPER',
  Viewer = 'VIEWER',
  ViewerAdvanced = 'VIEWER_ADVANCED'
}

export type AppCustomScopeSpec = {
  description: Scalars['String']['input'];
  displayName: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export enum AppDeploymentEventLogLevel {
  Error = 'ERROR',
  Info = 'INFO',
  Warning = 'WARNING'
}

export enum AppDeploymentStatus {
  Done = 'DONE',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS'
}

export enum AppDeploymentStepStatus {
  Done = 'DONE',
  Failed = 'FAILED',
  Started = 'STARTED'
}

/** Used to uniquely identify an environment, when being used as an input. */
export type AppEnvironmentInput = {
  appId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
};

export enum AppEnvironmentType {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING'
}

/** The input needed to create or update an environment variable. */
export type AppEnvironmentVariableInput = {
  /** Whether or not to encrypt (default=false) */
  encrypt?: InputMaybe<Scalars['Boolean']['input']>;
  /** The key of the environment variable */
  key: Scalars['String']['input'];
  /** The value of the environment variable */
  value: Scalars['String']['input'];
};

export enum AppFeatureKey {
  HasCustomLifecycle = 'HAS_CUSTOM_LIFECYCLE',
  HasExposedCredentials = 'HAS_EXPOSED_CREDENTIALS',
  HasResourceRestrictedToken = 'HAS_RESOURCE_RESTRICTED_TOKEN',
  SupportsCompute = 'SUPPORTS_COMPUTE'
}

export type AppFeaturesExposedCredentialsInput = {
  contactLink?: InputMaybe<Scalars['String']['input']>;
  defaultAuthClientType?: InputMaybe<AuthClientType>;
  distributionStatus?: InputMaybe<DistributionStatus>;
  hasPDReportingApiImplemented?: InputMaybe<Scalars['Boolean']['input']>;
  privacyPolicy?: InputMaybe<Scalars['String']['input']>;
  refreshTokenRotation?: InputMaybe<Scalars['Boolean']['input']>;
  storesPersonalData?: InputMaybe<Scalars['Boolean']['input']>;
  termsOfService?: InputMaybe<Scalars['String']['input']>;
  vendorName?: InputMaybe<Scalars['String']['input']>;
  vendorType?: InputMaybe<VendorType>;
};

export type AppFeaturesInput = {
  hasCustomLifecycle?: InputMaybe<Scalars['Boolean']['input']>;
  hasExposedCredentials?: InputMaybe<AppFeaturesExposedCredentialsInput>;
  /**
   * hasResourceRestrictedToken toggles whether a 3LO app is restricted to only using resources in the claim
   * See https://hello.atlassian.net/wiki/spaces/ECO/pages/5648555348/ECORFC-554+-+Resource+restrictions+for+3LO+apps
   */
  hasResourceRestrictedToken?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Input payload for the app environment install mutation */
export type AppInstallationInput = {
  /** A unique Id representing the app */
  appId: Scalars['ID']['input'];
  /** The key of the app's environment to be used for installation */
  environmentKey: Scalars['String']['input'];
  /** A unique Id representing the context into which the app is being installed */
  installationContext: Scalars['ID']['input'];
  /** Bypass licensing flow if licenseOverride is set */
  licenseOverride?: InputMaybe<LicenseOverrideState>;
  /** An object to override the app installation settings. */
  overrides?: InputMaybe<EcosystemAppInstallationOverridesInput>;
  /** An ID for checking whether an app license has been activated via POA, providing this will bypass the COFS activation flow */
  provisionRequestId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique Id representing a specific version of an app */
  versionId?: InputMaybe<Scalars['ID']['input']>;
};

export type AppInstallationTasksFilter = {
  appId: Scalars['ID']['input'];
  taskContext: Scalars['ID']['input'];
};

/** Input payload for the app environment upgrade mutation */
export type AppInstallationUpgradeInput = {
  /** A unique Id representing the app */
  appId: Scalars['ID']['input'];
  /** A boolean to indicate that this is a compute only upgrade */
  computeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** The key of the app's environment to be used for installation upgrade */
  environmentKey: Scalars['String']['input'];
  /** A unique Id representing the context into which the app is being upgraded */
  installationContext: Scalars['ID']['input'];
  /**
   * Determines whether the original billing type is HAMS or CCP. Will be treated as HAMS if not provided.
   * Providing CCP will skip deactivation via COFS
   */
  sourceBillingType?: InputMaybe<SourceBillingType>;
  /** A unique Id representing a specific major version of the app */
  versionId?: InputMaybe<Scalars['ID']['input']>;
};

export type AppInstallationsByAppFilter = {
  appEnvironments?: InputMaybe<InstallationsListFilterByAppEnvironments>;
  appInstallations?: InputMaybe<InstallationsListFilterByAppInstallations>;
  apps: InstallationsListFilterByApps;
  includeSystemApps?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AppInstallationsByContextFilter = {
  appInstallations: InstallationsListFilterByAppInstallationsWithCompulsoryContexts;
  apps?: InputMaybe<InstallationsListFilterByApps>;
  /** A flag to retrieve installations that have secondary contexts that match context filter. Defaults to true */
  includeOptionalLinks?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * A flag to retrieve installations that have been uninstalled but are recoverable
   * NOTE: The functionality associated with installation recovery is currently under development.
   */
  includeRecoverable?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AppInstallationsFilter = {
  appId: Scalars['ID']['input'];
  environmentType?: InputMaybe<AppEnvironmentType>;
};

export enum AppNetworkEgressCategory {
  Analytics = 'ANALYTICS'
}

export enum AppNetworkEgressCategoryExtension {
  Analytics = 'ANALYTICS'
}

export enum AppNetworkPermissionType {
  FetchBackendSide = 'FETCH_BACKEND_SIDE',
  FetchClientSide = 'FETCH_CLIENT_SIDE',
  Fonts = 'FONTS',
  Frames = 'FRAMES',
  Images = 'IMAGES',
  Media = 'MEDIA',
  Navigation = 'NAVIGATION',
  Scripts = 'SCRIPTS',
  Styles = 'STYLES'
}

export enum AppNetworkPermissionTypeExtension {
  FetchBackendSide = 'FETCH_BACKEND_SIDE',
  FetchClientSide = 'FETCH_CLIENT_SIDE',
  Fonts = 'FONTS',
  Frames = 'FRAMES',
  Images = 'IMAGES',
  Media = 'MEDIA',
  Navigation = 'NAVIGATION',
  Scripts = 'SCRIPTS',
  Styles = 'STYLES'
}

/**
 * The context object provides essential insights into the users' current experience and operations.
 * The supported product and subproduct keys can be found at https://hello.atlassian.net/wiki/spaces/ECON/pages/2339030895/App+Identifiers
 */
export type AppRecContext = {
  anonymousId?: InputMaybe<Scalars['ID']['input']>;
  containers?: InputMaybe<Scalars['JSON']['input']>;
  /** Language-Sub language identifier format (ISO 639-1 and ISO 639-2) */
  locale?: InputMaybe<Scalars['String']['input']>;
  orgId?: InputMaybe<Scalars['ID']['input']>;
  product?: InputMaybe<Scalars['String']['input']>;
  /** This is an identifier for tagging analytics events, useful for correlating across frontend and backend */
  sessionId?: InputMaybe<Scalars['ID']['input']>;
  subproduct?: InputMaybe<Scalars['String']['input']>;
  /** The tenant id is also well known as the cloud id */
  tenantId?: InputMaybe<Scalars['ID']['input']>;
  useCase?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
  workspaceId?: InputMaybe<Scalars['ID']['input']>;
};

export type AppRecDismissRecommendationInput = {
  /** The context is temporarily optional. It will be enforced to be mandatory once consumers complete the migration. */
  context?: InputMaybe<AppRecContext>;
  /** A CCP identifier */
  productId: Scalars['ID']['input'];
};

export type AppRecUndoDismissalInput = {
  context: AppRecContext;
  /** A CCP identifier */
  productId: Scalars['ID']['input'];
};

export enum AppSecurityPoliciesPermissionType {
  Scripts = 'SCRIPTS',
  Styles = 'STYLES'
}

export enum AppSecurityPoliciesPermissionTypeExtension {
  Scripts = 'SCRIPTS',
  Styles = 'STYLES'
}

export type AppServicesFilter = {
  name: Scalars['String']['input'];
};

export type AppStorageKvsAdminQueryInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  installationId: Scalars['ID']['input'];
};

export type AppStorageKvsAdminSetInput = {
  installationId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
  value: Scalars['AppStorageEntityValue']['input'];
};

/**
 *  `appStorageLifecycle` is not included in AGG because it is not publicly exposed,
 *  and does not have the correct schema prefix
 *  type Mutation {
 *    appStorageLifecycle: AppStorageLifecycle
 *  }
 */
export type AppStorageKvsQueryInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  contextAri: Scalars['ID']['input'];
  environmentId: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  installationId: Scalars['ID']['input'];
  oauthClientId: Scalars['ID']['input'];
};

export type AppStorageKvsSetInput = {
  contextAri: Scalars['ID']['input'];
  environmentId: Scalars['ID']['input'];
  installationId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
  oauthClientId: Scalars['ID']['input'];
  value: Scalars['AppStorageEntityValue']['input'];
};

export type AppStorageLifecycleQueryInstallationInfoInput = {
  installationId: Scalars['ID']['input'];
};

export type AppStorageOrderByInput = {
  columnName: Scalars['String']['input'];
  direction: AppStorageSqlTableDataSortDirection;
};

export type AppStorageSqlDatabaseInput = {
  appId: Scalars['ID']['input'];
  installationId: Scalars['ID']['input'];
};

export type AppStorageSqlTableDataInput = {
  appId: Scalars['ID']['input'];
  installationId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AppStorageOrderByInput>>;
  tableName: Scalars['String']['input'];
};

export enum AppStorageSqlTableDataSortDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type AppStoredCustomEntityFilter = {
  condition: AppStoredCustomEntityFilterCondition;
  property: Scalars['String']['input'];
  values: Array<Scalars['AppStoredCustomEntityFieldValue']['input']>;
};

export enum AppStoredCustomEntityFilterCondition {
  BeginsWith = 'BEGINS_WITH',
  Between = 'BETWEEN',
  Contains = 'CONTAINS',
  EqualTo = 'EQUAL_TO',
  Exists = 'EXISTS',
  GreaterThan = 'GREATER_THAN',
  GreaterThanEqualTo = 'GREATER_THAN_EQUAL_TO',
  LessThan = 'LESS_THAN',
  LessThanEqualTo = 'LESS_THAN_EQUAL_TO',
  NotContains = 'NOT_CONTAINS',
  NotEqualTo = 'NOT_EQUAL_TO',
  NotExists = 'NOT_EXISTS'
}

export type AppStoredCustomEntityFilters = {
  and?: InputMaybe<Array<AppStoredCustomEntityFilter>>;
  or?: InputMaybe<Array<AppStoredCustomEntityFilter>>;
};

export type AppStoredCustomEntityRange = {
  condition: AppStoredCustomEntityRangeCondition;
  values: Array<Scalars['AppStoredCustomEntityFieldValue']['input']>;
};

export enum AppStoredCustomEntityRangeCondition {
  BeginsWith = 'BEGINS_WITH',
  Between = 'BETWEEN',
  EqualTo = 'EQUAL_TO',
  GreaterThan = 'GREATER_THAN',
  GreaterThanEqualTo = 'GREATER_THAN_EQUAL_TO',
  LessThan = 'LESS_THAN',
  LessThanEqualTo = 'LESS_THAN_EQUAL_TO'
}

export enum AppStoredEntityCondition {
  In = 'IN',
  NotEqualTo = 'NOT_EQUAL_TO',
  StartsWith = 'STARTS_WITH'
}

/**
 * The identifier for this entity
 *
 * where condition to filter
 */
export type AppStoredEntityFilter = {
  condition: AppStoredEntityCondition;
  /** Condition filter to be provided when querying for Entities. */
  field: Scalars['String']['input'];
  value: Scalars['AppStoredEntityFieldValue']['input'];
};

export type AppSubscribeInput = {
  appId: Scalars['ID']['input'];
  envKey: Scalars['String']['input'];
  installationContext: Scalars['ID']['input'];
};

export enum AppTaskState {
  Complete = 'COMPLETE',
  Failed = 'FAILED',
  Pending = 'PENDING',
  Running = 'RUNNING'
}

/** App trust information state */
export enum AppTrustInformationState {
  Draft = 'DRAFT',
  Live = 'LIVE'
}

/** Input payload for the app environment uninstall mutation */
export type AppUninstallationInput = {
  /** A unique Id representing the app */
  appId: Scalars['ID']['input'];
  /** The key of the app's environment to be used for uninstallation */
  environmentKey: Scalars['String']['input'];
  /** Indicates the user consents to forfeit any remaining funds on the entitlement of the app being uninstalled */
  forfeitRemainingFunds?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique Id representing the context into which the app is being uninstalled */
  installationContext?: InputMaybe<Scalars['ID']['input']>;
  /** A unique Id representing the installationId */
  installationId?: InputMaybe<Scalars['ID']['input']>;
  /** Bypass licensing flow if licenseOverride is set */
  licenseOverride?: InputMaybe<LicenseOverrideState>;
  /**
   * Determines whether the original billing type is HAMS or CCP. Will be treated as HAMS if not provided.
   * Providing CCP will skip deactivation via COFS
   */
  sourceBillingType?: InputMaybe<SourceBillingType>;
};

export type AppUnsubscribeInput = {
  appId: Scalars['ID']['input'];
  envKey: Scalars['String']['input'];
  installationContext: Scalars['ID']['input'];
};

export enum AppVersionRolloutStatus {
  Cancelled = 'CANCELLED',
  Complete = 'COMPLETE',
  Running = 'RUNNING'
}

export type ApplyPolarisProjectTemplateInput = {
  ideaType: Scalars['ID']['input'];
  project: Scalars['ID']['input'];
  template: Scalars['ID']['input'];
};

export type AppsFilter = {
  developerSpaceId?: InputMaybe<Scalars['ID']['input']>;
  isPublishable?: InputMaybe<Scalars['Boolean']['input']>;
  migrationKey?: InputMaybe<Scalars['String']['input']>;
  storesPersonalData?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AquaNotificationLogsFilter = {
  filterActionable?: InputMaybe<Scalars['Boolean']['input']>;
  selectedFilters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type ArchiveSpaceInput = {
  /** The alias of the archived space */
  alias: Scalars['String']['input'];
};

export enum ArchivedMode {
  ActiveOnly = 'ACTIVE_ONLY',
  /** @deprecated Underlying service does not support `ALL`. It will coerce `ACTIVE_ONLY`. */
  All = 'ALL',
  ArchivedOnly = 'ARCHIVED_ONLY'
}

export type AriGraphCreateRelationshipsInput = {
  relationships: Array<AriGraphCreateRelationshipsInputRelationship>;
};

export type AriGraphCreateRelationshipsInputRelationship = {
  /** ARI of the subject */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. `updateTime` as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** ARI of the object */
  to: Scalars['ID']['input'];
  /** Type of the relationship */
  type: Scalars['ID']['input'];
  /** Time at which this relationship was last observed. `updateTime` at the request level will be used if this is omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

/**
 * At least 'from' or 'to' must be specified. If both are specified, then 'type' is required.
 *
 * If only one side of the relationship is provided, and no type is provided,
 * then every relationship (where that side of the relationship equals the provided ARI)
 * for every applicable relationship type will be deleted.
 */
export type AriGraphDeleteRelationshipsInput = {
  /** ARI of the subject */
  from?: InputMaybe<Scalars['ID']['input']>;
  /** ARI of the object */
  to?: InputMaybe<Scalars['ID']['input']>;
  /** Type of the relationship */
  type?: InputMaybe<Scalars['ID']['input']>;
};

/** At least one of `from` or `to` must be specified */
export type AriGraphRelationshipsFilter = {
  /**
   * @deprecated(reason: "Use variable [from] at the root of the query instead")
   * Kept for backwards compatibility only.
   */
  from?: InputMaybe<Scalars['ID']['input']>;
  /**
   * @deprecated(reason: "Use variable [to] at the root of the query instead")
   * Kept for backwards compatibility only.
   */
  to?: InputMaybe<Scalars['ID']['input']>;
  /**
   * @deprecated(reason: "Use variable [type] at the root of the query instead")
   * Kept for backwards compatibility only.
   */
  type?: InputMaybe<Scalars['ID']['input']>;
  /** Only include relationships updated after the given DateTime */
  updatedFrom?: InputMaybe<Scalars['DateTime']['input']>;
  /** Only include relationships updated before the given DateTime */
  updatedTo?: InputMaybe<Scalars['DateTime']['input']>;
};

export type AriGraphRelationshipsSort = {
  /** The direction of results based on the lastUpdated time of the relationships. Default is ascending (ASC). */
  lastUpdatedSortDirection?: InputMaybe<AriGraphRelationshipsSortDirection>;
};

export enum AriGraphRelationshipsSortDirection {
  /** Sort in ascending order */
  Asc = 'ASC',
  /** Sort in descending order */
  Desc = 'DESC'
}

export type AriGraphReplaceRelationshipsInput = {
  /** Relationships that replace any existing for the given type and from/to depending on cardinality. */
  relationships: Array<AriGraphReplaceRelationshipsInputRelationship>;
  /** Sequence number of this relationship, used for versioning. `updateTime` as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** Type of the relationship */
  type: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type AriGraphReplaceRelationshipsInputRelationship = {
  /** ARI of the subject */
  from: Scalars['ID']['input'];
  /** ARI of the object */
  to: Scalars['ID']['input'];
};

export type AriRoutingFilter = {
  owner: Scalars['String']['input'];
  type?: InputMaybe<Scalars['String']['input']>;
};

export type AssetsDmAddDataDictionaryInput = {
  destinationObjectAttributeId: Scalars['ID']['input'];
  isSyncRequired?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  objectId: Scalars['ID']['input'];
  priority: Scalars['Int']['input'];
  sourceObjectAttributeId: Scalars['ID']['input'];
  sourceObjectAttributeId2?: InputMaybe<Scalars['ID']['input']>;
};

export type AssetsDmAddDefaultAttributeMappingInput = {
  columnType: AssetsDmDefaultAttributeMappingColumnType;
  dataSourceTypeId: Scalars['ID']['input'];
  destinationColumnName: Scalars['String']['input'];
  isPrimaryKey: Scalars['Boolean']['input'];
  isSecondaryKey: Scalars['Boolean']['input'];
  objectAttributeId: Scalars['ID']['input'];
  sourceColumn: Scalars['String']['input'];
};

export enum AssetsDmAttributeMappingSaveDefaultOption {
  AddNewOnly = 'AddNewOnly',
  Merge = 'Merge',
  OverwriteAll = 'OverwriteAll',
  UpdateOnly = 'UpdateOnly'
}

export type AssetsDmAttributePrioritySearch = {
  attributeName?: InputMaybe<Scalars['String']['input']>;
  dataSourceName?: InputMaybe<Scalars['String']['input']>;
};

export type AssetsDmAttributePrioritySort = {
  field: AssetsDmAttributePrioritySortField;
  order?: AssetsDmSortByInputOrder;
};

export enum AssetsDmAttributePrioritySortField {
  AttributeName = 'AttributeName',
  DataSourceName = 'DataSourceName',
  Priority = 'Priority'
}

export type AssetsDmAutoColumnMappingInput = {
  delimiter: Scalars['String']['input'];
  header: Scalars['String']['input'];
  isEndWithDelimiter?: InputMaybe<Scalars['Boolean']['input']>;
  qualifier?: InputMaybe<Scalars['String']['input']>;
};

export type AssetsDmChangeDataSourceStatusArgs = {
  cloudId: Scalars['ID']['input'];
  input: AssetsDmChangeDataSourceStatusInput;
  workspaceId: Scalars['ID']['input'];
};

export type AssetsDmChangeDataSourceStatusInput = {
  dataSourceId: Scalars['ID']['input'];
  status: AssetsDmDataSourceStatus;
};

export enum AssetsDmCleansingReasonOrder {
  ReasonAsc = 'REASON_ASC',
  ReasonDesc = 'REASON_DESC'
}

export type AssetsDmCreateAttributePriorityInput = {
  dataSourceId: Scalars['ID']['input'];
  objectAttributeId: Scalars['ID']['input'];
  priority: Scalars['Int']['input'];
};

export type AssetsDmCreateCleansingReasonInput = {
  reason: Scalars['String']['input'];
};

export type AssetsDmCreateComputeDictionaryValueInput = {
  computeDictionaryGroupId: Scalars['ID']['input'];
  computeDictionaryId: Scalars['ID']['input'];
  isImported: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
};

export type AssetsDmCreateDataDictionaryGroupInput = {
  computeDictionaryId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

export type AssetsDmCreateDataDictionaryGroupValueInput = {
  computeDictionaryGroupId: Scalars['ID']['input'];
  computeDictionaryId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

export type AssetsDmCreateDataSourceArgs = {
  cloudId: Scalars['ID']['input'];
  input: AssetsDmCreateDataSourceInput;
  workspaceId: Scalars['ID']['input'];
};

export type AssetsDmCreateDataSourceInput = {
  dataSourceTypeId: Scalars['ID']['input'];
  enabled: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
  objectId: Scalars['ID']['input'];
  priority: Scalars['Int']['input'];
  refreshGap: Scalars['Int']['input'];
  tableName: Scalars['String']['input'];
};

export type AssetsDmCreateDataSourceTypeInput = {
  defaultGap?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
};

export type AssetsDmCreateDefaultCleansingRuleInput = {
  dataSourceTypeId?: InputMaybe<Scalars['ID']['input']>;
  defFunctionId: Scalars['ID']['input'];
  defaultFunctionParameters?: InputMaybe<Array<InputMaybe<AssetsDmDefaultFunctionParameterInput>>>;
  enabled?: Scalars['Boolean']['input'];
  objectId?: InputMaybe<Scalars['ID']['input']>;
  priority: Scalars['Int']['input'];
  reasonId: Scalars['ID']['input'];
};

export enum AssetsDmDataDictionaryColumnName {
  ComputeDictionaryId = 'computeDictionaryId',
  DestinationObjectAttributeId = 'destinationObjectAttributeId',
  DmComputeDictionaryDate = 'dmComputeDictionaryDate',
  DmComputeDictionaryId = 'dmComputeDictionaryId',
  Name = 'name',
  ObjectId = 'objectId',
  Priority = 'priority',
  Scope = 'scope',
  SourceObjectAttributeId = 'sourceObjectAttributeId',
  SourceObjectAttributeId2 = 'sourceObjectAttributeId2',
  TenantId = 'tenantId'
}

export type AssetsDmDataDictionaryFilter = {
  columnName: AssetsDmDataDictionaryFilterColumn;
  value: Scalars['String']['input'];
};

export enum AssetsDmDataDictionaryFilterColumn {
  Name = 'name'
}

export type AssetsDmDataDictionaryPageInfoInput = {
  pageCursor?: InputMaybe<Scalars['Int']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
};

export enum AssetsDmDataDictionaryScope {
  Imported = 'imported',
  Local = 'local'
}

export type AssetsDmDataDictionarySortBy = {
  columnName: AssetsDmDataDictionarySortColumn;
  order: AssetsDmDataDictionarySortOrder;
};

export enum AssetsDmDataDictionarySortColumn {
  ComputedIssuesCount = 'computedIssuesCount',
  DestinationObjectAttributeId = 'destinationObjectAttributeId',
  Name = 'name',
  Priority = 'priority',
  Scope = 'scope',
  SourceObjectAttributeId = 'sourceObjectAttributeId',
  SourceObjectAttributeId2 = 'sourceObjectAttributeId2'
}

export enum AssetsDmDataDictionarySortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type AssetsDmDataSourceArgs = {
  cloudId: Scalars['ID']['input'];
  dataSourceId: Scalars['ID']['input'];
  workspaceId: Scalars['ID']['input'];
};

export type AssetsDmDataSourceCleansingReasonInput = {
  reason: Scalars['String']['input'];
  reasonCode: Scalars['Int']['input'];
  reasonId: Scalars['ID']['input'];
  tenantId: Scalars['ID']['input'];
};

export type AssetsDmDataSourceCleansingRuleDefFunctionInput = {
  defFunctionId: Scalars['ID']['input'];
  defFunctionParameters: Array<AssetsDmDataSourceCleansingRuleDefFunctionParameterInput>;
  description: Scalars['String']['input'];
  name: Scalars['String']['input'];
  type: Scalars['String']['input'];
};

export type AssetsDmDataSourceCleansingRuleDefFunctionParameterInput = {
  dataType: Scalars['Int']['input'];
  defFunctionId: Scalars['ID']['input'];
  defFunctionParameterId: Scalars['ID']['input'];
  description: Scalars['String']['input'];
  displayName: Scalars['String']['input'];
  displayOrder: Scalars['Int']['input'];
  isColumn: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
  required: Scalars['Boolean']['input'];
  type: Scalars['Int']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type AssetsDmDataSourceCleansingRuleFunctionParameterInput = {
  defFunctionParameter: AssetsDmDataSourceCleansingRuleDefFunctionParameterInput;
  defFunctionParameterId: Scalars['ID']['input'];
  functionId?: InputMaybe<Scalars['ID']['input']>;
  functionParameterId: Scalars['ID']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type AssetsDmDataSourceCleansingRuleInput = {
  dataSourceId: Scalars['ID']['input'];
  defFunction: AssetsDmDataSourceCleansingRuleDefFunctionInput;
  defFunctionId: Scalars['ID']['input'];
  enabled: Scalars['Boolean']['input'];
  functionId?: InputMaybe<Scalars['ID']['input']>;
  functionParameters: Array<AssetsDmDataSourceCleansingRuleFunctionParameterInput>;
  priority: Scalars['Int']['input'];
  reason: AssetsDmDataSourceCleansingReasonInput;
  reasonId: Scalars['ID']['input'];
};

export type AssetsDmDataSourceConfigureMappingInput = {
  columnType: Scalars['Int']['input'];
  columnTypeName: Scalars['String']['input'];
  dataSourceId: Scalars['ID']['input'];
  destinationColumnName: Scalars['String']['input'];
  isChanged: Scalars['Boolean']['input'];
  isNew: Scalars['Boolean']['input'];
  isPkElsewhere: Scalars['Boolean']['input'];
  isPrimaryKey: Scalars['Boolean']['input'];
  isRemoved: Scalars['Boolean']['input'];
  isSecondaryKey: Scalars['Boolean']['input'];
  objectAttributeId?: InputMaybe<Scalars['ID']['input']>;
  objectAttributeMappingId: Scalars['ID']['input'];
  objectAttributeName?: InputMaybe<Scalars['String']['input']>;
  sourceColumnName: Scalars['String']['input'];
};

export type AssetsDmDataSourceInput = {
  adapterType: Scalars['String']['input'];
  configuration: Scalars['JSON']['input'];
  objectClassType: AssetsDmObjectClassEnum;
};

export enum AssetsDmDataSourceOperationEnum {
  Create = 'Create',
  Update = 'Update',
  UpdateTransform = 'UpdateTransform'
}

export type AssetsDmDataSourceSearch = {
  dataSourceType?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objectClass?: InputMaybe<AssetsDmObjectClassEnum>;
};

export type AssetsDmDataSourceSort = {
  field: AssetsDmDataSourceSortField;
  order?: AssetsDmSortByInputOrder;
};

export enum AssetsDmDataSourceSortField {
  DataSourceTypeName = 'DataSourceTypeName',
  Name = 'Name',
  ObjectName = 'ObjectName',
  Priority = 'Priority',
  RefreshGap = 'RefreshGap'
}

export enum AssetsDmDataSourceStatus {
  CleanseFailed = 'CLEANSE_FAILED',
  CleanseRequired = 'CLEANSE_REQUIRED',
  Disabled = 'DISABLED',
  FunctionReviewRequired = 'FUNCTION_REVIEW_REQUIRED',
  ImportFailed = 'IMPORT_FAILED',
  ImportRequired = 'IMPORT_REQUIRED',
  MappingRequired = 'MAPPING_REQUIRED',
  New = 'NEW',
  Outdated = 'OUTDATED',
  Valid = 'VALID'
}

export enum AssetsDmDataSourceTransformParameterType {
  Date = 'date',
  Numeric = 'numeric',
  Select = 'select',
  String = 'string'
}

export enum AssetsDmDataSourceTransformSelectFieldType {
  ColumnTypes = 'columnTypes',
  Columns = 'columns',
  ColumnsWithDateTime = 'columnsWithDateTime',
  DateFormats = 'dateFormats',
  Intervals = 'intervals',
  Jobs = 'jobs'
}

export type AssetsDmDataSourcesListArgs = {
  cloudId: Scalars['ID']['input'];
  search?: InputMaybe<AssetsDmDataSourceSearch>;
  sortBy?: InputMaybe<AssetsDmDataSourceSort>;
  workspaceId: Scalars['ID']['input'];
};

export type AssetsDmDefFunctionParameterInput = {
  dataType: Scalars['Int']['input'];
  defFunctionId: Scalars['ID']['input'];
  defFunctionParameterId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  displayName: Scalars['String']['input'];
  displayOrder: Scalars['Int']['input'];
  isColumn: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
  required: Scalars['Boolean']['input'];
  type: Scalars['Int']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export enum AssetsDmDefaultAttributeMappingColumnName {
  AttributeName = 'attributeName',
  ColumnType = 'columnType',
  DataSourceType = 'dataSourceType',
  DestinationColumn = 'destinationColumn',
  IsPrimaryKey = 'isPrimaryKey',
  IsSecondaryKey = 'isSecondaryKey',
  SourceColumn = 'sourceColumn'
}

export enum AssetsDmDefaultAttributeMappingColumnType {
  BigInt = 'bigInt',
  Boolean = 'boolean',
  DateTime = 'dateTime',
  Decimal = 'decimal',
  Integer = 'integer',
  String = 'string'
}

export type AssetsDmDefaultAttributeMappingFilterBy = {
  attributeName?: InputMaybe<Scalars['String']['input']>;
  dataSourceType?: InputMaybe<Scalars['String']['input']>;
};

export type AssetsDmDefaultAttributeMappingPageInfoInput = {
  pageCursor?: InputMaybe<Scalars['Int']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
};

export type AssetsDmDefaultAttributeMappingSortBy = {
  name: AssetsDmDefaultAttributeMappingColumnName;
  order: AssetsDmDefaultAttributeMappingSortOrder;
};

export enum AssetsDmDefaultAttributeMappingSortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type AssetsDmDefaultFunctionParameterInput = {
  defFunctionParameter?: InputMaybe<AssetsDmDefFunctionParameterInput>;
  defFunctionParameterId: Scalars['ID']['input'];
  defaultFunctionId?: InputMaybe<Scalars['ID']['input']>;
  defaultFunctionParameterId?: InputMaybe<Scalars['ID']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type AssetsDmDeleteAttributePriorityInput = {
  objectAttributePriorityId: Scalars['ID']['input'];
};

export type AssetsDmDeleteDataSourceArgs = {
  cloudId: Scalars['ID']['input'];
  input: AssetsDmDeleteDataSourceInput;
  workspaceId: Scalars['ID']['input'];
};

export type AssetsDmDeleteDataSourceInput = {
  dataSourceId: Scalars['ID']['input'];
};

export type AssetsDmDeleteDefaultCleansingRuleInput = {
  defaultFunctionId: Scalars['ID']['input'];
};

export type AssetsDmEditDataDictionaryGroupInput = {
  computeDictionaryGroupId: Scalars['ID']['input'];
  computeDictionaryId: Scalars['ID']['input'];
  dmComputeDictionaryGroupId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
};

export type AssetsDmEditDataDictionaryGroupValueInput = {
  computeDictionaryGroupId: Scalars['ID']['input'];
  computeDictionaryId: Scalars['ID']['input'];
  computeDictionaryValueId: Scalars['ID']['input'];
  isImported: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
};

export type AssetsDmEditDataDictionaryInput = {
  computeDictionaryId: Scalars['ID']['input'];
  destinationObjectAttributeId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  objectId: Scalars['ID']['input'];
  priority: Scalars['Int']['input'];
  sourceObjectAttributeId: Scalars['ID']['input'];
  sourceObjectAttributeId2?: InputMaybe<Scalars['ID']['input']>;
};

export type AssetsDmEditDefaultAttributeMappingInput = {
  columnType: AssetsDmDefaultAttributeMappingColumnType;
  dataSourceTypeId: Scalars['ID']['input'];
  defaultObjectAttributeMappingId: Scalars['ID']['input'];
  destinationColumnName: Scalars['String']['input'];
  isSecondaryKey: Scalars['Boolean']['input'];
  objectAttributeId: Scalars['ID']['input'];
  sourceColumn: Scalars['String']['input'];
};

export type AssetsDmExportedObjectsListFileStatusPayload = {
  name: Scalars['String']['input'];
};

export type AssetsDmGenerateAdapterTokenInput = {
  adapterType: Scalars['String']['input'];
  password: Scalars['String']['input'];
  username: Scalars['String']['input'];
};

export type AssetsDmImportDataDictionaryInput = {
  computeDictionaryId: Scalars['ID']['input'];
  destinationObjectAttributeId: Scalars['ID']['input'];
  isSyncRequired?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  objectId: Scalars['ID']['input'];
  sourceObjectAttributeId: Scalars['ID']['input'];
};

export enum AssetsDmJobDataColumnType {
  Boolean = 'BOOLEAN',
  Datetime = 'DATETIME',
  Number = 'NUMBER',
  String = 'STRING'
}

export type AssetsDmJobDataFilterInput = {
  columnName: Scalars['String']['input'];
  columnType: AssetsDmJobDataColumnType;
  filterValue: Scalars['String']['input'];
  filterValueTo?: InputMaybe<Scalars['String']['input']>;
};

export type AssetsDmJobDataSearchGroup = {
  condition?: InputMaybe<AssetsDmObjectsListSearchGroupCondition>;
  searchItems: Array<AssetsDmJobDataSearchItem>;
};

export type AssetsDmJobDataSearchItem = {
  columnName: Scalars['String']['input'];
  condition?: InputMaybe<AssetsDmObjectsListSearchCondition>;
  operator: AssetsDmObjectsListSearchOperator;
  rawColumnType: AssetsDmObjectsListRawColumnType;
  values: Array<Scalars['String']['input']>;
};

export enum AssetsDmJobDataType {
  Cleansed = 'CLEANSED',
  Raw = 'RAW',
  Transformed = 'TRANSFORMED'
}

export type AssetsDmNotificationPayload = {
  exportedObjectsListFileStatus?: InputMaybe<Array<InputMaybe<AssetsDmExportedObjectsListFileStatusPayload>>>;
};

export enum AssetsDmObjectClassEnum {
  Compute = 'Compute',
  Network = 'Network',
  People = 'People',
  Peripherals = 'Peripherals',
  Software = 'Software'
}

export type AssetsDmObjectTagAssociateInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  objectItemId: Scalars['ID']['input'];
  tagId: Scalars['ID']['input'];
};

export type AssetsDmObjectTagCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  objectId: Scalars['ID']['input'];
};

export type AssetsDmObjectTagDissociateInput = {
  primaryKeyValue: Scalars['String']['input'];
  tagId: Scalars['ID']['input'];
};

export type AssetsDmObjectTagEditInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  objectId: Scalars['ID']['input'];
  tagCode: Scalars['Int']['input'];
  tagId: Scalars['ID']['input'];
};

export enum AssetsDmObjectsListColumnType {
  Boolean = 'BOOLEAN',
  Datetime = 'DATETIME',
  Icon = 'ICON',
  Number = 'NUMBER',
  String = 'STRING',
  Tag = 'TAG'
}

export enum AssetsDmObjectsListIconType {
  Failed = 'FAILED',
  Success = 'SUCCESS',
  Unknown = 'UNKNOWN'
}

export type AssetsDmObjectsListPageInfoInput = {
  pageCursor?: InputMaybe<Scalars['Int']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
};

export enum AssetsDmObjectsListRawColumnType {
  Bigint = 'BIGINT',
  Boolean = 'BOOLEAN',
  Datetime = 'DATETIME',
  Decimal = 'DECIMAL',
  Int = 'INT',
  String = 'STRING'
}

export enum AssetsDmObjectsListSearchCondition {
  And = 'AND',
  Andnot = 'ANDNOT',
  Not = 'NOT',
  Or = 'OR',
  Ornot = 'ORNOT'
}

export type AssetsDmObjectsListSearchGroup = {
  condition?: InputMaybe<AssetsDmObjectsListSearchGroupCondition>;
  searchGroups?: Array<AssetsDmObjectsListSearchGroup>;
  searchItems?: Array<AssetsDmObjectsListSearchItem>;
};

export enum AssetsDmObjectsListSearchGroupCondition {
  And = 'AND',
  Andnot = 'ANDNOT',
  Not = 'NOT',
  Or = 'OR',
  Ornot = 'ORNOT'
}

export type AssetsDmObjectsListSearchItem = {
  columnName?: InputMaybe<Scalars['String']['input']>;
  condition?: InputMaybe<AssetsDmObjectsListSearchCondition>;
  isAttribute?: Scalars['Boolean']['input'];
  isDataSource?: Scalars['Boolean']['input'];
  operator: AssetsDmObjectsListSearchOperator;
  rawColumnType?: InputMaybe<AssetsDmObjectsListRawColumnType>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  tagCodes?: InputMaybe<Array<Scalars['Int']['input']>>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
  whereDataSource?: InputMaybe<Scalars['String']['input']>;
};

export enum AssetsDmObjectsListSearchOperator {
  AfterNext = 'AFTER_NEXT',
  ComputeIssues = 'COMPUTE_ISSUES',
  Contains = 'CONTAINS',
  Empty = 'EMPTY',
  EndsWith = 'ENDS_WITH',
  /**  Conditional Operators */
  Equals = 'EQUALS',
  GreaterThan = 'GREATER_THAN',
  /**  Multiple Values Operators */
  In = 'IN',
  Known = 'KNOWN',
  LessThan = 'LESS_THAN',
  /**  Other Operators */
  Mapped = 'MAPPED',
  NotContains = 'NOT_CONTAINS',
  NotEmpty = 'NOT_EMPTY',
  NotEndsWith = 'NOT_ENDS_WITH',
  NotEquals = 'NOT_EQUALS',
  NotIn = 'NOT_IN',
  NotMapped = 'NOT_MAPPED',
  NotNull = 'NOT_NULL',
  NotNullOrEmpty = 'NOT_NULL_OR_EMPTY',
  NotStartsWith = 'NOT_STARTS_WITH',
  /**  Null & Empty Operators */
  Null = 'NULL',
  NullOrEmpty = 'NULL_OR_EMPTY',
  OlderThan = 'OLDER_THAN',
  StartsWith = 'STARTS_WITH',
  Unknown = 'UNKNOWN',
  WithinLast = 'WITHIN_LAST',
  WithinNext = 'WITHIN_NEXT'
}

export type AssetsDmObjectsListSortBy = {
  name: Scalars['String']['input'];
  order: AssetsDmObjectsListSortOrder;
};

export enum AssetsDmObjectsListSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

/**
 *  Common types for Assets DM API
 *  Pagination types for Assets DM
 */
export type AssetsDmPaginationInput = {
  pageCursor?: Scalars['Int']['input'];
  pageSize?: Scalars['Int']['input'];
};

/**
 *  Pagination types are defined in common.nadel
 *  Filter types for raw data
 */
export type AssetsDmRawDataFilterInput = {
  name: Scalars['String']['input'];
  type: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
  valueTo?: InputMaybe<Scalars['String']['input']>;
};

export type AssetsDmSavedSearchInput = {
  searchGroups?: Array<AssetsDmObjectsListSearchGroup>;
};

export type AssetsDmSavedSearchesQueryArgs = {
  isPublic?: Scalars['Boolean']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

export type AssetsDmSortByInput = {
  name: Scalars['String']['input'];
  order?: AssetsDmSortByInputOrder;
};

export enum AssetsDmSortByInputOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export enum AssetsDmStepStatus {
  Blocked = 'BLOCKED',
  Completed = 'COMPLETED',
  Error = 'ERROR',
  NotStarted = 'NOT_STARTED',
  Outdated = 'OUTDATED'
}

/**
 *  Pagination types are defined in common.nadel
 *  Filter types for transformed data
 */
export type AssetsDmTransformedDataFilterInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
  valueTo?: InputMaybe<Scalars['String']['input']>;
};

export type AssetsDmUpdateAttributePriorityInput = {
  dataSourceId: Scalars['ID']['input'];
  objectAttributeId: Scalars['ID']['input'];
  objectAttributePriorityId: Scalars['ID']['input'];
  priority: Scalars['Int']['input'];
};

export type AssetsDmUpdateAttributePriorityOrderInput = {
  increase: Scalars['Boolean']['input'];
  objectAttributePriorityId: Scalars['ID']['input'];
};

export type AssetsDmUpdateCleansingReasonInput = {
  reason: Scalars['String']['input'];
  reasonCode: Scalars['Int']['input'];
  reasonId: Scalars['ID']['input'];
  tenantId: Scalars['ID']['input'];
};

export type AssetsDmUpdateDataSourceArgs = {
  cloudId: Scalars['ID']['input'];
  input: AssetsDmUpdateDataSourceInput;
  workspaceId: Scalars['ID']['input'];
};

export type AssetsDmUpdateDataSourceInput = {
  dataSourceId: Scalars['ID']['input'];
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  refreshGap?: InputMaybe<Scalars['Int']['input']>;
};

export type AssetsDmUpdateDataSourcePriorityArgs = {
  cloudId: Scalars['ID']['input'];
  input: AssetsDmUpdateDataSourcePriorityInput;
  workspaceId: Scalars['ID']['input'];
};

export type AssetsDmUpdateDataSourcePriorityInput = {
  dataSourceId: Scalars['ID']['input'];
  increase: Scalars['Boolean']['input'];
};

export type AssetsDmUpdateDataSourceTypeInput = {
  dataSourceTypeId: Scalars['ID']['input'];
  defaultGap?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  tenantId?: InputMaybe<Scalars['String']['input']>;
};

export type AssetsDmUpdateDefaultCleansingRuleInput = {
  dataSourceTypeId?: InputMaybe<Scalars['ID']['input']>;
  defFunctionId: Scalars['ID']['input'];
  defaultFunctionId: Scalars['ID']['input'];
  defaultFunctionParameters?: InputMaybe<Array<InputMaybe<AssetsDmDefaultFunctionParameterInput>>>;
  enabled: Scalars['Boolean']['input'];
  objectId?: InputMaybe<Scalars['ID']['input']>;
  priority: Scalars['Int']['input'];
  reasonId: Scalars['ID']['input'];
};

export enum AssetsStatusCategory {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  Pending = 'PENDING'
}

export type AssignIssueParentInput = {
  boardId: Scalars['ID']['input'];
  issueIds: Array<Scalars['ID']['input']>;
  issueParentId: Scalars['ID']['input'];
};

/** Hosting type where Atlassian product instance is installed. */
export enum AtlassianProductHostingType {
  Cloud = 'CLOUD',
  DataCenter = 'DATA_CENTER',
  Server = 'SERVER'
}

/** Accepts input to attach a data manager to a component. */
export type AttachCompassComponentDataManagerInput = {
  /** The ID of the component to attach a data manager to. */
  componentId: Scalars['ID']['input'];
  /** An URL of the external source of the component's data. */
  externalSourceURL?: InputMaybe<Scalars['URL']['input']>;
};

export type AttachEventSourceInput = {
  /** The ID of the component to attach the event source to. */
  componentId: Scalars['ID']['input'];
  /** The ID of the event source. */
  eventSourceId: Scalars['ID']['input'];
};

export enum AuthClientType {
  AtlassianMobile = 'ATLASSIAN_MOBILE',
  ThirdParty = 'THIRD_PARTY',
  ThirdPartyNative = 'THIRD_PARTY_NATIVE'
}

/** Payload to invoke an AUX Effect */
export type AuxEffectsInvocationPayload = {
  /** Configuration arguments for the instance of the AUX extension */
  config?: InputMaybe<Scalars['JSON']['input']>;
  /** Environment information about where the effects are dispatched from */
  context: Scalars['JSON']['input'];
  /** A signed token representing the context information of the extension */
  contextToken?: InputMaybe<Scalars['String']['input']>;
  /** The effects to action inside the function */
  effects: Array<Scalars['JSON']['input']>;
  /** Dynamic data from the extension point */
  extensionPayload?: InputMaybe<Scalars['JSON']['input']>;
  /** The current state of the AUX extension */
  state: Scalars['JSON']['input'];
};

/** The input for a Avatar for a Third Party Repository */
export type AvatarInput = {
  /** The description of the avatar. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the avatar. */
  webUrl?: InputMaybe<Scalars['String']['input']>;
};

export enum BackendExperiment {
  Einstein = 'EINSTEIN'
}

export type BatchedInlineTasksInput = {
  contentId: Scalars['ID']['input'];
  tasks: Array<InputMaybe<InlineTask>>;
  trigger?: InputMaybe<PageUpdateTrigger>;
};

export enum BillingSourceSystem {
  Ccp = 'CCP',
  Hams = 'HAMS'
}

/** Bitbucket Permission Enum */
export enum BitbucketPermission {
  /** Bitbucket admin permission */
  Admin = 'ADMIN'
}

/**
 * -----------------------------------------------
 * !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
 * !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
 * -----------------------------------------------
 */
export type BlockServiceBatchRetrieveBlocksInput = {
  blockAris: Array<Scalars['String']['input']>;
  blockIdentifiers?: InputMaybe<Array<BlockServiceBlockIdentifierInput>>;
  documentAri?: InputMaybe<Scalars['String']['input']>;
};

export type BlockServiceBlockIdentifierInput = {
  blockAri: Scalars['String']['input'];
  blockInstanceId?: InputMaybe<Scalars['String']['input']>;
};

export type BlockServiceBlockNodeInput = {
  blockAri: Scalars['String']['input'];
  blockInstanceId: Scalars['String']['input'];
};

/** The product type for a synced block */
export enum BlockServiceBlockProduct {
  ConfluencePage = 'CONFLUENCE_PAGE',
  JiraWorkItem = 'JIRA_WORK_ITEM'
}

export type BlockServiceCreateBlockInput = {
  blockAri: Scalars['String']['input'];
  blockInstanceId: Scalars['String']['input'];
  content: Scalars['String']['input'];
  product: BlockServiceBlockProduct;
  sourceAri: Scalars['String']['input'];
  status?: InputMaybe<Scalars['String']['input']>;
  stepVersion?: InputMaybe<Scalars['Float']['input']>;
};

export type BlockServiceDeleteBlockInput = {
  blockAri: Scalars['String']['input'];
  deletionReason?: InputMaybe<Scalars['String']['input']>;
};

export type BlockServiceUpdateBlockInput = {
  blockAri: Scalars['String']['input'];
  content: Scalars['String']['input'];
  stepVersion?: InputMaybe<Scalars['Float']['input']>;
};

export type BlockServiceUpdateDocumentReferencesInput = {
  blocks: Array<BlockServiceBlockNodeInput>;
  documentAri: Scalars['String']['input'];
  noContent?: InputMaybe<Scalars['Boolean']['input']>;
};

export type BlockedAccessSubjectInput = {
  subjectId: Scalars['ID']['input'];
  subjectType: BlockedAccessSubjectType;
};

export enum BlockedAccessSubjectType {
  Group = 'GROUP',
  User = 'USER'
}

export type BoardCardMoveInput = {
  /** the ID of a board */
  boardId?: InputMaybe<Scalars['ID']['input']>;
  /** The IDs of cards to move */
  cardIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Card information on where card should be positioned */
  rank?: InputMaybe<CardRank>;
  /** The swimlane position, which might set additional fields */
  swimlaneId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the transition */
  transition?: InputMaybe<Scalars['ID']['input']>;
};

export enum BoardFeatureStatus {
  ComingSoon = 'COMING_SOON',
  Disabled = 'DISABLED',
  Enabled = 'ENABLED'
}

export enum BoardFeatureToggleStatus {
  Disabled = 'DISABLED',
  Enabled = 'ENABLED'
}

/** Available strategies for grouping issues into swimlanes for a classic board */
export enum BoardSwimlaneStrategy {
  AssigneeUnassignedFirst = 'ASSIGNEE_UNASSIGNED_FIRST',
  AssigneeUnassignedLast = 'ASSIGNEE_UNASSIGNED_LAST',
  Custom = 'CUSTOM',
  Epic = 'EPIC',
  IssueChildren = 'ISSUE_CHILDREN',
  IssueParent = 'ISSUE_PARENT',
  None = 'NONE',
  ParentChild = 'PARENT_CHILD',
  Project = 'PROJECT',
  RequestType = 'REQUEST_TYPE'
}

export enum BodyFormatType {
  AnonymousExportView = 'ANONYMOUS_EXPORT_VIEW',
  AtlasDocFormat = 'ATLAS_DOC_FORMAT',
  Editor = 'EDITOR',
  Editor2 = 'EDITOR2',
  ExportView = 'EXPORT_VIEW',
  Storage = 'STORAGE',
  StyledView = 'STYLED_VIEW',
  View = 'VIEW'
}

export type BooleanUserInput = {
  type: BooleanUserInputType;
  value?: InputMaybe<Scalars['Boolean']['input']>;
  variableName: Scalars['String']['input'];
};

export enum BooleanUserInputType {
  Boolean = 'BOOLEAN'
}

export type BulkArchivePagesInput = {
  archiveNote?: InputMaybe<Scalars['String']['input']>;
  areChildrenIncluded?: InputMaybe<Scalars['Boolean']['input']>;
  descendantsNoteApplicationOption?: InputMaybe<DescendantsNoteApplicationOption>;
  excludedBranchRootPageIDs?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  isSelected?: InputMaybe<Scalars['Boolean']['input']>;
  pageID: Scalars['Long']['input'];
};

/** Accepts input for deleting multiple existing components. */
export type BulkDeleteCompassComponentsInput = {
  /** A list of IDs of components being deleted. All IDs must belong in the same workspace. */
  ids: Array<Scalars['ID']['input']>;
};

export type BulkDeleteContentDataClassificationLevelInput = {
  contentStatuses: Array<InputMaybe<ContentDataClassificationMutationContentStatus>>;
  id: Scalars['Long']['input'];
};

export type BulkRemoveRoleAssignmentFromSpacesInput = {
  principal: RoleAssignmentPrincipalInput;
  spaceTypes: Array<InputMaybe<BulkRoleAssignmentSpaceType>>;
};

export enum BulkRoleAssignmentSpaceType {
  Collaboration = 'COLLABORATION',
  Global = 'GLOBAL',
  KnowledgeBase = 'KNOWLEDGE_BASE',
  Personal = 'PERSONAL'
}

export type BulkSetRoleAssignmentToSpacesInput = {
  roleAssignment: RoleAssignment;
  spaceTypes: Array<InputMaybe<BulkRoleAssignmentSpaceType>>;
};

export type BulkSetSpacePermissionInput = {
  spacePermissions: Array<InputMaybe<SpacePermissionType>>;
  spaceTypes: Array<InputMaybe<BulkSetSpacePermissionSpaceType>>;
  subjectId: Scalars['ID']['input'];
  subjectType: BulkSetSpacePermissionSubjectType;
};

export enum BulkSetSpacePermissionSpaceType {
  Collaboration = 'COLLABORATION',
  Global = 'GLOBAL',
  KnowledgeBase = 'KNOWLEDGE_BASE',
  Personal = 'PERSONAL'
}

export enum BulkSetSpacePermissionSubjectType {
  AccessClass = 'ACCESS_CLASS',
  Group = 'GROUP',
  User = 'USER'
}

/** Accepts input for updating multiple existing components. */
export type BulkUpdateCompassComponentsInput = {
  /** A list of IDs of components being updated. All IDs must belong in the same workspace. */
  ids: Array<Scalars['ID']['input']>;
  /** The updated state of the components. */
  state?: InputMaybe<Scalars['String']['input']>;
};

export type BulkUpdateContentDataClassificationLevelInput = {
  classificationLevelId: Scalars['ID']['input'];
  contentStatuses: Array<InputMaybe<ContentDataClassificationMutationContentStatus>>;
  id: Scalars['Long']['input'];
};

export type BulkUpdateMainSpaceSidebarLinksInput = {
  hidden: Scalars['Boolean']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  linkIdentifier?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<SpaceSidebarLinkType>;
};

/** Input payload to cancel an app version rollout */
export type CancelAppVersionRolloutInput = {
  id: Scalars['ID']['input'];
};

export enum CapabilitySet {
  CapabilityAdvanced = 'capabilityAdvanced',
  CapabilityStandard = 'capabilityStandard'
}

export enum CardHierarchyLevelEnumType {
  Base = 'BASE',
  Child = 'CHILD',
  Parent = 'PARENT'
}

export type CardParentCreateInput = {
  boardId: Scalars['ID']['input'];
  newIssueParents: Array<NewCardParent>;
};

export type CardParentRankInput = {
  boardId: Scalars['ID']['input'];
  issueParentIds: Array<Scalars['ID']['input']>;
  rankAfterIssueParentId?: InputMaybe<Scalars['Long']['input']>;
  rankBeforeIssueParentId?: InputMaybe<Scalars['Long']['input']>;
};

export type CardRank = {
  /** The card that is after this card */
  afterCardId?: InputMaybe<Scalars['ID']['input']>;
  /** The card that is before this card */
  beforeCardId?: InputMaybe<Scalars['ID']['input']>;
};

export enum CatchupContentType {
  Blogpost = 'BLOGPOST',
  Page = 'PAGE'
}

export enum CatchupOverviewUpdateType {
  SinceLastViewed = 'SINCE_LAST_VIEWED',
  SinceLastViewedMarkdown = 'SINCE_LAST_VIEWED_MARKDOWN',
  SinceXDays = 'SINCE_X_DAYS'
}

export enum CcpActivationReason {
  AdvantagePricing = 'ADVANTAGE_PRICING',
  DefaultPricing = 'DEFAULT_PRICING',
  ExperimentalPricing = 'EXPERIMENTAL_PRICING'
}

export enum CcpAllowancePoolAllocationDetailsType {
  Custom = 'CUSTOM',
  Default = 'DEFAULT'
}

export enum CcpAndOr {
  And = 'AND',
  Or = 'OR'
}

export enum CcpBehaviourAtEndOfTrial {
  /** Cancels the entitlement after trial ends */
  Cancel = 'CANCEL',
  /** Converts the trial to paid after trial ends */
  ConvertToPaid = 'CONVERT_TO_PAID',
  /** Reverts to previous offering after trial ends */
  RevertTrial = 'REVERT_TRIAL'
}

export enum CcpBenefitValueAppliedOn {
  Renew = 'RENEW',
  Total = 'TOTAL',
  Upsell = 'UPSELL'
}

export enum CcpBillingInterval {
  Day = 'DAY',
  Month = 'MONTH',
  Week = 'WEEK',
  Year = 'YEAR'
}

export enum CcpCancelEntitlementExperienceCapabilityReasonCode {
  EntitlementIsCollectionInstance = 'ENTITLEMENT_IS_COLLECTION_INSTANCE'
}

export type CcpChargeElementLatestAllowancesInput = {
  entityId?: InputMaybe<Scalars['String']['input']>;
  entityType: CcpLatestAllowancesEntityType;
  page?: InputMaybe<Scalars['Int']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  usageKey: Scalars['String']['input'];
};

export enum CcpChargeType {
  AutoScaling = 'AUTO_SCALING',
  Licensed = 'LICENSED',
  Metered = 'METERED'
}

export type CcpCompareOfferingsHighlightedOfferingInput = {
  /** The offering key for the offering that will be highlighted as recommended. Only one of offeringKey or offeringName can be provided. */
  offeringKey?: InputMaybe<Scalars['ID']['input']>;
  /** The offering name in the default group that will be highlighted as recommended. Only one of offeringKey or offeringName can be provided. */
  offeringName?: InputMaybe<Scalars['String']['input']>;
};

export type CcpCompareOfferingsInput = {
  highlightedOffering?: InputMaybe<CcpCompareOfferingsHighlightedOfferingInput>;
};

export type CcpCreateEntitlementExistingEntitlement = {
  entitlementId: Scalars['ID']['input'];
};

export enum CcpCreateEntitlementExperienceCapabilityErrorReasonCode {
  AnnualToMonthlyTransition = 'ANNUAL_TO_MONTHLY_TRANSITION',
  AnnualTransitionNotSupported = 'ANNUAL_TRANSITION_NOT_SUPPORTED',
  EntitlementsInDifferentIg = 'ENTITLEMENTS_IN_DIFFERENT_IG',
  EntitlementsInDifferentTxa = 'ENTITLEMENTS_IN_DIFFERENT_TXA',
  EntitlementsOnDifferentBillingCycle = 'ENTITLEMENTS_ON_DIFFERENT_BILLING_CYCLE',
  InsufficientInput = 'INSUFFICIENT_INPUT',
  InvoiceGroupInDunning = 'INVOICE_GROUP_IN_DUNNING',
  MultipleTransactionAccount = 'MULTIPLE_TRANSACTION_ACCOUNT',
  NoOfferingForProduct = 'NO_OFFERING_FOR_PRODUCT',
  UnableToSourceTxa = 'UNABLE_TO_SOURCE_TXA',
  UsecaseNotImplemented = 'USECASE_NOT_IMPLEMENTED'
}

export type CcpCreateEntitlementExperienceOptions = {
  /** Configures what is displayed on confirmation screen */
  confirmationScreen?: InputMaybe<CcpCreateEntitlementExperienceOptionsConfirmationScreen>;
};

export enum CcpCreateEntitlementExperienceOptionsConfirmationScreen {
  /** Show comparison screen for confirmation screen */
  Comparison = 'COMPARISON',
  /** Show default screen for confirmation screen */
  Default = 'DEFAULT'
}

export type CcpCreateEntitlementInput = {
  /** Options to modify experience screens in creation order flow */
  experienceOptions?: InputMaybe<CcpCreateEntitlementExperienceOptions>;
  /**
   * Fallback entitlement IDs.
   * This serves as a fallback option to retrieve a valid transaction account ID from the order defaults API
   * when the entitlement IDs from relatedEntitlements result in a null transaction account ID.
   */
  fallbackEntitlementIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** The offering ID to create entitlement for. Required if productKey is not provided */
  offeringKey?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The offering name for the offering to be created.
   * Will only be used if productKey is specified
   */
  offeringName?: InputMaybe<Scalars['String']['input']>;
  /** Options for the order to create the entitlement */
  orderOptions?: InputMaybe<CcpCreateEntitlementOrderOptions>;
  /** The product ID to create entitlement on. Required if offeringKey is not provided */
  productKey?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Related entitlements for the main entitlement to be created.
   * Where orders involve multiple related entitlements (e.g. collections, Jira Family, etc),
   * this specifies which existing entitlements should be linked to or how new entitlements should be created.
   */
  relatedEntitlements?: InputMaybe<Array<CcpCreateEntitlementRelationship>>;
};

export type CcpCreateEntitlementNewEntitlement = {
  /** The name of the site that the product will be created on */
  hostName?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the offering to be created */
  offeringId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the product to be created, must be provided if offeringId is not provided */
  productId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Additional related entitlements to connect.
   * For example when creating a collection, a related entitlement might be Jira,
   * and the Jira itself might additionally relate to a new or existing Jira Family
   * Container entitlement .
   */
  relatedEntitlements?: InputMaybe<Array<CcpCreateEntitlementRelationship>>;
};

export type CcpCreateEntitlementOrderOptions = {
  /** Which billing cycle to create the entitlement for, only MONTH and YEAR is supported at the moment. Defaults to MONTH if not provided */
  billingCycle?: InputMaybe<CcpBillingInterval>;
  /** The provisioning request identifier */
  provisioningRequestId?: InputMaybe<Scalars['ID']['input']>;
  /** Trial intent */
  trial?: InputMaybe<CcpCreateEntitlementTrialIntent>;
};

/**
 * Arguments for additional related entitlements. Separate cases for linking to
 * an existing entitlement, and for creating a new entitlement.
 */
export type CcpCreateEntitlementRelationship = {
  /** The direction of the relationship */
  direction: CcpOfferingRelationshipDirection;
  /** The entitlement */
  entitlement: CcpCreateEntitlementRelationshipEntitlement;
  /** The relationship type, e.g. COLLECTION, FAMILY_CONTAINER, etc */
  relationshipType: CcpRelationshipType;
};

export type CcpCreateEntitlementRelationshipEntitlement = {
  existingEntitlement?: InputMaybe<CcpCreateEntitlementExistingEntitlement>;
  newEntitlement?: InputMaybe<CcpCreateEntitlementNewEntitlement>;
};

export type CcpCreateEntitlementTrialIntent = {
  /**
   * Configures behavior at end of trial to support auto/non-auto converting trials
   * https://hello.atlassian.net/wiki/spaces/tintin/pages/4544550787/Offering+Types+and+Valid+Trial+Intent+Behaviours
   */
  behaviourAtEndOfTrial?: InputMaybe<CcpBehaviourAtEndOfTrial>;
  /** Should entitlement be created without trial */
  skipTrial?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum CcpCurrency {
  Jpy = 'JPY',
  Usd = 'USD'
}

export enum CcpCustomizationSetCouplingOperationComparator {
  Equal = 'EQUAL',
  GreaterThan = 'GREATER_THAN',
  GreaterThanOrEqual = 'GREATER_THAN_OR_EQUAL',
  LessThan = 'LESS_THAN',
  LessThanOrEqual = 'LESS_THAN_OR_EQUAL',
  MatchTo = 'MATCH_TO'
}

export enum CcpCustomizationSetCouplingOperationComputeArgumentTag {
  MultiInstanceTag = 'MULTI_INSTANCE_TAG'
}

export enum CcpCustomizationSetCouplingOperationRelaxContextInTrial {
  Any = 'ANY',
  Both = 'BOTH',
  From = 'FROM',
  To = 'TO'
}

export enum CcpCustomizationSetCouplingOperationSource {
  Relationship = 'RELATIONSHIP',
  RelationshipFrom = 'RELATIONSHIP_FROM',
  RelationshipTo = 'RELATIONSHIP_TO',
  RelationshipToMax = 'RELATIONSHIP_TO_MAX'
}

export enum CcpCustomizationSetCouplingOperationType {
  Compute = 'COMPUTE',
  Constraint = 'CONSTRAINT'
}

export enum CcpCustomizationSetCouplingType {
  CouplingBillingAnchorDate = 'COUPLING_BILLING_ANCHOR_DATE',
  CouplingBillingCycle = 'COUPLING_BILLING_CYCLE',
  CouplingBillingTermedDate = 'COUPLING_BILLING_TERMED_DATE',
  CouplingChargeElementBillableLimit = 'COUPLING_CHARGE_ELEMENT_BILLABLE_LIMIT',
  CouplingChargeType = 'COUPLING_CHARGE_TYPE',
  CouplingInvoiceGroup = 'COUPLING_INVOICE_GROUP',
  CouplingTagMultiInstanceType = 'COUPLING_TAG_MULTI_INSTANCE_TYPE',
  CouplingTransactionAccount = 'COUPLING_TRANSACTION_ACCOUNT',
  CouplingTrialEndDate = 'COUPLING_TRIAL_END_DATE'
}

export enum CcpDuration {
  Forever = 'FOREVER',
  Once = 'ONCE',
  Repeating = 'REPEATING'
}

export enum CcpEntitlementPreDunningStatus {
  InPreDunning = 'IN_PRE_DUNNING',
  NotInPreDunning = 'NOT_IN_PRE_DUNNING'
}

export enum CcpEntitlementStatus {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

export enum CcpEntitlementTemplateStatus {
  Deprecated = 'DEPRECATED',
  None = 'NONE',
  Published = 'PUBLISHED',
  Unpublished = 'UNPUBLISHED'
}

export enum CcpExtensionEntityType {
  Offering = 'OFFERING',
  PricingPlan = 'PRICING_PLAN',
  Product = 'PRODUCT'
}

export enum CcpLatestAllowanceEnforcementModeType {
  Block = 'BLOCK',
  LimitedOverage = 'LIMITED_OVERAGE',
  Overage = 'OVERAGE'
}

export enum CcpLatestAllowancesEntityType {
  Cloud = 'CLOUD',
  Entitlement = 'ENTITLEMENT',
  Organization = 'ORGANIZATION',
  User = 'USER'
}

/** Error codes for license retrieval failures */
export enum CcpLicenseErrorCode {
  /** Active License not found for the given entitlement (L-ERR-4007) */
  ActiveLicenseNotFound = 'ACTIVE_LICENSE_NOT_FOUND',
  /** Internal server error */
  InternalError = 'INTERNAL_ERROR',
  /** License not found for the given entitlement (L-ERR-4005) */
  LicenseNotFound = 'LICENSE_NOT_FOUND',
  /** Server ID is missing (L-ERR-4006) */
  ServerIdMissing = 'SERVER_ID_MISSING'
}

export type CcpMeteredChargeElementAggregatedInput = {
  chargeElementName: Scalars['String']['input'];
  end: Scalars['Float']['input'];
  groupByDimensions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  page: Scalars['Int']['input'];
  pageSize: Scalars['Int']['input'];
  resolution: CcpUsageQueryResolution;
  start: Scalars['Float']['input'];
  statistics: CcpUsageQueryStatistics;
};

export type CcpMeteredChargeElementLatestUsageInput = {
  chargeElementName: Scalars['String']['input'];
  chargeElementType: CcpMeteredChargeElementType;
  groupByDimensions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export enum CcpMeteredChargeElementType {
  Counter = 'COUNTER',
  Gauge = 'GAUGE'
}

export enum CcpOfferingHostingType {
  Cloud = 'CLOUD',
  Datacenter = 'DATACENTER'
}

export enum CcpOfferingRelationshipDirection {
  From = 'FROM',
  To = 'TO'
}

export enum CcpOfferingRelationshipTemplateConditionsHostingType {
  Cloud = 'CLOUD',
  Datacenter = 'DATACENTER',
  Server = 'SERVER'
}

export enum CcpOfferingRelationshipTemplateCustomizationSet {
  AddOnBillingCoupled = 'ADD_ON_BILLING_COUPLED',
  AppDatacenter = 'APP_DATACENTER',
  CollectionEnterprise = 'COLLECTION_ENTERPRISE',
  CollectionNonEnterprise = 'COLLECTION_NON_ENTERPRISE',
  CollectionTrialEnterprise = 'COLLECTION_TRIAL_ENTERPRISE',
  Enterprise = 'ENTERPRISE',
  EnterpriseSandboxGrant = 'ENTERPRISE_SANDBOX_GRANT',
  JiraFamily = 'JIRA_FAMILY',
  Marketplace = 'MARKETPLACE',
  MarketplaceMultiInstance = 'MARKETPLACE_MULTI_INSTANCE',
  MultiInstance = 'MULTI_INSTANCE',
  Sandbox = 'SANDBOX',
  SandboxDependenceContainer = 'SANDBOX_DEPENDENCE_CONTAINER',
  SandboxGrant = 'SANDBOX_GRANT'
}

export enum CcpOfferingRelationshipTemplateOverrideTrigger {
  Any = 'ANY',
  CouplingConstraintMultiInstanceTag = 'COUPLING_CONSTRAINT_MULTI_INSTANCE_TAG',
  CreatingFrom = 'CREATING_FROM',
  CreatingTo = 'CREATING_TO',
  DeactivatingFrom = 'DEACTIVATING_FROM',
  DeactivatingTo = 'DEACTIVATING_TO',
  TermEndDateOnFrom = 'TERM_END_DATE_ON_FROM',
  UpdatingFrom = 'UPDATING_FROM',
  UpdatingTo = 'UPDATING_TO'
}

export enum CcpOfferingRelationshipTemplateOverrideType {
  DeactivateEntitlement = 'DEACTIVATE_ENTITLEMENT',
  DeactivateRelationship = 'DEACTIVATE_RELATIONSHIP',
  DeactivateTo = 'DEACTIVATE_TO',
  InheritChargeElementBillableLimit = 'INHERIT_CHARGE_ELEMENT_BILLABLE_LIMIT',
  InheritTrialEndDate = 'INHERIT_TRIAL_END_DATE',
  SoftTermEntitlement = 'SOFT_TERM_ENTITLEMENT'
}

export enum CcpOfferingRelationshipTemplateProcessorConfigStrategy {
  ComputeGlpAsWhole = 'COMPUTE_GLP_AS_WHOLE'
}

export enum CcpOfferingRelationshipTemplateStatus {
  Active = 'ACTIVE',
  Deprecated = 'DEPRECATED',
  Draft = 'DRAFT',
  None = 'NONE'
}

export enum CcpOfferingRelationshipTemplateType {
  AddonDependence = 'ADDON_DEPENDENCE',
  AppCompatibility = 'APP_COMPATIBILITY',
  AppDependence = 'APP_DEPENDENCE',
  Collection = 'COLLECTION',
  CollectionTrial = 'COLLECTION_TRIAL',
  Enterprise = 'ENTERPRISE',
  EnterpriseSandboxGrant = 'ENTERPRISE_SANDBOX_GRANT',
  FamilyContainer = 'FAMILY_CONTAINER',
  MultiInstance = 'MULTI_INSTANCE',
  SandboxDependence = 'SANDBOX_DEPENDENCE',
  SandboxGrant = 'SANDBOX_GRANT'
}

export enum CcpOfferingRouteBehaviourEnum {
  DefaultPricing = 'DEFAULT_PRICING',
  Legacy = 'LEGACY',
  PricingMigration = 'PRICING_MIGRATION'
}

export enum CcpOfferingStatus {
  Active = 'ACTIVE',
  AtNotice = 'AT_NOTICE',
  Draft = 'DRAFT',
  Expired = 'EXPIRED'
}

export enum CcpOfferingType {
  Child = 'CHILD',
  Parent = 'PARENT'
}

export enum CcpOfferingUncollectibleActionType {
  Cancel = 'CANCEL',
  Downgrade = 'DOWNGRADE',
  NoAction = 'NO_ACTION'
}

/** Arguments for order-defaults */
export type CcpOrderDefaultsInput = {
  country?: InputMaybe<Scalars['String']['input']>;
  currentEntitlementId?: InputMaybe<Scalars['String']['input']>;
  offeringId?: InputMaybe<Scalars['String']['input']>;
};

/** Enum for payment method types */
export enum CcpPaymentMethodType {
  Ach = 'ACH',
  Card = 'CARD',
  Deferred = 'DEFERRED',
  Paypal = 'PAYPAL'
}

export type CcpPlaceOrderLiteTargetOfferingInput = {
  /** The offering key for the offering that will be placed. Only one of offeringKey or offeringName can be provided. */
  offeringKey?: InputMaybe<Scalars['ID']['input']>;
  /** The offering name in the default group that will be placed. Only one of offeringKey or offeringName can be provided. */
  offeringName?: InputMaybe<Scalars['String']['input']>;
};

export enum CcpPricingPlanStatus {
  Active = 'ACTIVE',
  AtNotice = 'AT_NOTICE',
  Draft = 'DRAFT',
  Expired = 'EXPIRED'
}

export enum CcpPricingType {
  External = 'EXTERNAL',
  Free = 'FREE',
  LimitedFree = 'LIMITED_FREE',
  Paid = 'PAID'
}

export enum CcpProductStatus {
  Active = 'ACTIVE',
  AtNotice = 'AT_NOTICE',
  Draft = 'DRAFT',
  Expired = 'EXPIRED'
}

export enum CcpPromotionAllowedRedemptionMethod {
  Promotion = 'PROMOTION',
  PromotionCode = 'PROMOTION_CODE'
}

export enum CcpPromotionBenefitType {
  Discount = 'DISCOUNT',
  Override = 'OVERRIDE'
}

export enum CcpPromotionBillingPeriodPrev {
  Free = 'FREE',
  Paid = 'PAID',
  Trial = 'TRIAL'
}

export enum CcpPromotionCodeType {
  None = 'NONE',
  Shared = 'SHARED',
  Unique = 'UNIQUE'
}

export enum CcpPromotionDynamicFieldEvaluatorComparator {
  Equal = 'EQUAL',
  GreaterThan = 'GREATER_THAN',
  LessThan = 'LESS_THAN',
  LessThanEqual = 'LESS_THAN_EQUAL',
  NotEqual = 'NOT_EQUAL',
  NotNull = 'NOT_NULL',
  Null = 'NULL'
}

export enum CcpPromotionDynamicFieldEvaluatorType {
  Number = 'NUMBER',
  String = 'STRING'
}

export enum CcpPromotionEligibilityPricingType {
  Free = 'FREE',
  LimitedFree = 'LIMITED_FREE',
  Paid = 'PAID'
}

export enum CcpPromotionHostingType {
  Cloud = 'CLOUD',
  Datacenter = 'DATACENTER',
  Server = 'SERVER'
}

export enum CcpPromotionLimiterType {
  Range = 'RANGE',
  Set = 'SET'
}

export enum CcpPromotionSaleTransitionType {
  Downgrade = 'DOWNGRADE',
  New = 'NEW',
  Renewal = 'RENEWAL',
  Upgrade = 'UPGRADE'
}

export enum CcpPromotionStatus {
  Active = 'ACTIVE',
  Cancelled = 'CANCELLED',
  Drafted = 'DRAFTED',
  Expired = 'EXPIRED',
  Inactive = 'INACTIVE',
  Withdrawn = 'WITHDRAWN'
}

export enum CcpPromotionSubBenefitType {
  Flat = 'FLAT',
  MultiPercentage = 'MULTI_PERCENTAGE',
  None = 'NONE',
  Percentage = 'PERCENTAGE',
  Trial = 'TRIAL'
}

export enum CcpPromotionType {
  DiscretionaryDiscount = 'DISCRETIONARY_DISCOUNT',
  ListPrice = 'LIST_PRICE',
  ListPriceAdjustment = 'LIST_PRICE_ADJUSTMENT',
  LoyaltyDiscount = 'LOYALTY_DISCOUNT',
  PartnerDiscount = 'PARTNER_DISCOUNT',
  PartnerMargin = 'PARTNER_MARGIN',
  PromoCode = 'PROMO_CODE',
  TrialExtension = 'TRIAL_EXTENSION'
}

export enum CcpProrateOnUsageChange {
  AlwaysInvoice = 'ALWAYS_INVOICE',
  CreateProrations = 'CREATE_PRORATIONS',
  None = 'NONE'
}

export enum CcpQuoteContractType {
  NonStandard = 'NON_STANDARD',
  Standard = 'STANDARD'
}

export enum CcpQuoteEndDateType {
  Duration = 'DURATION',
  Timestamp = 'TIMESTAMP'
}

export enum CcpQuoteInterval {
  Year = 'YEAR'
}

export enum CcpQuoteLineItemStatus {
  Cancelled = 'CANCELLED',
  Stale = 'STALE'
}

export enum CcpQuoteLineItemType {
  AccountModification = 'ACCOUNT_MODIFICATION',
  AmendEntitlement = 'AMEND_ENTITLEMENT',
  CancelEntitlement = 'CANCEL_ENTITLEMENT',
  CreateEntitlement = 'CREATE_ENTITLEMENT',
  ReactivateEntitlement = 'REACTIVATE_ENTITLEMENT'
}

export enum CcpQuoteProrationBehaviour {
  CreateProrations = 'CREATE_PRORATIONS',
  None = 'NONE'
}

export enum CcpQuoteReferenceType {
  Entitlement = 'ENTITLEMENT',
  LineItem = 'LINE_ITEM'
}

export enum CcpQuoteStartDateType {
  QuoteAcceptanceDate = 'QUOTE_ACCEPTANCE_DATE',
  Timestamp = 'TIMESTAMP',
  UpcomingInvoice = 'UPCOMING_INVOICE'
}

export enum CcpQuoteStatus {
  AcceptanceInProgress = 'ACCEPTANCE_IN_PROGRESS',
  Accepted = 'ACCEPTED',
  CancellationInProgress = 'CANCELLATION_IN_PROGRESS',
  Cancelled = 'CANCELLED',
  CloningInProgress = 'CLONING_IN_PROGRESS',
  CreationInProgress = 'CREATION_IN_PROGRESS',
  Draft = 'DRAFT',
  FinalizationInProgress = 'FINALIZATION_IN_PROGRESS',
  Open = 'OPEN',
  RevisionInProgress = 'REVISION_IN_PROGRESS',
  Stale = 'STALE',
  UpdateInProgress = 'UPDATE_IN_PROGRESS',
  ValidationInProgress = 'VALIDATION_IN_PROGRESS'
}

export enum CcpRelationshipPricingType {
  AdvantagePricing = 'ADVANTAGE_PRICING',
  CurrencyGenerated = 'CURRENCY_GENERATED',
  NextPricing = 'NEXT_PRICING',
  SyntheticGenerated = 'SYNTHETIC_GENERATED'
}

export enum CcpRelationshipStatus {
  Active = 'ACTIVE',
  Deprecated = 'DEPRECATED'
}

export enum CcpRelationshipType {
  AddonDependence = 'ADDON_DEPENDENCE',
  AppCompatibility = 'APP_COMPATIBILITY',
  AppDependence = 'APP_DEPENDENCE',
  Collection = 'COLLECTION',
  CollectionTrial = 'COLLECTION_TRIAL',
  Enterprise = 'ENTERPRISE',
  EnterpriseSandboxGrant = 'ENTERPRISE_SANDBOX_GRANT',
  FamilyContainer = 'FAMILY_CONTAINER',
  MultiInstance = 'MULTI_INSTANCE',
  SandboxDependence = 'SANDBOX_DEPENDENCE',
  SandboxGrant = 'SANDBOX_GRANT'
}

export type CcpSearchFieldRangeInput = {
  bounds: CcpSearchTimestampBoundsInput;
  field: Scalars['String']['input'];
};

export type CcpSearchSortInput = {
  /** The field to sort by */
  field: Scalars['String']['input'];
  /** The order to sort by */
  order: CcpSearchSortOrder;
};

export enum CcpSearchSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type CcpSearchTimestampBoundsInput = {
  gte?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
};

export enum CcpSubscriptionScheduleAction {
  Cancel = 'CANCEL',
  Update = 'UPDATE'
}

export enum CcpSubscriptionStatus {
  Active = 'ACTIVE',
  Cancelled = 'CANCELLED',
  Processing = 'PROCESSING'
}

export enum CcpSupportedBillingSystems {
  BackOffice = 'BACK_OFFICE',
  Ccp = 'CCP',
  Hams = 'HAMS',
  Opsgenie = 'OPSGENIE'
}

export enum CcpTiersMode {
  Graduated = 'GRADUATED',
  Volume = 'VOLUME'
}

export enum CcpTransactionAccountType {
  Direct = 'DIRECT',
  Partner = 'PARTNER',
  UnaffiliatedReseller = 'UNAFFILIATED_RESELLER'
}

export enum CcpTrialEndBehaviour {
  BillingPlan = 'BILLING_PLAN',
  TrialPlan = 'TRIAL_PLAN'
}

export enum CcpUsageQueryResolution {
  OneDay = 'ONE_DAY',
  OneHour = 'ONE_HOUR',
  OneMonth = 'ONE_MONTH'
}

export enum CcpUsageQueryStatistics {
  Latest = 'LATEST',
  Sum = 'SUM'
}

export type ChangeManagementUpdateGlobalRiskAssessmentSettingsInput = {
  cloudId: Scalars['ID']['input'];
  isEnabled: Scalars['Boolean']['input'];
  projectId: Scalars['String']['input'];
};

export type ChangeManagementUpdateLastRovoRiskAssessmentInput = {
  cloudId: Scalars['ID']['input'];
  issueId: Scalars['String']['input'];
  response: Scalars['String']['input'];
};

export type ChangeManagementUpdateRovoRiskAssessmentSettingsInput = {
  cloudId: Scalars['ID']['input'];
  isBusinessEnabled: Scalars['Boolean']['input'];
  isComplianceEnabled: Scalars['Boolean']['input'];
  isOperationalEnabled: Scalars['Boolean']['input'];
  isTechnicalEnabled: Scalars['Boolean']['input'];
  knowledgeBases: Array<Scalars['String']['input']>;
  projectId: Scalars['String']['input'];
};

export type ChannelPlatformChannelAvailabilityRequestInput = {
  aaId?: InputMaybe<Scalars['String']['input']>;
  cloudId?: InputMaybe<Scalars['String']['input']>;
  cloudUrl?: InputMaybe<Scalars['String']['input']>;
  countryCode?: InputMaybe<Scalars['String']['input']>;
  customerTimezone?: InputMaybe<Scalars['String']['input']>;
  emailExclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  entitlementId?: InputMaybe<Scalars['String']['input']>;
  hipaaEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  impactLevel?: InputMaybe<Scalars['Int']['input']>;
  isCESFlagEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  product?: InputMaybe<Scalars['String']['input']>;
  productKey?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  skillSegment?: InputMaybe<Scalars['String']['input']>;
  supportChannel?: InputMaybe<Scalars['String']['input']>;
  supportLevel?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  unitCount?: InputMaybe<Scalars['Int']['input']>;
  userEmailDomain?: InputMaybe<Scalars['String']['input']>;
};

export enum ChannelPlatformChannelType {
  Chat = 'CHAT',
  Phone = 'PHONE',
  Ticket = 'TICKET',
  Voice = 'VOICE'
}

export type ChannelPlatformChatRequestDetailsRequest = {
  conversationId?: InputMaybe<Scalars['String']['input']>;
};

export enum ChannelPlatformContactState {
  Assigned = 'ASSIGNED',
  Closed = 'CLOSED',
  Initialized = 'INITIALIZED',
  Unassigned = 'UNASSIGNED'
}

export type ChannelPlatformEventRelayRequest = {
  channelType?: InputMaybe<ChannelPlatformChannelType>;
  conversationId?: InputMaybe<Scalars['String']['input']>;
  eventType?: InputMaybe<ChannelPlatformEventType>;
  payload?: InputMaybe<Scalars['JSON']['input']>;
};

export enum ChannelPlatformEventType {
  AgentInitialMessage = 'AGENT_INITIAL_MESSAGE',
  ConferenceEnded = 'CONFERENCE_ENDED',
  ConferenceInitiated = 'CONFERENCE_INITIATED',
  ConferenceResponse = 'CONFERENCE_RESPONSE',
  CustomChatClosed = 'CUSTOM_CHAT_CLOSED',
  CustomPhoneClosed = 'CUSTOM_PHONE_CLOSED',
  Hold = 'HOLD',
  Initiated = 'INITIATED',
  Mute = 'MUTE',
  Resume = 'RESUME',
  Unmute = 'UNMUTE'
}

export type ChannelPlatformGetChannelTokenRequest = {
  channelType?: InputMaybe<ChannelPlatformChannelType>;
  contactFlowId?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  instanceId?: InputMaybe<Scalars['String']['input']>;
};

export enum ChannelPlatformMutationStatus {
  Failure = 'FAILURE',
  Success = 'SUCCESS'
}

export enum ChannelPlatformParticipantRole {
  Agent = 'AGENT',
  Customer = 'CUSTOMER',
  CustomBot = 'CUSTOM_BOT',
  Supervisor = 'SUPERVISOR',
  System = 'SYSTEM'
}

export type ChannelPlatformPluginActionRequest = {
  actionName?: InputMaybe<Scalars['String']['input']>;
  appId?: InputMaybe<Scalars['String']['input']>;
  contactId?: InputMaybe<Scalars['String']['input']>;
  payload?: InputMaybe<Scalars['JSON']['input']>;
};

export type ChannelPlatformQuickResponseFilter = {
  includeNoExistence?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  operator: ChannelPlatformQuickResponseFilterOperator;
  values: Array<Scalars['String']['input']>;
};

export enum ChannelPlatformQuickResponseFilterOperator {
  Equals = 'EQUALS',
  Prefix = 'PREFIX'
}

export enum ChannelPlatformQuickResponseOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type ChannelPlatformQuickResponseOrderField = {
  name: Scalars['String']['input'];
  order: ChannelPlatformQuickResponseOrder;
};

export type ChannelPlatformQuickResponseQuery = {
  allowFuzziness?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  operator: ChannelPlatformQuickResponseQueryOperator;
  values: Array<Scalars['String']['input']>;
};

export enum ChannelPlatformQuickResponseQueryOperator {
  Contains = 'CONTAINS',
  ContainsAndPrefix = 'CONTAINS_AND_PREFIX'
}

export type ChannelPlatformQuickResponseSearchExpression = {
  filters?: InputMaybe<Array<ChannelPlatformQuickResponseFilter>>;
  orderOnField?: InputMaybe<ChannelPlatformQuickResponseOrderField>;
  queries?: InputMaybe<Array<ChannelPlatformQuickResponseQuery>>;
};

export type ChannelPlatformQuickResponseSearchRequest = {
  maxResults?: InputMaybe<Scalars['Int']['input']>;
  nextToken?: InputMaybe<Scalars['String']['input']>;
  searchExpression: ChannelPlatformQuickResponseSearchExpression;
};

export enum ChannelPlatformRole {
  Agent = 'AGENT',
  Customer = 'CUSTOMER'
}

export type ChannelPlatformSubmitRequestInput = {
  attributes?: InputMaybe<Scalars['JSON']['input']>;
  issueId?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Scalars['JSON']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  payload?: InputMaybe<Scalars['JSON']['input']>;
  resumeChat?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelPlatformTranscriptRequest = {
  contactId?: InputMaybe<Scalars['String']['input']>;
  isStaleTolerant?: InputMaybe<Scalars['Boolean']['input']>;
  role?: InputMaybe<ChannelPlatformRole>;
  startAfterChatMessageId?: InputMaybe<Scalars['String']['input']>;
};

/** The input arguments for checking if a user can authorise an app by OauthID */
export type CheckConsentPermissionByOAuthClientIdInput = {
  /** Cloud id where app is trying to be installed */
  cloudId: Scalars['ID']['input'];
  /** App's oauthClientId which will be checked against the DB if it's valid */
  oauthClientId: Scalars['ID']['input'];
  /** The requested scopes of the app connection. */
  scopes: Array<Scalars['String']['input']>;
  /** The User's Atlassian account ID to verify their permissions on the target site */
  userId: Scalars['ID']['input'];
};

export enum Classification {
  Other = 'other',
  Pii = 'pii',
  Ugc = 'ugc'
}

export enum ClassificationLevelSource {
  Content = 'CONTENT',
  Organization = 'ORGANIZATION',
  Space = 'SPACE'
}

/** This enum defines the valid collabContextProduct owners for CloudID directives. */
export enum CloudIdProduct {
  Avp = 'AVP',
  Beacon = 'BEACON',
  Compass = 'COMPASS',
  Confluence = 'CONFLUENCE',
  Devai = 'DEVAI',
  Goal = 'GOAL',
  JiraCustomerService = 'JIRA_CUSTOMER_SERVICE',
  JiraProductDiscovery = 'JIRA_PRODUCT_DISCOVERY',
  JiraServiceDesk = 'JIRA_SERVICE_DESK',
  JiraSoftware = 'JIRA_SOFTWARE',
  Loom = 'LOOM',
  Mercury = 'MERCURY',
  Opsgenie = 'OPSGENIE',
  Passionfruit = 'PASSIONFRUIT',
  Project = 'PROJECT',
  Radar = 'RADAR',
  Statuspage = 'STATUSPAGE'
}

export enum CollabFormat {
  Adf = 'ADF',
  Pm = 'PM'
}

export type CollaborationGraphRequestContext = {
  containerId?: InputMaybe<Scalars['String']['input']>;
  objectId?: InputMaybe<Scalars['String']['input']>;
  product?: InputMaybe<Scalars['String']['input']>;
  toPrivacySafeString?: InputMaybe<Scalars['String']['input']>;
};

export type CommentBody = {
  representationFormat: ContentRepresentation;
  value: Scalars['String']['input'];
};

export enum CommentCreationLocation {
  Database = 'DATABASE',
  Editor = 'EDITOR',
  Live = 'LIVE',
  Renderer = 'RENDERER',
  Whiteboard = 'WHITEBOARD'
}

export enum CommentDeletionLocation {
  Editor = 'EDITOR',
  Live = 'LIVE'
}

export enum CommentReplyType {
  Emoji = 'EMOJI',
  Prompt = 'PROMPT',
  QuickReply = 'QUICK_REPLY'
}

export enum CommentType {
  Footer = 'FOOTER',
  Inline = 'INLINE',
  Resolved = 'RESOLVED',
  Unresolved = 'UNRESOLVED'
}

export enum CommentsType {
  Footer = 'FOOTER',
  Inline = 'INLINE'
}

/**
 * Entitlement filter returns entitlement only if filter conditions have been met
 *
 * There can be only one condition or operand present at the time (similar to @oneOf directive)
 */
export type CommerceEntitlementFilter = {
  AND?: InputMaybe<Array<InputMaybe<CommerceEntitlementFilter>>>;
  OR?: InputMaybe<Array<InputMaybe<CommerceEntitlementFilter>>>;
  /** Return only entitlements that have a specific relationshipFrom Type */
  hasRelationshipFromWithType?: InputMaybe<Scalars['String']['input']>;
  /** Return only entitlements that are in predunning */
  inPreDunning?: InputMaybe<Scalars['Boolean']['input']>;
  /** Return only entitlements that are in trial or predunning */
  inTrialOrPreDunning?: InputMaybe<Scalars['Boolean']['input']>;
};

/** SaleTransitionType */
export enum CommerceExpSaleTransitionType {
  /** DOWNGRADE */
  Downgrade = 'DOWNGRADE',
  /** NA */
  Na = 'NA',
  /** NEW */
  New = 'NEW',
  /** RENEW */
  Renew = 'RENEW',
  /** UPGRADE */
  Upgrade = 'UPGRADE'
}

/** Accepts input for acknowledging an announcement. */
export type CompassAcknowledgeAnnouncementInput = {
  /** The ID of the announcement being acknowledged. */
  announcementId: Scalars['ID']['input'];
  /** The ID of the component that is acknowledging the announcement. */
  componentId: Scalars['ID']['input'];
};

/** The user-provided input to add a new document */
export type CompassAddDocumentInput = {
  /** The ID of the component to add the document to. */
  componentId: Scalars['ID']['input'];
  /** The ID of the documentation category to add the document to. */
  documentationCategoryId: Scalars['ID']['input'];
  /** The (optional) display title of the document. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the document */
  url: Scalars['URL']['input'];
};

/** Accepts input for adding labels to a team. */
export type CompassAddTeamLabelsInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
  /** A list of labels that should be added to the team. */
  labels: Array<Scalars['String']['input']>;
  /** The unique identifier (ID) of the target team. */
  teamId: Scalars['ID']['input'];
};

/** The list of properties of the alert event. */
export type CompassAlertEventPropertiesInput = {
  /** The last time the alert status changed to ACKNOWLEDGED. */
  acknowledgedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The last time the alert status changed to CLOSED. */
  closedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Timestamp for when the alert was created, when status is set to OPENED. */
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The ID of the alert. */
  id: Scalars['ID']['input'];
  /** Priority of the alert. */
  priority?: InputMaybe<AlertPriority>;
  /** The last time the alert status changed to SNOOZED. */
  snoozedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Status of the alert. */
  status?: InputMaybe<AlertEventStatus>;
};

/** The query to get all managed components on a Compass site. */
export type CompassApplicationManagedComponentsQuery = {
  /** Returns results after the specified cursor. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The cloud ID of the site to query for managed components. */
  cloudId: Scalars['ID']['input'];
  /** The number of results to return in the query. The default is 10. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassAttentionItemQuery = {
  after?: InputMaybe<Scalars['String']['input']>;
  cloudId: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassBooleanFieldValueInput = {
  booleanValue: Scalars['Boolean']['input'];
};

/** The build event pipeline. */
export type CompassBuildEventPipelineInput = {
  /** The name of the build event pipeline. */
  displayName?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the build event pipeline. */
  pipelineId: Scalars['String']['input'];
  /** The URL to the build event pipeline. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The list of properties of the build event. */
export type CompassBuildEventPropertiesInput = {
  /** Time the build completed. */
  completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The build event pipeline. */
  pipeline: CompassBuildEventPipelineInput;
  /** Time the build started. */
  startedAt: Scalars['DateTime']['input'];
  /** The state of the build. */
  state: CompassBuildEventState;
};

/** Potential states for Build events */
export enum CompassBuildEventState {
  Cancelled = 'CANCELLED',
  Error = 'ERROR',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Successful = 'SUCCESSFUL',
  TimedOut = 'TIMED_OUT',
  Unknown = 'UNKNOWN'
}

export type CompassCampaignQuery = {
  /** Returns only campaigns whose attributes match those in the filters specified. */
  filter?: InputMaybe<CompassCampaignQueryFilter>;
  /** Returns campaigns according to the sorting scheme specified. */
  sort?: InputMaybe<CompassCampaignQuerySort>;
};

export type CompassCampaignQueryFilter = {
  /** Filter campaigns that are applied to a component in a scorecard context */
  componentId?: InputMaybe<Scalars['ID']['input']>;
  /** Filter campaigns by the user who created the campaign */
  createdByUserId?: InputMaybe<Scalars['ID']['input']>;
  /** Filter campaigns by status */
  status?: InputMaybe<Scalars['String']['input']>;
};

export type CompassCampaignQuerySort = {
  /** The name of the field to sort by: due_date */
  name: Scalars['String']['input'];
  /** The order of the field to sort */
  order?: InputMaybe<CompassCampaignQuerySortOrder>;
};

export enum CompassCampaignQuerySortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

/**
 * ###################################################################################################################
 *  Compass Catalog Bootstrap
 * ###################################################################################################################
 */
export enum CompassCatalogBootstrapStatus {
  Complete = 'COMPLETE',
  Error = 'ERROR',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export type CompassComponentApiHistoricSpecTagsQuery = {
  tagName: Scalars['String']['input'];
};

export type CompassComponentApiRepoUpdate = {
  provider: Scalars['String']['input'];
  repoUrl: Scalars['String']['input'];
};

export enum CompassComponentBootstrapStatus {
  Complete = 'COMPLETE',
  Error = 'ERROR',
  Pending = 'PENDING'
}

export type CompassComponentCreationTimeFilterInput = {
  /** The filter date of component creation. */
  createdAt: Scalars['DateTime']['input'];
  /** Filter before or after the time. */
  filter: CompassComponentCreationTimeFilterType;
};

export enum CompassComponentCreationTimeFilterType {
  After = 'AFTER',
  Before = 'BEFORE'
}

export type CompassComponentCustomBooleanFieldFilterInput = {
  /** The custom field definition ID to apply the filter to */
  customFieldId: Scalars['String']['input'];
  /** Nullable Boolean value to filter on */
  value?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CompassComponentDescriptionDetailsInput = {
  /** The extended description details text body associated with a component. */
  content: Scalars['String']['input'];
};

/** The query to get the metric sources of a component. */
export type CompassComponentMetricSourcesQuery = {
  /** Returns results after the specified cursor. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The number of results to return in the query. The default is 10. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Scorecard score on a component for a scorecard. */
export type CompassComponentScorecardScoreQuery = {
  /** The unique identifier (ID) of the scorecard. */
  scorecardId: Scalars['ID']['input'];
};

/** Accepts input to find Component Scorecard work items. */
export type CompassComponentScorecardWorkItemsQuery = {
  /** Returns the work items after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The first N number of work items to return in the query. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** Identifies the type of component. */
export enum CompassComponentType {
  /** A standalone software artifact that is directly consumable by an end-user. */
  Application = 'APPLICATION',
  /** A standalone software artifact that provides some functionality for other software via embedding. */
  Library = 'LIBRARY',
  /** A software artifact that does not fit into the pre-defined categories. */
  Other = 'OTHER',
  /** A software artifact that provides some functionality for other software over the network. */
  Service = 'SERVICE'
}

/** Input for querying Compass component types */
export type CompassComponentTypeQueryInput = {
  /** Returns results after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The number of results to return in the query.  The default number is 25. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** An alert event. */
export type CompassCreateAlertEventInput = {
  /** Alert Properties */
  alertProperties: CompassAlertEventPropertiesInput;
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

/** Accepts input for creating a component announcement. */
export type CompassCreateAnnouncementInput = {
  /** The ID of the component to create an announcement for. */
  componentId: Scalars['ID']['input'];
  /** The description of the announcement. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The date on which the changes in the announcement will take effect. */
  targetDate: Scalars['DateTime']['input'];
  /** The title of the announcement. */
  title: Scalars['String']['input'];
};

/** A build event. */
export type CompassCreateBuildEventInput = {
  /** Build Properties */
  buildProperties: CompassBuildEventPropertiesInput;
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

export type CompassCreateCampaignInput = {
  description: Scalars['String']['input'];
  dueDate: Scalars['DateTime']['input'];
  goalId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  scorecardId: Scalars['ID']['input'];
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Accepts input for creating a component scorecard work item. */
export type CompassCreateComponentScorecardWorkItemInput = {
  /** The ID of the component associated with the work item. */
  componentId: Scalars['ID']['input'];
  /** The ID of the scorecard associated with the work item. */
  scorecardId: Scalars['ID']['input'];
  /** The URL of the work item. */
  url: Scalars['URL']['input'];
  /** The ID of the work item. */
  workItemId: Scalars['ID']['input'];
};

/** Input for creating a component subscription. */
export type CompassCreateComponentSubscriptionInput = {
  /** The ID of the component being subscribed. */
  componentId: Scalars['ID']['input'];
};

/**
 * ###################################################################################################################
 *  Criteria exemptions
 * ###################################################################################################################
 */
export type CompassCreateCriterionExemptionInput = {
  /** Optional component ID, if null, the exemption will be applied to all components. */
  componentId?: InputMaybe<Scalars['ID']['input']>;
  /** The target criterion ID to set the exemption for. */
  criterionId: Scalars['ID']['input'];
  /** Some context or description of why we added an exemption for auditing purposes. */
  description: Scalars['String']['input'];
  /** The date time this exemption is valid until. */
  endDate: Scalars['DateTime']['input'];
  /** The date this exemption will start at. Defaults to current date time. */
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** The type of exemption, default to EXEMPTION for a specific componentId and GLOBAL for all components */
  type?: InputMaybe<CriterionExemptionType>;
};

/** Accepts input for creating a custom boolean field definition. */
export type CompassCreateCustomBooleanFieldDefinitionInput = {
  /** The cloud ID of the site to create a custom boolean field definition for. */
  cloudId: Scalars['ID']['input'];
  /** The component types the custom boolean field appleis to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom boolean field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom boolean field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the custom boolean field. */
  name: Scalars['String']['input'];
};

/** A custom event. */
export type CompassCreateCustomEventInput = {
  /** Custom Event Properties */
  customEventProperties: CompassCustomEventPropertiesInput;
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

/** Accepts input for creating a custom field definition. You must provide exactly one of the fields in this input type. */
export type CompassCreateCustomFieldDefinitionInput = {
  /** Input for creating a custom boolean field definition. */
  booleanFieldDefinition?: InputMaybe<CompassCreateCustomBooleanFieldDefinitionInput>;
  /** Input for creating a custom multi-select field definition. */
  multiSelectFieldDefinition?: InputMaybe<CompassCreateCustomMultiSelectFieldDefinitionInput>;
  /** Input for creating a custom number field definition. */
  numberFieldDefinition?: InputMaybe<CompassCreateCustomNumberFieldDefinitionInput>;
  /** Input for creating a custom single-select field definition. */
  singleSelectFieldDefinition?: InputMaybe<CompassCreateCustomSingleSelectFieldDefinitionInput>;
  /** Input for creating a custom text field definition. */
  textFieldDefinition?: InputMaybe<CompassCreateCustomTextFieldDefinitionInput>;
  /** Input for creating a custom user field definition. */
  userFieldDefinition?: InputMaybe<CompassCreateCustomUserFieldDefinitionInput>;
};

/** Accepts input for creating a custom multi select field definition. */
export type CompassCreateCustomMultiSelectFieldDefinitionInput = {
  /** The cloud ID of the site to create a custom multi-select field definition for. */
  cloudId: Scalars['ID']['input'];
  /** The component types the custom multi-select field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The description of the custom multi-select field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the custom multi-select field. */
  name: Scalars['String']['input'];
  /** A list of options. */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Accepts input for creating a custom number field definition. */
export type CompassCreateCustomNumberFieldDefinitionInput = {
  /** The cloud ID of the site to create a custom number field definition for. */
  cloudId: Scalars['ID']['input'];
  /** The component types the custom number field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom number field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom number field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the custom number field. */
  name: Scalars['String']['input'];
};

/** Accepts input for creating a custom single select field definition. */
export type CompassCreateCustomSingleSelectFieldDefinitionInput = {
  /** The cloud ID of the site to create a custom single-select field definition for. */
  cloudId: Scalars['ID']['input'];
  /** The component types the custom single-select field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The description of the custom single-select field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the custom single-select field. */
  name: Scalars['String']['input'];
  /** A list of options. */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Accepts input for creating a custom text field definition. */
export type CompassCreateCustomTextFieldDefinitionInput = {
  /** The cloud ID of the site to create a custom text field definition for. */
  cloudId: Scalars['ID']['input'];
  /** The component types the custom text field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom text field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom text field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the custom text field. */
  name: Scalars['String']['input'];
};

/** Accepts input for creating a custom user field definition. */
export type CompassCreateCustomUserFieldDefinitionInput = {
  /** The cloud ID of the site to create a custom user field definition for. */
  cloudId: Scalars['ID']['input'];
  /** The component types the custom user field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom user field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom user field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the custom user field. */
  name: Scalars['String']['input'];
};

/** A deployment event. */
export type CompassCreateDeploymentEventInput = {
  /** Deployment Properties */
  deploymentProperties: CompassCreateDeploymentEventPropertiesInput;
  /** The description of the deployment event. */
  description: Scalars['String']['input'];
  /** The name of the deployment event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the deployment event. */
  url: Scalars['URL']['input'];
};

/** The list of properties of the deployment event. */
export type CompassCreateDeploymentEventPropertiesInput = {
  /** The time this deployment was completed at. */
  completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The environment where the deployment event has occurred. */
  environment: CompassDeploymentEventEnvironmentInput;
  /** The deployment event pipeline. */
  pipeline: CompassDeploymentEventPipelineInput;
  /** The sequence number for the deployment. */
  sequenceNumber: Scalars['Long']['input'];
  /** The time this deployment was started at. */
  startedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The state of the deployment. */
  state: CompassDeploymentEventState;
};

/**  Create Inputs */
export type CompassCreateDynamicScorecardCriteriaInput = {
  expressions: Array<CompassCreateScorecardCriterionExpressionTreeInput>;
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  weight: Scalars['Int']['input'];
};

export type CompassCreateEventInput = {
  /** The cloud ID of the site to create the event for. */
  cloudId: Scalars['ID']['input'];
  componentId?: InputMaybe<Scalars['String']['input']>;
  event: CompassEventInput;
};

/** A flag event. */
export type CompassCreateFlagEventInput = {
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** Flag Properties */
  flagProperties: CompassCreateFlagEventPropertiesInput;
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

/** The list of properties of the flag event. */
export type CompassCreateFlagEventPropertiesInput = {
  /** The ID of the flag. */
  id: Scalars['ID']['input'];
  /** The flag's status. The recognized values (case-insensitive) are on, off, created, archived, deleted, and targeting_updated. Any other value, although acceptable, will be displayed as unknown on the activity feed. */
  status?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input to create a scorecard criterion checking the value of a specified custom boolean field. */
export type CompassCreateHasCustomBooleanFieldScorecardCriteriaInput = {
  /** The comparison operation to be performed. */
  booleanComparator: CompassCriteriaBooleanComparatorOptions;
  /** The value that the field is compared to. */
  booleanComparatorValue: Scalars['Boolean']['input'];
  /** The ID of the component custom boolean field to check the value of. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

export type CompassCreateHasCustomMultiSelectFieldScorecardCriteriaInput = {
  /** The comparison operation to be performed between the field and comparator value. */
  collectionComparator: CompassCriteriaCollectionComparatorOptions;
  /** The list of multi select options that the field is compared to. */
  collectionComparatorValue?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The ID of the component custom multi select field to check the value of. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts input to create a scorecard criterion checking the value of a specified custom number field. */
export type CompassCreateHasCustomNumberFieldScorecardCriteriaInput = {
  /** The ID of the component custom number field to check the value of. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The comparison operation to be performed between the field and comparator value. */
  numberComparator: CompassCriteriaNumberComparatorOptions;
  /** The threshold value that the field is compared to. */
  numberComparatorValue?: InputMaybe<Scalars['Float']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

export type CompassCreateHasCustomSingleSelectFieldScorecardCriteriaInput = {
  /** The ID of the component custom single select field to check the value of. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The comparison operation to be performed between the field and comparator value. */
  membershipComparator: CompassCriteriaMembershipComparatorOptions;
  /** The list of single select options that the field is compared to. */
  membershipComparatorValue?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts input to create a scorecard criterion checking the value of a specified custom text field. */
export type CompassCreateHasCustomTextFieldScorecardCriteriaInput = {
  /** The ID of the component custom text field to check the value of. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The comparison operation to be performed. */
  textComparator?: InputMaybe<CompassCriteriaTextComparatorOptions>;
  /** The value that the field is compared to. */
  textComparatorValue?: InputMaybe<Scalars['String']['input']>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

export type CompassCreateHasPackageDependencyScorecardCriteriaInput = {
  /** Comparison operations the package must satisfy to pass. */
  comparators: Array<CompassPackageDependencyComparatorInput>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The relevant package manager. */
  packageManager: CompassPackageDependencyManagerOptions;
  /** The name of the dependency package. */
  packageName: Scalars['String']['input'];
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** An incident event. */
export type CompassCreateIncidentEventInput = {
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The list of properties of the incident event. */
  incidentProperties: CompassCreateIncidentEventPropertiesInput;
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

/** The list of properties of the incident event. */
export type CompassCreateIncidentEventPropertiesInput = {
  /** The time when the incident ended */
  endTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** The ID of the incident. */
  id: Scalars['ID']['input'];
  /** The severity of the incident */
  severity?: InputMaybe<CompassIncidentEventSeverityInput>;
  /** The time when the incident started */
  startTime: Scalars['DateTime']['input'];
  /** The state of the incident. */
  state: CompassIncidentEventState;
};

/** The user-provided input to create an incoming webhook */
export type CompassCreateIncomingWebhookInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
  /** The description of the webhook. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the webhook. */
  name: Scalars['String']['input'];
  /** The source of the webhook. */
  source: Scalars['String']['input'];
};

export type CompassCreateIncomingWebhookTokenInput = {
  /** Name of auth token */
  name?: InputMaybe<Scalars['String']['input']>;
  /** ID of the webhook to associate the token with. */
  webhookId: Scalars['ID']['input'];
};

/** A lifecycle event. */
export type CompassCreateLifecycleEventInput = {
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** Lifecycle Properties */
  lifecycleProperties: CompassLifecycleEventInputProperties;
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

/** The input for creating a metric definition. */
export type CompassCreateMetricDefinitionInput = {
  /** The cloud ID of the Compass site to create a metric definition on. */
  cloudId: Scalars['ID']['input'];
  /** The configuration of the metric definition. */
  configuration?: InputMaybe<CompassMetricDefinitionConfigurationInput>;
  /** The description of the metric definition. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The format option for applying to the display of metric values. */
  format?: InputMaybe<CompassMetricDefinitionFormatInput>;
  /** The name of the metric definition. */
  name: Scalars['String']['input'];
};

/** The input to create a metric source. */
export type CompassCreateMetricSourceInput = {
  /** The ID of the component to create a metric source on. */
  componentId: Scalars['ID']['input'];
  /** The configuration of this metric source. */
  configuration?: InputMaybe<CompassMetricSourceConfigurationInput>;
  /** The data connection configuration of this metric source. */
  dataConnectionConfiguration?: InputMaybe<CompassDataConnectionConfigurationInput>;
  /** Whether the metric source is derived from Compass events or not. */
  derived?: InputMaybe<Scalars['Boolean']['input']>;
  /** The external metric source configuration input */
  externalConfiguration?: InputMaybe<CompassExternalMetricSourceConfigurationInput>;
  /** The unique identifier (ID) of the metric source that is external to the Compass site, for example, a Bitbucket repository ID. */
  externalMetricSourceId: Scalars['ID']['input'];
  /** The ID of the Forge app that sends metric values. */
  forgeAppId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the metric definition which defines the metric source. */
  metricDefinitionId: Scalars['ID']['input'];
  /** The URL of the metric source. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** A pull request event. */
export type CompassCreatePullRequestEventInput = {
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** The list of properties of the pull request event. */
  pullRequestProperties: CompassPullRequestInputProperties;
};

export enum CompassCreatePullRequestStatus {
  Created = 'CREATED',
  InReview = 'IN_REVIEW',
  Merged = 'MERGED',
  Rejected = 'REJECTED'
}

/** A push event. */
export type CompassCreatePushEventInput = {
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** The list of properties of the push event. */
  pushEventProperties: CompassPushEventInputProperties;
  /** A number specifying the order of the update to the event. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
};

export type CompassCreateScorecardCriteriaScoringStrategyRulesInput = {
  onError?: InputMaybe<CompassScorecardCriteriaScoringStrategyRuleAction>;
  onFalse?: InputMaybe<CompassScorecardCriteriaScoringStrategyRuleAction>;
  onTrue?: InputMaybe<CompassScorecardCriteriaScoringStrategyRuleAction>;
};

export type CompassCreateScorecardCriterionExpressionAndGroupInput = {
  expressions: Array<CompassCreateScorecardCriterionExpressionGroupInput>;
};

export type CompassCreateScorecardCriterionExpressionBooleanInput = {
  booleanComparator: CompassScorecardCriterionExpressionBooleanComparatorOptions;
  booleanComparatorValue: Scalars['Boolean']['input'];
  requirement: CompassCreateScorecardCriterionExpressionRequirementInput;
};

export type CompassCreateScorecardCriterionExpressionCollectionInput = {
  collectionComparator: CompassScorecardCriterionExpressionCollectionComparatorOptions;
  collectionComparatorValue: Array<Scalars['ID']['input']>;
  requirement: CompassCreateScorecardCriterionExpressionRequirementInput;
};

export type CompassCreateScorecardCriterionExpressionEvaluableInput = {
  expression: CompassCreateScorecardCriterionExpressionInput;
};

export type CompassCreateScorecardCriterionExpressionEvaluationRulesInput = {
  onError?: InputMaybe<CompassScorecardCriterionExpressionEvaluationRuleAction>;
  onFalse?: InputMaybe<CompassScorecardCriterionExpressionEvaluationRuleAction>;
  onTrue?: InputMaybe<CompassScorecardCriterionExpressionEvaluationRuleAction>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassCreateScorecardCriterionExpressionGroupInput = {
  and?: InputMaybe<CompassCreateScorecardCriterionExpressionAndGroupInput>;
  evaluable?: InputMaybe<CompassCreateScorecardCriterionExpressionEvaluableInput>;
  or?: InputMaybe<CompassCreateScorecardCriterionExpressionOrGroupInput>;
};

export type CompassCreateScorecardCriterionExpressionInput = {
  boolean?: InputMaybe<CompassCreateScorecardCriterionExpressionBooleanInput>;
  collection?: InputMaybe<CompassCreateScorecardCriterionExpressionCollectionInput>;
  membership?: InputMaybe<CompassCreateScorecardCriterionExpressionMembershipInput>;
  number?: InputMaybe<CompassCreateScorecardCriterionExpressionNumberInput>;
  text?: InputMaybe<CompassCreateScorecardCriterionExpressionTextInput>;
};

export type CompassCreateScorecardCriterionExpressionMembershipInput = {
  membershipComparator: CompassScorecardCriterionExpressionMembershipComparatorOptions;
  membershipComparatorValue: Array<Scalars['ID']['input']>;
  requirement: CompassCreateScorecardCriterionExpressionRequirementInput;
};

export type CompassCreateScorecardCriterionExpressionNumberInput = {
  numberComparator: CompassScorecardCriterionExpressionNumberComparatorOptions;
  numberComparatorValue: Scalars['Float']['input'];
  requirement: CompassCreateScorecardCriterionExpressionRequirementInput;
};

export type CompassCreateScorecardCriterionExpressionOrGroupInput = {
  expressions: Array<CompassCreateScorecardCriterionExpressionGroupInput>;
};

export type CompassCreateScorecardCriterionExpressionRequirementCustomFieldInput = {
  customFieldDefinitionId: Scalars['ID']['input'];
};

export type CompassCreateScorecardCriterionExpressionRequirementDefaultFieldInput = {
  fieldName: Scalars['String']['input'];
};

export type CompassCreateScorecardCriterionExpressionRequirementInput = {
  customField?: InputMaybe<CompassCreateScorecardCriterionExpressionRequirementCustomFieldInput>;
  defaultField?: InputMaybe<CompassCreateScorecardCriterionExpressionRequirementDefaultFieldInput>;
  metric?: InputMaybe<CompassCreateScorecardCriterionExpressionRequirementMetricInput>;
};

export type CompassCreateScorecardCriterionExpressionRequirementMetricInput = {
  metricDefinitionId: Scalars['ID']['input'];
};

export type CompassCreateScorecardCriterionExpressionRequirementScorecardInput = {
  fieldName: Scalars['String']['input'];
  scorecardId: Scalars['ID']['input'];
};

export type CompassCreateScorecardCriterionExpressionTextInput = {
  requirement: CompassCreateScorecardCriterionExpressionRequirementInput;
  textComparator: CompassScorecardCriterionExpressionTextComparatorOptions;
  textComparatorValue: Scalars['String']['input'];
};

export type CompassCreateScorecardCriterionExpressionTreeInput = {
  evaluationRules?: InputMaybe<CompassCreateScorecardCriterionExpressionEvaluationRulesInput>;
  root: CompassCreateScorecardCriterionExpressionGroupInput;
};

/** Accepts input for creating team checkin's action item. */
export type CompassCreateTeamCheckinActionInput = {
  /** The text of the team checkin action item. */
  actionText: Scalars['String']['input'];
  /** Whether the action is completed or not. */
  completed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Accepts input for creating a checkin. */
export type CompassCreateTeamCheckinInput = {
  /** A list of action items to be created with the checkin. */
  actions?: InputMaybe<Array<CompassCreateTeamCheckinActionInput>>;
  /** The cloud ID of the site to update a checkin on. */
  cloudId: Scalars['ID']['input'];
  /** The mood of the checkin. */
  mood: Scalars['Int']['input'];
  /** The response to the question 1 of the team checkin. */
  response1?: InputMaybe<Scalars['String']['input']>;
  /** The response to the question 1 of the team checkin in a rich text format. */
  response1RichText?: InputMaybe<CompassCreateTeamCheckinResponseRichText>;
  /** The response to the question 2 of the team checkin. */
  response2?: InputMaybe<Scalars['String']['input']>;
  /** The response to the question 2 of the team checkin in a rich text format. */
  response2RichText?: InputMaybe<CompassCreateTeamCheckinResponseRichText>;
  /** The response to the question 3 of the team checkin. */
  response3?: InputMaybe<Scalars['String']['input']>;
  /** The response to the question 3 of the team checkin in a rich text format. */
  response3RichText?: InputMaybe<CompassCreateTeamCheckinResponseRichText>;
  /** The unique identifier (ID) of the team that did the checkin. */
  teamId: Scalars['ID']['input'];
};

/** Accepts input for creating team checkin responses with rich text. */
export type CompassCreateTeamCheckinResponseRichText = {
  /** Input for a team checkin response in Atlassian Document Format. */
  adf?: InputMaybe<Scalars['String']['input']>;
};

/** A vulnerability event. */
export type CompassCreateVulnerabilityEventInput = {
  /** The description of the event. */
  description: Scalars['String']['input'];
  /** The name of the event. */
  displayName: Scalars['String']['input'];
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime']['input'];
  /** A number specifying the order of the update to the event. Must be incremented to save new events. Otherwise, the request will be ignored. */
  updateSequenceNumber: Scalars['Long']['input'];
  /** The URL of the event. */
  url: Scalars['URL']['input'];
  /** The list of properties of the vulnerability event. */
  vulnerabilityProperties: CompassCreateVulnerabilityEventPropertiesInput;
};

/** The list of properties of the vulnerability event. */
export type CompassCreateVulnerabilityEventPropertiesInput = {
  /** The source or tool that discovered the vulnerability. */
  discoverySource?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the vulnerability. */
  id: Scalars['ID']['input'];
  /** The time when the vulnerability was remediated. */
  remediationTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** The CVSS score of the vulnerability (0-10). */
  score?: InputMaybe<Scalars['Float']['input']>;
  /** The severity of the vulnerability */
  severity: CompassVulnerabilityEventSeverityInput;
  /** The state of the vulnerability. */
  state: CompassVulnerabilityEventState;
  /** The time when the vulnerability started. */
  vulnerabilityStartTime: Scalars['DateTime']['input'];
  /** The target system or component that is vulnerable. */
  vulnerableTarget?: InputMaybe<Scalars['String']['input']>;
};

export enum CompassCriteriaBooleanComparatorOptions {
  Equals = 'EQUALS'
}

export enum CompassCriteriaCollectionComparatorOptions {
  AllOf = 'ALL_OF',
  AnyOf = 'ANY_OF',
  IsPresent = 'IS_PRESENT',
  NoneOf = 'NONE_OF'
}

export type CompassCriteriaGraduatedSeriesInput = {
  /** The comparison operation to be performed between the metric and comparator value on this graduated series */
  comparator: CompassCriteriaNumberComparatorOptions;
  /** The threshold value that the metric is compared to for this graduated series comparator */
  comparatorValue: Scalars['Float']['input'];
  /** The weight to be given for this graduated series comparator if it is evaluated as true */
  fractionalWeight: Scalars['Int']['input'];
};

export enum CompassCriteriaMembershipComparatorOptions {
  In = 'IN',
  IsPresent = 'IS_PRESENT',
  NotIn = 'NOT_IN'
}

export enum CompassCriteriaNumberComparatorOptions {
  Equals = 'EQUALS',
  GreaterThan = 'GREATER_THAN',
  GreaterThanOrEqualTo = 'GREATER_THAN_OR_EQUAL_TO',
  IsPresent = 'IS_PRESENT',
  LessThan = 'LESS_THAN',
  LessThanOrEqualTo = 'LESS_THAN_OR_EQUAL_TO'
}

export enum CompassCriteriaTextComparatorOptions {
  IsPresent = 'IS_PRESENT',
  MatchesRegex = 'MATCHES_REGEX'
}

/** Accepts input for setting a boolean value on a custom field. */
export type CompassCustomBooleanFieldInput = {
  /** The annotations attached to a custom field. */
  annotations?: InputMaybe<Array<CompassCustomFieldAnnotationInput>>;
  /** The boolean value contained in the custom field on a component. */
  booleanValue: Scalars['Boolean']['input'];
  /** The ID of the custom boolean field definition. */
  definitionId: Scalars['ID']['input'];
};

export enum CompassCustomEventIcon {
  Checkpoint = 'CHECKPOINT',
  Info = 'INFO',
  Warning = 'WARNING'
}

/** The list of properties of the custom event. */
export type CompassCustomEventPropertiesInput = {
  /** The icon for the custom event. */
  icon: CompassCustomEventIcon;
  /** The ID of the custom event. */
  id: Scalars['ID']['input'];
};

/** Annotatation input for a custom field value */
export type CompassCustomFieldAnnotationInput = {
  /** Description of the annotation. */
  description: Scalars['String']['input'];
  /** The text to display for a given linkURI. */
  linkText: Scalars['String']['input'];
  /** Link to display alongside an annotations description. */
  linkUri: Scalars['URL']['input'];
};

/** The query for retrieving a custom field definition by id on a Compass site. */
export type CompassCustomFieldDefinitionQuery = {
  /** The cloud ID of the site to retrieve custom field definitions from. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the custom field definition to retrieve. */
  id: Scalars['ID']['input'];
};

/** The query for retrieving custom field definitions on a Compass site. */
export type CompassCustomFieldDefinitionsQuery = {
  /** The cloud ID of the site to retrieve custom field definitions from. */
  cloudId: Scalars['ID']['input'];
  /**
   * Optional filter to search for custom field definitions applied to any of the specific component types.
   * Returns all custom field definitions by default.
   */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * Optional filter to search for custom field definitions applied to any of the specified component types.
   * Returns all custom field definitions by default.
   */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
};

export type CompassCustomFieldFilterInput = {
  /** Input type for boolean custom field filter */
  boolean?: InputMaybe<CompassComponentCustomBooleanFieldFilterInput>;
  /** Input type for multiselect custom field filter */
  multiselect?: InputMaybe<CompassCustomMultiselectFieldFilterInput>;
  /** Input type for number custom field filter */
  number?: InputMaybe<CompassCustomNumberFieldFilterInput>;
  /** Input type for single select custom field filter */
  singleSelect?: InputMaybe<CompassCustomSingleSelectFieldFilterInput>;
  /** Input type for text custom field filter */
  text?: InputMaybe<CompassCustomTextFieldFilterInput>;
  /** Input type for user custom field filter */
  user?: InputMaybe<CompassCustomUserFieldFilterInput>;
};

/** Accepts input for setting a custom field value. You must provide exactly one of the fields in this input type. */
export type CompassCustomFieldInput = {
  /** Input for setting a value on a custom field containing a boolean value. */
  booleanField?: InputMaybe<CompassCustomBooleanFieldInput>;
  /** Input for setting a value on a custom field containing multiple options */
  multiSelectField?: InputMaybe<CompassCustomMultiSelectFieldInput>;
  /** Input for setting a value on a custom field containing a number. */
  numberField?: InputMaybe<CompassCustomNumberFieldInput>;
  /** Input for setting a value on a custom field containing a single option */
  singleSelectField?: InputMaybe<CompassCustomSingleSelectFieldInput>;
  /** Input for setting a value on a custom field containing a text string. */
  textField?: InputMaybe<CompassCustomTextFieldInput>;
  /** Input for setting a value on a custom field containing a user. */
  userField?: InputMaybe<CompassCustomUserFieldInput>;
};

/** Accepts input for setting options for a multi-select field. */
export type CompassCustomMultiSelectFieldInput = {
  /** The annotations attached to a custom field. */
  annotations?: InputMaybe<Array<CompassCustomFieldAnnotationInput>>;
  /** The ID of the custom boolean field definition. */
  definitionId: Scalars['ID']['input'];
  /** The option IDs for the custom field on a component. */
  options?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type CompassCustomMultiselectFieldFilterInput = {
  /** Comparator to use with this filter */
  comparator?: InputMaybe<CustomMultiselectFieldInputComparators>;
  /** The custom field definition ID to apply the filter to */
  customFieldId: Scalars['String']['input'];
  /** Values to use for filtering */
  values: Array<Scalars['String']['input']>;
};

export type CompassCustomNumberFieldFilterInput = {
  /** The custom field value comparator */
  comparator?: InputMaybe<CustomNumberFieldInputComparators>;
  /** The custom field definition ID to apply the filter to */
  customFieldId: Scalars['String']['input'];
  /** The custom field value to search by, when comparator is CONTAIN_ANY */
  values?: InputMaybe<Array<Scalars['Float']['input']>>;
};

/** Accepts input for setting a number on a custom field. */
export type CompassCustomNumberFieldInput = {
  /** The annotations attached to a custom field. */
  annotations?: InputMaybe<Array<CompassCustomFieldAnnotationInput>>;
  /** The ID of the custom number field definition. */
  definitionId: Scalars['ID']['input'];
  /** The number contained in the custom field on a component. */
  numberValue?: InputMaybe<Scalars['Float']['input']>;
};

/** Preset options to update custom permission configs, either open to all teams/roles or restricted to product admins and owners. */
export enum CompassCustomPermissionPreset {
  /** Restrictive option which only permits product admins and owners to create/edit/delete, which vary depending on entity, i.e. component */
  AdminsAndOwners = 'ADMINS_AND_OWNERS',
  /** Default option which permits the owner team, as well as all teams and roles. */
  Default = 'DEFAULT'
}

export type CompassCustomSingleSelectFieldFilterInput = {
  /** Comparator to use with this filter */
  comparator?: InputMaybe<CustomSingleSelectFieldInputComparators>;
  /** The custom field definition ID for the field to apply the filter to. */
  customFieldId: Scalars['String']['input'];
  /** List of option IDs to use for filtering. Empty array for NOT_SET and IS_SET */
  values: Array<Scalars['ID']['input']>;
};

/** Accepts input for setting an option for single-select field. */
export type CompassCustomSingleSelectFieldInput = {
  /** The annotations attached to a custom field. */
  annotations?: InputMaybe<Array<CompassCustomFieldAnnotationInput>>;
  /** The ID of the custom boolean field definition. */
  definitionId: Scalars['ID']['input'];
  /** The option ID for the custom field on a component. */
  option?: InputMaybe<Scalars['ID']['input']>;
};

export type CompassCustomTextFieldFilterInput = {
  /** The custom field value comparator */
  comparator?: InputMaybe<CustomTextFieldInputComparators>;
  /** The custom field definition ID to apply the filter to */
  customFieldId: Scalars['String']['input'];
  /** The custom field value to search by, when comparator is CONTAIN_ANY */
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Accepts input for setting a text string on a custom field. */
export type CompassCustomTextFieldInput = {
  /** The annotations attached to a custom field. */
  annotations?: InputMaybe<Array<CompassCustomFieldAnnotationInput>>;
  /** The ID of the custom text field definition. */
  definitionId: Scalars['ID']['input'];
  /** The text string contained in the custom field on a component. */
  textValue?: InputMaybe<Scalars['String']['input']>;
};

export type CompassCustomUserFieldFilterInput = {
  /** The custom field value comparator */
  comparator?: InputMaybe<CustomUserFieldInputComparators>;
  /** The custom field definition ID to apply the filter to */
  customFieldId: Scalars['String']['input'];
  /** User IDs to filter on or empty array for IS_SET or NOT_SET */
  values: Array<Scalars['ID']['input']>;
};

/** Accepts input for setting a user on a custom field. */
export type CompassCustomUserFieldInput = {
  /** The annotations attached to a custom field. */
  annotations?: InputMaybe<Array<CompassCustomFieldAnnotationInput>>;
  /** The ID of the custom user field definition. */
  definitionId: Scalars['ID']['input'];
  /** The user contained in the custom field on a component. */
  userIdValue?: InputMaybe<Scalars['ID']['input']>;
};

export type CompassDataConnectionApiConfigurationInput = {
  /** Component links that provide data for the metric. */
  dataSourceLinks?: InputMaybe<Array<Scalars['ID']['input']>>;
  source?: InputMaybe<CompassDataConnectionSource>;
};

export type CompassDataConnectionAppConfigurationInput = {
  /** Component links that provide data for the metric. */
  dataSourceLinks?: InputMaybe<Array<Scalars['ID']['input']>>;
  source?: InputMaybe<CompassDataConnectionSource>;
};

/** The input of data connection configuration. One and only one of the fields in this input type must be provided. */
export type CompassDataConnectionConfigurationInput = {
  api?: InputMaybe<CompassDataConnectionApiConfigurationInput>;
  app?: InputMaybe<CompassDataConnectionAppConfigurationInput>;
  incomingWebhook?: InputMaybe<CompassDataConnectionIncomingWebhookConfigurationInput>;
};

export type CompassDataConnectionIncomingWebhookConfigurationInput = {
  /** Component links that provide data for the metric. */
  dataSourceLinks?: InputMaybe<Array<Scalars['ID']['input']>>;
  incomingWebhookId: Scalars['ID']['input'];
  source?: InputMaybe<CompassDataConnectionSource>;
};

/** Used to identify the source for connection */
export enum CompassDataConnectionSource {
  Api = 'API',
  Bitbucket = 'BITBUCKET',
  Circleci = 'CIRCLECI',
  CustomWebhooks = 'CUSTOM_WEBHOOKS',
  ForgeApp = 'FORGE_APP',
  Github = 'GITHUB',
  Gitlab = 'GITLAB',
  Jira = 'JIRA',
  JiraDocumentation = 'JIRA_DOCUMENTATION',
  MarketplaceApps = 'MARKETPLACE_APPS',
  Pagerduty = 'PAGERDUTY',
  Snyk = 'SNYK',
  Sonarqube = 'SONARQUBE',
  Webhook = 'WEBHOOK'
}

/** Accepts input for deleting a component announcement. */
export type CompassDeleteAnnouncementInput = {
  /** The cloud ID of the site to delete an announcement from. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the announcement to delete. */
  id: Scalars['ID']['input'];
};

/** Accepts input for delete a subscription. */
export type CompassDeleteComponentSubscriptionInput = {
  /** The ID of the component to unsubscribe. */
  componentId: Scalars['ID']['input'];
};

/** Accepts input for deleting a custom field definition, along with all values associated with the definition. */
export type CompassDeleteCustomFieldDefinitionInput = {
  /** The ID of the custom field definition to be deleted. */
  id: Scalars['ID']['input'];
};

export type CompassDeleteDocumentInput = {
  /** The ARI of the document to delete */
  id: Scalars['ID']['input'];
};

export type CompassDeleteExternalAliasInput = {
  /** The ID of the component in the external source */
  externalId: Scalars['ID']['input'];
  /** The external system hosting the component */
  externalSource: Scalars['ID']['input'];
};

/** The user-provided input to delete an incoming webhook */
export type CompassDeleteIncomingWebhookInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
  /** The ARI of the webhook to delete */
  id: Scalars['ID']['input'];
};

/** The input to delete a metric definition. */
export type CompassDeleteMetricDefinitionInput = {
  /** The ID of the metric definition to be deleted. */
  id: Scalars['ID']['input'];
};

/** The input to delete a metric source. */
export type CompassDeleteMetricSourceInput = {
  /** The ID of the metric source to be deleted. */
  id: Scalars['ID']['input'];
};

/** Accepts input for deleting a team checkin. */
export type CompassDeleteTeamCheckinActionInput = {
  /** The ID of the team checkin item to delete. */
  id: Scalars['ID']['input'];
};

/** Accepts input for deleting a team checkin. */
export type CompassDeleteTeamCheckinInput = {
  /** The cloud ID of the site to update a checkin on. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the team checkin to delete. */
  id: Scalars['ID']['input'];
};

export enum CompassDeploymentEventEnvironmentCategory {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

/** The environment where the deployment event has occurred. */
export type CompassDeploymentEventEnvironmentInput = {
  /** The type of environment where the deployment event occurred. */
  category: CompassDeploymentEventEnvironmentCategory;
  /** The display name of the environment where the deployment event occurred. */
  displayName: Scalars['String']['input'];
  /** The ID of the environment where the deployment event occurred. */
  environmentId: Scalars['String']['input'];
};

/** Filters for deployment events. */
export type CompassDeploymentEventFilters = {
  /** A list of environments to filter deployment events by. */
  environments?: InputMaybe<Array<CompassDeploymentEventEnvironmentCategory>>;
  /** A list of states to filter deployment events by. */
  states?: InputMaybe<Array<CompassDeploymentEventState>>;
};

/** The deployment event pipeline. */
export type CompassDeploymentEventPipelineInput = {
  /** The name of the deployment event pipeline. */
  displayName: Scalars['String']['input'];
  /** The ID of the deployment event pipeline. */
  pipelineId: Scalars['String']['input'];
  /** The URL of the deployment event pipeline. */
  url: Scalars['String']['input'];
};

/**  Compass Deployment Event */
export enum CompassDeploymentEventState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type CompassEnumFieldValueInput = {
  value?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Filters for events sent to Compass. */
export type CompassEventFilters = {
  /** Filters for deployment events. */
  deployments?: InputMaybe<CompassDeploymentEventFilters>;
};

/** The type of event. One and only one of the fields in this input type must be provided. */
export type CompassEventInput = {
  alert?: InputMaybe<CompassCreateAlertEventInput>;
  build?: InputMaybe<CompassCreateBuildEventInput>;
  custom?: InputMaybe<CompassCreateCustomEventInput>;
  deployment?: InputMaybe<CompassCreateDeploymentEventInput>;
  flag?: InputMaybe<CompassCreateFlagEventInput>;
  incident?: InputMaybe<CompassCreateIncidentEventInput>;
  lifecycle?: InputMaybe<CompassCreateLifecycleEventInput>;
  pullRequest?: InputMaybe<CompassCreatePullRequestEventInput>;
  push?: InputMaybe<CompassCreatePushEventInput>;
  vulnerability?: InputMaybe<CompassCreateVulnerabilityEventInput>;
};

export type CompassEventTimeParameters = {
  /** The time to end querying for event data. */
  endAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The time to begin querying for event data. */
  startFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

export enum CompassEventType {
  Alert = 'ALERT',
  Build = 'BUILD',
  Custom = 'CUSTOM',
  Deployment = 'DEPLOYMENT',
  Flag = 'FLAG',
  Incident = 'INCIDENT',
  Lifecycle = 'LIFECYCLE',
  PullRequest = 'PULL_REQUEST',
  Push = 'PUSH',
  Vulnerability = 'VULNERABILITY'
}

export type CompassEventsInEventSourceQuery = {
  /** Returns the events after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Filter events based on CompassEventFilters. */
  eventFilters?: InputMaybe<CompassEventFilters>;
  /** The first N number of events to return in the query. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Returns the events after that match the CompassEventTimeParameters. */
  timeParameters?: InputMaybe<CompassEventTimeParameters>;
};

export type CompassEventsQuery = {
  /** Returns the events after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Filter events based on CompassEventFilters */
  eventFilters?: InputMaybe<CompassEventFilters>;
  /** The list of event types. */
  eventTypes?: InputMaybe<Array<CompassEventType>>;
  /** The first N number of events to return in the query. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Returns the events after that match the CompassEventTimeParameters. */
  timeParameters?: InputMaybe<CompassEventTimeParameters>;
};

export type CompassExternalAliasInput = {
  /** The ID of the component in the external source */
  externalId: Scalars['ID']['input'];
  /** The external system hosting the component */
  externalSource: Scalars['ID']['input'];
  /** The url of the component in an external system. */
  url?: InputMaybe<Scalars['String']['input']>;
};

export type CompassExternalMetricSourceConfigurationInput = {
  /** Plain external metric source configuration input */
  plain?: InputMaybe<CompassPlainMetricSourceConfigurationInput>;
  /** SLO external metric source configuration input */
  slo?: InputMaybe<CompassSloMetricSourceConfigurationInput>;
};

/** Specifies the type of value for a field. */
export enum CompassFieldType {
  Boolean = 'BOOLEAN',
  Date = 'DATE',
  Enum = 'ENUM',
  Number = 'NUMBER',
  Text = 'TEXT'
}

export type CompassFieldValueInput = {
  boolean?: InputMaybe<CompassBooleanFieldValueInput>;
  enum?: InputMaybe<CompassEnumFieldValueInput>;
};

/** Accepts input to find filtered components count */
export type CompassFilteredComponentsCountQuery = {
  componentCreationTimeFilter?: InputMaybe<CompassComponentCreationTimeFilterInput>;
  componentCustomFieldFilters?: InputMaybe<Array<CompassCustomFieldFilterInput>>;
  fields?: InputMaybe<Array<CompassScorecardAppliedToComponentsFieldFilter>>;
  labels?: InputMaybe<CompassScorecardAppliedToComponentsLabelsFilter>;
  lifecycleFilter?: InputMaybe<CompassLifecycleFilterInput>;
  ownerIds?: InputMaybe<CompassScorecardAppliedToComponentsOwnerFilter>;
  repositoryLinkFilter?: InputMaybe<CompassRepositoryValueInput>;
  types?: InputMaybe<CompassScorecardAppliedToComponentsTypesFilter>;
};

/** Accepts input to find components a scorecard is applied to and their scores */
export type CompassGoalAppliedToComponentsQuery = {
  /** Returns components according to the sorting scheme specified. */
  sort?: InputMaybe<CompassGoalAppliedToComponentsQuerySort>;
};

export type CompassGoalAppliedToComponentsQuerySort = {
  /** The name of the field to sort by. */
  name: Scalars['String']['input'];
  /** The order to sort the applied components by. */
  order: CompassQuerySortOrder;
};

export type CompassGoalCriteriaScoreStatisticsHistoryQuery = {
  filter?: InputMaybe<CompassGoalCriteriaScoreStatisticsHistoryQueryFilter>;
};

/** Accepts input to filter the goal criteria statistics history. */
export type CompassGoalCriteriaScoreStatisticsHistoryQueryFilter = {
  /** The types of components to filter by. */
  componentTypes?: InputMaybe<CompassScoreStatisticsHistoryComponentTypesFilter>;
  /** The date at which to start filtering. */
  date?: InputMaybe<CompassScoreStatisticsHistoryDateFilter>;
  /** The team owners to filter by. */
  owners?: InputMaybe<CompassScoreStatisticsHistoryOwnersFilter>;
};

export type CompassGoalFiltersInput = {
  applicationTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  componentLabels?: InputMaybe<Array<Scalars['String']['input']>>;
  componentOwnerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  componentTiers?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type CompassGoalScoreStatisticsHistoryQuery = {
  filter?: InputMaybe<CompassGoalScoreStatisticsHistoryQueryFilter>;
};

export type CompassGoalScoreStatisticsHistoryQueryFilter = {
  /** The types of components to filter by. */
  componentTypes?: InputMaybe<CompassScoreStatisticsHistoryComponentTypesFilter>;
  /** The date at which to start filtering. */
  date?: InputMaybe<CompassScoreStatisticsHistoryDateFilter>;
  /** The team owners to filter by. */
  owners?: InputMaybe<CompassScoreStatisticsHistoryOwnersFilter>;
};

/** The severity of an incident */
export type CompassIncidentEventSeverityInput = {
  /** The label to use for displaying the severity of the incident */
  label?: InputMaybe<Scalars['String']['input']>;
  /** The severity level. A severity level of 'ONE' is the most severe, and a level of 'FIVE' is the least severe. */
  level?: InputMaybe<CompassIncidentEventSeverityLevel>;
};

export enum CompassIncidentEventSeverityLevel {
  Five = 'FIVE',
  Four = 'FOUR',
  One = 'ONE',
  Three = 'THREE',
  Two = 'TWO'
}

export enum CompassIncidentEventState {
  Deleted = 'DELETED',
  Open = 'OPEN',
  Resolved = 'RESOLVED'
}

/** The input to insert a metric value in all metric sources that match a specific combination of metricDefinitionId and externalMetricSourceId. */
export type CompassInsertMetricValueByExternalIdInput = {
  /** The cloud ID of the site to insert a metric value for. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the metric source that is external to the Compass site, for example, a Bitbucket repository ID. */
  externalMetricSourceId: Scalars['ID']['input'];
  /** The ID of the metric definition for which the value applies. */
  metricDefinitionId: Scalars['ID']['input'];
  /** The metric value to be inserted. */
  value: CompassMetricValueInput;
};

/** The input to insert a metric value into a metric source. */
export type CompassInsertMetricValueInput = {
  /** The ID of the metric source to insert the value into. */
  metricSourceId: Scalars['ID']['input'];
  /** The metric value to insert. */
  value: CompassMetricValueInput;
};

export type CompassJqlMetricDefinitionConfigurationInput = {
  /** Whether or not the JQL of this metric definition is customizable. */
  customizable: Scalars['Boolean']['input'];
  /** The format used to scope the JQL of this metric definition. */
  format?: InputMaybe<Scalars['String']['input']>;
  /** The JQL of this metric definition. */
  jql: Scalars['String']['input'];
};

export type CompassJqlMetricSourceConfigurationInput = {
  /** The custom JQL for the respective JQL metric definition */
  jql: Scalars['String']['input'];
};

/** The list of properties of the lifecycle event. */
export type CompassLifecycleEventInputProperties = {
  /** The ID of the lifecycle. */
  id: Scalars['ID']['input'];
  /** The stage of the lifecycle event. */
  stage: CompassLifecycleEventStage;
};

export enum CompassLifecycleEventStage {
  Deprecation = 'DEPRECATION',
  EndOfLife = 'END_OF_LIFE',
  PreRelease = 'PRE_RELEASE',
  Production = 'PRODUCTION'
}

export type CompassLifecycleFilterInput = {
  /** logical operator to use for values in the list */
  operator: CompassLifecycleFilterOperator;
  /** stages to consider when filtering components for application of scorecards */
  values: Array<Scalars['String']['input']>;
};

/**  MUTATION INPUTS/PAYLOAD TYPES */
export enum CompassLifecycleFilterOperator {
  Nor = 'NOR',
  Or = 'OR'
}

/** The types used to identify the intent of the link. */
export enum CompassLinkType {
  /** Chat Channels for contacting the owners/support of the component */
  ChatChannel = 'CHAT_CHANNEL',
  /** A link to the dashboard of the component. */
  Dashboard = 'DASHBOARD',
  /**
   * A link to the documentation of the component.
   * @deprecated Documents should be created with the documentation API
   */
  Document = 'DOCUMENT',
  /** A link to the on-call schedule of the component. */
  OnCall = 'ON_CALL',
  /** Other link for a Component. */
  OtherLink = 'OTHER_LINK',
  /** A link to the Jira or third-party project of the component. */
  Project = 'PROJECT',
  /** A link to the source code repository of the component. */
  Repository = 'REPOSITORY'
}

export type CompassMetricDefinitionConfigurationInput = {
  /** The JQL configuration of the metric definition. */
  jql?: InputMaybe<CompassJqlMetricDefinitionConfigurationInput>;
};

export type CompassMetricDefinitionFormatInput = {
  /** A plain-text suffix appended to the metric value when displayed, for example, 'MB/s'. */
  suffix?: InputMaybe<CompassMetricDefinitionFormatSuffixInput>;
};

/** The format option to append a plain-text suffix to metric values. */
export type CompassMetricDefinitionFormatSuffixInput = {
  /** A plain-text suffix appended to the metric value when displayed, for example, 'MB/s'. */
  suffix: Scalars['String']['input'];
};

/** Used to identify the type for the metric */
export enum CompassMetricDefinitionType {
  /** Predefined metrics built in to Compass */
  BuiltIn = 'BUILT_IN',
  /** Metrics defined by the individual user */
  Custom = 'CUSTOM'
}

/** The query to get the metric definitions on a Compass site. */
export type CompassMetricDefinitionsQuery = {
  /** Returns results after the specified cursor. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The cloud ID of the site to query for metric definitions on. */
  cloudId: Scalars['ID']['input'];
  /** The number of results to return in the query. The default is 10. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassMetricSourceConfigurationInput = {
  /** The custom JQL for the respective JQL metric definition */
  jql?: InputMaybe<CompassJqlMetricSourceConfigurationInput>;
};

export type CompassMetricSourceFilter = {
  metricDefinition?: InputMaybe<CompassMetricSourceMetricDefinitionFilter>;
};

export type CompassMetricSourceMetricDefinitionFilter = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type CompassMetricSourceQuery = {
  matchAnyFilter?: InputMaybe<Array<CompassMetricSourceFilter>>;
};

/** The query to get the metric values from a component's metric source. */
export type CompassMetricSourceValuesQuery = {
  /** Returns the values after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The number of results to return in the query. The default is 10. */
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassMetricSourcesQuery = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};

/** A metric value to be inserted. */
export type CompassMetricValueInput = {
  /** The time the metric value was collected. */
  timestamp: Scalars['DateTime']['input'];
  /** The value of the metric. */
  value: Scalars['Float']['input'];
};

export type CompassMetricValuesFilter = {
  timeRange?: InputMaybe<CompassMetricValuesTimeRangeFilter>;
};

export type CompassMetricValuesQuery = {
  matchAnyFilter?: InputMaybe<Array<CompassMetricValuesFilter>>;
};

export type CompassMetricValuesTimeRangeFilter = {
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
};

export type CompassPackageDependencyComparatorInput = {
  packageDependencyNullaryComparatorInput?: InputMaybe<CompassPackageDependencyNullaryComparatorInput>;
  packageDependencyUnaryComparatorInput?: InputMaybe<CompassPackageDependencyUnaryComparatorInput>;
};

export enum CompassPackageDependencyManagerOptions {
  Npm = 'NPM'
}

export type CompassPackageDependencyNullaryComparatorInput = {
  /** The comparison operation to be performed on the package. */
  comparator: CompassPackageDependencyNullaryComparatorOptions;
};

export enum CompassPackageDependencyNullaryComparatorOptions {
  IsAbsent = 'IS_ABSENT',
  IsPresent = 'IS_PRESENT'
}

export type CompassPackageDependencyUnaryComparatorInput = {
  /** The comparison operation to be performed between the package version and comparator value. */
  comparator: CompassPackageDependencyUnaryComparatorOptions;
  /** The comparator value, like a version number or a regex. */
  comparatorValue: Scalars['String']['input'];
};

export enum CompassPackageDependencyUnaryComparatorOptions {
  CompatibleWith = 'COMPATIBLE_WITH',
  Equals = 'EQUALS',
  GreaterThan = 'GREATER_THAN',
  GreaterThanOrEqualTo = 'GREATER_THAN_OR_EQUAL_TO',
  LessThan = 'LESS_THAN',
  LessThanOrEqualTo = 'LESS_THAN_OR_EQUAL_TO',
  MatchesRegex = 'MATCHES_REGEX',
  NotEqualTo = 'NOT_EQUAL_TO'
}

export type CompassPlainMetricSourceConfigurationInput = {
  /** External configuration query */
  query: Scalars['String']['input'];
};

/** The list of properties of the pull event. */
export type CompassPullRequestInputProperties = {
  /** The ID of the pull request event. */
  id: Scalars['String']['input'];
  /** The URL of the pull request. */
  pullRequestUrl: Scalars['String']['input'];
  /** The URL of the repository of the pull request. */
  repoUrl: Scalars['String']['input'];
  /** The status of the pull request. */
  status: CompassCreatePullRequestStatus;
};

export enum CompassPullRequestQuerySortName {
  /** The time between a PR's created and merged or rejected state. */
  CycleTime = 'CYCLE_TIME',
  OpenToFirstReview = 'OPEN_TO_FIRST_REVIEW',
  PrClosedTime = 'PR_CLOSED_TIME',
  PrCreatedTime = 'PR_CREATED_TIME',
  /** The time between a PR's first reviewed and last reviewed timestamps. */
  ReviewTime = 'REVIEW_TIME'
}

export enum CompassPullRequestStatus {
  Created = 'CREATED',
  FirstReviewed = 'FIRST_REVIEWED',
  Merged = 'MERGED',
  Overdue = 'OVERDUE',
  Rejected = 'REJECTED'
}

/** The pull request status used in the StatusInTimeRangeFilter query. */
export enum CompassPullRequestStatusForStatusInTimeRangeFilter {
  Created = 'CREATED',
  FirstReviewed = 'FIRST_REVIEWED',
  Merged = 'MERGED',
  Rejected = 'REJECTED'
}

/** Accepts input to find pull requests. */
export type CompassPullRequestsQuery = {
  /** Returns the pull requests which matches one of the current status. */
  matchAnyCurrentStatus?: InputMaybe<Array<CompassPullRequestStatus>>;
  /** The filters used in the query. The relationship of filters is OR. */
  matchAnyFilters?: InputMaybe<Array<CompassPullRequestsQueryFilter>>;
  /** The sorting mechanism used in the query. */
  sort?: InputMaybe<CompassPullRequestsQuerySort>;
};

/** Accepts input for querying pull requests. */
export type CompassPullRequestsQueryFilter = {
  /** Input for querying pull request based on status and time range. */
  statusInTimeRange?: InputMaybe<PullRequestStatusInTimeRangeQueryFilter>;
};

export type CompassPullRequestsQuerySort = {
  /** The name of the field to sort by. */
  name: CompassPullRequestQuerySortName;
  /** The order to sort by. */
  order: CompassQuerySortOrder;
};

/** The author who made the push */
export type CompassPushEventAuthorInput = {
  /** The email of the author. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** The name of the author. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The list of properties of the push event. */
export type CompassPushEventInputProperties = {
  /** The author who made the push. */
  author?: InputMaybe<CompassPushEventAuthorInput>;
  /** The name of the branch being pushed to. */
  branchName: Scalars['String']['input'];
  /** The ID of the push to event. */
  id: Scalars['ID']['input'];
};

/** A filter to apply to the search results. */
export type CompassQueryFieldFilter = {
  filter?: InputMaybe<CompassQueryFilter>;
  /** The name of the field to apply the filter. The valid field names are compass:tier, labels, ownerId, score, type, links, linkTypes, state, and eventSourceCount. */
  name: Scalars['String']['input'];
};

export type CompassQueryFilter = {
  eq?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to */
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to */
  lte?: InputMaybe<Scalars['String']['input']>;
  neq?: InputMaybe<Scalars['String']['input']>;
};

export type CompassQuerySort = {
  name?: InputMaybe<Scalars['String']['input']>;
  /**  name of field to sort results by */
  order?: InputMaybe<CompassQuerySortOrder>;
};

export enum CompassQuerySortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type CompassQueryTimeRange = {
  /** End date for query, exclusive. */
  endDate: Scalars['DateTime']['input'];
  /** Start date for query, inclusive. */
  startDate: Scalars['DateTime']['input'];
};

/** Defines the possible relationship directions between components. */
export enum CompassRelationshipDirection {
  /** Going from the other component to this component. */
  Inward = 'INWARD',
  /** Going from this component to the other component. */
  Outward = 'OUTWARD'
}

/** Accepts input for finding component relationships. */
export type CompassRelationshipQuery = {
  /** The relationships to be returned after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The direction of relationships to be searched for. */
  direction?: CompassRelationshipDirection;
  /** The number of relationships to return in the query. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** The filter for the relationship type to be searched for. */
  relationshipType?: CompassRelationshipTypeInput;
};

export type CompassRelationshipQueryFilters = {
  /** OR'd set of relationship types. */
  types?: InputMaybe<Array<CompassRelationshipType>>;
};

/** Defines the relationship types. A relationship must be one of these types. */
export enum CompassRelationshipType {
  DependsOn = 'DEPENDS_ON'
}

/** Defines the relationship input types. A relationship type input must be one of these types. */
export enum CompassRelationshipTypeInput {
  ChildOf = 'CHILD_OF',
  DependsOn = 'DEPENDS_ON'
}

/** Accepts input for removing labels from a team. */
export type CompassRemoveTeamLabelsInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
  /** A list of labels that should be removed from the team. */
  labels: Array<Scalars['String']['input']>;
  /** The unique identifier (ID) of the target team. */
  teamId: Scalars['ID']['input'];
};

export type CompassRepositoryValueInput = {
  /** The repository link exists or not */
  exists: Scalars['Boolean']['input'];
};

export type CompassResyncRepoFileInput = {
  action: Scalars['String']['input'];
  currentFilePath: CompassResyncRepoFilePaths;
  fileSize?: InputMaybe<Scalars['Int']['input']>;
  oldFilePath?: InputMaybe<CompassResyncRepoFilePaths>;
};

export type CompassResyncRepoFilePaths = {
  fullFilePath: Scalars['String']['input'];
  localFilePath: Scalars['String']['input'];
};

export type CompassResyncRepoFilesInput = {
  baseRepoUrl: Scalars['String']['input'];
  changedFiles: Array<CompassResyncRepoFileInput>;
  cloudId: Scalars['ID']['input'];
  repoId: Scalars['String']['input'];
};

export type CompassRevokeJqlMetricSourceUserInput = {
  metricSourceId: Scalars['ID']['input'];
};

export type CompassScoreStatisticsHistoryComponentTypesFilter = {
  /** The types of components to filter on, for example SERVICE. */
  in: Array<Scalars['ID']['input']>;
};

export type CompassScoreStatisticsHistoryDateFilter = {
  /** The date to start filtering score statistics history. */
  startFrom: Scalars['DateTime']['input'];
};

export type CompassScoreStatisticsHistoryOwnersFilter = {
  /** The team owners to filter on. */
  in: Array<Scalars['ID']['input']>;
};

export type CompassScorecardAppliedToComponentsComponentStateFilter = {
  /** The states of the component to filter on, for example ACTIVE. */
  in: Array<Scalars['String']['input']>;
};

export type CompassScorecardAppliedToComponentsCriteriaFilter = {
  /** The ID of the scorecard criterion. */
  id: Scalars['ID']['input'];
  /** The statuses of the criterion to filter on, for example FAILING. */
  statuses: Array<Scalars['ID']['input']>;
};

export type CompassScorecardAppliedToComponentsFieldFilter = {
  /** The ID of the field definition, for example 'compass:tier'. */
  definition: Scalars['ID']['input'];
  /** The values of the field to filter on. */
  in: Array<CompassFieldValueInput>;
};

export type CompassScorecardAppliedToComponentsLabelsFilter = {
  /** The labels of components to filter on. */
  in: Array<Scalars['String']['input']>;
};

export type CompassScorecardAppliedToComponentsMaturityLevelFilter = {
  maturityLevels: Array<Scalars['ID']['input']>;
};

export type CompassScorecardAppliedToComponentsOwnerFilter = {
  /** The team owners to filter on. */
  in: Array<Scalars['ID']['input']>;
};

/** Accepts input to find components a scorecard is applied to and their scores */
export type CompassScorecardAppliedToComponentsQuery = {
  /** Returns the components after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Returns only components whose attributes match those in the filters specified */
  filter?: InputMaybe<CompassScorecardAppliedToComponentsQueryFilter>;
  /** The first N number of components to return in the query. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Returns components according to the sorting scheme specified. */
  sort?: InputMaybe<CompassScorecardAppliedToComponentsQuerySort>;
};

export type CompassScorecardAppliedToComponentsQueryFilter = {
  componentStates?: InputMaybe<CompassScorecardAppliedToComponentsComponentStateFilter>;
  customFields?: InputMaybe<Array<CompassCustomFieldFilterInput>>;
  fields?: InputMaybe<Array<CompassScorecardAppliedToComponentsFieldFilter>>;
  labels?: InputMaybe<CompassScorecardAppliedToComponentsLabelsFilter>;
  owners?: InputMaybe<CompassScorecardAppliedToComponentsOwnerFilter>;
  score?: InputMaybe<CompassScorecardAppliedToComponentsThresholdFilter>;
  scoreRanges?: InputMaybe<CompassScorecardAppliedToComponentsScoreRangeFilter>;
  scorecardCriteria?: InputMaybe<Array<CompassScorecardAppliedToComponentsCriteriaFilter>>;
  scorecardMaturityLevels?: InputMaybe<CompassScorecardAppliedToComponentsMaturityLevelFilter>;
  scorecardStatus?: InputMaybe<CompassScorecardAppliedToComponentsStatusFilter>;
  types?: InputMaybe<CompassScorecardAppliedToComponentsTypesFilter>;
};

/** Accepts input to sort the applied components by. */
export type CompassScorecardAppliedToComponentsQuerySort = {
  /** The name of the field to sort by. Supports `SCORE` for scorecard score. */
  name: Scalars['String']['input'];
  /** The order to sort the applied components by. */
  order: CompassScorecardQuerySortOrder;
};

export type CompassScorecardAppliedToComponentsScoreRange = {
  from: Scalars['Int']['input'];
  to: Scalars['Int']['input'];
};

export type CompassScorecardAppliedToComponentsScoreRangeFilter = {
  in: Array<CompassScorecardAppliedToComponentsScoreRange>;
};

export type CompassScorecardAppliedToComponentsStatusFilter = {
  /** The statuses of the scorecard to filter on, for example NEEDS_ATTENTION. */
  statuses: Array<Scalars['ID']['input']>;
};

export type CompassScorecardAppliedToComponentsThresholdFilter = {
  lt: Scalars['Int']['input'];
};

export type CompassScorecardAppliedToComponentsTypesFilter = {
  /** The types of components to filter on, for example SERVICE. */
  in: Array<Scalars['ID']['input']>;
};

export type CompassScorecardCriteriaMaturityGroupInput = {
  /** The maturity level to assign the scorecard criterion to. */
  maturityLevel: CompassScorecardCriteriaMaturityLevelInput;
};

export type CompassScorecardCriteriaMaturityLevelInput = {
  /** The maturity level ID. */
  id: Scalars['ID']['input'];
};

/** Specifies the periodicity (regular repetition at fixed intervals) of the criteria score history data. */
export enum CompassScorecardCriteriaScoreHistoryPeriodicity {
  Daily = 'DAILY',
  Weekly = 'WEEKLY'
}

/** Accepts input for querying criteria score history. */
export type CompassScorecardCriteriaScoreHistoryQuery = {
  /** A filter which refines the criteria score history query. */
  filter?: InputMaybe<CompassScorecardCriteriaScoreHistoryQueryFilter>;
};

/** Accepts input for filtering when querying criteria score history. */
export type CompassScorecardCriteriaScoreHistoryQueryFilter = {
  /** The periodicity (regular repetition at fixed intervals) of the criteria score history data. */
  periodicity?: InputMaybe<CompassScorecardCriteriaScoreHistoryPeriodicity>;
  /** The date (midnight UTC) which the queried criteria score history data will start, which cannot be in the future. */
  startFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

export type CompassScorecardCriteriaScoreQuery = {
  /** The unique identifier (ID) of the component. */
  componentId: Scalars['ID']['input'];
};

export type CompassScorecardCriteriaScoreStatisticsHistoryQuery = {
  filter?: InputMaybe<CompassScorecardCriteriaScoreStatisticsHistoryQueryFilter>;
};

/** Accepts input to filter the scorecard criteria statistics history. */
export type CompassScorecardCriteriaScoreStatisticsHistoryQueryFilter = {
  /** The component states to filter by. */
  componentStates?: InputMaybe<CompassScorecardAppliedToComponentsComponentStateFilter>;
  /** The types of components to filter by. */
  componentTypes?: InputMaybe<CompassScoreStatisticsHistoryComponentTypesFilter>;
  /** A collection of custom field IDs and values to filter what components the scorecard applies to */
  customFields?: InputMaybe<Array<CompassCustomFieldFilterInput>>;
  /** The date at which to start filtering. */
  date?: InputMaybe<CompassScoreStatisticsHistoryDateFilter>;
  /** A collection of component labels used to filter what components the scorecard applies to. */
  labels?: InputMaybe<CompassScorecardScoreStatisticsLabelsFilter>;
  /** The team owners to filter by. */
  owners?: InputMaybe<CompassScoreStatisticsHistoryOwnersFilter>;
};

export enum CompassScorecardCriteriaScoringStrategyRuleAction {
  MarkAsError = 'MARK_AS_ERROR',
  MarkAsFailed = 'MARK_AS_FAILED',
  MarkAsPassed = 'MARK_AS_PASSED',
  MarkAsSkipped = 'MARK_AS_SKIPPED'
}

export enum CompassScorecardCriterionExpressionBooleanComparatorOptions {
  EqualTo = 'EQUAL_TO',
  NotEqualTo = 'NOT_EQUAL_TO'
}

export enum CompassScorecardCriterionExpressionCollectionComparatorOptions {
  AllOf = 'ALL_OF',
  AnyOf = 'ANY_OF',
  NoneOf = 'NONE_OF'
}

export enum CompassScorecardCriterionExpressionEvaluationRuleAction {
  Continue = 'CONTINUE',
  ReturnError = 'RETURN_ERROR',
  ReturnFailed = 'RETURN_FAILED',
  ReturnPassed = 'RETURN_PASSED',
  ReturnSkipped = 'RETURN_SKIPPED'
}

export enum CompassScorecardCriterionExpressionMembershipComparatorOptions {
  In = 'IN',
  NotIn = 'NOT_IN'
}

export enum CompassScorecardCriterionExpressionNumberComparatorOptions {
  EqualTo = 'EQUAL_TO',
  GreaterThan = 'GREATER_THAN',
  GreaterThanOrEqualTo = 'GREATER_THAN_OR_EQUAL_TO',
  LessThan = 'LESS_THAN',
  LessThanOrEqualTo = 'LESS_THAN_OR_EQUAL_TO',
  NotEqualTo = 'NOT_EQUAL_TO'
}

/**  Create/Update Inputs */
export enum CompassScorecardCriterionExpressionTextComparatorOptions {
  EqualTo = 'EQUAL_TO',
  NotEqualTo = 'NOT_EQUAL_TO',
  Regex = 'REGEX'
}

/**  COMPASS SCORECARD DEACTIVATION TYPES */
export type CompassScorecardDeactivatedComponentsQuery = {
  filter?: InputMaybe<CompassScorecardDeactivatedComponentsQueryFilter>;
  sort?: InputMaybe<CompassScorecardDeactivatedComponentsQuerySort>;
};

export type CompassScorecardDeactivatedComponentsQueryFilter = {
  fields?: InputMaybe<Array<CompassScorecardAppliedToComponentsFieldFilter>>;
  labels?: InputMaybe<CompassScorecardAppliedToComponentsLabelsFilter>;
  owners?: InputMaybe<CompassScorecardAppliedToComponentsOwnerFilter>;
  types?: InputMaybe<CompassScorecardAppliedToComponentsTypesFilter>;
};

/** Accepts input to sort the deactivated components by. */
export type CompassScorecardDeactivatedComponentsQuerySort = {
  /** The name of the field to sort by. */
  name: Scalars['String']['input'];
  /** The order to sort the deactivated components by. */
  order: CompassScorecardQuerySortOrder;
};

/** The types used to identify the importance of the scorecard. */
export enum CompassScorecardImportance {
  /** Recommended to the component's owner when they select a scorecard to apply to their component. */
  Recommended = 'RECOMMENDED',
  /** Automatically applied to all components of the specified type or types and cannot be removed. */
  Required = 'REQUIRED',
  /** Custom scorecard, focused on specific use cases within teams or departments. */
  UserDefined = 'USER_DEFINED'
}

export type CompassScorecardMaturityLevelHistoryQuery = {
  filter?: InputMaybe<CompassScorecardMaturityLevelHistoryQueryFilter>;
};

export type CompassScorecardMaturityLevelHistoryQueryFilter = {
  periodicity?: InputMaybe<CompassScorecardScoreHistoryPeriodicity>;
  startFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

export type CompassScorecardMaturityLevelStatisticsHistoryQuery = {
  filter?: InputMaybe<CompassScorecardMaturityLevelStatisticsHistoryQueryFilter>;
};

export type CompassScorecardMaturityLevelStatisticsHistoryQueryFilter = {
  componentStates?: InputMaybe<CompassScorecardAppliedToComponentsComponentStateFilter>;
  componentTypes?: InputMaybe<CompassScoreStatisticsHistoryComponentTypesFilter>;
  date?: InputMaybe<CompassScoreStatisticsHistoryDateFilter>;
  owners?: InputMaybe<CompassScoreStatisticsHistoryOwnersFilter>;
};

/** Accepts input to filter the scorecards by. */
export type CompassScorecardQueryFilter = {
  /** Filter by the collection of component types matching that of the scorecards. */
  componentTypeIds?: InputMaybe<CompassScorecardAppliedToComponentsTypesFilter>;
  /** Text input used to find matching scorecards by name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Filter by the scorecard owner's accountId. */
  ownerId?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filter by the state of the scorecard. */
  state?: InputMaybe<Scalars['String']['input']>;
  /** Filter by the type of the scorecard. */
  type?: InputMaybe<CompassScorecardTypesFilter>;
  /** Filter by the scorecard's verified status. */
  verified?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Accepts input to sort the scorecards by. */
export type CompassScorecardQuerySort = {
  /** Sort by the specified field. Supports `NAME` for scorecard name and `COMPONENT_COUNT` for associated component count. */
  name: Scalars['String']['input'];
  /** The order to sort the scorecards by. */
  order: CompassScorecardQuerySortOrder;
};

/** Sort scorecards in ascending or descending order of specified field. */
export enum CompassScorecardQuerySortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type CompassScorecardScoreDurationStatisticsQuery = {
  filter?: InputMaybe<CompassScorecardScoreDurationStatisticsQueryFilter>;
};

/** Accepts input to filter the scorecard score durations statistics. */
export type CompassScorecardScoreDurationStatisticsQueryFilter = {
  /** The types of components to filter by. */
  componentTypes?: InputMaybe<CompassScoreStatisticsHistoryComponentTypesFilter>;
  /** A collection of custom field IDs and values to filter what components the scorecard applies to */
  customFields?: InputMaybe<Array<CompassCustomFieldFilterInput>>;
  /** A collection of component labels used to filter what components the scorecard applies to. */
  labels?: InputMaybe<CompassScorecardScoreStatisticsLabelsFilter>;
  /** The team owners to filter by. */
  owners?: InputMaybe<CompassScoreStatisticsHistoryOwnersFilter>;
};

/** Specifies the periodicity (regular repetition at fixed intervals) of the scorecard score history data. */
export enum CompassScorecardScoreHistoryPeriodicity {
  Daily = 'DAILY',
  Weekly = 'WEEKLY'
}

/** Accepts input for querying scorecard score history. */
export type CompassScorecardScoreHistoryQuery = {
  /** A filter which refines the scorecard score history query. */
  filter?: InputMaybe<CompassScorecardScoreHistoryQueryFilter>;
};

/** Accepts input for filtering when querying scorecard score history. */
export type CompassScorecardScoreHistoryQueryFilter = {
  /** The periodicity (regular repetition at fixed intervals) of the scorecard score history data. */
  periodicity?: InputMaybe<CompassScorecardScoreHistoryPeriodicity>;
  /** The date (midnight UTC) which the queried scorecard score history data will start, which cannot be in the future. */
  startFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Scorecard score on a scorecard for a component. */
export type CompassScorecardScoreQuery = {
  /** The unique identifier (ID) of the component. */
  componentId: Scalars['ID']['input'];
};

export type CompassScorecardScoreStatisticsHistoryQuery = {
  filter?: InputMaybe<CompassScorecardScoreStatisticsHistoryQueryFilter>;
};

/** Accepts input to filter the scorecard score statistics history. */
export type CompassScorecardScoreStatisticsHistoryQueryFilter = {
  /** The component states to filter by. */
  componentStates?: InputMaybe<CompassScorecardAppliedToComponentsComponentStateFilter>;
  /** The types of components to filter by. */
  componentTypes?: InputMaybe<CompassScoreStatisticsHistoryComponentTypesFilter>;
  /** A collection of custom field IDs and values to filter what components the scorecard applies to */
  customFields?: InputMaybe<Array<CompassCustomFieldFilterInput>>;
  /** The date at which to start filtering. */
  date?: InputMaybe<CompassScoreStatisticsHistoryDateFilter>;
  /** A collection of component labels used to filter what components the scorecard applies to. */
  labels?: InputMaybe<CompassScorecardScoreStatisticsLabelsFilter>;
  /** The team owners to filter by. */
  owners?: InputMaybe<CompassScoreStatisticsHistoryOwnersFilter>;
};

export type CompassScorecardScoreStatisticsLabelsFilter = {
  /** The labels of components to filter on. */
  in: Array<Scalars['String']['input']>;
};

export enum CompassScorecardScoreSystemType {
  MaturityLevel = 'MATURITY_LEVEL',
  ThresholdPercentageBased = 'THRESHOLD_PERCENTAGE_BASED',
  ThresholdPointBased = 'THRESHOLD_POINT_BASED'
}

export enum CompassScorecardScoringStrategyType {
  PercentageBased = 'PERCENTAGE_BASED',
  PointBased = 'POINT_BASED',
  WeightBased = 'WEIGHT_BASED'
}

export type CompassScorecardStatusConfigInput = {
  /** Input for threshold for a failing status. */
  failing: CompassScorecardStatusThresholdInput;
  /** Input for threshold for a needs-attention status. */
  needsAttention: CompassScorecardStatusThresholdInput;
  /** Input for threshold for a passing status. */
  passing: CompassScorecardStatusThresholdInput;
};

export type CompassScorecardStatusThresholdInput = {
  /** Input for lower threshold value for particular status. */
  lowerBound: Scalars['Int']['input'];
  /** Input for upper threshold value for particular status. */
  upperBound: Scalars['Int']['input'];
};

export type CompassScorecardTypesFilter = {
  /** The types of scorecards to filter on, for example CUSTOM. */
  in: Array<Scalars['String']['input']>;
};

/** Accepts input to find available scorecards, optionally filtered and/or sorted. */
export type CompassScorecardsQuery = {
  /** Returns the scorecards after the specified cursor position. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Returns only scorecards whose attributes match those in the filters specified. */
  filter?: InputMaybe<CompassScorecardQueryFilter>;
  /** The first N number of scorecards to return in the query. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Returns scorecards according to the sorting scheme specified. */
  sort?: InputMaybe<CompassScorecardQuerySort>;
};

/** The query to find component labels within Compass. */
export type CompassSearchComponentLabelsQuery = {
  /** Returns results after the specified cursor. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Number of results to return in the query. The default is 25. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Text query to search against. */
  query?: InputMaybe<Scalars['String']['input']>;
  /** Sorting parameters for the results to be searched for. The default is by ranked results. */
  sort?: InputMaybe<Array<InputMaybe<CompassQuerySort>>>;
};

/** The query to find components. */
export type CompassSearchComponentQuery = {
  /** Returns results after the specified cursor. */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Filters on component fields to be searched against. */
  fieldFilters?: InputMaybe<Array<InputMaybe<CompassQueryFieldFilter>>>;
  /** Number of results to return in the query. The default is 25. */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Text query to search against. */
  query?: InputMaybe<Scalars['String']['input']>;
  /** How the query results will be sorted. This is essential for proper pagination of results. */
  sort?: InputMaybe<Array<InputMaybe<CompassQuerySort>>>;
};

export type CompassSearchPackagesQuery = {
  /** The package manager type. */
  packageManager?: InputMaybe<CompassPackageDependencyManagerOptions>;
  /** The name of the package to search for. */
  query?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for searching team labels. */
export type CompassSearchTeamLabelsInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
};

export type CompassSearchTeamsInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
  /** A list of possible labels to filter by. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The possible term to search teams by. */
  term?: InputMaybe<Scalars['String']['input']>;
};

export type CompassSetEntityPropertyInput = {
  cloudId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type CompassSloMetricSourceConfigurationInput = {
  /** External configuration bad metrics query */
  badQuery: Scalars['String']['input'];
  /** External configuration good metrics query */
  goodQuery: Scalars['String']['input'];
};

export type CompassSynchronizeLinkAssociationsInput = {
  /** The cloud ID of the site to synchronize link associations on. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the Forge app to query for link association information */
  forgeAppId: Scalars['ID']['input'];
  /** The parameters to synchronize link associations on. */
  options?: InputMaybe<CompassSynchronizeLinkAssociationsOptions>;
};

export type CompassSynchronizeLinkAssociationsOptions = {
  /** The event types to synchronize link associations on. If not provided, all event types will be considered for synchronization. */
  eventTypes?: InputMaybe<Array<InputMaybe<CompassEventType>>>;
  /** A regular expression that filters the URLs of links to be synchronized. If not provided, all URLs will be considered for synchronization. */
  urlFilterRegex?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for creating/updating/deleting team checkin's action item. */
export type CompassTeamCheckinActionInput = {
  create?: InputMaybe<CompassCreateTeamCheckinActionInput>;
  delete?: InputMaybe<CompassDeleteTeamCheckinActionInput>;
  update?: InputMaybe<CompassUpdateTeamCheckinActionInput>;
};

/** Accepts input for deleting a team checkin. */
export type CompassTeamCheckinsInput = {
  /** The cloud ID of the site to update a checkin on. */
  cloudId: Scalars['ID']['input'];
  /** The unique identifier (ID) of the team that did the checkin. */
  teamId: Scalars['ID']['input'];
};

/** Accepts input for viewing Compass-specific data about a team. */
export type CompassTeamDataInput = {
  /** The cloud ID of the target site. */
  cloudId: Scalars['ID']['input'];
  /** The unique identifier (ID) of the target team. */
  teamId: Scalars['ID']['input'];
};

export type CompassUnsetEntityPropertyInput = {
  cloudId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
};

/** Accepts input for updating a component announcement. */
export type CompassUpdateAnnouncementInput = {
  /** Whether the existing acknowledgements should be reset or not. */
  clearAcknowledgements?: InputMaybe<Scalars['Boolean']['input']>;
  /** The cloud ID of the site to update an announcement on. */
  cloudId: Scalars['ID']['input'];
  /** The description of the announcement. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the announcement being updated. */
  id: Scalars['ID']['input'];
  /** The date on which the changes in the announcement will take effect. */
  targetDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** The title of the announcement. */
  title?: InputMaybe<Scalars['String']['input']>;
};

export type CompassUpdateCampaignInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  dueDate?: InputMaybe<Scalars['DateTime']['input']>;
  filters?: InputMaybe<CompassGoalFiltersInput>;
  goalId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for updating a Component Scorecard work item. */
export type CompassUpdateComponentScorecardWorkItemInput = {
  /** The ID of the component. */
  componentId: Scalars['ID']['input'];
  /** Whether a Component scorecard work item is active or not. */
  isActive: Scalars['Boolean']['input'];
  /** The ID of the scorecard. */
  scorecardId: Scalars['ID']['input'];
  /** The ID of the work item. */
  workItemId: Scalars['ID']['input'];
};

/** Accepts input for updating a custom boolean field definition. */
export type CompassUpdateCustomBooleanFieldDefinitionInput = {
  /** The component types the custom boolean field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom boolean field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom boolean field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom boolean field definition. */
  id: Scalars['ID']['input'];
  /** The name of the custom boolean field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for updating a custom field definition. You must provide exactly one of the fields in this input type. */
export type CompassUpdateCustomFieldDefinitionInput = {
  /** Input for updating a custom boolean field definition. */
  booleanFieldDefinition?: InputMaybe<CompassUpdateCustomBooleanFieldDefinitionInput>;
  /** Input for updating a custom multi-select field definition. */
  multiSelectFieldDefinition?: InputMaybe<CompassUpdateCustomMultiSelectFieldDefinitionInput>;
  /** Input for updating a custom number field definition. */
  numberFieldDefinition?: InputMaybe<CompassUpdateCustomNumberFieldDefinitionInput>;
  /** Input for updating a custom single-select field definition. */
  singleSelectFieldDefinition?: InputMaybe<CompassUpdateCustomSingleSelectFieldDefinitionInput>;
  /** Input for updating a custom text field definition. */
  textFieldDefinition?: InputMaybe<CompassUpdateCustomTextFieldDefinitionInput>;
  /** Input for updating a custom user field definition. */
  userFieldDefinition?: InputMaybe<CompassUpdateCustomUserFieldDefinitionInput>;
};

/** Accepts input for updating an option of a custom field. */
export type CompassUpdateCustomFieldOptionDefinitionInput = {
  /** The ID of the option to update. */
  id: Scalars['ID']['input'];
  /** New name for the option. */
  name: Scalars['String']['input'];
};

/** Accepts input for updating a custom multi select field definition. */
export type CompassUpdateCustomMultiSelectFieldDefinitionInput = {
  /** The component types the custom multi-select field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A list of options to create. */
  createOptions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of options to delete. */
  deleteOptions?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The description of the custom multi-select field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom multi-select field definition. */
  id: Scalars['ID']['input'];
  /** The name of the custom multi-select field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** A list of options to update. */
  updateOptions?: InputMaybe<Array<CompassUpdateCustomFieldOptionDefinitionInput>>;
};

/** Accepts input for updating a custom number field definition. */
export type CompassUpdateCustomNumberFieldDefinitionInput = {
  /** The component types the custom number field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom number field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom number field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom number field definition. */
  id: Scalars['ID']['input'];
  /** The name of the custom number field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type CompassUpdateCustomPermissionConfigsInput = {
  preset?: InputMaybe<CompassCustomPermissionPreset>;
};

/** Accepts input for updating a custom single select field definition. */
export type CompassUpdateCustomSingleSelectFieldDefinitionInput = {
  /** The component types the custom single-select field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A list of options to create. */
  createOptions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of options to delete. */
  deleteOptions?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The description of the custom single-select field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom single-select field definition. */
  id: Scalars['ID']['input'];
  /** The name of the custom single-select field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** A list of options to update. */
  updateOptions?: InputMaybe<Array<CompassUpdateCustomFieldOptionDefinitionInput>>;
};

/** Accepts input for updating a custom text field definition. */
export type CompassUpdateCustomTextFieldDefinitionInput = {
  /** The component types the custom text field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom text field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom text field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom text field definition. */
  id: Scalars['ID']['input'];
  /** The name of the custom text field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for updating a custom user field definition. */
export type CompassUpdateCustomUserFieldDefinitionInput = {
  /** The component types the custom user field applies to. */
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The component types the custom user field applies to. */
  componentTypes?: InputMaybe<Array<CompassComponentType>>;
  /** The description of the custom user field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom user field definition. */
  id: Scalars['ID']['input'];
  /** The name of the custom user field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type CompassUpdateDocumentInput = {
  /** The ID of the documentation category the document was added to. */
  documentationCategoryId?: InputMaybe<Scalars['ID']['input']>;
  /** The ARI of the document to update. */
  id: Scalars['ID']['input'];
  /** The (optional) display title of the document. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the document. */
  url?: InputMaybe<Scalars['URL']['input']>;
};

/**  Update Inputs */
export type CompassUpdateDynamicScorecardCriteriaInput = {
  expressions?: InputMaybe<Array<CompassUpdateScorecardCriterionExpressionTreeInput>>;
  id: Scalars['ID']['input'];
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to update a scorecard criterion checking the value of a specified custom boolean field. */
export type CompassUpdateHasCustomBooleanFieldScorecardCriteriaInput = {
  /** The comparison operation to be performed. */
  booleanComparator?: InputMaybe<CompassCriteriaBooleanComparatorOptions>;
  /** The value that the field is compared to. */
  booleanComparatorValue?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the component custom boolean field to check the value of. */
  customFieldDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassUpdateHasCustomMultiSelectFieldScorecardCriteriaInput = {
  /** The comparison operation to be performed between the field and comparator value. */
  collectionComparator?: InputMaybe<CompassCriteriaCollectionComparatorOptions>;
  /** The list of multi select options that the field is compared to. */
  collectionComparatorValue?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The ID of the component custom multi select field to check the value of. */
  customFieldDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to update a scorecard criterion checking the value of a specified custom number field. */
export type CompassUpdateHasCustomNumberFieldScorecardCriteriaInput = {
  /** The ID of the component custom number field to check the value of. */
  customFieldDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The comparison operation to be performed between the field and comparator value. */
  numberComparator?: InputMaybe<CompassCriteriaNumberComparatorOptions>;
  /** The threshold value that the field is compared to. */
  numberComparatorValue?: InputMaybe<Scalars['Float']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassUpdateHasCustomSingleSelectFieldScorecardCriteriaInput = {
  /** The ID of the component custom single select field to check the value of. */
  customFieldDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The comparison operation to be performed between the field and comparator value. */
  membershipComparator?: InputMaybe<CompassCriteriaMembershipComparatorOptions>;
  /** The list of single select options that the field is compared to. */
  membershipComparatorValue?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to update a scorecard criterion checking the value of a specified custom text field. */
export type CompassUpdateHasCustomTextFieldScorecardCriteriaInput = {
  /** The ID of the component custom text field to check the value of. */
  customFieldDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The comparison operation to be performed. */
  textComparator?: InputMaybe<CompassCriteriaTextComparatorOptions>;
  /** The value that the field is compared to. */
  textComparatorValue?: InputMaybe<Scalars['String']['input']>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassUpdateHasPackageDependencyScorecardCriteriaInput = {
  /** Comparison operations the package must satisfy to pass. */
  comparators?: InputMaybe<Array<CompassPackageDependencyComparatorInput>>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The relevant package manager. */
  packageManager?: InputMaybe<CompassPackageDependencyManagerOptions>;
  /** The name of the dependency package. */
  packageName?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassUpdateJqlMetricSourceUserInput = {
  metricSourceId: Scalars['ID']['input'];
};

/** The input to update a metric definition. */
export type CompassUpdateMetricDefinitionInput = {
  /** The cloud ID of the built in metric definition being updated */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The configuration of the metric definition. */
  configuration?: InputMaybe<CompassMetricDefinitionConfigurationInput>;
  /** The updated description of the metric definition. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The updated format option of the metric definition. */
  format?: InputMaybe<CompassMetricDefinitionFormatInput>;
  /** The ID of the metric definition being updated. */
  id: Scalars['ID']['input'];
  isPinned?: InputMaybe<Scalars['Boolean']['input']>;
  /** The updated name of the metric definition. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The input for updating a metric source. */
export type CompassUpdateMetricSourceInput = {
  /** The configuration input used to update the metric source. */
  configuration?: InputMaybe<CompassMetricSourceConfigurationInput>;
  /** The data connection configuration of this metric source. */
  dataConnectionConfiguration?: InputMaybe<CompassDataConnectionConfigurationInput>;
  /** The metric source ID. */
  id: Scalars['ID']['input'];
};

export type CompassUpdateScorecardCriteriaScoringStrategyRulesInput = {
  onError?: InputMaybe<CompassScorecardCriteriaScoringStrategyRuleAction>;
  onFalse?: InputMaybe<CompassScorecardCriteriaScoringStrategyRuleAction>;
  onTrue?: InputMaybe<CompassScorecardCriteriaScoringStrategyRuleAction>;
};

export type CompassUpdateScorecardCriterionExpressionAndGroupInput = {
  expressions: Array<CompassUpdateScorecardCriterionExpressionGroupInput>;
};

export type CompassUpdateScorecardCriterionExpressionBooleanInput = {
  booleanComparator: CompassScorecardCriterionExpressionBooleanComparatorOptions;
  booleanComparatorValue: Scalars['Boolean']['input'];
  requirement: CompassUpdateScorecardCriterionExpressionRequirementInput;
};

export type CompassUpdateScorecardCriterionExpressionCollectionInput = {
  collectionComparator: CompassScorecardCriterionExpressionCollectionComparatorOptions;
  collectionComparatorValue: Array<Scalars['ID']['input']>;
  requirement: CompassUpdateScorecardCriterionExpressionRequirementInput;
};

export type CompassUpdateScorecardCriterionExpressionEvaluableInput = {
  expression: CompassUpdateScorecardCriterionExpressionInput;
};

export type CompassUpdateScorecardCriterionExpressionEvaluationRulesInput = {
  onError?: InputMaybe<CompassScorecardCriterionExpressionEvaluationRuleAction>;
  onFalse?: InputMaybe<CompassScorecardCriterionExpressionEvaluationRuleAction>;
  onTrue?: InputMaybe<CompassScorecardCriterionExpressionEvaluationRuleAction>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

export type CompassUpdateScorecardCriterionExpressionGroupInput = {
  and?: InputMaybe<CompassUpdateScorecardCriterionExpressionAndGroupInput>;
  evaluable?: InputMaybe<CompassUpdateScorecardCriterionExpressionEvaluableInput>;
  or?: InputMaybe<CompassUpdateScorecardCriterionExpressionOrGroupInput>;
};

export type CompassUpdateScorecardCriterionExpressionInput = {
  boolean?: InputMaybe<CompassUpdateScorecardCriterionExpressionBooleanInput>;
  collection?: InputMaybe<CompassUpdateScorecardCriterionExpressionCollectionInput>;
  membership?: InputMaybe<CompassUpdateScorecardCriterionExpressionMembershipInput>;
  number?: InputMaybe<CompassUpdateScorecardCriterionExpressionNumberInput>;
  text?: InputMaybe<CompassUpdateScorecardCriterionExpressionTextInput>;
};

export type CompassUpdateScorecardCriterionExpressionMembershipInput = {
  membershipComparator: CompassScorecardCriterionExpressionMembershipComparatorOptions;
  membershipComparatorValue: Array<Scalars['ID']['input']>;
  requirement: CompassUpdateScorecardCriterionExpressionRequirementInput;
};

export type CompassUpdateScorecardCriterionExpressionNumberInput = {
  numberComparator: CompassScorecardCriterionExpressionNumberComparatorOptions;
  numberComparatorValue: Scalars['Float']['input'];
  requirement: CompassUpdateScorecardCriterionExpressionRequirementInput;
};

export type CompassUpdateScorecardCriterionExpressionOrGroupInput = {
  expressions: Array<CompassUpdateScorecardCriterionExpressionGroupInput>;
};

export type CompassUpdateScorecardCriterionExpressionRequirementCustomFieldInput = {
  customFieldDefinitionId: Scalars['ID']['input'];
};

export type CompassUpdateScorecardCriterionExpressionRequirementDefaultFieldInput = {
  fieldName: Scalars['String']['input'];
};

export type CompassUpdateScorecardCriterionExpressionRequirementInput = {
  customField?: InputMaybe<CompassUpdateScorecardCriterionExpressionRequirementCustomFieldInput>;
  defaultField?: InputMaybe<CompassUpdateScorecardCriterionExpressionRequirementDefaultFieldInput>;
  metric?: InputMaybe<CompassUpdateScorecardCriterionExpressionRequirementMetricInput>;
};

export type CompassUpdateScorecardCriterionExpressionRequirementMetricInput = {
  metricDefinitionId: Scalars['ID']['input'];
};

export type CompassUpdateScorecardCriterionExpressionRequirementScorecardInput = {
  fieldName: Scalars['String']['input'];
  scorecardId: Scalars['ID']['input'];
};

export type CompassUpdateScorecardCriterionExpressionTextInput = {
  requirement: CompassUpdateScorecardCriterionExpressionRequirementInput;
  textComparator: CompassScorecardCriterionExpressionTextComparatorOptions;
  textComparatorValue: Scalars['String']['input'];
};

export type CompassUpdateScorecardCriterionExpressionTreeInput = {
  evaluationRules?: InputMaybe<CompassUpdateScorecardCriterionExpressionEvaluationRulesInput>;
  root: CompassUpdateScorecardCriterionExpressionGroupInput;
};

/** Accepts input for updating a team checkin action. */
export type CompassUpdateTeamCheckinActionInput = {
  /** The text of the team checkin action item. */
  actionText?: InputMaybe<Scalars['String']['input']>;
  /** Whether the action is completed or not. */
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the team checkin action item. */
  id: Scalars['ID']['input'];
};

/** Accepts input for updating a team checkin. */
export type CompassUpdateTeamCheckinInput = {
  /** A list of action items belong to the checkin. */
  actions?: InputMaybe<Array<CompassTeamCheckinActionInput>>;
  /** The cloud ID of the site to update a checkin on. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the team checkin being updated. */
  id: Scalars['ID']['input'];
  /** The mood of the team checkin. */
  mood: Scalars['Int']['input'];
  /** The response to the question 1 of the team checkin. */
  response1?: InputMaybe<Scalars['String']['input']>;
  /** The response to the question 1 of the team checkin in a rich text format. */
  response1RichText?: InputMaybe<CompassUpdateTeamCheckinResponseRichText>;
  /** The response to the question 2 of the team checkin. */
  response2?: InputMaybe<Scalars['String']['input']>;
  /** The response to the question 2 of the team checkin in a rich text format. */
  response2RichText?: InputMaybe<CompassUpdateTeamCheckinResponseRichText>;
  /** The response to the question 3 of the team checkin. */
  response3?: InputMaybe<Scalars['String']['input']>;
  /** The response to the question 3 of the team checkin in a rich text format. */
  response3RichText?: InputMaybe<CompassUpdateTeamCheckinResponseRichText>;
};

/** Accepts input for updating team checkin responses with rich text. */
export type CompassUpdateTeamCheckinResponseRichText = {
  /** Input for a team checkin response in Atlassian Document Format. */
  adf?: InputMaybe<Scalars['String']['input']>;
};

/** The severity of a vulnerability */
export type CompassVulnerabilityEventSeverityInput = {
  /** The label to use for displaying the severity */
  label?: InputMaybe<Scalars['String']['input']>;
  /** The severity level of the vulnerability */
  level: CompassVulnerabilityEventSeverityLevel;
};

export enum CompassVulnerabilityEventSeverityLevel {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM'
}

export enum CompassVulnerabilityEventState {
  Declined = 'DECLINED',
  Open = 'OPEN',
  Remediated = 'REMEDIATED'
}

/** Complete sprint */
export type CompleteSprintInput = {
  boardId: Scalars['ID']['input'];
  incompleteCardsDestination: SoftwareCardsDestination;
  sprintId: Scalars['ID']['input'];
};

/** Compliance Boundary of the Marketplace app's version */
export enum ComplianceBoundary {
  Commercial = 'COMMERCIAL',
  FedrampModerate = 'FEDRAMP_MODERATE',
  IsolatedCloud = 'ISOLATED_CLOUD'
}

/** Input for querying a component by one of it's unique identifiers. */
export type ComponentReferenceInput = {
  /** Input for querying a component by its ARI. */
  ari?: InputMaybe<Scalars['ID']['input']>;
  /** Input for querying a component by its slug. */
  slug?: InputMaybe<ComponentSlugReferenceInput>;
};

/** The component's identifier slug and cloud ID. */
export type ComponentSlugReferenceInput = {
  cloudId: Scalars['ID']['input'];
  slug: Scalars['String']['input'];
};

/** Details on the result of the last component sync. */
export type ComponentSyncEventInput = {
  /** Error messages explaining why last sync event failed. */
  lastSyncErrors?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Status of the last sync event. */
  status: ComponentSyncEventStatus;
};

/** Status types of a data manager sync event. */
export enum ComponentSyncEventStatus {
  /** A Compass internal server issue prevented the sync from occurring. */
  ServerError = 'SERVER_ERROR',
  /** The component updates were successfully synced to Compass. */
  Success = 'SUCCESS',
  /** An issue with the calling app or user input prevented the component from syncing to Compass. */
  UserError = 'USER_ERROR'
}

export type ConfluenceAcceptAnswerInput = {
  /** Flag to indicate if the answer is accepted/unaccepted by the author of the question */
  accept: Scalars['Boolean']['input'];
  /** Answer ID to be accepted */
  answerId: Scalars['ID']['input'];
  /** Question ID for the Answer */
  questionId: Scalars['ID']['input'];
};

export type ConfluenceAddCustomApplicationLinkInput = {
  allowedGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  displayName: Scalars['String']['input'];
  isHidden: Scalars['Boolean']['input'];
  url: Scalars['String']['input'];
};

export type ConfluenceAddTrackInput = {
  top?: InputMaybe<Scalars['Boolean']['input']>;
  track: ConfluenceTrackInput;
};

export enum ConfluenceAdminAnnouncementBannerStatusType {
  Published = 'PUBLISHED',
  Saved = 'SAVED',
  Scheduled = 'SCHEDULED'
}

export enum ConfluenceAdminAnnouncementBannerVisibilityType {
  All = 'ALL',
  Authorized = 'AUTHORIZED'
}

export enum ConfluenceAnalyticsCommentContentType {
  Database = 'database',
  Page = 'page',
  Whiteboard = 'whiteboard'
}

export type ConfluenceAnswerFilters = {
  /** Example filter */
  exampleFilter?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export enum ConfluenceAppInstallationLicenseCapabilitySet {
  CapabilityAdvanced = 'CAPABILITY_ADVANCED',
  CapabilityStandard = 'CAPABILITY_STANDARD'
}

export type ConfluenceAppLinkMapping = {
  newAppLink: ConfluenceAppLinkMetadataInput;
  oldAppLink: ConfluenceAppLinkMetadataInput;
};

export type ConfluenceAppLinkMetadataInput = {
  /** Server Id from Macro */
  serverId: Scalars['ID']['input'];
  /** Server name from Macro */
  serverName: Scalars['String']['input'];
};

export enum ConfluenceAppType {
  Connect = 'CONNECT',
  Forge = 'FORGE'
}

export enum ConfluenceApplication {
  Html = 'HTML',
  Miro = 'MIRO',
  Mural = 'MURAL',
  Notion = 'NOTION'
}

export enum ConfluenceApprovalTransitionType {
  Directed = 'DIRECTED',
  Initial = 'INITIAL'
}

export enum ConfluenceAssignableSpaceRolePrincipalType {
  Anonymous = 'ANONYMOUS',
  Guest = 'GUEST'
}

export enum ConfluenceAttachmentSecurityLevel {
  Insecure = 'INSECURE',
  Secure = 'SECURE',
  Smart = 'SMART'
}

export type ConfluenceBatchFollowTeammatesInput = {
  numFollowers?: InputMaybe<Scalars['Int']['input']>;
};

export enum ConfluenceBlogPostStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Deleted = 'DELETED',
  Draft = 'DRAFT',
  Historical = 'HISTORICAL',
  Trashed = 'TRASHED'
}

export enum ConfluenceBodyRepresentation {
  AnonymousExportView = 'ANONYMOUS_EXPORT_VIEW',
  AtlasDocFormat = 'ATLAS_DOC_FORMAT',
  Dynamic = 'DYNAMIC',
  Editor = 'EDITOR',
  Editor2 = 'EDITOR2',
  ExportView = 'EXPORT_VIEW',
  Storage = 'STORAGE',
  StyledView = 'STYLED_VIEW',
  View = 'VIEW',
  WhiteboardDocFormat = 'WHITEBOARD_DOC_FORMAT'
}

export type ConfluenceBulkPdfExportContent = {
  areChildrenIncluded?: InputMaybe<Scalars['Boolean']['input']>;
  /** ARI for the content. */
  contentId: Scalars['ID']['input'];
  /** ARIs for each direct child which should not be included in the final PDF export. */
  excludedChildrenIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type ConfluenceCalendarPermissionInput = {
  permission: ConfluenceCalendarPermissionsType;
  principalId: Scalars['ID']['input'];
};

export enum ConfluenceCalendarPermissionsType {
  Edit = 'EDIT',
  View = 'VIEW'
}

export type ConfluenceCalendarSubscribeInput = {
  calendarContext?: InputMaybe<Scalars['String']['input']>;
  ids: Array<InputMaybe<Scalars['String']['input']>>;
  viewingSpaceKey?: InputMaybe<Scalars['String']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum ConfluenceCatchupOverviewTimeframeLength {
  AllTime = 'ALL_TIME',
  OneDayAgo = 'ONE_DAY_AGO',
  OneMonthAgo = 'ONE_MONTH_AGO',
  OneWeekAgo = 'ONE_WEEK_AGO',
  TwoWeeksAgo = 'TWO_WEEKS_AGO'
}

export enum ConfluenceCategorizeNbmCategoryTypes {
  NotSupported = 'NOT_SUPPORTED',
  Supported = 'SUPPORTED',
  SupportedWithMitigation = 'SUPPORTED_WITH_MITIGATION',
  Unverified = 'UNVERIFIED'
}

export type ConfluenceChangeOrderOfCustomApplicationLinkInput = {
  id: Scalars['ID']['input'];
  idAfter?: InputMaybe<Scalars['ID']['input']>;
  isMoveToBeginning?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum ConfluenceCollaborativeEditingService {
  Ncs = 'NCS',
  Synchrony = 'SYNCHRONY'
}

export type ConfluenceCommentFilter = {
  commentState?: InputMaybe<Array<InputMaybe<ConfluenceCommentState>>>;
  commentType?: InputMaybe<Array<InputMaybe<CommentType>>>;
};

export enum ConfluenceCommentLevel {
  Reply = 'REPLY',
  TopLevel = 'TOP_LEVEL'
}

export enum ConfluenceCommentResolveAllLocation {
  Editor = 'EDITOR',
  Live = 'LIVE',
  Renderer = 'RENDERER'
}

export enum ConfluenceCommentState {
  Resolved = 'RESOLVED',
  Unresolved = 'UNRESOLVED'
}

export enum ConfluenceCommentStatus {
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export enum ConfluenceCommentType {
  Footer = 'FOOTER',
  Inline = 'INLINE'
}

export enum ConfluenceContentAccessRequestStatus {
  Approve = 'APPROVE',
  Deny = 'DENY',
  Pending = 'PENDING',
  PendingSiteApproval = 'PENDING_SITE_APPROVAL'
}

export type ConfluenceContentApprovalReviewerInput = {
  isRequired?: InputMaybe<Scalars['Boolean']['input']>;
  principalId: Scalars['String']['input'];
  principalType: ConfluencePrincipalType;
};

export type ConfluenceContentBlueprintSpecInput = {
  blueprintId?: InputMaybe<Scalars['String']['input']>;
  context?: InputMaybe<ConfluenceTemplateInfoInput>;
  templateId?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceContentBodyInput = {
  representation: ConfluenceContentRepresentation;
  value: Scalars['String']['input'];
};

export type ConfluenceContentInput = {
  contentBody?: InputMaybe<Scalars['String']['input']>;
  contentId: Scalars['ID']['input'];
  contentStatus?: InputMaybe<Scalars['String']['input']>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  minorEdit?: InputMaybe<Scalars['Boolean']['input']>;
  moveRequest?: InputMaybe<ConfluenceMoveRequestInput>;
  ncsStepVersion?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<PageRestrictionsInput>;
  schedulePublishDate?: InputMaybe<Scalars['String']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
  syncRev?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  versionMessage?: InputMaybe<Scalars['String']['input']>;
};

export enum ConfluenceContentPosition {
  After = 'AFTER',
  Append = 'APPEND',
  Before = 'BEFORE'
}

export enum ConfluenceContentRepresentation {
  AtlasDocFormat = 'ATLAS_DOC_FORMAT',
  Editor = 'EDITOR',
  Editor2 = 'EDITOR2',
  ExportView = 'EXPORT_VIEW',
  Plain = 'PLAIN',
  Raw = 'RAW',
  Storage = 'STORAGE',
  StyledView = 'STYLED_VIEW',
  View = 'VIEW',
  Wiki = 'WIKI'
}

export enum ConfluenceContentRestrictionState {
  EditRestricted = 'EDIT_RESTRICTED',
  Open = 'OPEN',
  RestrictedByParent = 'RESTRICTED_BY_PARENT',
  ViewRestricted = 'VIEW_RESTRICTED'
}

export enum ConfluenceContentRestrictionStateInput {
  EditRestricted = 'EDIT_RESTRICTED',
  Open = 'OPEN',
  ViewRestricted = 'VIEW_RESTRICTED'
}

export type ConfluenceContentShareMetadata = {
  altOrigin?: InputMaybe<Scalars['String']['input']>;
  shareAction?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceContentShareRecipient = {
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  recipientType: ConfluenceRecipientType;
};

export type ConfluenceContentShareRequestInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  content: ConfluenceShareContent;
  contentShareMetadata?: InputMaybe<ConfluenceContentShareMetadata>;
  recipients?: InputMaybe<Array<InputMaybe<ConfluenceContentShareRecipient>>>;
  sharerAaid?: InputMaybe<Scalars['String']['input']>;
};

export enum ConfluenceContentStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Deleted = 'DELETED',
  Draft = 'DRAFT',
  Historical = 'HISTORICAL',
  Trashed = 'TRASHED'
}

export enum ConfluenceContentType {
  Attachment = 'ATTACHMENT',
  BlogPost = 'BLOG_POST',
  Comment = 'COMMENT',
  Database = 'DATABASE',
  Embed = 'EMBED',
  Folder = 'FOLDER',
  Page = 'PAGE',
  Whiteboard = 'WHITEBOARD'
}

export enum ConfluenceContributionStatus {
  Current = 'CURRENT',
  Draft = 'DRAFT',
  Unknown = 'UNKNOWN',
  Unpublished = 'UNPUBLISHED'
}

export type ConfluenceConvertContentToBlogpostInput = {
  confluenceContentInput: ConfluenceContentInput;
  destinationSpaceKey: Scalars['String']['input'];
  sourceStatus: Scalars['String']['input'];
};

export type ConfluenceConvertNoteInput = {
  containerId?: InputMaybe<Scalars['ID']['input']>;
  contentType: NotesContentType;
  id: Scalars['ID']['input'];
  parentId?: InputMaybe<Scalars['ID']['input']>;
  product: NotesProduct;
};

export type ConfluenceCopyPageHierarchyInput = {
  copyAsDraft: Scalars['Boolean']['input'];
  copyAttachments?: InputMaybe<Scalars['Boolean']['input']>;
  copyCustomContents?: InputMaybe<Scalars['Boolean']['input']>;
  copyDescendants?: InputMaybe<Scalars['Boolean']['input']>;
  copyLabels?: InputMaybe<Scalars['Boolean']['input']>;
  copyPermissions?: InputMaybe<Scalars['Boolean']['input']>;
  copyProperties?: InputMaybe<Scalars['Boolean']['input']>;
  destinationPageId: Scalars['ID']['input'];
  mentionOptions: ConfluenceCopyPageHierarchyMentionOptionsInput;
  sourcePageId: Scalars['ID']['input'];
  titleOptions: ConfluenceCopyPageHierarchyTitleOptionsInput;
};

export type ConfluenceCopyPageHierarchyMentionOptionsInput = {
  notificationAction?: InputMaybe<NotificationAction>;
};

export type ConfluenceCopyPageHierarchyTitleOptionsInput = {
  prefix?: InputMaybe<Scalars['String']['input']>;
  replace?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceCopySpaceSecurityConfigurationInput = {
  copyFromSpaceId: Scalars['ID']['input'];
  copyToSpaceId: Scalars['ID']['input'];
};

export type ConfluenceCreateAdminAnnouncementBannerInput = {
  appearance: Scalars['String']['input'];
  content: Scalars['String']['input'];
  isDismissible: Scalars['Boolean']['input'];
  scheduledEndTime?: InputMaybe<Scalars['String']['input']>;
  scheduledStartTime?: InputMaybe<Scalars['String']['input']>;
  scheduledTimeZone?: InputMaybe<Scalars['String']['input']>;
  status: ConfluenceAdminAnnouncementBannerStatusType;
  title?: InputMaybe<Scalars['String']['input']>;
  visibility: ConfluenceAdminAnnouncementBannerVisibilityType;
};

export type ConfluenceCreateAnswerInput = {
  /** Body of the Answer */
  body?: InputMaybe<ConfluenceContentBodyInput>;
  /** Question ID for the Answer */
  questionId: Scalars['ID']['input'];
};

export type ConfluenceCreateAutoConvertedDateInput = {
  contentId: Scalars['ID']['input'];
};

export type ConfluenceCreateBlogPostInput = {
  body?: InputMaybe<ConfluenceContentBodyInput>;
  spaceId: Scalars['ID']['input'];
  /** Status with which the BlogPost will be created. Defaults to CURRENT status. */
  status?: InputMaybe<ConfluenceMutationContentStatus>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceCreateBlogPostPropertyInput = {
  blogPostId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ConfluenceCreateCalendarInput = {
  color?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  location?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  spaceKey: Scalars['String']['input'];
  timeZoneId: Scalars['String']['input'];
  type: Scalars['String']['input'];
};

export type ConfluenceCreateCommentOnAnswerInput = {
  /** ID of the Answer the comment will be created on */
  answerId: Scalars['ID']['input'];
  /** Body of the comment */
  body: ConfluenceContentBodyInput;
};

export type ConfluenceCreateCommentOnQuestionInput = {
  /** Body of the comment */
  body: ConfluenceContentBodyInput;
  /** ID of the Question the comment will be created on */
  questionId: Scalars['ID']['input'];
};

export type ConfluenceCreateContentApprovalRequestInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  contentId: Scalars['Long']['input'];
  contentStatus: GraphQlContentStatus;
  reviewers?: InputMaybe<Array<InputMaybe<ConfluenceContentApprovalReviewerInput>>>;
  version: Scalars['Int']['input'];
};

export type ConfluenceCreateCsvExportTaskInput = {
  /** ARI of the space containing the content */
  spaceAri: Scalars['String']['input'];
};

export type ConfluenceCreateCustomRoleInput = {
  description: Scalars['String']['input'];
  name: Scalars['String']['input'];
  permissions: Array<InputMaybe<Scalars['String']['input']>>;
};

export type ConfluenceCreateFooterCommentOnBlogPostInput = {
  blogPostId: Scalars['ID']['input'];
  body: ConfluenceContentBodyInput;
};

export type ConfluenceCreateFooterCommentOnPageInput = {
  body: ConfluenceContentBodyInput;
  pageId: Scalars['ID']['input'];
};

export type ConfluenceCreatePageInput = {
  body?: InputMaybe<ConfluenceContentBodyInput>;
  spaceId: Scalars['ID']['input'];
  /** Status with which the Page will be created. Defaults to CURRENT status. */
  status?: InputMaybe<ConfluenceMutationContentStatus>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceCreatePagePropertyInput = {
  key: Scalars['String']['input'];
  pageId: Scalars['ID']['input'];
  value: Scalars['String']['input'];
};

export type ConfluenceCreatePdfExportTaskForBulkContentInput = {
  /** The list of contents to be exported in bulk. If null or empty, the whole space will be exported. */
  exportContents?: InputMaybe<Array<InputMaybe<ConfluenceBulkPdfExportContent>>>;
  /** ARI of the space containing the content to be exported in bulk. */
  spaceAri: Scalars['String']['input'];
};

export type ConfluenceCreatePdfExportTaskForSingleContentInput = {
  /** ARI of the content to be exported to PDF. */
  contentId: Scalars['ID']['input'];
};

export type ConfluenceCreateQuestionInput = {
  /** Body of the Question */
  body?: InputMaybe<ConfluenceContentBodyInput>;
  /** Labels for the Question */
  labels?: InputMaybe<Array<InputMaybe<LabelInput>>>;
  /** Space ID for the Question */
  spaceId: Scalars['ID']['input'];
  /** Title of the Question */
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceCreateSpaceContent = {
  parent?: InputMaybe<ConfluenceCreateSpaceContentParent>;
  templateKey?: InputMaybe<Scalars['String']['input']>;
  title: Scalars['String']['input'];
  type: ConfluenceCreateSpaceContentType;
};

export type ConfluenceCreateSpaceContentParent = {
  title: Scalars['String']['input'];
  type: ConfluenceCreateSpaceContentType;
};

export enum ConfluenceCreateSpaceContentType {
  Folder = 'FOLDER',
  Page = 'PAGE'
}

export type ConfluenceCreateSpaceInput = {
  key: Scalars['String']['input'];
  name: Scalars['String']['input'];
  type?: InputMaybe<ConfluenceSpaceType>;
};

export type ConfluenceCreateTopicInput = {
  /** Description of the Topic */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the Topic is featured */
  featured?: InputMaybe<Scalars['Boolean']['input']>;
  /** Logo ID for the Topic (file store ID) */
  logoId?: InputMaybe<Scalars['String']['input']>;
  /** Logo Url for the Topic */
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Name of the Topic */
  name: Scalars['String']['input'];
};

export type ConfluenceCreateWorkflowApplicationRequestInput = {
  contentId: Scalars['Long']['input'];
  contentStatus: GraphQlContentStatus;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  version: Scalars['Int']['input'];
  workflowId?: InputMaybe<Scalars['Long']['input']>;
  workflowStatusId?: InputMaybe<Scalars['Long']['input']>;
};

export type ConfluenceCustomContentPermissionInput = {
  customContentTypeKey: Scalars['String']['input'];
  permission: ConfluenceCustomContentPermissionType;
};

export enum ConfluenceCustomContentPermissionPrincipalType {
  App = 'APP',
  Group = 'GROUP',
  Guest = 'GUEST',
  User = 'USER',
  UserClass = 'USER_CLASS'
}

export enum ConfluenceCustomContentPermissionType {
  Create = 'CREATE',
  Delete = 'DELETE',
  Read = 'READ'
}

export type ConfluenceCustomContentPrincipalInput = {
  principalId: Scalars['ID']['input'];
  principalType: ConfluenceCustomContentPermissionPrincipalType;
};

export type ConfluenceDeleteAnswerInput = {
  /** ID of the Answer */
  answerId: Scalars['ID']['input'];
  /** ID of the Question */
  questionId: Scalars['ID']['input'];
};

export type ConfluenceDeleteBlogPostPropertyInput = {
  blogPostId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
};

export type ConfluenceDeleteCalendarCustomEventTypeInput = {
  id: Scalars['ID']['input'];
  subCalendarId: Scalars['ID']['input'];
};

export type ConfluenceDeleteCalendarInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceDeleteCommentInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceDeleteContentVersionInput = {
  contentId: Scalars['ID']['input'];
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

export type ConfluenceDeleteCustomApplicationLinkInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceDeleteCustomRoleInput = {
  anonymousRoleId?: InputMaybe<Scalars['ID']['input']>;
  guestRoleId?: InputMaybe<Scalars['ID']['input']>;
  newRoleId?: InputMaybe<Scalars['ID']['input']>;
  roleId: Scalars['ID']['input'];
};

export type ConfluenceDeleteDraftBlogPostInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceDeleteDraftPageInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceDeleteGlobalPageTemplateInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceDeletePagePropertyInput = {
  key: Scalars['String']['input'];
  pageId: Scalars['ID']['input'];
};

export type ConfluenceDeleteQuestionInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceDeleteSpacePageTemplateInput = {
  id: Scalars['ID']['input'];
  spaceId: Scalars['Long']['input'];
};

export type ConfluenceDeleteSubCalendarAllFutureEventsInput = {
  recurUntil?: InputMaybe<Scalars['String']['input']>;
  subCalendarId: Scalars['ID']['input'];
  uid: Scalars['ID']['input'];
};

export type ConfluenceDeleteSubCalendarEventInput = {
  subCalendarId: Scalars['ID']['input'];
  uid: Scalars['ID']['input'];
};

export type ConfluenceDeleteSubCalendarHiddenEventsInput = {
  subCalendarId: Scalars['ID']['input'];
};

export type ConfluenceDeleteSubCalendarPrivateUrlInput = {
  subCalendarId: Scalars['ID']['input'];
};

export type ConfluenceDeleteSubCalendarSingleEventInput = {
  originalStart?: InputMaybe<Scalars['String']['input']>;
  recurrenceId?: InputMaybe<Scalars['ID']['input']>;
  subCalendarId: Scalars['ID']['input'];
  uid: Scalars['ID']['input'];
};

export type ConfluenceDeleteTopicInput = {
  /** ID of the Topic to delete */
  id: Scalars['ID']['input'];
};

export type ConfluenceDirectRestrictionsAddInput = {
  edit?: InputMaybe<ConfluenceRestrictionsInput>;
  view?: InputMaybe<ConfluenceRestrictionsInput>;
};

export type ConfluenceDirectRestrictionsRemoveInput = {
  edit?: InputMaybe<ConfluenceRestrictionsInput>;
  view?: InputMaybe<ConfluenceRestrictionsInput>;
};

export type ConfluenceDisableBlueprintInput = {
  id: Scalars['ID']['input'];
  spaceId: Scalars['Long']['input'];
};

export type ConfluenceDisableGlobalPageBlueprintInput = {
  id: Scalars['ID']['input'];
};

export enum ConfluenceEdition {
  Free = 'FREE',
  Premium = 'PREMIUM',
  Standard = 'STANDARD'
}

export type ConfluenceEditorSettingsInput = {
  /** editor toolbar docking initial position */
  toolbarDockingInitialPosition?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceEnableBlueprintInput = {
  id: Scalars['ID']['input'];
  spaceId: Scalars['Long']['input'];
};

export type ConfluenceEnableGlobalPageBlueprintInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceExtensionRenderingContextInput = {
  contentId?: InputMaybe<Scalars['Long']['input']>;
  spaceId?: InputMaybe<Scalars['Long']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceExtensionSpecificContext = {
  appVersion: Scalars['String']['input'];
  context: ConfluenceForgePayloadContext;
  extensionId: Scalars['String']['input'];
  extensionType?: InputMaybe<Scalars['String']['input']>;
  installationId?: InputMaybe<Scalars['String']['input']>;
};

export enum ConfluenceExtensionVisibilityControlMechanism {
  AppAccessRules = 'APP_ACCESS_RULES',
  DisplayConditions = 'DISPLAY_CONDITIONS'
}

export type ConfluenceForgeContextTokenRequestInput = {
  contextIds: Array<InputMaybe<Scalars['String']['input']>>;
  extensionSpecificContexts: ConfluenceExtensionSpecificContext;
};

export type ConfluenceForgeExtensionData = {
  autoConvertLink?: InputMaybe<Scalars['String']['input']>;
  config?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ConfluenceForgeExtensionDataContent>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  isEditing?: InputMaybe<Scalars['Boolean']['input']>;
  location?: InputMaybe<Scalars['String']['input']>;
  macro?: InputMaybe<ConfluenceForgeExtensionDataMacro>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  selectedText?: InputMaybe<Scalars['String']['input']>;
  space?: InputMaybe<ConfluenceForgeExtensionDataSpace>;
  template?: InputMaybe<ConfluenceForgeExtensionDataTemplate>;
  type: Scalars['String']['input'];
};

export type ConfluenceForgeExtensionDataContent = {
  id: Scalars['ID']['input'];
  subtype?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceForgeExtensionDataMacro = {
  body?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceForgeExtensionDataSpace = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceForgeExtensionDataTemplate = {
  id?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceForgePayloadContext = {
  appVersion?: InputMaybe<Scalars['String']['input']>;
  environmentId?: InputMaybe<Scalars['String']['input']>;
  environmentType?: InputMaybe<Scalars['String']['input']>;
  extension: ConfluenceForgeExtensionData;
  localId?: InputMaybe<Scalars['String']['input']>;
  moduleKey?: InputMaybe<Scalars['String']['input']>;
  siteUrl?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceGenerateSearchPerformedEventInput = {
  /** The search query string */
  query: Scalars['String']['input'];
  /** The number of search results returned */
  resultCount: Scalars['Int']['input'];
  /** The date-time timestamp when the search was performed (ISO-8601 format, e.g., '2024-01-15T10:30:00.000Z') */
  timestamp: Scalars['String']['input'];
};

export enum ConfluenceGraphQlContentMode {
  Compact = 'COMPACT',
  Dense = 'DENSE',
  Standard = 'STANDARD'
}

export enum ConfluenceGraphQlDefaultTitleEmoji {
  LivePageDefault = 'LIVE_PAGE_DEFAULT',
  None = 'NONE'
}

export enum ConfluenceGroupManagementType {
  Admins = 'ADMINS',
  External = 'EXTERNAL',
  Open = 'OPEN',
  TeamMembers = 'TEAM_MEMBERS'
}

export enum ConfluenceGroupUsageType {
  AdminOversight = 'ADMIN_OVERSIGHT',
  TeamCollaboration = 'TEAM_COLLABORATION',
  UserbaseGroup = 'USERBASE_GROUP'
}

export type ConfluenceImportSpaceInput = {
  jiraProjectKey?: InputMaybe<Scalars['String']['input']>;
  mediaFileId: Scalars['ID']['input'];
};

export enum ConfluenceImportSpaceTaskState {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS'
}

export enum ConfluenceImportStatus {
  CombinedManifests = 'COMBINED_MANIFESTS',
  CombiningManifests = 'COMBINING_MANIFESTS',
  Created = 'CREATED',
  CreatedPagesAndSpaces = 'CREATED_PAGES_AND_SPACES',
  CreatedSpace = 'CREATED_SPACE',
  CreatingPagesAndSpaces = 'CREATING_PAGES_AND_SPACES',
  CreatingSpace = 'CREATING_SPACE',
  DetectedExportType = 'DETECTED_EXPORT_TYPE',
  DetectingExportType = 'DETECTING_EXPORT_TYPE',
  ExportedFrom_3P = 'EXPORTED_FROM_3P',
  ExportingFrom_3P = 'EXPORTING_FROM_3P',
  Failed = 'FAILED',
  FetchedEntitiesToExport = 'FETCHED_ENTITIES_TO_EXPORT',
  FetchedIdsFrom_3P = 'FETCHED_IDS_FROM_3P',
  FetchingEntitiesToExport = 'FETCHING_ENTITIES_TO_EXPORT',
  FetchingIdsFrom_3P = 'FETCHING_IDS_FROM_3P',
  Finished = 'FINISHED',
  ImportedUser = 'IMPORTED_USER',
  ImportedWhiteboard = 'IMPORTED_WHITEBOARD',
  ImportedWhiteboards = 'IMPORTED_WHITEBOARDS',
  ImportingUser = 'IMPORTING_USER',
  ImportingWhiteboards = 'IMPORTING_WHITEBOARDS',
  NestedUnzipping = 'NESTED_UNZIPPING',
  NormalizeManifest = 'NORMALIZE_MANIFEST',
  PartialFailed = 'PARTIAL_FAILED',
  PreparedMetadata = 'PREPARED_METADATA',
  PreparingMetadata = 'PREPARING_METADATA',
  Queued = 'QUEUED',
  RenamedExportFrom_3P = 'RENAMED_EXPORT_FROM_3P',
  RenamingExportFrom_3P = 'RENAMING_EXPORT_FROM_3P',
  SendingNotification = 'SENDING_NOTIFICATION',
  Started = 'STARTED',
  Success = 'SUCCESS',
  Unzipped = 'UNZIPPED',
  Unzipping = 'UNZIPPING',
  Updated = 'UPDATED',
  UpdatedContent = 'UPDATED_CONTENT',
  UpdatingContent = 'UPDATING_CONTENT'
}

export enum ConfluenceInlineCommentResolutionStatus {
  Resolved = 'RESOLVED',
  Unresolved = 'UNRESOLVED'
}

export enum ConfluenceInlineCommentStepType {
  AddMark = 'ADD_MARK',
  AddNodeMark = 'ADD_NODE_MARK',
  RemoveMark = 'REMOVE_MARK',
  RemoveNodeMark = 'REMOVE_NODE_MARK',
  SetAttrs = 'SET_ATTRS'
}

export enum ConfluenceInlineTaskStatus {
  Complete = 'COMPLETE',
  Incomplete = 'INCOMPLETE'
}

export type ConfluenceInsertOfflineVersionInput = {
  adfContent: Scalars['String']['input'];
  contentId: Scalars['ID']['input'];
  versionComment?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceInviteUserInput = {
  inviteeIds: Array<InputMaybe<Scalars['ID']['input']>>;
};

export enum ConfluenceJiraMacroAppLinksValidationStatus {
  Done = 'DONE',
  Error = 'ERROR',
  Fixing = 'FIXING',
  NotStarted = 'NOT_STARTED',
  NoApplink = 'NO_APPLINK',
  Scanning = 'SCANNING',
  WaitForConfig = 'WAIT_FOR_CONFIG'
}

export type ConfluenceLabelWatchInput = {
  accountId?: InputMaybe<Scalars['String']['input']>;
  currentUser?: InputMaybe<Scalars['Boolean']['input']>;
  labelName: Scalars['String']['input'];
};

export enum ConfluenceLegacyEditorReportType {
  Page = 'PAGE',
  Template = 'TEMPLATE'
}

export enum ConfluenceLength {
  Long = 'LONG',
  Medium = 'MEDIUM',
  Short = 'SHORT'
}

export type ConfluenceMacroDefinitionInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  defaultParameterValue?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  params?: InputMaybe<Array<InputMaybe<ConfluenceMacroParameterInput>>>;
  schemaVersion?: InputMaybe<Scalars['Int']['input']>;
};

export type ConfluenceMacroParameterInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceMakeSubCalendarPrivateUrlInput = {
  subCalendarId: Scalars['ID']['input'];
};

export type ConfluenceMarkAllContainerCommentsAsReadInput = {
  contentId: Scalars['String']['input'];
  readView?: InputMaybe<ConfluenceViewState>;
};

export type ConfluenceMoveRequestInput = {
  position: ConfluenceContentPosition;
  targetId: Scalars['ID']['input'];
};

export enum ConfluenceMutationContentStatus {
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export type ConfluenceNbmBulkUpdateVerificationEntryInput = {
  /** ID of the NBM scan */
  scanId: Scalars['ID']['input'];
  /** Verification entries to update */
  verificationEntries: Array<InputMaybe<ConfluenceNbmVerificationEntryInput>>;
};

export enum ConfluenceNbmCategoryTypes {
  NotSupported = 'NOT_SUPPORTED',
  Supported = 'SUPPORTED',
  SupportedWithMitigation = 'SUPPORTED_WITH_MITIGATION',
  Unknown = 'UNKNOWN',
  Unverified = 'UNVERIFIED'
}

export type ConfluenceNbmRetryPerfScanLongTaskInput = {
  /** Existing scanId to associate this perf scan task to. */
  scanId: Scalars['ID']['input'];
};

export type ConfluenceNbmRetryScanLongTaskInput = {
  /** Existing scanId to associate this scan task to. */
  scanId: Scalars['ID']['input'];
};

export enum ConfluenceNbmScanStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  Pending = 'PENDING',
  Running = 'RUNNING'
}

export type ConfluenceNbmStartPerfScanLongTaskInput = {
  /** Scan all spaces */
  includeAllSpaces: Scalars['Boolean']['input'];
  /** Existing scanId to associate this scan task to. If not specified will create a new scanId */
  scanId?: InputMaybe<Scalars['String']['input']>;
  /** Scan specific spaces */
  spaceIds: Array<Scalars['Long']['input']>;
};

export type ConfluenceNbmStartScanLongTaskInput = {
  /** Scan all spaces */
  includeAllSpaces: Scalars['Boolean']['input'];
  /** Existing scanId to associate this scan task to. If not specified will create a new scanId */
  scanId?: InputMaybe<Scalars['String']['input']>;
  /** Scan specific spaces */
  spaceIds: Array<InputMaybe<Scalars['Long']['input']>>;
};

export type ConfluenceNbmStartTransformationLongTaskInput = {
  runMode: ConfluenceNbmTransformationRunMode;
  scanId: Scalars['ID']['input'];
  spaceKeyInclusion: ConfluenceNbmTransformationSpaceKeyInclusion;
  spaceKeys: Array<InputMaybe<Scalars['String']['input']>>;
  transformerNames: Array<InputMaybe<Scalars['String']['input']>>;
};

export type ConfluenceNbmStartVerificationLongTaskInput = {
  /** The scanId for which to start the verification task */
  scanId: Scalars['String']['input'];
  /** List of existing verification entry IDs to reverify. If not specified, all entries from the scan will be verified. */
  verificationEntryIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export enum ConfluenceNbmTransformationRunMode {
  DryRun = 'DRY_RUN',
  Execute = 'EXECUTE'
}

export enum ConfluenceNbmTransformationSpaceKeyInclusion {
  Exclude = 'EXCLUDE',
  Include = 'INCLUDE'
}

export enum ConfluenceNbmTransformationStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  NotTriggered = 'NOT_TRIGGERED',
  Pending = 'PENDING',
  Running = 'RUNNING'
}

export enum ConfluenceNbmVerificationAiState {
  Broken = 'BROKEN',
  Unknown = 'UNKNOWN',
  Working = 'WORKING'
}

export type ConfluenceNbmVerificationEntryInput = {
  /** Id of verification entry */
  id: Scalars['ID']['input'];
  /** Is verification entry approved */
  isApproved: Scalars['Boolean']['input'];
  /** Manual verification state */
  manualState?: InputMaybe<ConfluenceNbmCategoryTypes>;
};

export enum ConfluenceNbmVerificationPhase {
  AiAnalysis = 'AI_ANALYSIS',
  Completed = 'COMPLETED',
  Copy = 'COPY',
  Pending = 'PENDING',
  Screenshot = 'SCREENSHOT',
  Setup = 'SETUP'
}

export enum ConfluenceNbmVerificationResultDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export enum ConfluenceNbmVerificationResultOrder {
  AiState = 'AI_STATE',
  ManualState = 'MANUAL_STATE',
  Status = 'STATUS'
}

export enum ConfluenceNbmVerificationStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  Pending = 'PENDING',
  Running = 'RUNNING'
}

export enum ConfluenceNotesOrdering {
  DateLastModifiedAsc = 'DATE_LAST_MODIFIED_ASC',
  DateLastModifiedDesc = 'DATE_LAST_MODIFIED_DESC'
}

export enum ConfluenceOperationName {
  Administer = 'ADMINISTER',
  Archive = 'ARCHIVE',
  Copy = 'COPY',
  Create = 'CREATE',
  CreateSpace = 'CREATE_SPACE',
  Delete = 'DELETE',
  Export = 'EXPORT',
  Move = 'MOVE',
  Purge = 'PURGE',
  PurgeVersion = 'PURGE_VERSION',
  Read = 'READ',
  Restore = 'RESTORE',
  RestrictContent = 'RESTRICT_CONTENT',
  Update = 'UPDATE',
  Use = 'USE'
}

export enum ConfluenceOperationTarget {
  Application = 'APPLICATION',
  Attachment = 'ATTACHMENT',
  BlogPost = 'BLOG_POST',
  Comment = 'COMMENT',
  Page = 'PAGE',
  Space = 'SPACE',
  UserProfile = 'USER_PROFILE'
}

export enum ConfluencePageStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Deleted = 'DELETED',
  Draft = 'DRAFT',
  Historical = 'HISTORICAL',
  Trashed = 'TRASHED'
}

export enum ConfluencePageSubType {
  Live = 'LIVE'
}

export type ConfluencePatchCalendarInput = {
  color?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  location?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['String']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
  timeZoneId?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluencePdfExportFontCustomInput = {
  /** Custom font variant for PDF export. */
  url: Scalars['String']['input'];
};

export enum ConfluencePdfExportFontEnum {
  Arial = 'ARIAL',
  AtlassianSans = 'ATLASSIAN_SANS',
  Courier = 'COURIER',
  TimesNewRoman = 'TIMES_NEW_ROMAN'
}

export enum ConfluencePdfExportFontEnumInput {
  Arial = 'ARIAL',
  AtlassianSans = 'ATLASSIAN_SANS',
  Courier = 'COURIER',
  TimesNewRoman = 'TIMES_NEW_ROMAN'
}

export type ConfluencePdfExportFontInput = {
  custom?: InputMaybe<ConfluencePdfExportFontCustomInput>;
  kind?: InputMaybe<ConfluencePdfExportFontKind>;
  predefined?: InputMaybe<ConfluencePdfExportFontPredefinedInput>;
};

export enum ConfluencePdfExportFontKind {
  Custom = 'CUSTOM',
  Predefined = 'PREDEFINED'
}

export type ConfluencePdfExportFontPredefinedInput = {
  /** Predefined font variant for PDF export. */
  font: ConfluencePdfExportFontEnumInput;
};

export type ConfluencePdfExportFooterConfigurationInput = {
  /** Alignment of the footer text in PDF export. */
  alignment: ConfluencePdfExportHeaderFooterAlignmentInput;
  /** Font size for the footer text in PDF export. */
  size: Scalars['Int']['input'];
  /** Footer text for PDF export. */
  text: Scalars['String']['input'];
};

export type ConfluencePdfExportFooterInclusionConfigurationInput = {
  /** Configuration for the footer in the PDF export */
  configuration: ConfluencePdfExportFooterConfigurationInput;
  /** Whether the footer is included in the PDF export */
  isIncluded: Scalars['Boolean']['input'];
};

export type ConfluencePdfExportHeaderConfigurationInput = {
  /** Alignment of the header text in PDF export. */
  alignment: ConfluencePdfExportHeaderFooterAlignmentInput;
  /** Header text size for PDF export. */
  size: Scalars['Int']['input'];
  /** Header text for PDF export. */
  text: Scalars['String']['input'];
};

export enum ConfluencePdfExportHeaderFooterAlignment {
  Center = 'CENTER',
  Left = 'LEFT'
}

export enum ConfluencePdfExportHeaderFooterAlignmentInput {
  Center = 'CENTER',
  Left = 'LEFT'
}

export type ConfluencePdfExportHeaderInclusionConfigurationInput = {
  /** Configuration for the header in the PDF export. */
  configuration: ConfluencePdfExportHeaderConfigurationInput;
  /** Indicates whether the header is included in the PDF export. */
  isIncluded: Scalars['Boolean']['input'];
};

export type ConfluencePdfExportPageMarginsInput = {
  /** Bottom margin for the PDF export page. */
  bottom: Scalars['Float']['input'];
  /** Left margin for the PDF export page. */
  left: Scalars['Float']['input'];
  /** Right margin for the PDF export page. */
  right: Scalars['Float']['input'];
  /** Defines the sides of the page margins for PDF export. */
  sides: ConfluencePdfExportPageMarginsSidesInput;
  /** Top margin for the PDF export page. */
  top: Scalars['Float']['input'];
  /** Defines the unit of measurement for the page margins in PDF export. */
  unit: ConfluencePdfExportPageMarginsUnitInput;
};

export enum ConfluencePdfExportPageMarginsSides {
  All = 'ALL',
  Individual = 'INDIVIDUAL'
}

export enum ConfluencePdfExportPageMarginsSidesInput {
  All = 'ALL',
  Individual = 'INDIVIDUAL'
}

export enum ConfluencePdfExportPageMarginsUnit {
  Centimeters = 'CENTIMETERS',
  Inches = 'INCHES'
}

export enum ConfluencePdfExportPageMarginsUnitInput {
  Centimeters = 'CENTIMETERS',
  Inches = 'INCHES'
}

export enum ConfluencePdfExportPageOrientation {
  Landscape = 'LANDSCAPE',
  Portrait = 'PORTRAIT'
}

export enum ConfluencePdfExportPageOrientationInput {
  Landscape = 'LANDSCAPE',
  Portrait = 'PORTRAIT'
}

export enum ConfluencePdfExportPageSize {
  A3 = 'A3',
  A4 = 'A4',
  A5 = 'A5',
  Legal = 'LEGAL',
  Tabloid = 'TABLOID',
  UsLetter = 'US_LETTER'
}

export enum ConfluencePdfExportPageSizeInput {
  A3 = 'A3',
  A4 = 'A4',
  A5 = 'A5',
  Legal = 'LEGAL',
  Tabloid = 'TABLOID',
  UsLetter = 'US_LETTER'
}

export enum ConfluencePdfExportState {
  Done = 'DONE',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Validating = 'VALIDATING'
}

export type ConfluencePdfExportTitlePageConfigurationInput = {
  /** Horizontal alignment of the title text on the PDF export title page. */
  horizontalAlignment: ConfluencePdfExportTitlePageHorizontalAlignmentInput;
  /** Title text size for PDF export title page. */
  size: Scalars['Int']['input'];
  /** Title text for PDF export title page. */
  text: Scalars['String']['input'];
  /** Vertical alignment of the title text on the PDF export title page. */
  verticalAlignment: ConfluencePdfExportTitlePageVerticalAlignmentInput;
};

export enum ConfluencePdfExportTitlePageHorizontalAlignment {
  Left = 'LEFT',
  Middle = 'MIDDLE',
  Right = 'RIGHT'
}

export enum ConfluencePdfExportTitlePageHorizontalAlignmentInput {
  Left = 'LEFT',
  Middle = 'MIDDLE',
  Right = 'RIGHT'
}

export type ConfluencePdfExportTitlePageInclusionConfigurationInput = {
  /** Configuration for the title page in the PDF export. */
  configuration: ConfluencePdfExportTitlePageConfigurationInput;
  /** Indicates whether the title page is included in the PDF export. */
  isIncluded: Scalars['Boolean']['input'];
};

export enum ConfluencePdfExportTitlePageVerticalAlignment {
  Bottom = 'BOTTOM',
  Middle = 'MIDDLE',
  Top = 'TOP'
}

export enum ConfluencePdfExportTitlePageVerticalAlignmentInput {
  Bottom = 'BOTTOM',
  Middle = 'MIDDLE',
  Top = 'TOP'
}

export enum ConfluencePermission {
  Edit = 'EDIT',
  Share = 'SHARE',
  View = 'VIEW'
}

export type ConfluencePermissionCombinationPrincipalTypeAssignmentInput = {
  principalType: ConfluencePermissionTransitionPrincipalType;
  removeAccess: Scalars['Boolean']['input'];
  roleId?: InputMaybe<Scalars['ID']['input']>;
};

export type ConfluencePermissionCombinationRoleAssignmentInput = {
  permissionCombinationId: Scalars['ID']['input'];
  principalTypeAssignment: Array<InputMaybe<ConfluencePermissionCombinationPrincipalTypeAssignmentInput>>;
};

export type ConfluencePermissionTransitionBulkAssignRolesInput = {
  assignments: Array<InputMaybe<ConfluencePermissionCombinationRoleAssignmentInput>>;
  spaceSelection: ConfluencePermissionTransitionSpaceTargetSelectionInput;
};

export type ConfluencePermissionTransitionBulkRemoveAccessInput = {
  permissionCombinationIds: Array<InputMaybe<Scalars['String']['input']>>;
  spaceTargetSelection: ConfluencePermissionTransitionSpaceTargetSelectionInput;
};

export enum ConfluencePermissionTransitionPrincipalType {
  Anonymous = 'ANONYMOUS',
  Group = 'GROUP',
  Guest = 'GUEST',
  User = 'USER'
}

export type ConfluencePermissionTransitionSpaceTargetSelectionInput = {
  selectedSpaces?: InputMaybe<Array<InputMaybe<ConfluenceSpaceTargetInput>>>;
  spaceType: ConfluencePermissionTransitionSpaceType;
};

export enum ConfluencePermissionTransitionSpaceType {
  All = 'ALL',
  AllExceptPersonal = 'ALL_EXCEPT_PERSONAL',
  AllExceptSpecific = 'ALL_EXCEPT_SPECIFIC',
  Personal = 'PERSONAL',
  Specific = 'SPECIFIC'
}

export enum ConfluencePermissionTransitionSpaceTypeFilter {
  Collaboration = 'COLLABORATION',
  Global = 'GLOBAL',
  KnowledgeBase = 'KNOWLEDGE_BASE',
  Personal = 'PERSONAL'
}

export enum ConfluencePermissionTypeAssignabilityCode {
  AnonymousAssignable = 'ANONYMOUS_ASSIGNABLE',
  Assignable = 'ASSIGNABLE',
  GuestAssignable = 'GUEST_ASSIGNABLE'
}

export enum ConfluencePolicyEnabledStatus {
  Disabled = 'DISABLED',
  Enabled = 'ENABLED',
  UndeterminedDueToInternalError = 'UNDETERMINED_DUE_TO_INTERNAL_ERROR'
}

export enum ConfluencePrincipalType {
  Group = 'GROUP',
  User = 'USER'
}

export type ConfluencePromoteBlueprintInput = {
  id: Scalars['ID']['input'];
  spaceId: Scalars['Long']['input'];
};

export type ConfluencePromotePageTemplateInput = {
  id: Scalars['ID']['input'];
  spaceId: Scalars['Long']['input'];
};

export enum ConfluencePublicLinkAccessType {
  External = 'EXTERNAL',
  InternalLicensed = 'INTERNAL_LICENSED'
}

export type ConfluencePublishBlogPostInput = {
  /** ID of draft BlogPost. */
  id: Scalars['ID']['input'];
  /** Title of the published BlogPost. If it is EMPTY, it will be same as draft BlogPost title. */
  publishTitle?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluencePublishBlueprintSharedDraftInput = {
  confluenceContentInput: ConfluenceContentInput;
  draftId: Scalars['ID']['input'];
  expand?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluencePublishPageInput = {
  /** ID of draft Page. */
  id: Scalars['ID']['input'];
  /** Title of the published Page. If it is EMPTY, it will be same as draft Page title. */
  publishTitle?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluencePurgeBlogPostInput = {
  /** ID of TRASHED BlogPost. */
  id: Scalars['ID']['input'];
};

export type ConfluencePurgePageInput = {
  /** ID of TRASHED Page. */
  id: Scalars['ID']['input'];
};

export type ConfluenceQuestionFilters = {
  /** Filter by answered status */
  answered?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum ConfluenceQuestionsOperationName {
  Create = 'CREATE',
  Delete = 'DELETE',
  Read = 'READ',
  Update = 'UPDATE'
}

export enum ConfluenceQuestionsOperationTarget {
  Answer = 'ANSWER',
  Attachment = 'ATTACHMENT',
  Comment = 'COMMENT',
  Question = 'QUESTION'
}

export enum ConfluenceReIndexLongTaskStatus {
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotTriggered = 'NOT_TRIGGERED',
  Submitted = 'SUBMITTED',
  Succeed = 'SUCCEED'
}

export type ConfluenceReactedUsersInput = {
  containerId?: InputMaybe<Scalars['String']['input']>;
  containerType?: InputMaybe<ContainerType>;
  contentId: Scalars['String']['input'];
  contentType: GraphQlReactionContentType;
  emojiId: Scalars['String']['input'];
};

export type ConfluenceReactionInput = {
  containerId?: InputMaybe<Scalars['Long']['input']>;
  containerType?: InputMaybe<ContainerType>;
  contentId?: InputMaybe<Scalars['Long']['input']>;
  contentType?: InputMaybe<GraphQlReactionContentType>;
  emojiId?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceReactionSummaryInput = {
  containerId?: InputMaybe<Scalars['Long']['input']>;
  containerType?: InputMaybe<ContainerType>;
  contentId?: InputMaybe<Scalars['Long']['input']>;
  contentType?: InputMaybe<GraphQlReactionContentType>;
};

export enum ConfluenceRecipientType {
  Group = 'GROUP',
  Team = 'TEAM',
  User = 'USER'
}

export type ConfluenceReopenInlineCommentInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceReorderTrackInput = {
  referenceTrack?: InputMaybe<ConfluenceTrackInput>;
  targetTrack: ConfluenceTrackInput;
};

export type ConfluenceRepairJiraMacroAppLinksInput = {
  appLinkMapping: Array<ConfluenceAppLinkMapping>;
};

export type ConfluenceReplyToCommentInput = {
  body: ConfluenceContentBodyInput;
  parentCommentId: Scalars['ID']['input'];
};

export enum ConfluenceRequestAccessApprovalDecision {
  Approve = 'APPROVE',
  Deny = 'DENY'
}

export type ConfluenceRequestSpaceAccessInput = {
  spaceKey: Scalars['String']['input'];
};

export type ConfluenceResolveInlineCommentInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceRestoreContentVersionInput = {
  contentId: Scalars['ID']['input'];
  expand?: InputMaybe<Scalars['String']['input']>;
  restoreTitle?: InputMaybe<Scalars['Boolean']['input']>;
  versionMessage?: InputMaybe<Scalars['String']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

export type ConfluenceRestrictionInput = {
  principalId: Scalars['ID']['input'];
  principalType: ConfluencePrincipalType;
};

export type ConfluenceRestrictionsInput = {
  restrictions: Array<InputMaybe<ConfluenceRestrictionInput>>;
};

export enum ConfluenceReviewerDecisionState {
  PendingReview = 'PENDING_REVIEW',
  ReviewerApproved = 'REVIEWER_APPROVED',
  ReviewerDenied = 'REVIEWER_DENIED',
  ReviewCanceled = 'REVIEW_CANCELED'
}

export enum ConfluenceRoleAssignabilityCode {
  Assignable = 'ASSIGNABLE',
  DefaultRoleAssignmentNotSupported = 'DEFAULT_ROLE_ASSIGNMENT_NOT_SUPPORTED',
  EscalationNotAssignable = 'ESCALATION_NOT_ASSIGNABLE',
  GuestExistingSpaceAccess = 'GUEST_EXISTING_SPACE_ACCESS',
  GuestSystemSpaceAccess = 'GUEST_SYSTEM_SPACE_ACCESS',
  NotAssignable = 'NOT_ASSIGNABLE',
  NoManageGuestUsersPermNotAssignable = 'NO_MANAGE_GUEST_USERS_PERM_NOT_ASSIGNABLE',
  NoManageNonlicensedUsersPermNotAssignable = 'NO_MANAGE_NONLICENSED_USERS_PERM_NOT_ASSIGNABLE',
  PrincipalInvalidRole = 'PRINCIPAL_INVALID_ROLE'
}

export type ConfluenceSaveOrUpdateSpaceOwnerInput = {
  /** The ID of the owner of the space */
  ownerId: Scalars['ID']['input'];
  /** The ID of the space */
  spaceId: Scalars['Long']['input'];
  /** The type of the owner */
  spaceOwnerType: ConfluenceSpaceOwnerType;
};

export enum ConfluenceSchedulePublishedType {
  Published = 'PUBLISHED',
  Scheduled = 'SCHEDULED',
  Unscheduled = 'UNSCHEDULED'
}

export type ConfluenceSetContentGeneralAccessModeInput = {
  contentId: Scalars['ID']['input'];
  mode: ConfluenceContentRestrictionStateInput;
};

export type ConfluenceSetSubCalendarReminderInput = {
  isReminder: Scalars['Boolean']['input'];
  subCalendarId: Scalars['ID']['input'];
};

export type ConfluenceShareContent = {
  contentId: Scalars['ID']['input'];
  contentUrl?: InputMaybe<Scalars['String']['input']>;
};

export enum ConfluenceSiteConfigurationEditorDefaultWidth {
  Max = 'MAX',
  Narrow = 'NARROW',
  Wide = 'WIDE'
}

export enum ConfluenceSiteEmailAddressStatus {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  SiteEmailAddressNotPresent = 'SITE_EMAIL_ADDRESS_NOT_PRESENT'
}

export type ConfluenceSpaceDetailsSpaceOwnerInput = {
  ownerId?: InputMaybe<Scalars['String']['input']>;
  ownerType?: InputMaybe<ConfluenceSpaceOwnerType>;
};

export type ConfluenceSpaceFilters = {
  /** It is used to filter Space by it type. */
  type?: InputMaybe<ConfluenceSpaceType>;
};

export enum ConfluenceSpaceOwnerType {
  Group = 'GROUP',
  User = 'USER'
}

export enum ConfluenceSpacePermissionAuditReportSpaceType {
  All = 'ALL',
  AllExceptPersonal = 'ALL_EXCEPT_PERSONAL',
  AllExceptSpecific = 'ALL_EXCEPT_SPECIFIC',
  Personal = 'PERSONAL',
  Specific = 'SPECIFIC'
}

export enum ConfluenceSpacePermissionAuditReportType {
  FullSitePermission = 'FULL_SITE_PERMISSION',
  PermissionCombination = 'PERMISSION_COMBINATION'
}

export enum ConfluenceSpacePermissionCombinationsByCriteriaOrder {
  Principal = 'PRINCIPAL',
  Space = 'SPACE'
}

export enum ConfluenceSpaceRoleMode {
  PreRoles = 'PRE_ROLES',
  Roles = 'ROLES',
  RolesTransition = 'ROLES_TRANSITION'
}

export enum ConfluenceSpaceSettingEditorVersion {
  V1 = 'V1',
  V2 = 'V2'
}

export enum ConfluenceSpaceStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Trashed = 'TRASHED'
}

export type ConfluenceSpaceTargetInput = {
  id: Scalars['ID']['input'];
  key: Scalars['String']['input'];
};

export enum ConfluenceSpaceType {
  Global = 'GLOBAL',
  Personal = 'PERSONAL'
}

export type ConfluenceSubjectCustomContentPermissionDelta = {
  permissionsToAdd: Array<InputMaybe<ConfluenceCustomContentPermissionInput>>;
  permissionsToRemove: Array<InputMaybe<ConfluenceCustomContentPermissionInput>>;
  principal: ConfluenceCustomContentPrincipalInput;
};

export enum ConfluenceSubscriptionContentType {
  Blogpost = 'BLOGPOST',
  Comment = 'COMMENT',
  Database = 'DATABASE',
  Embed = 'EMBED',
  Folder = 'FOLDER',
  Page = 'PAGE',
  Whiteboard = 'WHITEBOARD'
}

export enum ConfluenceTeamAdminControlsMode {
  AllTeams = 'ALL_TEAMS',
  MemberManagedTeams = 'MEMBER_MANAGED_TEAMS',
  NoTeams = 'NO_TEAMS',
  VerifiedTeams = 'VERIFIED_TEAMS'
}

export enum ConfluenceTeamCalendarTimeFormatTypes {
  DisplayTimeFormat_12 = 'DISPLAY_TIME_FORMAT_12',
  DisplayTimeFormat_24 = 'DISPLAY_TIME_FORMAT_24'
}

export enum ConfluenceTeamCalendarWeekValues {
  Default = 'DEFAULT',
  Five = 'FIVE',
  Four = 'FOUR',
  One = 'ONE',
  Seven = 'SEVEN',
  Six = 'SIX',
  Three = 'THREE',
  Two = 'TWO'
}

export type ConfluenceTemplateInfoInput = {
  author?: InputMaybe<Scalars['String']['input']>;
  blueprintModuleCompleteKey?: InputMaybe<Scalars['String']['input']>;
  categoryIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  contentBlueprintId?: InputMaybe<Scalars['String']['input']>;
  currentDateLozenge?: InputMaybe<Scalars['String']['input']>;
  darkModeIconURL?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  hasGlobalBlueprintContent?: InputMaybe<Scalars['Boolean']['input']>;
  hasWizard?: InputMaybe<Scalars['Boolean']['input']>;
  iconURL?: InputMaybe<Scalars['String']['input']>;
  isFavourite?: InputMaybe<Scalars['Boolean']['input']>;
  isNew?: InputMaybe<Scalars['Boolean']['input']>;
  isPromoted?: InputMaybe<Scalars['Boolean']['input']>;
  itemModuleCompleteKey?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name?: InputMaybe<Scalars['String']['input']>;
  recommendationRank?: InputMaybe<Scalars['Int']['input']>;
  spaceId?: InputMaybe<Scalars['Int']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
  styleClass?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['String']['input']>;
  templateType?: InputMaybe<Scalars['String']['input']>;
  variables?: InputMaybe<Array<InputMaybe<ConfluenceTemplateVariableInput>>>;
};

export type ConfluenceTemplateVariableInput = {
  key: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export enum ConfluenceTone {
  Conversational = 'CONVERSATIONAL',
  Playful = 'PLAYFUL',
  Professional = 'PROFESSIONAL',
  Surprise = 'SURPRISE'
}

export type ConfluenceTrackInput = {
  mainSource: Scalars['ID']['input'];
  supportingSources?: InputMaybe<Array<Scalars['ID']['input']>>;
  trackSource?: InputMaybe<ConfluenceTrackSourceInput>;
  trackType: ConfluenceTrackType;
};

export enum ConfluenceTrackSource {
  Mobile = 'MOBILE',
  Unknown = 'UNKNOWN',
  Web = 'WEB'
}

export enum ConfluenceTrackSourceInput {
  Mobile = 'MOBILE',
  Web = 'WEB'
}

export enum ConfluenceTrackType {
  Briefing = 'BRIEFING',
  Narration = 'NARRATION'
}

export type ConfluenceTrashBlogPostInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceTrashPageInput = {
  id: Scalars['ID']['input'];
};

export type ConfluenceUnpromoteBlueprintInput = {
  id: Scalars['ID']['input'];
  spaceId: Scalars['Long']['input'];
};

export type ConfluenceUnpromotePageTemplateInput = {
  id: Scalars['ID']['input'];
  spaceId: Scalars['Long']['input'];
};

export type ConfluenceUnschedulePublishInput = {
  contentId: Scalars['String']['input'];
};

export type ConfluenceUnsubscribeCalendarInput = {
  calendarContext?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  viewingSpaceKey?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUnwatchSubCalendarInput = {
  subCalendarId: Scalars['ID']['input'];
};

export type ConfluenceUpdateAccessRequestSettingsInput = {
  /** Whether access requests should be enabled or disabled */
  enabled: Scalars['Boolean']['input'];
  /** Associated message content that users will see if access requests are blocked */
  messageContent?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateAdminAnnouncementBannerInput = {
  appearance?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  isDismissible?: InputMaybe<Scalars['Boolean']['input']>;
  scheduledEndTime?: InputMaybe<Scalars['String']['input']>;
  scheduledStartTime?: InputMaybe<Scalars['String']['input']>;
  scheduledTimeZone?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ConfluenceAdminAnnouncementBannerStatusType>;
  title?: InputMaybe<Scalars['String']['input']>;
  visibility?: InputMaybe<ConfluenceAdminAnnouncementBannerVisibilityType>;
};

export type ConfluenceUpdateAnswerInput = {
  /** Body of the Answer */
  body?: InputMaybe<ConfluenceContentBodyInput>;
  /** ID of the Answer */
  id: Scalars['ID']['input'];
  /** Version number to be updated to */
  version: Scalars['Int']['input'];
};

export type ConfluenceUpdateAudioPreferenceInput = {
  length?: InputMaybe<ConfluenceLength>;
  playbackSpeed?: InputMaybe<Scalars['Float']['input']>;
  tone?: InputMaybe<ConfluenceTone>;
};

export type ConfluenceUpdateBlogPostInput = {
  confluenceContentInput: ConfluenceContentInput;
  status?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateCalendarEventInput = {
  allDayEvent?: InputMaybe<Scalars['Boolean']['input']>;
  calendarId: Scalars['ID']['input'];
  childCalendarId?: InputMaybe<Scalars['String']['input']>;
  customEventTypeId?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  editAllInRecurrenceSeries?: InputMaybe<Scalars['Boolean']['input']>;
  endDate?: InputMaybe<Scalars['String']['input']>;
  endTime?: InputMaybe<Scalars['String']['input']>;
  eventType?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  location?: InputMaybe<Scalars['String']['input']>;
  mentionedUserNote?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  notifyWatchers?: InputMaybe<Scalars['Boolean']['input']>;
  originalCalendarId?: InputMaybe<Scalars['String']['input']>;
  originalCustomEventTypeId?: InputMaybe<Scalars['String']['input']>;
  originalEventType?: InputMaybe<Scalars['String']['input']>;
  originalStartDate?: InputMaybe<Scalars['String']['input']>;
  persons?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  recurrenceId?: InputMaybe<Scalars['String']['input']>;
  recurrenceRule?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['String']['input']>;
  startTime?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  userTimeZoneId?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateCalendarEventTypeInput = {
  calendarId: Scalars['String']['input'];
  icon: Scalars['String']['input'];
  id: Scalars['ID']['input'];
  periodInMins?: InputMaybe<Scalars['Int']['input']>;
  title: Scalars['String']['input'];
};

export type ConfluenceUpdateCalendarPermissionInput = {
  groups: Array<InputMaybe<ConfluenceCalendarPermissionInput>>;
  id: Scalars['ID']['input'];
  users: Array<InputMaybe<ConfluenceCalendarPermissionInput>>;
};

export type ConfluenceUpdateCalendarViewInput = {
  view: Scalars['String']['input'];
};

export type ConfluenceUpdateCommentInput = {
  body: ConfluenceContentBodyInput;
  id: Scalars['ID']['input'];
};

export type ConfluenceUpdateContentAccessRequestInput = {
  accessRequestedAccountId: Scalars['ID']['input'];
  accessType: ResourceAccessType;
  approvalDecision: ConfluenceRequestAccessApprovalDecision;
  contentId: Scalars['ID']['input'];
  requestId: Scalars['ID']['input'];
};

export type ConfluenceUpdateContentAppearanceInput = {
  contentAppearance: Scalars['String']['input'];
  contentId: Scalars['ID']['input'];
  /** Determines whether mutation updates CURRENT vs. DRAFT page entity. Defaults to CURRENT status. */
  contentStatus?: InputMaybe<ConfluenceMutationContentStatus>;
};

export type ConfluenceUpdateContentApprovalRequestInput = {
  approvalStatus?: InputMaybe<ConfluenceWorkflowReviewStatus>;
  comment?: InputMaybe<Scalars['String']['input']>;
  contentApprovalReviewId: Scalars['Long']['input'];
  reviewers?: InputMaybe<Array<InputMaybe<ConfluenceContentApprovalReviewerInput>>>;
  workflowApplicationId: Scalars['Long']['input'];
};

export type ConfluenceUpdateContentDirectRestrictionsInput = {
  add?: InputMaybe<ConfluenceDirectRestrictionsAddInput>;
  contentId: Scalars['ID']['input'];
  includeInvites?: InputMaybe<Scalars['Boolean']['input']>;
  remove?: InputMaybe<ConfluenceDirectRestrictionsRemoveInput>;
};

export type ConfluenceUpdateContentModeInput = {
  contentId: Scalars['ID']['input'];
  contentMode: ConfluenceGraphQlContentMode;
  contentStatus?: InputMaybe<ConfluenceMutationContentStatus>;
};

export type ConfluenceUpdateCoverPictureInput = {
  contentId: Scalars['ID']['input'];
  /** Determines whether mutation updates CURRENT vs. DRAFT page entity. Defaults to CURRENT status. */
  contentStatus?: InputMaybe<ConfluenceMutationContentStatus>;
  coverPicture: Scalars['String']['input'];
};

export type ConfluenceUpdateCurrentBlogPostInput = {
  body?: InputMaybe<ConfluenceContentBodyInput>;
  id: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateCurrentPageInput = {
  body?: InputMaybe<ConfluenceContentBodyInput>;
  id: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateCustomApplicationLinkInput = {
  allowedGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  isHidden: Scalars['Boolean']['input'];
  url?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateCustomContentPermissionsInput = {
  spaceId: Scalars['Long']['input'];
  subjectPermissionDeltasList: Array<InputMaybe<ConfluenceSubjectCustomContentPermissionDelta>>;
};

export type ConfluenceUpdateCustomPageConfigurationInput = {
  /** Footer text configuration which can be applied to all the pages. It can be in the Atlassian WIKI markup format. */
  footerText: Scalars['String']['input'];
  /** Header text configuration which can be applied to all the pages. It can be in the Atlassian WIKI markup format. */
  headerText: Scalars['String']['input'];
};

export type ConfluenceUpdateCustomPageSpaceConfigurationInput = {
  /** Footer text configuration which can be applied to all the pages. It can be in the Atlassian WIKI markup format. */
  footerText: Scalars['String']['input'];
  /** Header text configuration which can be applied to all the pages. It can be in the Atlassian WIKI markup format. */
  headerText: Scalars['String']['input'];
  spaceId: Scalars['Long']['input'];
};

export type ConfluenceUpdateCustomRoleInput = {
  anonymousReassignmentRoleId?: InputMaybe<Scalars['ID']['input']>;
  description: Scalars['String']['input'];
  guestReassignmentRoleId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  permissions: Array<InputMaybe<Scalars['String']['input']>>;
  roleId: Scalars['ID']['input'];
};

export type ConfluenceUpdateDefaultTitleEmojiInput = {
  contentId: Scalars['ID']['input'];
  defaultTitleEmoji: ConfluenceGraphQlDefaultTitleEmoji;
};

export type ConfluenceUpdateDraftBlogPostInput = {
  body?: InputMaybe<ConfluenceContentBodyInput>;
  id: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateDraftPageInput = {
  body?: InputMaybe<ConfluenceContentBodyInput>;
  id: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateEmailSiteConfigurationInput = {
  /** Enabling recommended email notifications will send weekly recommended emails on the site. */
  isEnableRecommendedEmailNotification: Scalars['Boolean']['input'];
};

export type ConfluenceUpdateGlobalDefaultLocaleConfigurationInput = {
  /** Default locale of site. */
  globalDefaultLocale: Scalars['String']['input'];
};

export type ConfluenceUpdateGlobalPageTemplateDescriptionInput = {
  description: Scalars['String']['input'];
  id: Scalars['ID']['input'];
};

export type ConfluenceUpdateGlobalThemeInput = {
  /** Set to null to remove the global theme */
  themeKey?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateIndexingLanguageConfigurationInput = {
  /** Indexing language configuration. */
  indexingLanguage: Scalars['String']['input'];
};

export type ConfluenceUpdateInstanceInput = {
  contentBlueprintSpec: ConfluenceContentBlueprintSpecInput;
  contentStatus: GraphQlContentStatus;
  /** The current version, if unpublished draft. Next incremented version, if published content. */
  nextVersion: Scalars['Int']['input'];
};

export type ConfluenceUpdateLoomEntryPointsConfigurationInput = {
  /** Enabling Loom entry points will recommend Loom to users on the site. */
  isEnabled: Scalars['Boolean']['input'];
};

export type ConfluenceUpdateNewCodeMacroInput = {
  languageName: Scalars['String']['input'];
  themeName: Scalars['String']['input'];
};

export type ConfluenceUpdatePageInput = {
  confluenceContentInput: ConfluenceContentInput;
  status: Scalars['String']['input'];
};

export type ConfluenceUpdatePdfExportConfigurationInput = {
  /** Customize export PDF document by adding footer in HTML format. */
  footer: Scalars['String']['input'];
  /** Customize export PDF document by adding header in HTML format. */
  header: Scalars['String']['input'];
  /** Customize export PDF document style by adding new style or override existing one. */
  style: Scalars['String']['input'];
  /** Customize export PDF document by adding title page in HTML format. */
  titlePage: Scalars['String']['input'];
};

/** Payload for updating the No-Code Styling configuration for PDF export in Confluence. */
export type ConfluenceUpdatePdfExportNoCodeStylingConfigInput = {
  /** The font size for the body text in the PDF document. */
  bodyFontSize: Scalars['Int']['input'];
  font: ConfluencePdfExportFontInput;
  footer: ConfluencePdfExportFooterInclusionConfigurationInput;
  header: ConfluencePdfExportHeaderInclusionConfigurationInput;
  /** The line spacing in the PDF document. */
  lineSpacing: Scalars['Float']['input'];
  /** The margins for the PDF pages. */
  pageMargins: ConfluencePdfExportPageMarginsInput;
  pageOrientation: ConfluencePdfExportPageOrientationInput;
  pageSize: ConfluencePdfExportPageSizeInput;
  /** Whether to include page numbers in the PDF export. */
  shouldIncludePageNumbers: Scalars['Boolean']['input'];
  /** Whether to include a table of contents in the PDF export. */
  shouldIncludeTableOfContents: Scalars['Boolean']['input'];
  titlePage: ConfluencePdfExportTitlePageInclusionConfigurationInput;
};

export type ConfluenceUpdatePdfExportSpaceConfigurationInput = {
  /** Customize export PDF document by adding footer in HTML format. */
  footer: Scalars['String']['input'];
  /** Customize export PDF document by adding header in HTML format. */
  header: Scalars['String']['input'];
  spaceId: Scalars['Long']['input'];
  /** Customize export PDF document style by adding new style or override existing one. */
  style: Scalars['String']['input'];
  /** Customize export PDF document by adding title page in HTML format. */
  titlePage: Scalars['String']['input'];
};

export type ConfluenceUpdateQuestionInput = {
  /** Body of the Question */
  body?: InputMaybe<ConfluenceContentBodyInput>;
  /** ID of the Question */
  id: Scalars['ID']['input'];
  /** Labels for the Question */
  labels?: InputMaybe<Array<InputMaybe<LabelInput>>>;
  /** Title of the Question */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Version number to be updated to */
  version: Scalars['Int']['input'];
};

export type ConfluenceUpdateReviewerDecisionInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  decisionStatus: ConfluenceReviewerDecisionState;
  reviewerId: Scalars['Long']['input'];
};

export type ConfluenceUpdateShareableLinksInput = {
  accessType: ConfluencePublicLinkAccessType;
  contentId: Scalars['ID']['input'];
};

export type ConfluenceUpdateSiteConfigurationInput = {
  /** Connection timeout in millisecond on the site. */
  connectionTimeout: Scalars['Int']['input'];
  /** Message that is shown to a user when they try to contact the site administrators. */
  customContactMessage: Scalars['String']['input'];
  /** Date format configuration on site. */
  dateFormat: Scalars['String']['input'];
  /** DateTime format configuration on site. */
  dateTimeFormat: Scalars['String']['input'];
  /** Decimal number format configuration on site. */
  decimalNumberFormat: Scalars['String']['input'];
  /** Site setting for default width with which display pages in editor */
  editorDefaultWidth?: InputMaybe<ConfluenceSiteConfigurationEditorDefaultWidth>;
  /** Default locale of site. */
  globalDefaultLocale: Scalars['String']['input'];
  /** Indexing language configuration. */
  indexingLanguage: Scalars['String']['input'];
  /** Enabling contact administrators form on the site. */
  isContactAdministratorsFormEnabled: Scalars['Boolean']['input'];
  /** Enabling editor conversion will display content in new editor. */
  isEditorConversionForSiteEnabled: Scalars['Boolean']['input'];
  /** Enabling editor full-width will display pages in full width. */
  isEditorFullWidthEnabled: Scalars['Boolean']['input'];
  /** Enabling email notification will send an email to user for the activity on the site. */
  isEmailNotificationEnabled: Scalars['Boolean']['input'];
  /** Enabling external connections on the site. */
  isExternalConnectionsEnabled: Scalars['Boolean']['input'];
  /** Enabling likes will allow users to like/react to pages, blogs, comments, and other content. */
  isLikesEnabled: Scalars['Boolean']['input'];
  /** Tenant-level opt-in for Global Navigation 4.0 */
  isNav4OptedIn?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enabling push notification will send an notification to user for the activity on the site. */
  isPushNotificationEnabled: Scalars['Boolean']['input'];
  /** Enabling sharing of snippets for the site. */
  isSnippetSharingForSiteEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Long number format configuration on site. */
  longNumberFormat: Scalars['String']['input'];
  /** Maximum attachment size per upload on the site. */
  maxAttachmentSize: Scalars['Long']['input'];
  /** Maximum number of attachments allowed per upload on the site. */
  maxNumberOfAttachmentsPerUpload: Scalars['Int']['input'];
  /** Configure the site home page, could be any landing page of space. Default is confluence home page. */
  siteHomePage: Scalars['String']['input'];
  /** Title of the site */
  siteTitle: Scalars['String']['input'];
  /** Socket timeout in millisecond on the site. */
  socketTimeout: Scalars['Int']['input'];
  /** Time format configuration on site. */
  timeFormat: Scalars['String']['input'];
};

export type ConfluenceUpdateSiteSecurityConfigurationInput = {
  /** Setting to provide the attachment security level. */
  attachmentSecurityLevel: ConfluenceAttachmentSecurityLevel;
  /** Setting to append wildcards to user and group. */
  isAddWildcardsToUserAndGroupSearchesEnabled: Scalars['Boolean']['input'];
  /** Setting allow anonymous access to remote api. */
  isAnonymousAccessToRemoteApiEnabled: Scalars['Boolean']['input'];
  /** Setting to enable elevated security check. */
  isElevatedSecurityCheckEnabled: Scalars['Boolean']['input'];
  /** Setting to hide external links. */
  isNofollowExternalLinksEnabled: Scalars['Boolean']['input'];
  /** Setting to enable privacy mode. */
  isPrivacyModeEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Setting to enable xsrf add comments. */
  isXsrfAddCommentsEnabled: Scalars['Boolean']['input'];
  /** Allowed login attempts. */
  loginAttemptsThreshold: Scalars['Int']['input'];
  /** Max RSS items allowed. */
  maxRssItems: Scalars['Int']['input'];
  /** Allowed page timeout. In seconds */
  pageTimeout: Scalars['Int']['input'];
  /** Max RSS timeout. In seconds */
  rssTimeout: Scalars['Int']['input'];
};

export type ConfluenceUpdateSiteSenderEmailAddressInput = {
  /** Email address that Confluence will send email notifications from. */
  emailAddress: Scalars['String']['input'];
};

export type ConfluenceUpdateSlackSiteConfigurationInput = {
  /** Enabling digest slack notifications will send digest slack notifs on the site. */
  isEnableDigestSlackNotification?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enabling mention reminder slack notifications will send weekly mention reminder slack notifs on the site. */
  isEnableMentionReminderSlackNotification?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enabling recommended slack notifications will send weekly recommended slack notifs on the site. */
  isEnableRecommendedSlackNotification: Scalars['Boolean']['input'];
};

export type ConfluenceUpdateSpaceInput = {
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateSpacePageTemplateDescriptionInput = {
  description: Scalars['String']['input'];
  id: Scalars['ID']['input'];
  spaceId: Scalars['Long']['input'];
};

export type ConfluenceUpdateSpaceSettingsInput = {
  /** ARI for the Space. */
  id: Scalars['String']['input'];
  /** Whether the space is opted in to No Code Styling for PDF export */
  pdfExportNoCodeStylingOptedIn?: InputMaybe<Scalars['Boolean']['input']>;
  /** Defines whether an override for the space home should be used. This is used in conjunction with a space theme provided by an app. For example, if this property is set to true, a theme can display a page other than the space homepage when users visit the root URL for a space. This property allows apps to provide content-only theming without overriding the space home. */
  routeOverrideEnabled: Scalars['Boolean']['input'];
};

export type ConfluenceUpdateSpaceThemeInput = {
  spaceId: Scalars['Long']['input'];
  /** Set to null to remove the global theme */
  themeKey?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateSubCalendarHiddenEventsInput = {
  subCalendarId: Scalars['ID']['input'];
};

export type ConfluenceUpdateTeamCalendarGlobalSettingsInput = {
  /** Is site admin allow to manage the calendars */
  allowSiteAdmin: Scalars['Boolean']['input'];
  /** Are private urls disabled for the calendar */
  disablePrivateUrls: Scalars['Boolean']['input'];
  /** To display week numbers */
  displayWeekNumbers: Scalars['Boolean']['input'];
  /** Start day of week */
  startDayOfWeek: ConfluenceTeamCalendarWeekValues;
  /** Format in which time is displayed */
  timeFormat: ConfluenceTeamCalendarTimeFormatTypes;
};

export type ConfluenceUpdateTeamPresenceSiteConfigurationInput = {
  /** Enabling team presence on content view will show users' avatars while they are viewing content on the site. */
  isEnabledOnContentView: Scalars['Boolean']['input'];
};

export type ConfluenceUpdateTeamPresenceSpaceSettingsInput = {
  isEnabledOnContentView: Scalars['Boolean']['input'];
  spaceId: Scalars['Long']['input'];
};

export type ConfluenceUpdateTeamsSiteConfigurationInput = {
  /** Enabling recommended teams notifications will send weekly recommended teams notifs on the site. */
  isEnableRecommendedTeamsNotification: Scalars['Boolean']['input'];
};

export type ConfluenceUpdateTitleEmojiInput = {
  contentId: Scalars['ID']['input'];
  /** Determines whether mutation updates CURRENT vs. DRAFT page entity. Defaults to CURRENT status. */
  contentStatus?: InputMaybe<ConfluenceMutationContentStatus>;
  titleEmoji: Scalars['String']['input'];
};

export type ConfluenceUpdateTopicInput = {
  /** Description of the Topic */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the Topic is featured */
  featured?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID of the Topic */
  id: Scalars['ID']['input'];
  /** Logo ID for the Topic (file store ID) */
  logoId?: InputMaybe<Scalars['String']['input']>;
  /** Logo Url for the Topic */
  logoUrl?: InputMaybe<Scalars['String']['input']>;
};

export type ConfluenceUpdateValueBlogPostPropertyInput = {
  blogPostId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ConfluenceUpdateValuePagePropertyInput = {
  key: Scalars['String']['input'];
  pageId: Scalars['ID']['input'];
  useSameVersion?: InputMaybe<Scalars['Boolean']['input']>;
  value: Scalars['String']['input'];
};

export type ConfluenceUpdateVoteInput = {
  /** The id of the content being voted on. */
  contentId: Scalars['ID']['input'];
  /** The id of the person who owns the content. */
  userId: Scalars['ID']['input'];
  /** The type of the vote, whether it is an upvote or a downvote. */
  voteType: ConfluenceVoteType;
};

export type ConfluenceUpdateWatermarkConfigInput = {
  /** The watermark configuration data as JSON string */
  data: Scalars['String']['input'];
};

export type ConfluenceUpdateWorkflowApplicationRequestInput = {
  contentId: Scalars['Long']['input'];
  contentStatus: GraphQlContentStatus;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  version: Scalars['Int']['input'];
  workflowId?: InputMaybe<Scalars['Long']['input']>;
  workflowStatusId?: InputMaybe<Scalars['Long']['input']>;
};

export type ConfluenceUploadDefaultSpaceLogoInput = {
  fileStoreId: Scalars['ID']['input'];
};

export enum ConfluenceUserType {
  Anonymous = 'ANONYMOUS',
  Known = 'KNOWN'
}

export enum ConfluenceViewState {
  Editor = 'EDITOR',
  Live = 'LIVE',
  Renderer = 'RENDERER'
}

export enum ConfluenceVoteType {
  Downvote = 'DOWNVOTE',
  Upvote = 'UPVOTE'
}

export type ConfluenceWatchSubCalendarInput = {
  subCalendarId: Scalars['ID']['input'];
};

export enum ConfluenceWorkflowReviewStatus {
  Approved = 'APPROVED',
  Canceled = 'CANCELED',
  Denied = 'DENIED',
  Pending = 'PENDING'
}

export type ConnectionManagerConfigurationInput = {
  parameters?: InputMaybe<Scalars['String']['input']>;
};

export type ConnectionManagerConnectionsFilter = {
  integrationKey?: InputMaybe<Scalars['String']['input']>;
};

export type ConnectionManagerCreateApiTokenConnectionInput = {
  configuration?: InputMaybe<ConnectionManagerConfigurationInput>;
  integrationKey?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tokens?: InputMaybe<Array<InputMaybe<ConnectionManagerTokenInput>>>;
};

export type ConnectionManagerCreateOAuthConnectionInput = {
  configuration?: InputMaybe<ConnectionManagerConfigurationInput>;
  credentials?: InputMaybe<ConnectionManagerOAuthCredentialsInput>;
  integrationKey?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  providerDetails?: InputMaybe<ConnectionManagerOAuthProviderDetailsInput>;
};

export type ConnectionManagerOAuthCredentialsInput = {
  clientId?: InputMaybe<Scalars['String']['input']>;
  clientSecret?: InputMaybe<Scalars['String']['input']>;
};

export type ConnectionManagerOAuthProviderDetailsInput = {
  authorizationUrl?: InputMaybe<Scalars['String']['input']>;
  exchangeUrl?: InputMaybe<Scalars['String']['input']>;
};

export type ConnectionManagerTokenInput = {
  token?: InputMaybe<Scalars['String']['input']>;
  tokenId?: InputMaybe<Scalars['String']['input']>;
};

export type ContactAdminMutationInput = {
  content: ContactAdminMutationInputContent;
  recaptchaResponseToken?: InputMaybe<Scalars['String']['input']>;
};

export type ContactAdminMutationInputContent = {
  from: Scalars['String']['input'];
  requestDetails: Scalars['String']['input'];
  subject: Scalars['String']['input'];
};

export enum ContactAdminPageDisabledReason {
  ConfigOff = 'CONFIG_OFF',
  NoAdminEmails = 'NO_ADMIN_EMAILS',
  NoMailServer = 'NO_MAIL_SERVER',
  NoRecaptcha = 'NO_RECAPTCHA'
}

export enum ContainerType {
  Blogpost = 'BLOGPOST',
  Database = 'DATABASE',
  Page = 'PAGE',
  Space = 'SPACE',
  Whiteboard = 'WHITEBOARD'
}

export enum ContentAccessInputType {
  EveryoneCanEdit = 'EVERYONE_CAN_EDIT',
  EveryoneCanView = 'EVERYONE_CAN_VIEW',
  EveryoneNoAccess = 'EVERYONE_NO_ACCESS',
  Private = 'PRIVATE'
}

export enum ContentAccessType {
  EveryoneCanEdit = 'EVERYONE_CAN_EDIT',
  EveryoneCanView = 'EVERYONE_CAN_VIEW',
  EveryoneNoAccess = 'EVERYONE_NO_ACCESS'
}

export enum ContentAction {
  Created = 'created',
  Updated = 'updated',
  Viewed = 'viewed'
}

export type ContentBodyInput = {
  representation: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export enum ContentDataClassificationMutationContentStatus {
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export enum ContentDataClassificationQueryContentStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export enum ContentDeleteActionType {
  DeleteDraft = 'DELETE_DRAFT',
  DeleteDraftIfBlank = 'DELETE_DRAFT_IF_BLANK',
  MoveToTrash = 'MOVE_TO_TRASH',
  PurgeFromTrash = 'PURGE_FROM_TRASH'
}

export type ContentMention = {
  mentionLocalId?: InputMaybe<Scalars['ID']['input']>;
  mentionedUserAccountId: Scalars['ID']['input'];
  notificationAction: NotificationAction;
};

export enum ContentPermissionType {
  Edit = 'EDIT',
  View = 'VIEW'
}

export enum ContentPlatformBooleanOperators {
  And = 'AND',
  Or = 'OR'
}

export type ContentPlatformContentClause = {
  /** Logical AND operator that expects all expressions within operator to be true */
  and?: InputMaybe<Array<ContentPlatformContentClause>>;
  /** Field name selector */
  fieldNamed?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to operator, currently used for date comparisons */
  gte?: InputMaybe<ContentPlatformDateCondition>;
  /** Existence selector */
  hasAnyValue?: InputMaybe<Scalars['Boolean']['input']>;
  /** Values selector */
  havingValues?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Less than or equal to operator, currently used for date comparisons */
  lte?: InputMaybe<ContentPlatformDateCondition>;
  /** Logical OR operator that expects at least one expression within operator to be true */
  or?: InputMaybe<Array<ContentPlatformContentClause>>;
  /** Object that allows users to search content for text snippets */
  searchText?: InputMaybe<ContentPlatformSearchTextClause>;
};

export type ContentPlatformContentQueryInput = {
  /** This is a cursor after which (exclusive) the data should be fetched */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Number of content results to fetch */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** This is how the entries returned will be sorted */
  sortBy?: InputMaybe<ContentPlatformSortClause>;
  /** Object used to filter and search text */
  where?: InputMaybe<ContentPlatformContentClause>;
  /** Fallback locale to use when no content is found in the requested locale */
  withFallback?: InputMaybe<Scalars['String']['input']>;
  /** Locales to return content in */
  withLocales?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Object containing the product Feature Flags associated with the Atlassian Product Instance */
  withProductFeatureFlags?: InputMaybe<Scalars['JSON']['input']>;
};

export type ContentPlatformDateCondition = {
  /**
   * Determines which date field to compare this operation to. One of:
   * * "createdAt"
   * * "publishDate"
   * * "updatedAt"
   * * "featureRolloutDate"
   * * "featureRolloutEndDate"
   */
  dateFieldNamed?: Scalars['String']['input'];
  /** An ISO date string that is used to filter items before or after a given date */
  havingDate: Scalars['DateTime']['input'];
};

export type ContentPlatformDateRangeFilter = {
  /** An ISO date string that is used to filter items after given date */
  after: Scalars['DateTime']['input'];
  /** An ISO date string that is used to filter items before given date */
  before: Scalars['DateTime']['input'];
};

export type ContentPlatformField = {
  /** Name of field to be searched. One of TITLE or DESCRIPTION */
  field: ContentPlatformFieldNames;
};

export enum ContentPlatformFieldNames {
  Description = 'DESCRIPTION',
  Title = 'TITLE'
}

export enum ContentPlatformOperators {
  All = 'ALL',
  Any = 'ANY'
}

export type ContentPlatformReleaseNoteFilterOptions = {
  /**
   * A list of change statuses on which to match release notes. Options:
   *   * "Coming soon"
   *   * "Generally available"
   *   * "Planned"
   *   * "Rolled back"
   *   * "Rolling out"
   */
  changeStatus?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * A list of Change Types on which to match release notes. Options:
   *   * "Experiment"
   *   * "Improvement"
   *   * "Removed"
   *   * "Announcement"
   *   * "Fix"
   */
  changeTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The Contentful ID of a product on which to match release notes */
  contextId?: InputMaybe<Scalars['String']['input']>;
  /** A list of Feature Delivery Jira issue keys on which to match release notes */
  fdIssueKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of Feature Delivery Jira ticket urls on which to match release notes */
  fdIssueLinks?: InputMaybe<Array<Scalars['String']['input']>>;
  /** This field will be removed in the next version of the service. Please use the `featureFlagEnvironment` filter at the parent level. */
  featureFlagEnvironment?: InputMaybe<Scalars['String']['input']>;
  /** This field will be removed in the next version of the service. Please use the `featureFlagProject` filter at the parent level. */
  featureFlagProject?: InputMaybe<Scalars['String']['input']>;
  /** Rollout dates on which to match release notes */
  featureRolloutDates?: InputMaybe<Array<Scalars['String']['input']>>;
  /** JSON passed in as a query variable corresponding to product feature flags defined in LaunchDarkly. The API will filter Release Notes based on the feature flag OFF value. */
  productFeatureFlags?: InputMaybe<Scalars['JSON']['input']>;
  /**
   * A list of product/app names on which to match release notes. Options:
   *   * "Advanced Roadmaps for Jira"
   *   * "Atlas"
   *   * "Atlassian Analytics"
   *   * "Atlassian Cloud"
   *   * "Bitbucket"
   *   * "Compass"
   *   * "Confluence"
   *   * "Halp"
   *   * "Jira Align"
   *   * "Jira Product Discovery"
   *   * "Jira Service Management"
   *   * "Jira Software"
   *   * "Jira Work Management"
   *   * "Opsgenie"
   *   * "Questions for Confluence"
   *   * "Statuspage"
   *   * "Team Calendars for Confluence"
   *   * "Trello"
   *   * "Cloud automation"
   *   * "Jira cloud app for Android"
   *   * "Jira cloud app for iOS"
   *   * "Jira cloud app for macOS"
   *   * "Opsgenie app for Android"
   *   * "Opsgenie app for BlackBerry Dynamics"
   *   * "Opsgenie app for iOS"
   */
  productNames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of feature flag off values on which to match release notes */
  releaseNoteFlagOffValues?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of feature flags on which to match release notes */
  releaseNoteFlags?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A date range where you can filter release notes within a specific date range on the updatedAt field */
  updatedAt?: InputMaybe<ContentPlatformDateRangeFilter>;
};

export type ContentPlatformSearchApIv2Query = {
  /** Queries to be sent to the search API */
  queries: Array<ContentPlatformContentQueryInput>;
};

export type ContentPlatformSearchOptions = {
  /** Boolean AND/OR for combining search queries in the query list */
  operator?: InputMaybe<ContentPlatformBooleanOperators>;
  /** Search query defining the search type, terms, term operators, fields, and field operators */
  queries: Array<ContentPlatformSearchQuery>;
};

export type ContentPlatformSearchQuery = {
  /** One of ANY or ALL. Defines whether search needs to match any of the fields queried (boolean OR) or of all of them (boolean AND) */
  fieldOperator?: InputMaybe<ContentPlatformOperators>;
  /** Fields to be searched */
  fields?: InputMaybe<Array<ContentPlatformField>>;
  /** Type of search to be executed. One of CONTAINS or EXACT_MATCH */
  searchType: ContentPlatformSearchTypes;
  /** One of ANY or ALL. Defines whether search needs to match any of the terms queried (boolean OR) or of all of them (boolean AND) */
  termOperator?: InputMaybe<ContentPlatformOperators>;
  /** The terms to be searched within fields of the Release Notes */
  terms: Array<Scalars['String']['input']>;
};

export type ContentPlatformSearchTextClause = {
  /** Logical AND operator that expects all expressions within operator to be true */
  and?: InputMaybe<Array<ContentPlatformSearchTextClause>>;
  /** Object used to search text using fuzzy matching */
  exactlyMatching?: InputMaybe<ContentPlatformSearchTextMatchingClause>;
  /** Logical OR operator that expects at least one expression within operator to be true */
  or?: InputMaybe<Array<ContentPlatformSearchTextClause>>;
  /** Object used to search text using exact matching */
  partiallyMatching?: InputMaybe<ContentPlatformSearchTextMatchingClause>;
};

export type ContentPlatformSearchTextMatchingClause = {
  /** Logical AND operator that expects all expressions within operator to be true */
  and?: InputMaybe<Array<ContentPlatformSearchTextMatchingClause>>;
  /** Field name selector */
  fieldNamed?: InputMaybe<Scalars['String']['input']>;
  /** Values selector */
  havingValues?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Values selector */
  matchingAllValues?: InputMaybe<Scalars['Boolean']['input']>;
  /** Logical OR operator that expects at least one expression within operator to be true */
  or?: InputMaybe<Array<ContentPlatformSearchTextMatchingClause>>;
};

export enum ContentPlatformSearchTypes {
  Contains = 'CONTAINS',
  ExactMatch = 'EXACT_MATCH'
}

export type ContentPlatformSortClause = {
  /**
   * This is how the data returned will be sorted, one of
   * * "relevancy" <- if searchText is used, this is the default, and no other sort order is specified
   * * "createdAt" <- DEFAULT
   * * "updatedAt"
   * * "featureRolloutDate"
   * * "featureRolloutEndDate"
   */
  fieldNamed?: Scalars['String']['input'];
  /** Options are DESC (DEFAULT) or ASC */
  havingOrder?: Scalars['String']['input'];
};

export enum ContentRendererMode {
  Editor = 'EDITOR',
  Pdf = 'PDF',
  Renderer = 'RENDERER'
}

export enum ContentRepresentation {
  AtlasDocFormat = 'ATLAS_DOC_FORMAT',
  Editor = 'EDITOR',
  Editor2 = 'EDITOR2',
  ExportView = 'EXPORT_VIEW',
  Plain = 'PLAIN',
  Raw = 'RAW',
  Storage = 'STORAGE',
  StyledView = 'STYLED_VIEW',
  View = 'VIEW',
  Wiki = 'WIKI'
}

export enum ContentRepresentationV2 {
  AtlasDocFormat = 'atlas_doc_format',
  Editor = 'editor',
  Editor2 = 'editor2',
  ExportView = 'export_view',
  Plain = 'plain',
  Raw = 'raw',
  Storage = 'storage',
  StyledView = 'styled_view',
  View = 'view',
  Wiki = 'wiki'
}

export enum ContentRole {
  Default = 'DEFAULT',
  Editor = 'EDITOR',
  Viewer = 'VIEWER'
}

export type ContentSpecificCreateInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ContentStateInput = {
  color?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Long']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
};

export enum ContentStateRestrictionLevel {
  None = 'NONE',
  PageOwner = 'PAGE_OWNER'
}

export type ContentTemplateBodyInput = {
  atlasDocFormat: ContentBodyInput;
};

export type ContentTemplateLabelInput = {
  id: Scalars['ID']['input'];
  label?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  prefix?: InputMaybe<Scalars['String']['input']>;
};

export type ContentTemplateSpaceInput = {
  key: Scalars['String']['input'];
};

export type ContentVersionHistoryFilter = {
  contentType: Scalars['String']['input'];
};

export enum Context {
  Compass = 'COMPASS',
  Confluence = 'CONFLUENCE',
  Jira = 'JIRA'
}

export type ConvertPageToLiveEditActionInput = {
  contentId: Scalars['ID']['input'];
};

/** The available action states sourced from ActionInvocationStatus. */
export enum ConvoAiActionStatus {
  Cancelled = 'CANCELLED',
  Errored = 'ERRORED',
  Finished = 'FINISHED',
  Planned = 'PLANNED',
  Started = 'STARTED'
}

/** Predefined templates for error messages sent during agent session execution. */
export enum ConvoAiErrorMessageTemplate {
  AcceptableUseViolations = 'ACCEPTABLE_USE_VIOLATIONS',
  Error = 'ERROR'
}

export enum ConvoAiHomeThreadSuggestedActionOriginType {
  CommentRule = 'COMMENT_RULE',
  ConfluenceInlineTasksRule = 'CONFLUENCE_INLINE_TASKS_RULE',
  ConfluencePageRule = 'CONFLUENCE_PAGE_RULE',
  ConfluenceTaggedPageRule = 'CONFLUENCE_TAGGED_PAGE_RULE',
  ConfluenceUpdatedPageRule = 'CONFLUENCE_UPDATED_PAGE_RULE',
  JiraIssueRule = 'JIRA_ISSUE_RULE',
  Llm = 'LLM',
  LoomVideoRule = 'LOOM_VIDEO_RULE',
  PullRequestRule = 'PULL_REQUEST_RULE'
}

export enum ConvoAiHomeThreadSuggestedActionType {
  Delete = 'DELETE',
  JumpBackIn = 'JUMP_BACK_IN',
  Reply = 'REPLY',
  Share = 'SHARE',
  TakeAction = 'TAKE_ACTION',
  View = 'VIEW'
}

export type ConvoAiHomeThreadsInput = {
  /** promptOverride -> Optional prompt to override the default prompt for generating threads */
  promptOverride?: InputMaybe<Scalars['String']['input']>;
  /** userId -> ID of the user to get threads for */
  userId: Scalars['ID']['input'];
};

export type ConvoAiJiraSearchSourcesInput = {
  /** Represents confluence site to perform search on. */
  confluenceSiteAri: Scalars['ID']['input'];
};

export type ConvoAiJiraSimilarWorkItemsInput = {
  /** description -> The description of the work item being searched for */
  description?: InputMaybe<Scalars['String']['input']>;
  /** excludeWorkItemIds -> A list of work items ids to exclude from results */
  excludeWorkItemIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** projectId -> The project id for the work item being searched for */
  projectId: Scalars['String']['input'];
  /** similarityConfig -> A group of optional parameters to configure the similarity model */
  similarityConfig?: InputMaybe<ConvoAiJiraSimilarWorkItemsSimilarityConfig>;
  /** summary -> The summary/title of the work item being searched for */
  summary: Scalars['String']['input'];
  /** workItemId -> The id of the work item being searched for */
  workItemId?: InputMaybe<Scalars['String']['input']>;
};

export type ConvoAiJiraSimilarWorkItemsSimilarityConfig = {
  /** minimumSimScore -> Optional override for the minimum similarity of the suggestions to return. The default is 0.5. */
  minimumSimScore?: InputMaybe<Scalars['Float']['input']>;
};

/** Author role type for a given message */
export enum ConvoAiMessageAuthorRole {
  /** Legacy author role */
  Agent = 'AGENT',
  Assistant = 'ASSISTANT',
  Human = 'HUMAN'
}

export type CopyPolarisInsightsContainerInput = {
  /** The container ARI which contains insights */
  container?: InputMaybe<Scalars['ID']['input']>;
  /** The project ARI which contains container */
  project: Scalars['ID']['input'];
};

export type CopyPolarisInsightsInput = {
  /** Destination container to copy insgihts */
  destination: CopyPolarisInsightsContainerInput;
  /** Insight ARI's list that should be copied. Leave it empty to copy all insights from source to destination */
  insights?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Source container to copy insgihts */
  source: CopyPolarisInsightsContainerInput;
};

/** Input for a single contribution entry. */
export type CplsAddContributionInput = {
  contributorDataId: Scalars['ID']['input'];
  endDate: Scalars['Date']['input'];
  startDate: Scalars['Date']['input'];
  value: Scalars['Float']['input'];
  valueType: CplsContributionValueType;
  workId: Scalars['ID']['input'];
};

/** Input for adding one or more contributions in bulk. */
export type CplsAddContributionsInput = {
  cloudId: Scalars['ID']['input'];
  contributions: Array<CplsAddContributionInput>;
  scopeId: Scalars['ID']['input'];
};

/** Input for adding one or more contributor associations in bulk. */
export type CplsAddContributorScopeAssociationInput = {
  cloudId: Scalars['ID']['input'];
  contributorDataIds: Array<Scalars['ID']['input']>;
  scopeId: Scalars['ID']['input'];
};

/** Input for adding one or more contributor work associations in bulk. */
export type CplsAddContributorWorkAssociationInput = {
  cloudId: Scalars['ID']['input'];
  contributorWorkAssociations: Array<CplsContributorWorkAssociation>;
};

/**
 * Input for adding one or more work associations to a scope in bulk.
 * workDataIds is validated to be of size between 1 and 100.
 */
export type CplsAddWorkScopeAssociationsInput = {
  cloudId: Scalars['ID']['input'];
  scopeId: Scalars['ID']['input'];
  workDataIds: Array<Scalars['ID']['input']>;
};

export enum CplsContributionValueType {
  Days = 'DAYS',
  Hours = 'HOURS',
  Percentage = 'PERCENTAGE'
}

/** A single contributor work association entry. */
export type CplsContributorWorkAssociation = {
  contributorDataId: Scalars['ID']['input'];
  workId: Scalars['ID']['input'];
};

/** Input for creating a custom contribution target. */
export type CplsCreateCustomContributionTargetInput = {
  cloudId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

/** Input for creating a custom contribution target with work association. */
export type CplsCreateCustomContributionTargetWithWorkAssociationInput = {
  cloudId: Scalars['ID']['input'];
  contributorDataId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

/** Input for deleting one or more contributor associations in bulk. */
export type CplsDeleteContributorScopeAssociationInput = {
  cloudId: Scalars['ID']['input'];
  contributorDataIds: Array<Scalars['ID']['input']>;
  scopeId: Scalars['ID']['input'];
};

/** Input for deleting one or more contributor work associations in bulk. */
export type CplsDeleteContributorWorkAssociationInput = {
  cloudId: Scalars['ID']['input'];
  contributorWorkAssociations: Array<CplsContributorWorkAssociation>;
};

/**
 * Input for deleting one or more work associations from a scope in bulk.
 * workDataIds is validated to be of size between 1 and 100.
 */
export type CplsDeleteWorkScopeAssociationsInput = {
  cloudId: Scalars['ID']['input'];
  scopeId: Scalars['ID']['input'];
  workDataIds: Array<Scalars['ID']['input']>;
};

export type CplsFiltersInput = {
  contributorDataIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  customContributionTargets?: InputMaybe<Array<Scalars['ID']['input']>>;
  jiraWorkItemStatusNames?: InputMaybe<Array<Scalars['String']['input']>>;
  jiraWorkItems?: InputMaybe<Array<Scalars['ID']['input']>>;
  workTypes?: InputMaybe<Array<CplsWorkType>>;
};

/**
 * Bulk import for coordinated creation of contributors, work assignments, and capacity data.
 * This mutation combines multiple bulk operations that would otherwise require separate calls.
 */
export type CplsImportCapacityDataInput = {
  /** Cloud ID for tenant context - required once at root level for all operations. */
  cloudId: Scalars['ID']['input'];
  /** Bulk add contributions with capacity data. */
  contributions?: InputMaybe<Array<CplsAddContributionInput>>;
  /** Bulk add contributors to a scope. */
  contributorDataIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Bulk add contributor-work associations. */
  contributorWorkAssociations?: InputMaybe<Array<CplsContributorWorkAssociation>>;
  /** Scope ID - used across all operations in this import. */
  scopeId: Scalars['ID']['input'];
};

/** Input for searching custom contribution targets. */
export type CplsSearchCustomContributionTargetsInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  cloudId: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};

export enum CplsTimeScaleType {
  Weekly = 'WEEKLY'
}

/** Input for updating a custom contribution target. */
export type CplsUpdateCustomContributionTargetInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

export type CplsUpdateFiltersInput = {
  filters: CplsFiltersInput;
  scopeId: Scalars['ID']['input'];
};

/** Input for updating the view settings via cpls_updateViewSettings. */
export type CplsUpdateViewSettingsInput = {
  scopeId: Scalars['ID']['input'];
  viewSettings: CplsViewSettingsInput;
};

/** Input for representing the ViewSettings in CplsUpdateViewSettingsInput */
export type CplsViewSettingsInput = {
  alwaysShowNumbersInGraph?: InputMaybe<Scalars['Boolean']['input']>;
  contributionValueType?: InputMaybe<CplsContributionValueType>;
  timeScale?: InputMaybe<CplsTimeScaleType>;
};

export enum CplsWorkType {
  CustomContributionTarget = 'CUSTOM_CONTRIBUTION_TARGET',
  JiraWorkItem = 'JIRA_WORK_ITEM'
}

export type CreateAppCustomScopesInput = {
  appId: Scalars['ID']['input'];
  environmentId: Scalars['ID']['input'];
  scopes: Array<AppCustomScopeSpec>;
};

export type CreateAppDeploymentInput = {
  appId: Scalars['ID']['input'];
  artifactUrl?: InputMaybe<Scalars['URL']['input']>;
  buildTag?: InputMaybe<Scalars['String']['input']>;
  environmentKey: Scalars['String']['input'];
  hostedResourceUploadId?: InputMaybe<Scalars['ID']['input']>;
  majorVersion?: InputMaybe<Scalars['Int']['input']>;
};

export type CreateAppDeploymentUrlInput = {
  appId: Scalars['ID']['input'];
  buildTag?: InputMaybe<Scalars['String']['input']>;
};

export type CreateAppEnvironmentInput = {
  appAri: Scalars['String']['input'];
  environmentKey: Scalars['String']['input'];
  environmentType: AppEnvironmentType;
};

export type CreateAppInput = {
  appFeatures?: InputMaybe<AppFeaturesInput>;
  billingConsent?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  developerSpaceId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
};

/**
 * Establish tunnels for a specific environment of an app.
 *
 * This will redirect all function calls to the provided faas url. This URL must implement the same
 * invocation contract that is used elsewhere in Xen.
 *
 * This will also be used to redirect Custom UI product rendering to the custom ui urls. We separate
 * them by extension key.
 */
export type CreateAppTunnelsInput = {
  /** The app to setup a tunnel for */
  appId: Scalars['ID']['input'];
  /** The environment key */
  environmentKey: Scalars['String']['input'];
  /** The tunnel definitions */
  tunnelDefinitions: TunnelDefinitionsInput;
};

/** Input payload to create an app version rollout */
export type CreateAppVersionRolloutInput = {
  sourceVersionId: Scalars['ID']['input'];
  targetVersionId: Scalars['ID']['input'];
};

/**
 * ## Mutations
 * ## Column Mutations ###
 */
export type CreateColumnInput = {
  boardId: Scalars['ID']['input'];
  columnName: Scalars['String']['input'];
};

export type CreateCommentInput = {
  commentBody: CommentBody;
  commentSource?: InputMaybe<Platform>;
  containerId: Scalars['ID']['input'];
  parentCommentId?: InputMaybe<Scalars['ID']['input']>;
};

/** The user-provided input to eventually get an answer to a given question */
export type CreateCompassAssistantAnswerInput = {
  /** User-provided prompt with the question to be answered */
  question: Scalars['String']['input'];
};

/** Accepts input to create an external alias of a component. */
export type CreateCompassComponentExternalAliasInput = {
  /** The ID of the component to which you add the alias. */
  componentId: Scalars['ID']['input'];
  /** An alias of the component identifier in external sources. */
  externalAlias: CompassExternalAliasInput;
};

/** Accepts input for creating a new component. */
export type CreateCompassComponentInput = {
  /** A collection of custom fields for storing data about the component. */
  customFields?: InputMaybe<Array<CompassCustomFieldInput>>;
  /** The description of the component. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** A collection of fields for storing data about the component. */
  fields?: InputMaybe<Array<CreateCompassFieldInput>>;
  /** A list of labels to add to the component */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A list of links to associate with the component */
  links?: InputMaybe<Array<CreateCompassLinkInput>>;
  /** The name of the component. */
  name: Scalars['String']['input'];
  /** The unique identifier (ID) of the team that owns the component. */
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the component. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** The state of the component. */
  state?: InputMaybe<Scalars['String']['input']>;
  /** The type of the component. */
  typeId?: InputMaybe<Scalars['ID']['input']>;
};

/** Accepts input to add links for a component. */
export type CreateCompassComponentLinkInput = {
  /** The ID of the component to add the link. */
  componentId: Scalars['ID']['input'];
  /** The link to be added for the component. */
  link: CreateCompassLinkInput;
};

export type CreateCompassComponentTypeInput = {
  /** The description of the component type. */
  description: Scalars['String']['input'];
  /** The icon key of the component type. */
  iconKey: Scalars['String']['input'];
  /** The name of the component type. */
  name: Scalars['String']['input'];
};

/** Accepts input to create a field. */
export type CreateCompassFieldInput = {
  /** The ID of the field definition. */
  definition: Scalars['ID']['input'];
  /** The value of the field. */
  value: CompassFieldValueInput;
};

/** Accepts input to a create a scorecard criterion representing the presence of a description. */
export type CreateCompassHasDescriptionScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts input to create a scorecard criterion representing the presence of a field, for example, 'Has Tier'. */
export type CreateCompassHasFieldScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID for the field definition that is the target of a relationship. */
  fieldDefinitionId: Scalars['ID']['input'];
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts input to create a scorecard criterion representing the presence of a link, for example, 'Has Repository' or 'Has Documentation'. */
export type CreateCompassHasLinkScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The type of link, for example, 'Repository' if 'Has Repository'. */
  linkType: CompassLinkType;
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The comparison operation to be performed. */
  textComparator?: InputMaybe<CompassCriteriaTextComparatorOptions>;
  /** The value that the field is compared to. */
  textComparatorValue?: InputMaybe<Scalars['String']['input']>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts input to create a scorecard criterion checking the value of a specified metric ID. */
export type CreateCompassHasMetricValueCriteriaInput = {
  /** Automatically create metric sources for the custom metric definition associated with this criterion */
  automaticallyCreateMetricSources?: InputMaybe<Scalars['Boolean']['input']>;
  /** The comparison operation to be performed between the metric and comparator value. */
  comparator: CompassCriteriaNumberComparatorOptions;
  /** The threshold value that the metric is compared to. */
  comparatorValue?: InputMaybe<Scalars['Float']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** A graduated series of comparators to score the criterion against */
  graduatedSeriesComparators?: InputMaybe<Array<CompassCriteriaGraduatedSeriesInput>>;
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The ID of the component metric to check the value of. */
  metricDefinitionId: Scalars['ID']['input'];
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts input to a create a scorecard criterion representing the presence of an owner. */
export type CreateCompassHasOwnerScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassCreateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int']['input'];
};

/** Accepts details of the link to add to a component. */
export type CreateCompassLinkInput = {
  /** The name of the link. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The unique ID of the object the link points to. Generally, this is configured by integrations and does not need to be added to links manually. Eg the Repository ID for a Repository */
  objectId?: InputMaybe<Scalars['ID']['input']>;
  /** The type of the link. */
  type: CompassLinkType;
  /** The URL of the link. */
  url: Scalars['URL']['input'];
};

/** Accepts input for creating a new relationship. */
export type CreateCompassRelationshipInput = {
  /** The unique identifier (ID) of the component at the ending node. */
  endNodeId: Scalars['ID']['input'];
  /** The type of relationship. eg DEPENDS_ON or CHILD_OF */
  relationshipType?: CompassRelationshipTypeInput;
  /** The unique identifier (ID) of the component at the starting node. */
  startNodeId: Scalars['ID']['input'];
};

/** Accepts input to create a scorecard criterion. */
export type CreateCompassScorecardCriteriaInput = {
  dynamic?: InputMaybe<CompassCreateDynamicScorecardCriteriaInput>;
  hasCustomBooleanValue?: InputMaybe<CompassCreateHasCustomBooleanFieldScorecardCriteriaInput>;
  hasCustomMultiSelectValue?: InputMaybe<CompassCreateHasCustomMultiSelectFieldScorecardCriteriaInput>;
  hasCustomNumberValue?: InputMaybe<CompassCreateHasCustomNumberFieldScorecardCriteriaInput>;
  hasCustomSingleSelectValue?: InputMaybe<CompassCreateHasCustomSingleSelectFieldScorecardCriteriaInput>;
  hasCustomTextValue?: InputMaybe<CompassCreateHasCustomTextFieldScorecardCriteriaInput>;
  hasDescription?: InputMaybe<CreateCompassHasDescriptionScorecardCriteriaInput>;
  hasField?: InputMaybe<CreateCompassHasFieldScorecardCriteriaInput>;
  hasLink?: InputMaybe<CreateCompassHasLinkScorecardCriteriaInput>;
  hasMetricValue?: InputMaybe<CreateCompassHasMetricValueCriteriaInput>;
  hasOwner?: InputMaybe<CreateCompassHasOwnerScorecardCriteriaInput>;
  hasPackageDependency?: InputMaybe<CompassCreateHasPackageDependencyScorecardCriteriaInput>;
};

export type CreateCompassScorecardInput = {
  componentCreationTimeFilter?: InputMaybe<CompassComponentCreationTimeFilterInput>;
  componentCustomFieldFilters?: InputMaybe<Array<CompassCustomFieldFilterInput>>;
  componentLabelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  componentLifecycleStages?: InputMaybe<CompassLifecycleFilterInput>;
  componentOwnerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  componentTierValues?: InputMaybe<Array<Scalars['String']['input']>>;
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  criterias?: InputMaybe<Array<CreateCompassScorecardCriteriaInput>>;
  description?: InputMaybe<Scalars['String']['input']>;
  importance: CompassScorecardImportance;
  isDeactivationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  libraryScorecardId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  repositoryValues?: InputMaybe<CompassRepositoryValueInput>;
  scoreSystemType?: InputMaybe<CompassScorecardScoreSystemType>;
  scoringStrategyType?: InputMaybe<CompassScorecardScoringStrategyType>;
  state?: InputMaybe<Scalars['String']['input']>;
  statusConfig?: InputMaybe<CompassScorecardStatusConfigInput>;
};

/** Accepts input for creating a starred component. */
export type CreateCompassStarredComponentInput = {
  /** The ID of the component to be starred. */
  componentId: Scalars['ID']['input'];
};

export type CreateComponentApiUploadInput = {
  componentId: Scalars['ID']['input'];
};

export type CreateContentInput = {
  contentSpecificCreateInput?: InputMaybe<Array<ContentSpecificCreateInput>>;
  parentId?: InputMaybe<Scalars['ID']['input']>;
  spaceId?: InputMaybe<Scalars['String']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
  status: GraphQlContentStatus;
  subType?: InputMaybe<ConfluencePageSubType>;
  title?: InputMaybe<Scalars['String']['input']>;
  type: Scalars['String']['input'];
};

export type CreateContentMentionNotificationActionInput = {
  contentId: Scalars['ID']['input'];
  mentions: Array<InputMaybe<ContentMention>>;
};

export type CreateContentTemplateInput = {
  body: ContentTemplateBodyInput;
  description?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<InputMaybe<ContentTemplateLabelInput>>>;
  name: Scalars['String']['input'];
  space?: InputMaybe<ContentTemplateSpaceInput>;
  templateType: GraphQlContentTemplateType;
};

export type CreateContentTemplateLabelsInput = {
  contentTemplateId: Scalars['ID']['input'];
  labels: Array<InputMaybe<ContentTemplateLabelInput>>;
};

/** CustomFilters Mutation */
export type CreateCustomFilterInput = {
  boardId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  jql: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

/** The request input for creating a relationship between a DevOps Service and an Jira Project. */
export type CreateDevOpsServiceAndJiraProjectRelationshipInput = {
  /** The ID of the site of the service and the Jira project. */
  cloudId: Scalars['ID']['input'];
  /** An optional description of the relationship. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The Jira project ARI */
  jiraProjectId: Scalars['ID']['input'];
  /** Optional properties of the relationship. */
  properties?: InputMaybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
  /** The type of the relationship. */
  relationshipType: DevOpsServiceAndJiraProjectRelationshipType;
  /** The ARI of the DevOps Service. */
  serviceId: Scalars['ID']['input'];
};

/** The request input for creating a relationship between a DevOps Service and an Opsgenie Team */
export type CreateDevOpsServiceAndOpsgenieTeamRelationshipInput = {
  /**
   * We can't infer this from the service ARI since the container association registry doesn't own the service ARI -
   * therefore we have to treat it as opaque.
   */
  cloudId: Scalars['ID']['input'];
  /** An optional description of the relationship. */
  description?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ARI of the Opsgenie Team
   *
   * The Opsgenie team must exist on the same site as the service. If it doesn't, the create will fail
   * with a OPSGENIE_TEAM_ID_INVALID error.
   */
  opsgenieTeamId: Scalars['ID']['input'];
  /** Optional properties of the relationship. */
  properties?: InputMaybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
  /** The ARI of the DevOps Service. */
  serviceId: Scalars['ID']['input'];
};

/** The request input for creating a relationship between a DevOps Service and a Repository */
export type CreateDevOpsServiceAndRepositoryRelationshipInput = {
  /** The Bitbucket Repository ARI */
  bitbucketRepositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** An optional description of the relationship. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Optional properties of the relationship. */
  properties?: InputMaybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
  /** The ARI of the DevOps Service. */
  serviceId: Scalars['ID']['input'];
  /** The Third Party Repository. It should be null when repositoryId is a Bitbucket Repository ARI */
  thirdPartyRepository?: InputMaybe<ThirdPartyRepositoryInput>;
};

/** The request input for creating a new DevOps Service */
export type CreateDevOpsServiceInput = {
  cloudId: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  properties?: InputMaybe<Array<DevOpsServiceEntityPropertyInput>>;
  /** Tier assigned to the DevOps Service */
  serviceTier: DevOpsServiceTierInput;
  /** Service Type asigned to the DevOps Service */
  serviceType?: InputMaybe<DevOpsServiceTypeInput>;
};

/** The request input for creating a new DevOps Service Relationship */
export type CreateDevOpsServiceRelationshipInput = {
  /** The description of the relationship */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The Service ARI of the end node of the relationship */
  endId: Scalars['ID']['input'];
  /** The properties of the relationship */
  properties?: InputMaybe<Array<DevOpsServiceEntityPropertyInput>>;
  /** The Service ARI of the start node of the relationship */
  startId: Scalars['ID']['input'];
  /** The inter-service relationship type */
  type: DevOpsServiceRelationshipType;
};

export type CreateEventSourceInput = {
  /** The cloud ID of the site to create an event source for. */
  cloudId: Scalars['ID']['input'];
  /** The type of the event that the event source can accept. */
  eventType: CompassEventType;
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
};

export type CreateFaviconFilesInput = {
  fileStoreId: Scalars['ID']['input'];
};

export type CreateHostedResourceUploadUrlInput = {
  appId: Scalars['ID']['input'];
  buildTag?: InputMaybe<Scalars['String']['input']>;
  environmentKey?: InputMaybe<Scalars['String']['input']>;
  resourceKeys: Array<Scalars['String']['input']>;
};

export type CreateInlineCommentInput = {
  commentBody: CommentBody;
  commentSource?: InputMaybe<Platform>;
  containerId: Scalars['ID']['input'];
  createdFrom: CommentCreationLocation;
  lastFetchTimeMillis: Scalars['Long']['input'];
  /** matchIndex must be greater than or equal to 0. */
  matchIndex: Scalars['Int']['input'];
  /** numMatches must be positive and greater than matchIndex. */
  numMatches: Scalars['Int']['input'];
  originalSelection: Scalars['String']['input'];
  parentCommentId?: InputMaybe<Scalars['ID']['input']>;
  publishedVersion?: InputMaybe<Scalars['Int']['input']>;
  step?: InputMaybe<Step>;
};

export type CreateInlineContentInput = {
  contentSpecificCreateInput?: InputMaybe<Array<ContentSpecificCreateInput>>;
  createdInContentId: Scalars['ID']['input'];
  spaceId?: InputMaybe<Scalars['String']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  type: Scalars['String']['input'];
};

export type CreateInlineTaskNotificationInput = {
  contentId: Scalars['ID']['input'];
  tasks: Array<InputMaybe<IndividualInlineTaskNotificationInput>>;
};

/** Create: Mutation (POST) */
export type CreateJiraPlaybookInput = {
  cloudId: Scalars['ID']['input'];
  filters?: InputMaybe<Array<JiraPlaybookIssueFilterInput>>;
  jql?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** scopeId is projectId */
  scopeId?: InputMaybe<Scalars['String']['input']>;
  scopeType: JiraPlaybookScopeType;
  state?: InputMaybe<JiraPlaybookStateField>;
  steps: Array<CreateJiraPlaybookStepInput>;
  templateId?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for Create PlaybookLabel: Mutation (POST) */
export type CreateJiraPlaybookLabelInput = {
  cloudId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  playbookId?: InputMaybe<Scalars['ID']['input']>;
  property?: InputMaybe<JiraPlaybookLabelPropertyInput>;
  /** scopeId is projectId */
  scopeId?: InputMaybe<Scalars['String']['input']>;
  scopeType: JiraPlaybookScopeType;
};

/** Create: Mutation (POST) */
export type CreateJiraPlaybookStepInput = {
  automationTemplateId?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  ruleId?: InputMaybe<Scalars['String']['input']>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
  type: JiraPlaybookStepType;
};

export type CreateJiraPlaybookStepRunInput = {
  playbookInstanceStepAri: Scalars['ID']['input'];
  targetTransition?: InputMaybe<TargetTransition>;
  userInputs?: InputMaybe<Array<UserInput>>;
};

export type CreateLivePageInput = {
  parentId?: InputMaybe<Scalars['ID']['input']>;
  spaceKey: Scalars['String']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
};

export type CreateMentionNotificationInput = {
  contentId: Scalars['ID']['input'];
  mentionLocalId?: InputMaybe<Scalars['ID']['input']>;
  mentionedUserAccountId: Scalars['ID']['input'];
};

export type CreateMentionReminderNotificationInput = {
  contentId: Scalars['ID']['input'];
  mentionData: Array<MentionData>;
};

export type CreateMetadataInput = {
  extraProps?: InputMaybe<Array<PropInput>>;
  isPinned?: InputMaybe<Scalars['Boolean']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  productLink?: InputMaybe<Scalars['String']['input']>;
};

export type CreateNoteInput = {
  backgroundColor?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<CreateMetadataInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type CreatePersonalSpaceInput = {
  /** Fetches the Space Permissions from the given space key and copies them to the new space. If this field is set, it must be accompanied with field initialPermissionOption: COPY_FROM_SPACE. */
  copySpacePermissionsFromSpaceKey?: InputMaybe<Scalars['String']['input']>;
  /** if this enum is set to PRIVATE, it will take precedence over copySpacePermissionsFromSpaceKey. */
  initialPermissionOption?: InputMaybe<InitialPermissionOptions>;
  spaceContents?: InputMaybe<Array<InputMaybe<ConfluenceCreateSpaceContent>>>;
  spaceName: Scalars['String']['input'];
};

export type CreatePolarisCommentInput = {
  content?: InputMaybe<Scalars['JSON']['input']>;
  kind?: InputMaybe<PolarisCommentKind>;
  subject?: InputMaybe<Scalars['ID']['input']>;
};

export type CreatePolarisIdeaTemplateInput = {
  color?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  emoji?: InputMaybe<Scalars['String']['input']>;
  project: Scalars['ID']['input'];
  /**
   * Template in ADF format.  See
   * https://developer.atlassian.com/platform/atlassian-document-format/
   */
  template?: InputMaybe<Scalars['JSON']['input']>;
  title: Scalars['String']['input'];
};

export type CreatePolarisInsightInput = {
  /** The cloudID in which we are adding insight */
  cloudID: Scalars['String']['input'];
  /**
   * DEPRECATED, DO NOT USE
   * Array of datas in JSON format. It will be validated with JSON schema of Polaris Insights Data format.
   */
  data?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Description in ADF format https://developer.atlassian.com/platform/atlassian-document-format/ */
  description?: InputMaybe<Scalars['JSON']['input']>;
  /** The issueID in which we are adding insight, cloud be empty for adding insight on project level */
  issueID?: InputMaybe<Scalars['Int']['input']>;
  /** The projectID in which we are adding insight */
  projectID: Scalars['Int']['input'];
  /** Array of snippets */
  snippets?: InputMaybe<Array<CreatePolarisSnippetInput>>;
};

/**  --------------------------------------------------------------------------------------------- */
export type CreatePolarisPlayContribution = {
  /**  the issue (idea) to which this contribution is being made */
  amount?: InputMaybe<Scalars['Int']['input']>;
  /**  the extent of the contribution (null=drop value) */
  comment?: InputMaybe<Scalars['JSON']['input']>;
  play: Scalars['ID']['input'];
  /**  the play being contributed to */
  subject: Scalars['ID']['input'];
};

export type CreatePolarisPlayInput = {
  /**  the view from which the play is created */
  description?: InputMaybe<Scalars['JSON']['input']>;
  fromView?: InputMaybe<Scalars['ID']['input']>;
  kind: PolarisPlayKind;
  label: Scalars['String']['input'];
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  project: Scalars['ID']['input'];
  /**  the label for the play field, and the "short" name of the play */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** # Types */
export type CreatePolarisProjectInput = {
  key: Scalars['String']['input'];
  name: Scalars['String']['input'];
  tenant: Scalars['ID']['input'];
};

export type CreatePolarisSnippetInput = {
  /** Data in JSON format. It will be validated with JSON schema of Polaris Insights Data format. */
  data?: InputMaybe<Scalars['JSON']['input']>;
  /** OauthClientId of CaaS app */
  oauthClientId: Scalars['String']['input'];
  /**
   * DEPRECATED, DO NOT USE
   * Snippet-level properties in JSON format.
   */
  properties?: InputMaybe<Scalars['JSON']['input']>;
  /** Snippet url that is source of data */
  url?: InputMaybe<Scalars['String']['input']>;
};

export type CreatePolarisViewInput = {
  container: Scalars['ID']['input'];
  /**  the type of viz to create */
  copyView?: InputMaybe<Scalars['ID']['input']>;
  /**  view to copy configuration from */
  update?: InputMaybe<UpdatePolarisViewInput>;
  visualizationType?: InputMaybe<PolarisVisualizationType>;
};

export type CreatePolarisViewSetInput = {
  container: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

/**  Types */
export type CreateRankingListInput = {
  items?: InputMaybe<Array<Scalars['String']['input']>>;
  listId: Scalars['ID']['input'];
};

export type CreateSpaceAdditionalSettingsInput = {
  jiraProject?: InputMaybe<CreateSpaceJiraProjectInput>;
  spaceTypeSettings?: InputMaybe<SpaceTypeSettingsInput>;
};

export type CreateSpaceInput = {
  additionalSettings?: InputMaybe<CreateSpaceAdditionalSettingsInput>;
  /** if this field is set, it must be accompanied with field initialPermissionOption: COPY_FROM_SPACE. */
  copySpacePermissionsFromSpaceKey?: InputMaybe<Scalars['String']['input']>;
  createSpaceContent?: InputMaybe<Array<InputMaybe<ConfluenceCreateSpaceContent>>>;
  /** if this enum is set to PRIVATE, it will take precedence over copySpacePermissionsFromSpaceKey. */
  initialPermissionOption?: InputMaybe<InitialPermissionOptions>;
  spaceKey: Scalars['String']['input'];
  spaceLogoDataURI?: InputMaybe<Scalars['String']['input']>;
  spaceName: Scalars['String']['input'];
  spaceTemplateKey?: InputMaybe<Scalars['String']['input']>;
};

export type CreateSpaceJiraProjectInput = {
  jiraProjectKey: Scalars['String']['input'];
  jiraProjectName?: InputMaybe<Scalars['String']['input']>;
  jiraServerId: Scalars['String']['input'];
};

/** Create sprint */
export type CreateSprintInput = {
  boardId: Scalars['ID']['input'];
};

export enum CriterionExemptionType {
  /** Exemption for a specific component */
  Exemption = 'EXEMPTION',
  /** Exemption for all components */
  Global = 'GLOBAL'
}

/** Enum representing action types */
export enum CsmAiActionType {
  Mutator = 'MUTATOR',
  Retriever = 'RETRIEVER'
}

/** Enum representing variable data types */
export enum CsmAiActionVariableDataType {
  Boolean = 'BOOLEAN',
  Integer = 'INTEGER',
  Number = 'NUMBER',
  String = 'STRING'
}

/** Input for action variables */
export type CsmAiActionVariableInput = {
  /** The data type of the variable */
  dataType: CsmAiActionVariableDataType;
  /** The default value for the variable */
  defaultValue?: InputMaybe<Scalars['String']['input']>;
  /** A description of the variable */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether the variable is required */
  isRequired: Scalars['Boolean']['input'];
  /** The name of the variable */
  name: Scalars['String']['input'];
};

/** Input for adding knowledge source to knowledge collection */
export type CsmAiAddKnowledgeSourceInput = {
  /** Filters of a knowledge source */
  csmAiKnowledgeFilter?: InputMaybe<CsmAiKnowledgeFilterInput>;
  /** Should the source be used in answering */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Type of the knowledge source */
  type: Scalars['String']['input'];
};

export type CsmAiAgentToneInput = {
  /** The prompt that defines the tone. Used for CUSTOM types */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The type of tone. E.g. FRIENDLY, PROFESSIONAL, CUSTOM etc. */
  type: Scalars['String']['input'];
};

/** Input for API operation details */
export type CsmAiApiOperationInput = {
  /** Headers to include in the request (optional) */
  headers?: InputMaybe<Array<InputMaybe<CsmAiKeyValueInput>>>;
  /** The HTTP method to use */
  method: CsmAiHttpMethod;
  /** Query parameters to include in the request (optional) */
  queryParameters?: InputMaybe<Array<InputMaybe<CsmAiKeyValueInput>>>;
  /** The request body (optional) */
  requestBody?: InputMaybe<Scalars['String']['input']>;
  /** The URL path to send the request to */
  requestUrl: Scalars['String']['input'];
  /** The server to send the request to */
  server: Scalars['String']['input'];
};

/** Input for authentication details */
export type CsmAiAuthenticationInput = {
  /** The type of authentication */
  type: CsmAiAuthenticationType;
};

/** Enum representing authentication types */
export enum CsmAiAuthenticationType {
  EndUserAuth = 'END_USER_AUTH',
  NoAuth = 'NO_AUTH'
}

/** Input for agent coaching actual contents */
export type CsmAiAuthoredCoachingContentInput = {
  /** coaching trigger behavior entered by support engineer */
  triggerBehaviorByCoach?: InputMaybe<Scalars['String']['input']>;
  /** coaching trigger condition entered by support engineer */
  triggerConditionByCoach?: InputMaybe<Scalars['String']['input']>;
};

/** Input for BYOD knowledge source filters */
export type CsmAiByodKnowledgeFilterInput = {
  byodSources?: InputMaybe<Array<CsmAiByodSourceInput>>;
};

/** Input for BYOD source details */
export type CsmAiByodSourceInput = {
  datasourceId: Scalars['String']['input'];
  integrationId: Scalars['String']['input'];
  workspaceName: Scalars['String']['input'];
  workspaceUrl: Scalars['String']['input'];
};

/** Input for Confluence knowledge source filters */
export type CsmAiConfluenceKnowledgeFilterInput = {
  parentFilter?: InputMaybe<Array<Scalars['ID']['input']>>;
  spaceFilter?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type CsmAiConnectorConfigurationInput = {
  messageHandoff?: InputMaybe<CsmAiMessageHandoffInput>;
  ticketingHandoff?: InputMaybe<CsmAiTicketingHandoffInput>;
};

/** Input for creating a new action */
export type CsmAiCreateActionInput = {
  /** The type of action (RETRIEVER or MUTATOR) */
  actionType: CsmAiActionType;
  /** Details of the API operation to execute */
  apiOperation: CsmAiApiOperationInput;
  /** Authentication details for the API request */
  authentication: CsmAiAuthenticationInput;
  /** A description of what the action does */
  description: Scalars['String']['input'];
  /** Whether confirmation is required before executing the action */
  isConfirmationRequired: Scalars['Boolean']['input'];
  /** Whether the action is enabled */
  isEnabled: Scalars['Boolean']['input'];
  /** The name of the action */
  name: Scalars['String']['input'];
  /** Variables required for the action */
  variables?: InputMaybe<Array<CsmAiActionVariableInput>>;
};

/** Input for creating a new agent coaching content */
export type CsmAiCreateCoachingContentInput = {
  /** The coaching contents that author provided */
  coachingContent: CsmAiAuthoredCoachingContentInput;
  /** The type of coaching content that author provided */
  coachingContentType?: InputMaybe<Scalars['String']['input']>;
  /** The id of the grounding conversation */
  groundingConversationId?: InputMaybe<Scalars['ID']['input']>;
  /** The id of the grounding message */
  groundingMessageId?: InputMaybe<Scalars['ID']['input']>;
  /** The name of the coaching content */
  name?: InputMaybe<Scalars['String']['input']>;
};

export enum CsmAiHandoffType {
  Csm = 'CSM',
  Message = 'MESSAGE'
}

export enum CsmAiHandoffTypeInput {
  Csm = 'CSM',
  Message = 'MESSAGE'
}

/** Enum representing HTTP methods */
export enum CsmAiHttpMethod {
  Delete = 'DELETE',
  Get = 'GET',
  Patch = 'PATCH',
  Post = 'POST',
  Put = 'PUT'
}

/** A key-value pair for input */
export type CsmAiKeyValueInput = {
  /** The key */
  key: Scalars['String']['input'];
  /** The value */
  value: Scalars['String']['input'];
};

/** Input for knowledge source filters */
export type CsmAiKnowledgeFilterInput = {
  /** Byod knowledge Filter */
  byodFilter?: InputMaybe<CsmAiByodKnowledgeFilterInput>;
  /** Page and space filters of a knowledge source */
  confluenceFilter?: InputMaybe<CsmAiConfluenceKnowledgeFilterInput>;
};

export type CsmAiMessageHandoffInput = {
  message: Scalars['String']['input'];
};

/** Authentication type for code snippets */
export enum CsmAiSnippetAuthType {
  /** Snippet for anonymous users (no authentication required) */
  Anonymous = 'ANONYMOUS',
  /** Snippet for authenticated users (authentication required) */
  Authenticated = 'AUTHENTICATED'
}

/** Supported programming languages for code snippets */
export enum CsmAiSnippetLanguage {
  Django = 'DJANGO',
  Go = 'GO',
  Java = 'JAVA',
  Node = 'NODE',
  Php = 'PHP',
  Rails = 'RAILS'
}

export type CsmAiTicketingHandoffInput = {
  formId: Scalars['ID']['input'];
};

/** Input for updating an existing action */
export type CsmAiUpdateActionInput = {
  /** The type of action (RETRIEVER or MUTATOR) */
  actionType?: InputMaybe<CsmAiActionType>;
  /** Details of the API operation to execute */
  apiOperation?: InputMaybe<CsmAiApiOperationInput>;
  /** Authentication details for the API request */
  authentication?: InputMaybe<CsmAiAuthenticationInput>;
  /** A description of what the action does */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether confirmation is required before executing the action */
  isConfirmationRequired?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the action is enabled */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the action */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Variables required for the action */
  variables?: InputMaybe<Array<InputMaybe<CsmAiActionVariableInput>>>;
};

export type CsmAiUpdateAgentConversationStarterInput = {
  /** The ID of the conversation starter */
  id: Scalars['ID']['input'];
  /** The message of the conversation starter */
  message?: InputMaybe<Scalars['String']['input']>;
};

export type CsmAiUpdateAgentInput = {
  /** Conversation starters to be added to the list */
  addedConversationStarters?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The description of the company */
  companyDescription?: InputMaybe<Scalars['String']['input']>;
  /** The name of the company */
  companyName?: InputMaybe<Scalars['String']['input']>;
  /** Conversation starters to be deleted from the list */
  deletedConversationStarters?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The initial greeting message for the agent */
  greetingMessage?: InputMaybe<Scalars['String']['input']>;
  /** The name of the agent */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The prompt that defines the agents tone */
  tone?: InputMaybe<CsmAiAgentToneInput>;
  /** Conversation starters to be updated */
  updatedConversationStarters?: InputMaybe<Array<CsmAiUpdateAgentConversationStarterInput>>;
};

/** Input for updating an existing coaching content */
export type CsmAiUpdateCoachingContentInput = {
  /** The coaching contents that author provided */
  coachingContent?: InputMaybe<CsmAiAuthoredCoachingContentInput>;
  /** The type of coaching content that author provided */
  coachingContentType?: InputMaybe<Scalars['String']['input']>;
  /** The embedding of the triggering condition */
  embedding?: InputMaybe<Scalars['String']['input']>;
  /** The id of the grounding conversation */
  groundingConversationId?: InputMaybe<Scalars['ID']['input']>;
  /** The id of the grounding message */
  groundingMessageId?: InputMaybe<Scalars['ID']['input']>;
  /** The name of the coaching content */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The ranking/priority of the coaching content */
  ranking?: InputMaybe<Scalars['String']['input']>;
  /** The status of the coaching content */
  status?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Agent Handoff Configuration */
export type CsmAiUpdateHandoffConfigInput = {
  connectorConfiguration: CsmAiConnectorConfigurationInput;
  enabled: Scalars['Boolean']['input'];
  type: CsmAiHandoffTypeInput;
};

/** Input for updating knowledge source in a knowledge collection */
export type CsmAiUpdateKnowledgeSourceInput = {
  /** Filters of a knowledge source */
  csmAiKnowledgeFilter?: InputMaybe<CsmAiKnowledgeFilterInput>;
  /** Should the source be used in answering */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Type of the knowledge source */
  type: Scalars['String']['input'];
};

/** Attribution for the widget branding */
export type CsmAiWidgetBrandingAttributionInput = {
  /** The text to display for attribution */
  text?: InputMaybe<Scalars['String']['input']>;
  /** The URL to link the attribution text to */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Chat Color vibe variant for the widget */
export enum CsmAiWidgetBrandingChatColorVibeVariant {
  Dark = 'DARK',
  Default = 'DEFAULT',
  Light = 'LIGHT',
  Vibrant = 'VIBRANT'
}

/** Color vibe variant for the widget */
export enum CsmAiWidgetBrandingColorVibeVariant {
  Dark = 'DARK',
  Light = 'LIGHT',
  Vibrant = 'VIBRANT'
}

/** Radius variant for the widget branding */
export enum CsmAiWidgetBrandingRadius {
  Normal = 'NORMAL',
  Rounded = 'ROUNDED',
  Sharp = 'SHARP'
}

/** Space variant for the widget branding */
export enum CsmAiWidgetBrandingSpaceVariant {
  Comfortable = 'COMFORTABLE',
  Cosy = 'COSY',
  Generous = 'GENEROUS'
}

/** Branding theme for the widget */
export type CsmAiWidgetBrandingThemeUpdateInput = {
  /** Attribution of the chat */
  attribution?: InputMaybe<CsmAiWidgetBrandingAttributionInput>;
  /** The chat color variant for the widget */
  chatColor: CsmAiWidgetBrandingChatColorVibeVariant;
  /** The secondary color for the widget */
  colorVibeVariant: CsmAiWidgetBrandingColorVibeVariant;
  /** The icon to display in the widget */
  icon?: InputMaybe<CsmAiWidgetIconUpdateInput>;
  /** The roundness of the widget corners */
  radius: CsmAiWidgetBrandingRadius;
  /** The spacing around the elements in the widget */
  space: CsmAiWidgetBrandingSpaceVariant;
};

/** Type of the widget icon */
export enum CsmAiWidgetIconType {
  Custom = 'CUSTOM',
  Default = 'DEFAULT',
  Inherited = 'INHERITED'
}

/** Icon for the widget */
export type CsmAiWidgetIconUpdateInput = {
  /** The type of the icon */
  type: CsmAiWidgetIconType;
  /** The URL of the icon image */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Position of the widget on the page */
export enum CsmAiWidgetPosition {
  Center = 'CENTER',
  Corner = 'CORNER'
}

/** Type of the widget */
export enum CsmAiWidgetType {
  Embed = 'EMBED',
  SupportSite = 'SUPPORT_SITE'
}

/** Configuration for the AI widget */
export type CsmAiWidgetUpdateInput = {
  /** Allowed domains for the widget */
  allowedDomains?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Description of the widget */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Can the widget be accessed by anonymous users */
  isAnonymousAccessEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is the widget enabled */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the widget */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Position of the widget on the page */
  position?: InputMaybe<CsmAiWidgetPosition>;
  /** The theme details for the widget */
  theme?: InputMaybe<CsmAiWidgetBrandingThemeUpdateInput>;
  /** The type of the widget */
  type?: InputMaybe<CsmAiWidgetType>;
};

export type CustomEntity = {
  attributes: Array<CustomEntityAttribute>;
  indexes?: InputMaybe<Array<CustomEntityIndex>>;
  name: Scalars['String']['input'];
};

export type CustomEntityAttribute = {
  name: Scalars['String']['input'];
  required?: InputMaybe<Scalars['Boolean']['input']>;
  type: CustomEntityAttributeType;
};

export enum CustomEntityAttributeType {
  Any = 'any',
  Boolean = 'boolean',
  Float = 'float',
  Integer = 'integer',
  String = 'string'
}

export type CustomEntityIndex = {
  name: Scalars['String']['input'];
  partition?: InputMaybe<Array<Scalars['String']['input']>>;
  range: Array<Scalars['String']['input']>;
};

export enum CustomEntityIndexStatus {
  Active = 'ACTIVE',
  Creating = 'CREATING',
  Inactive = 'INACTIVE',
  Pending = 'PENDING'
}

export type CustomEntityMutationInput = {
  entities: Array<CustomEntity>;
  oauthClientId: Scalars['String']['input'];
};

export enum CustomEntityStatus {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

export enum CustomMultiselectFieldInputComparators {
  ContainAll = 'CONTAIN_ALL',
  ContainAny = 'CONTAIN_ANY',
  ContainNone = 'CONTAIN_NONE',
  IsSet = 'IS_SET',
  NotSet = 'NOT_SET'
}

export enum CustomNumberFieldInputComparators {
  /** Filter components applied to a scorecard by value of the custom field */
  ContainAny = 'CONTAIN_ANY',
  IsSet = 'IS_SET',
  NotSet = 'NOT_SET'
}

export enum CustomSingleSelectFieldInputComparators {
  ContainAny = 'CONTAIN_ANY',
  ContainNone = 'CONTAIN_NONE',
  IsSet = 'IS_SET',
  NotSet = 'NOT_SET'
}

export enum CustomTextFieldInputComparators {
  /** Filter components applied to a scorecard by value of the custom field */
  ContainAny = 'CONTAIN_ANY',
  IsSet = 'IS_SET',
  NotSet = 'NOT_SET'
}

export type CustomUiTunnelDefinitionInput = {
  resourceKey?: InputMaybe<Scalars['String']['input']>;
  tunnelUrl?: InputMaybe<Scalars['URL']['input']>;
};

export enum CustomUserFieldInputComparators {
  ContainAny = 'CONTAIN_ANY',
  IsSet = 'IS_SET',
  NotSet = 'NOT_SET'
}

export type CustomerServiceAcceptEscalationInput = {
  /** Type of escalation */
  escalationType: CustomerServiceEscalationType;
  /** The Id of the linked (new or existing) Work Item (Jira Issue ID) */
  linkedWorkItemId: Scalars['ID']['input'];
  /** The type of the linked work item */
  linkedWorkItemType: CustomerServiceAcceptEscalationLinkedWorkItemType;
};

export enum CustomerServiceAcceptEscalationLinkedWorkItemType {
  ExistingWorkItem = 'EXISTING_WORK_ITEM',
  NewWorkItem = 'NEW_WORK_ITEM'
}

/** DEPRECATED: Use CustomerServiceCustomDetailConfigMetadataUpdateInput instead. */
export type CustomerServiceAttributeConfigMetadataUpdateInput = {
  /** Context configuration */
  contextConfigurations?: InputMaybe<Array<InputMaybe<CustomerServiceContextConfigurationInput>>>;
  /** ID of the custom attribute */
  id: Scalars['ID']['input'];
  /** position of the attribute */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** Styles configuration */
  styleConfiguration?: InputMaybe<CustomerServiceCustomAttributeStyleConfigurationInput>;
};

/** DEPRECATED: use CustomerServiceCustomDetailCreateInput instead. */
export type CustomerServiceAttributeCreateInput = {
  /** Context configuration */
  contextConfigurations?: InputMaybe<Array<InputMaybe<CustomerServiceContextConfigurationInput>>>;
  /** The name of the attribute to create */
  name: Scalars['String']['input'];
  /** The type of the attribute to create */
  type?: InputMaybe<CustomerServiceAttributeCreateTypeInput>;
};

/** DEPRECATED: use CustomerServiceCustomDetailCreateTypeInput instead. */
export type CustomerServiceAttributeCreateTypeInput = {
  /** The type of the attribute to be created */
  name?: InputMaybe<CustomerServiceAttributeTypeName>;
  /** Options for this type, only valid if the provided type is SELECT/MULTI-SELECT. Empty otherwise. */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** DEPRECATED: Use CustomerServiceCustomDetailDeleteInput instead. */
export type CustomerServiceAttributeDeleteInput = {
  /** ID of the custom attribute */
  id: Scalars['ID']['input'];
};

/**
 * The types of attributes that can exist
 * DEPRECATED: use CustomerServiceCustomDetailTypeName instead.
 * NOTE: Please do not modify enums without first notifying the FE team.
 */
export enum CustomerServiceAttributeTypeName {
  Boolean = 'BOOLEAN',
  Date = 'DATE',
  Email = 'EMAIL',
  Multiselect = 'MULTISELECT',
  Number = 'NUMBER',
  Phone = 'PHONE',
  Select = 'SELECT',
  Text = 'TEXT',
  Url = 'URL',
  User = 'USER'
}

/** DEPRECATED: use CustomerServiceCustomDetailUpdateInput instead. */
export type CustomerServiceAttributeUpdateInput = {
  /** ID of the custom attribute */
  id: Scalars['ID']['input'];
  /** The updated name for the attribute to update */
  name: Scalars['String']['input'];
  /** The type of the attribute to update */
  type?: InputMaybe<CustomerServiceAttributeUpdateTypeInput>;
};

/** DEPRECATED: use CustomerServiceCustomDetailUpdateTypeInput instead. */
export type CustomerServiceAttributeUpdateTypeInput = {
  /** The type of the attribute to be updated */
  name?: InputMaybe<CustomerServiceAttributeTypeName>;
  /** Options for this type, only valid if the provided type is SELECT/MULTI-SELECT. Empty Otherwise. */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * #########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceBrandingColorsInput = {
  /** The primary color for the branding */
  primary?: InputMaybe<Scalars['String']['input']>;
  /** Text color for the branding */
  textColor?: InputMaybe<Scalars['String']['input']>;
};

export enum CustomerServiceBrandingEntityType {
  /** Global branding applied across all customer hub channels, such as widget and support site. */
  CustomerHub = 'CUSTOMER_HUB',
  /** Branding applied to the support site. */
  SupportSite = 'SUPPORT_SITE'
}

export type CustomerServiceBrandingIconInput = {
  mediaFileId?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerServiceBrandingLogoInput = {
  mediaFileId?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerServiceBrandingTileInput = {
  mediaFileId?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerServiceBrandingUpsertInput = {
  colors?: InputMaybe<CustomerServiceBrandingColorsInput>;
  /** The type of the entity to which the branding will be applied */
  entityType: CustomerServiceBrandingEntityType;
  icon?: InputMaybe<CustomerServiceBrandingIconInput>;
  logo?: InputMaybe<CustomerServiceBrandingLogoInput>;
  tile?: InputMaybe<CustomerServiceBrandingTileInput>;
};

export type CustomerServiceContext = {
  issueId?: InputMaybe<Scalars['String']['input']>;
  type: CustomerServiceContextType;
};

export type CustomerServiceContextConfigurationInput = {
  context: CustomerServiceContextType;
  enabled: Scalars['Boolean']['input'];
};

/** Context is the place where detail fields are being requested. The Context determines which configurations to use. Configurations determines settings like: the max number of fields allowed and if a field is enabled for displayed or not */
export enum CustomerServiceContextType {
  /** Organization/Customer Details View */
  Default = 'DEFAULT',
  /** Jira Issue View */
  Issue = 'ISSUE'
}

export type CustomerServiceCustomAttributeOptionStyleInput = {
  backgroundColour: Scalars['String']['input'];
};

export type CustomerServiceCustomAttributeOptionsStyleConfigurationInput = {
  optionValue: Scalars['String']['input'];
  style: CustomerServiceCustomAttributeOptionStyleInput;
};

export type CustomerServiceCustomAttributeStyleConfigurationInput = {
  options?: InputMaybe<Array<CustomerServiceCustomAttributeOptionsStyleConfigurationInput>>;
};

export type CustomerServiceCustomDetailConfigMetadataUpdateInput = {
  /** Context configuration */
  contextConfigurations?: InputMaybe<Array<CustomerServiceContextConfigurationInput>>;
  /** The ID of the custom detail */
  id: Scalars['ID']['input'];
  /** The position of the custom detail */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** Styles configuration */
  styleConfiguration?: InputMaybe<CustomerServiceCustomAttributeStyleConfigurationInput>;
};

export type CustomerServiceCustomDetailContextInput = {
  /** Context configuration */
  contextConfigurations?: InputMaybe<Array<CustomerServiceContextConfigurationInput>>;
  /** The ID of the custom detail */
  id: Scalars['ID']['input'];
};

export enum CustomerServiceCustomDetailCreateErrorCode {
  ColorNotSaved = 'COLOR_NOT_SAVED',
  PermissionsNotSaved = 'PERMISSIONS_NOT_SAVED'
}

export type CustomerServiceCustomDetailCreateInput = {
  /** Context configuration */
  contextConfigurations?: InputMaybe<Array<CustomerServiceContextConfigurationInput>>;
  /** The entity type to create a custom detail for */
  customDetailEntityType: CustomerServiceCustomDetailsEntityType;
  /** The PermissionGroup IDs of the user roles that are able to edit this detail */
  editPermissions?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The name of the custom detail to create */
  name: Scalars['String']['input'];
  /** The PermissionGroup IDs of the user roles that are able to view this detail */
  readPermissions?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Styles configuration */
  styleConfiguration?: InputMaybe<CustomerServiceCustomAttributeStyleConfigurationInput>;
  /** The type of the custom detail to create */
  type?: InputMaybe<CustomerServiceCustomDetailCreateTypeInput>;
};

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceCustomDetailCreateTypeInput = {
  /** The type of the custom detail to be created */
  name?: InputMaybe<CustomerServiceCustomDetailTypeName>;
  /** Options for this type, only valid if the provided type is SELECT/MULTI-SELECT. Empty otherwise. */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type CustomerServiceCustomDetailDeleteInput = {
  /** ID of the custom detail */
  id: Scalars['ID']['input'];
};

export type CustomerServiceCustomDetailEntityTypeId = {
  /** The ID of the individual that the custom detail is for */
  accountId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the entitlement that the custom detail is for */
  entitlementId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the organization that the custom detail is for */
  organizationId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceCustomDetailPermissionsUpdateInput = {
  /** The CustomerServicePermissionGroup IDs that are able to edit this detail. */
  editPermissions?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The ID of the detail */
  id: Scalars['ID']['input'];
  /** The CustomerServicePermissionGroup IDs that are able to view this detail */
  readPermissions?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * The types of custom details that can exist
 * NOTE: Please do not modify enums without first notifying the FE team.
 */
export enum CustomerServiceCustomDetailTypeName {
  Boolean = 'BOOLEAN',
  Date = 'DATE',
  Email = 'EMAIL',
  Multiselect = 'MULTISELECT',
  Number = 'NUMBER',
  Phone = 'PHONE',
  Select = 'SELECT',
  Text = 'TEXT',
  Url = 'URL',
  User = 'USER'
}

export type CustomerServiceCustomDetailUpdateInput = {
  /** ID of the custom detail */
  id: Scalars['ID']['input'];
  /** The updated name for the custom detail to update */
  name: Scalars['String']['input'];
  /** The type of the custom detail to update */
  type?: InputMaybe<CustomerServiceCustomDetailUpdateTypeInput>;
};

export type CustomerServiceCustomDetailUpdateTypeInput = {
  /** The type of the custom detail to be updated */
  name?: InputMaybe<CustomerServiceCustomDetailTypeName>;
  /** Options for this type, only valid if the provided type is SELECT/MULTI-SELECT. Empty Otherwise. */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** The available entities */
export enum CustomerServiceCustomDetailsEntityType {
  Customer = 'CUSTOMER',
  Entitlement = 'ENTITLEMENT',
  Organization = 'ORGANIZATION'
}

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceDefaultRoutingRuleInput = {
  /** ID of the issue type associated with the routing rule. */
  issueTypeId: Scalars['String']['input'];
  /** ID of the project associated with the routing rule. */
  projectId: Scalars['ID']['input'];
};

/**
 * #########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceEntitlementAddInput = {
  /** The ID of the entity that the entitlement is for (customer or organization) */
  entitlementEntityId: CustomerServiceEntitlementEntityId;
  /** The ID of the product that the entitlement is for */
  productId: Scalars['ID']['input'];
};

export type CustomerServiceEntitlementEntityId = {
  /** The ID of the customer that the entitlement is for */
  accountId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the organization that the entitlement is for */
  organizationId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * ###############################
 *  Base objects for entitlements
 * ###############################
 */
export type CustomerServiceEntitlementFilterInput = {
  /** The product ID to filter entitlements results by */
  productId?: InputMaybe<Scalars['ID']['input']>;
};

export type CustomerServiceEntitlementRemoveInput = {
  /** The ID of the entitlement */
  entitlementId: Scalars['ID']['input'];
};

export type CustomerServiceEscalateWorkItemInput = {
  /** Type of escalation */
  escalationType?: InputMaybe<CustomerServiceEscalationType>;
};

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export enum CustomerServiceEscalationType {
  SupportEscalation = 'SUPPORT_ESCALATION'
}

export type CustomerServiceFilterInput = {
  context: CustomerServiceContext;
};

export type CustomerServiceIndividualUpdateAttributeByNameInput = {
  /** Account ID of the individual whose attribute you wish to update */
  accountId: Scalars['String']['input'];
  /** The name of the attribute whose value should be updated */
  attributeName: Scalars['String']['input'];
  /** The new value for the attribute */
  attributeValue: Scalars['String']['input'];
};

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceIndividualUpdateAttributeInput = {
  /** Account ID of the individual whose attribute you wish to update */
  accountId: Scalars['String']['input'];
  /** The ID of the attribute whose value should be updated */
  attributeId: Scalars['String']['input'];
  /** The new value for the attribute */
  attributeValue: Scalars['String']['input'];
};

export type CustomerServiceIndividualUpdateAttributeMultiValueByNameInput = {
  /** Account ID of the individual whose attribute you wish to update */
  accountId: Scalars['String']['input'];
  /** The name of the attribute whose value should be updated */
  attributeName: Scalars['String']['input'];
  /** The new value for the attribute */
  attributeValues: Array<Scalars['String']['input']>;
};

export type CustomerServiceNoteCreateInput = {
  body: Scalars['String']['input'];
  entityId: Scalars['ID']['input'];
  entityType: CustomerServiceNoteEntity;
};

export type CustomerServiceNoteDeleteInput = {
  entityId: Scalars['ID']['input'];
  entityType: CustomerServiceNoteEntity;
  noteId: Scalars['ID']['input'];
};

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export enum CustomerServiceNoteEntity {
  Customer = 'CUSTOMER',
  Organization = 'ORGANIZATION'
}

export type CustomerServiceNoteUpdateInput = {
  body: Scalars['String']['input'];
  entityId: Scalars['ID']['input'];
  entityType: CustomerServiceNoteEntity;
  noteId: Scalars['ID']['input'];
};

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceOrganizationCreateInput = {
  /** The ID of the organization to create */
  id: Scalars['ID']['input'];
  /** Organization name to be created */
  name: Scalars['String']['input'];
};

export type CustomerServiceOrganizationDeleteInput = {
  /** The ID of the organization to delete */
  id: Scalars['ID']['input'];
};

export type CustomerServiceOrganizationUpdateAttributeByNameInput = {
  /** The name of the attribute whose value should be updated */
  attributeName: Scalars['String']['input'];
  /** The new value for the attribute */
  attributeValue: Scalars['String']['input'];
  /** ID of the organisation whose attribute you wish to update */
  organizationId: Scalars['String']['input'];
};

export type CustomerServiceOrganizationUpdateAttributeInput = {
  /** The ID of the attribute whose value should be updated */
  attributeId: Scalars['String']['input'];
  /** The new value for the attribute */
  attributeValue: Scalars['String']['input'];
  /** ID of the organisation whose attribute you wish to update */
  organizationId: Scalars['String']['input'];
};

export type CustomerServiceOrganizationUpdateAttributeMultiValueByNameInput = {
  /** The name of the attribute whose value should be updated */
  attributeName: Scalars['String']['input'];
  /** The new values for the attribute */
  attributeValues: Array<Scalars['String']['input']>;
  /** ID of the organisation whose attribute you wish to update */
  organizationId: Scalars['String']['input'];
};

export type CustomerServiceOrganizationUpdateInput = {
  /** The ID of the organization to update */
  id: Scalars['ID']['input'];
  /** Organization name to be updated */
  name?: InputMaybe<Scalars['String']['input']>;
};

export enum CustomerServicePermissionGroupType {
  Admins = 'ADMINS',
  AdminsAgents = 'ADMINS_AGENTS',
  AdminsAgentsSiteAccess = 'ADMINS_AGENTS_SITE_ACCESS'
}

/**
 * #########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceProductCreateInput = {
  /** The name of the new product */
  name: Scalars['String']['input'];
};

export type CustomerServiceProductDeleteInput = {
  /** The ID of the product to be deleted */
  id: Scalars['ID']['input'];
};

export type CustomerServiceProductFilterInput = {
  /** Case insensitive string to filter products by names they begin with */
  nameBeginsWith?: InputMaybe<Scalars['String']['input']>;
  /** Case insensitive string to filter product names with */
  nameContains?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerServiceProductUpdateInput = {
  /** The ID of the product to be updated */
  id: Scalars['ID']['input'];
  /** The updated name of the product */
  name: Scalars['String']['input'];
};

export type CustomerServiceRequestFilterInput = {
  /** Filter requests by search text (case insensitive) */
  searchText?: InputMaybe<Scalars['String']['input']>;
  /** Filter requests by status key (SUBMITTED, RESOLVED) */
  status?: InputMaybe<CustomerServiceStatusKey>;
};

export type CustomerServiceReturnEscalationInput = {
  /** Type of escalation */
  escalationType: CustomerServiceEscalationType;
  /** The reason provided for the escalation return */
  reason?: InputMaybe<Scalars['String']['input']>;
};

export enum CustomerServiceStatusKey {
  Resolved = 'RESOLVED',
  Submitted = 'SUBMITTED'
}

export enum CustomerServiceTemplateFormChannelType {
  /** Email channel */
  Email = 'EMAIL',
  /** 3rd party embedded widget channel */
  Embed = 'EMBED',
  /** Support site and chat widget channel */
  SupportSite = 'SUPPORT_SITE',
  /** Voice channel */
  Voice = 'VOICE'
}

export type CustomerServiceTemplateFormCreateInput = {
  /** The default routing rule */
  defaultRoutingRule?: InputMaybe<CustomerServiceDefaultRoutingRuleInput>;
  /** The ID of the help center to configure the form against */
  helpCenterId: Scalars['ID']['input'];
  /** The name of the new template form */
  name: Scalars['String']['input'];
};

export type CustomerServiceTemplateFormDeleteInput = {
  /** ID of the help center the template form is associated with, as an ARI */
  helpCenterId: Scalars['ID']['input'];
  /** ID of the template form to be deleted, as an ARI */
  templateFormId: Scalars['ID']['input'];
};

export type CustomerServiceTemplateFormEnabledChannelsInput = {
  /** The type of the channel. */
  channelType: CustomerServiceTemplateFormChannelType;
  /** Whether the template form is enabled for use in the channel. */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The customer service template form filter input */
export type CustomerServiceTemplateFormFilterInput = {
  /** Boolean to filter out forms that are not AI-Fillable. */
  isAiFillable?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CustomerServiceTemplateFormUpdateInput = {
  /** The update default routing rule for the form */
  defaultRoutingRule?: InputMaybe<CustomerServiceDefaultRoutingRuleInput>;
  /** Description of the form. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** List of channel types to their enabled status. */
  enabledChannels?: InputMaybe<Array<CustomerServiceTemplateFormEnabledChannelsInput>>;
};

export type CustomerServiceUpdateCustomDetailValueInput = {
  /** ID of the entity whose custom detail you wish to update */
  id: CustomerServiceCustomDetailEntityTypeId;
  /** The name of the custom detail whose value should be updated */
  name: Scalars['String']['input'];
  /** The new value for the custom detail, for a single value field */
  value?: InputMaybe<Scalars['String']['input']>;
  /** The new value for the custom detail, for a multi-value field */
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * ########################
 *  Mutation Inputs
 * #########################
 */
export type CustomerServiceUpdateRequestParticipantInput = {
  /** Email Ids of the participants to be added to the request */
  addedParticipants: Array<Scalars['String']['input']>;
  /** Account Ids of the participants to be removed from the request */
  deletedParticipants: Array<Scalars['ID']['input']>;
};

export type DataClassificationPolicyDecisionInput = {
  dataClassificationTags: Array<Scalars['ID']['input']>;
};

export enum DataClassificationPolicyDecisionStatus {
  Allowed = 'ALLOWED',
  Blocked = 'BLOCKED'
}

export enum DataResidencyResponse {
  AppDoesNotSupportDr = 'APP_DOES_NOT_SUPPORT_DR',
  NotApplicable = 'NOT_APPLICABLE',
  StoredExternalToAtlassian = 'STORED_EXTERNAL_TO_ATLASSIAN',
  StoredInAtlassianAndDrNotSupported = 'STORED_IN_ATLASSIAN_AND_DR_NOT_SUPPORTED',
  StoredInAtlassianAndDrSupported = 'STORED_IN_ATLASSIAN_AND_DR_SUPPORTED'
}

export enum DataSecurityPolicyAction {
  AiAccess = 'AI_ACCESS',
  AnonymousAccess = 'ANONYMOUS_ACCESS',
  AppAccess = 'APP_ACCESS',
  AppAccessConfigured = 'APP_ACCESS_CONFIGURED',
  AttachmentDownload = 'ATTACHMENT_DOWNLOAD',
  PageExport = 'PAGE_EXPORT',
  PublicLinks = 'PUBLIC_LINKS'
}

export enum DataSecurityPolicyCoverageType {
  ClassificationLevel = 'CLASSIFICATION_LEVEL',
  Container = 'CONTAINER',
  None = 'NONE',
  Workspace = 'WORKSPACE'
}

export enum DataSecurityPolicyDecidableContentStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

/** Time ranges of invocation date. */
export type DateSearchInput = {
  /**
   * The start time of the earliest invocation to include in the results.
   * If null, search results will only be limited by retention limits.
   *
   * RFC-3339 formatted timestamp.
   */
  earliestStart?: InputMaybe<Scalars['String']['input']>;
  /**
   * The start time of the latest invocation to include in the results.
   * If null, will include most recent invocations.
   *
   * RFC-3339 formatted timestamp.
   */
  latestStart?: InputMaybe<Scalars['String']['input']>;
};

export type DeactivatePaywallContentInput = {
  deactivationIdentifier: Scalars['ID']['input'];
};

export enum DeactivatedPageOwnerUserType {
  FormerUsers = 'FORMER_USERS',
  NonFormerUsers = 'NON_FORMER_USERS'
}

export type DeleteAppEnvironmentInput = {
  appAri: Scalars['ID']['input'];
  environmentKey: Scalars['String']['input'];
};

export type DeleteAppEnvironmentVariableInput = {
  environment: AppEnvironmentInput;
  /** The key of the environment variable to delete */
  key: Scalars['String']['input'];
};

export type DeleteAppInput = {
  appId: Scalars['ID']['input'];
};

export type DeleteAppStoredCustomEntityMutationInput = {
  /** The ARI to store this entity within */
  contextAri?: InputMaybe<Scalars['ID']['input']>;
  /** Specify entity name for custom schema */
  entityName: Scalars['String']['input'];
  /** The identifier for the entity */
  key: Scalars['ID']['input'];
};

export type DeleteAppStoredEntityMutationInput = {
  /** The ARI to store this entity within */
  contextAri?: InputMaybe<Scalars['ID']['input']>;
  /** Specify whether the encrypted value should be deleted */
  encrypted?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The identifier for the entity
   *
   * Keys must be between 1-100 characters long and must match the following pattern /^[a-zA-Z0-9:._\s-]+$/
   */
  key: Scalars['ID']['input'];
};

export type DeleteAppTunnelInput = {
  /** The app to setup a tunnel for */
  appId: Scalars['ID']['input'];
  /** The environment key */
  environmentKey: Scalars['String']['input'];
};

export type DeleteCardInput = {
  cardId: Scalars['ID']['input'];
};

export type DeleteColumnInput = {
  boardId: Scalars['ID']['input'];
  columnId: Scalars['ID']['input'];
};

/** Accepts input to delete an external alias. */
export type DeleteCompassComponentExternalAliasInput = {
  /** The ID of the component to which you add the external alias. */
  componentId: Scalars['ID']['input'];
  /** The alias of the component identifier in external sources. */
  externalAlias: CompassDeleteExternalAliasInput;
};

/** Accepts input for deleting an existing component. */
export type DeleteCompassComponentInput = {
  /** The ID of the component to be deleted. */
  id: Scalars['ID']['input'];
};

/** Accepts input to delete a component link. */
export type DeleteCompassComponentLinkInput = {
  /** The ID for the component to delete a link. */
  componentId: Scalars['ID']['input'];
  /** The component link to be deleted. */
  link: Scalars['ID']['input'];
};

/** Input to delete a component type. */
export type DeleteCompassComponentTypeInput = {
  /** The ARI of the component type to be deleted. */
  id: Scalars['ID']['input'];
};

/** Accepts input for deleting an existing relationship between two components. */
export type DeleteCompassRelationshipInput = {
  /** The unique identifier (ID) of the component at the ending node. */
  endNodeId: Scalars['ID']['input'];
  /** The type of relationship. eg DEPENDS_ON or CHILD_OF */
  relationshipType?: CompassRelationshipTypeInput;
  /** The unique identifier (ID) of the component at the starting node. */
  startNodeId: Scalars['ID']['input'];
};

export type DeleteCompassScorecardCriteriaInput = {
  /** ID of the scorecard criterion for deletion. The criteria is already applied to a scorecard. */
  id: Scalars['ID']['input'];
};

/** Accepts input for deleting a starred component. */
export type DeleteCompassStarredComponentInput = {
  /** The ID of the component to be un-starred. */
  componentId: Scalars['ID']['input'];
};

export type DeleteContentDataClassificationLevelInput = {
  contentStatus: ContentDataClassificationMutationContentStatus;
  id: Scalars['Long']['input'];
};

export type DeleteContentTemplateLabelInput = {
  contentTemplateId: Scalars['ID']['input'];
  labelId: Scalars['ID']['input'];
};

export type DeleteCustomFilterInput = {
  boardId: Scalars['ID']['input'];
  customFilterId: Scalars['String']['input'];
};

export type DeleteDefaultSpaceRoleAssignmentsInput = {
  principalsList: Array<RoleAssignmentPrincipalInput>;
};

/** The request input for deleting relationship properties */
export type DeleteDevOpsContainerRelationshipEntityPropertiesInput = {
  /** The ARI of the any of the relationship entity */
  id: Scalars['ID']['input'];
  /** The properties with the given keys in the list will be removed from the relationship */
  keys: Array<Scalars['String']['input']>;
};

/** The request input for deleting a relationship between a DevOps Service and a Jira Project */
export type DeleteDevOpsServiceAndJiraProjectRelationshipInput = {
  /** The DevOps Graph Service_And_Jira_Project relationship ARI */
  id: Scalars['ID']['input'];
};

/** The request input for deleting a relationship between a DevOps Service and an Opsgenie Team */
export type DeleteDevOpsServiceAndOpsgenieTeamRelationshipInput = {
  id: Scalars['ID']['input'];
};

/** The request input for deleting a relationship between a DevOps Service and a Repository */
export type DeleteDevOpsServiceAndRepositoryRelationshipInput = {
  /** The ARI of the relationship */
  id: Scalars['ID']['input'];
};

/** The request input for deleting DevOps Service Entity Properties */
export type DeleteDevOpsServiceEntityPropertiesInput = {
  /** The ARI of the DevOps Service */
  id: Scalars['ID']['input'];
  /** The properties with the given keys in the list will be removed from the DevOps Service */
  keys: Array<Scalars['String']['input']>;
};

/** The request input for deleting a DevOps Service */
export type DeleteDevOpsServiceInput = {
  id: Scalars['ID']['input'];
};

/** The request input for deleting a DevOps Service Relationship */
export type DeleteDevOpsServiceRelationshipInput = {
  /** The ARI of the DevOps Service Relationship */
  id: Scalars['ID']['input'];
};

export type DeleteEventSourceInput = {
  /** The cloud ID of the site to delete an event source for. */
  cloudId: Scalars['ID']['input'];
  /** The type of event to be deleted. */
  eventType: CompassEventType;
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID']['input'];
};

export type DeleteExCoSpacePermissionsInput = {
  accountId: Scalars['String']['input'];
};

export type DeleteInlineCommentInput = {
  commentId: Scalars['ID']['input'];
  step?: InputMaybe<Step>;
};

/** Delete: Mutation (Delete) */
export type DeleteJiraPlaybookInput = {
  id: Scalars['ID']['input'];
};

export type DeleteLabelInput = {
  contentId: Scalars['ID']['input'];
  label: Scalars['String']['input'];
};

export type DeleteNoteInput = {
  ari?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type DeletePagesInput = {
  areChildrenIncluded?: InputMaybe<Scalars['Boolean']['input']>;
  excludedBranchRootPageIDs?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  isSelected?: InputMaybe<Scalars['Boolean']['input']>;
  pageID: Scalars['Long']['input'];
};

export type DeletePolarisIdeaTemplateInput = {
  id: Scalars['ID']['input'];
  project: Scalars['ID']['input'];
};

export type DeleteRelationInput = {
  relationName: RelationType;
  sourceKey: Scalars['String']['input'];
  sourceType: RelationSourceType;
  targetKey: Scalars['String']['input'];
  targetType: RelationTargetType;
};

export type DeleteSpaceDefaultClassificationLevelInput = {
  id: Scalars['Long']['input'];
};

export type DeleteSpaceRoleAssignmentsInput = {
  principalList: Array<RoleAssignmentPrincipalInput>;
  spaceId: Scalars['Long']['input'];
};

/** Delete sprint */
export type DeleteSprintInput = {
  boardId: Scalars['ID']['input'];
  sprintId: Scalars['ID']['input'];
};

export type DeleteUserGrantInput = {
  oauthClientId: Scalars['ID']['input'];
};

/** The state that a code deployment can be in (think of a deployment in Bitbucket Pipelines, CircleCI, etc). */
export enum DeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum Depth {
  All = 'ALL',
  Root = 'ROOT'
}

export enum DescendantsNoteApplicationOption {
  All = 'ALL',
  None = 'NONE',
  Roots = 'ROOTS'
}

/** Accepts input to detach a data manager from a component. */
export type DetachCompassComponentDataManagerInput = {
  /** The ID of the component to detach a data manager from. */
  componentId: Scalars['ID']['input'];
};

export type DetachEventSourceInput = {
  /** The ID of the component to detach the event source from. */
  componentId: Scalars['ID']['input'];
  /** The ID of the event source. */
  eventSourceId: Scalars['ID']['input'];
};

/** The "phase" of the job the group of logs is associated with. Coding, planning, etc. */
export enum DevAiAutodevLogGroupPhase {
  CodeGenerating = 'CODE_GENERATING',
  CodeReview = 'CODE_REVIEW',
  CodeReGenerating = 'CODE_RE_GENERATING',
  PlanGenerating = 'PLAN_GENERATING',
  PlanReview = 'PLAN_REVIEW',
  PlanReGenerating = 'PLAN_RE_GENERATING'
}

/** Overall status of the group of logs. */
export enum DevAiAutodevLogGroupStatus {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS'
}

/** The "phase" of the job the log is associated with. Coding, planning, etc. */
export enum DevAiAutodevLogPhase {
  CodeGenerating = 'CODE_GENERATING',
  CodeReview = 'CODE_REVIEW',
  CodeReGenerating = 'CODE_RE_GENERATING',
  PlanGenerating = 'PLAN_GENERATING',
  PlanReview = 'PLAN_REVIEW',
  PlanReGenerating = 'PLAN_RE_GENERATING'
}

/** Priority of the log item. */
export enum DevAiAutodevLogPriority {
  Lowest = 'LOWEST',
  Medium = 'MEDIUM'
}

/** Status of the log item. */
export enum DevAiAutodevLogStatus {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS'
}

export type DevAiAutofixScanOrderInput = {
  order: SortDirection;
  sortByField: DevAiAutofixScanSortField;
};

export enum DevAiAutofixScanSortField {
  StartDate = 'START_DATE'
}

export enum DevAiAutofixScanStatus {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS'
}

export type DevAiAutofixTaskFilterInput = {
  primaryLanguage?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<DevAiAutofixTaskStatus>>;
};

export type DevAiAutofixTaskOrderInput = {
  order: SortDirection;
  sortByField: DevAiAutofixTaskSortField;
};

export enum DevAiAutofixTaskSortField {
  CreatedAt = 'CREATED_AT',
  Filename = 'FILENAME',
  NewCoveragePercentage = 'NEW_COVERAGE_PERCENTAGE',
  PreviousCoveragePercentage = 'PREVIOUS_COVERAGE_PERCENTAGE',
  PrimaryLanguage = 'PRIMARY_LANGUAGE',
  Status = 'STATUS',
  UpdatedAt = 'UPDATED_AT'
}

export enum DevAiAutofixTaskStatus {
  PrDeclined = 'PR_DECLINED',
  PrMerged = 'PR_MERGED',
  PrOpened = 'PR_OPENED',
  WorkflowCancelled = 'WORKFLOW_CANCELLED',
  WorkflowCompleted = 'WORKFLOW_COMPLETED',
  WorkflowInprogress = 'WORKFLOW_INPROGRESS',
  WorkflowPending = 'WORKFLOW_PENDING'
}

export type DevAiCancelRunningAutofixScanInput = {
  repoUrl: Scalars['URL']['input'];
  workspaceId: Scalars['ID']['input'];
};

export enum DevAiFlowPipelinesStatus {
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Provisioned = 'PROVISIONED',
  Starting = 'STARTING',
  Stopped = 'STOPPED'
}

export enum DevAiFlowSessionsStatus {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Paused = 'PAUSED',
  Pending = 'PENDING'
}

/**
 * Represents the issue suitability label for using Autodev to solve the task.
 *
 * - A value of UNSOLVABLE represents issues that we cannot use Autodev to solve
 * - A value of IN_SCOPE represents issues that are good candidates for Autodev
 * - A value of RECOVERABLE represents issues that require additional context for Autodev to succeed
 * - A value of COMPLEX represents issues that should be broken down into sub-tasks or smaller issues
 */
export enum DevAiIssueScopingLabel {
  Complex = 'COMPLEX',
  InScope = 'IN_SCOPE',
  Optimal = 'OPTIMAL',
  Recoverable = 'RECOVERABLE',
  Unsolvable = 'UNSOLVABLE'
}

export enum DevAiResourceType {
  NoActiveProduct = 'NO_ACTIVE_PRODUCT',
  RovoDevBeta = 'ROVO_DEV_BETA',
  RovoDevEverywhere = 'ROVO_DEV_EVERYWHERE',
  RovoDevStandard = 'ROVO_DEV_STANDARD',
  RovoDevStandardTrial = 'ROVO_DEV_STANDARD_TRIAL'
}

/**
 * When the Rovo agent is ranked for compatibility with a list of issues using the agent ranking
 * service, it is assigned a rank category which can be used to determine display priority on the UI.
 */
export enum DevAiRovoAgentRankCategory {
  /**
   * Agent ranker has determined this agent is an adequate match to complete the in-scope issue(s).
   * Assigned when the raw similarity score is less than 0.48 and greater than or equal to 0.15.
   */
  AdequateMatch = 'ADEQUATE_MATCH',
  /**
   * Agent ranker has determined this agent is a good match to complete the in-scope issue(s).
   * Assigned when the raw similarity score is greater than or equal to 0.48.
   */
  GoodMatch = 'GOOD_MATCH',
  /**
   * Agent ranker has determined this agent is a poor match to complete the in-scope issue(s).
   * Assigned when the raw similarity score is less than 0.15.
   */
  PoorMatch = 'POOR_MATCH'
}

/** Whether the query should include, exclude, or only have agent templates in the results. */
export enum DevAiRovoAgentTemplateFilter {
  Exclude = 'EXCLUDE',
  Include = 'INCLUDE',
  Only = 'ONLY'
}

/** Input for archiving a Rovo Dev Session */
export type DevAiRovoDevArchiveSessionInput = {
  /** The ID of the session to archive */
  sessionId: Scalars['ID']['input'];
};

/** Build status for code pushed to CI pipelines */
export enum DevAiRovoDevBuildStatus {
  Active = 'ACTIVE',
  Failed = 'FAILED',
  Inactive = 'INACTIVE',
  Succeeded = 'SUCCEEDED'
}

/**
 * Input for bulk creating new Rovo Dev Sessions
 * The FE does not have easy access to the workspace ARI from jira, so we use the cloudId instead.
 */
export type DevAiRovoDevBulkCreateSessionByCloudIdInput = {
  /**
   * List of Issue ARIs to create new sessions for
   * Max 20 issues per bulk create
   */
  issueAris: Array<Scalars['ID']['input']>;
  /** Input for creating each Rovo Dev Session */
  options: DevAiRovoDevCreateSessionByCloudIdInput;
};

/** Input for creating a pull request for a Rovo Dev Session */
export type DevAiRovoDevCreatePullRequestInput = {
  /** Optional branch name to override the session's target branch */
  branchName?: InputMaybe<Scalars['String']['input']>;
  /** Optional code changes as a string */
  codeChanges?: InputMaybe<Scalars['String']['input']>;
  /** The ARI of the session to create pull request for */
  sessionAri: Scalars['ID']['input'];
};

/**
 * Input for creating a new Rovo Dev Session by Cloud ID
 * The FE does not have easy access to the workspace ARI from jira, so we use the cloudId instead.
 */
export type DevAiRovoDevCreateSessionByCloudIdInput = {
  /** Atlassian Account ID of the automation user who triggered the rule */
  automationInvokerId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The cloud ID of the Jira instance
   * Used to find the workspace ARI
   */
  cloudId: Scalars['ID']['input'];
  /** Conversation ID to link this session to an existing conversation */
  linkConversationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Related entities to provide additional context.
   * Add as many links as needed to satisfy query patterns.
   */
  links?: InputMaybe<Array<DevAiRovoDevSessionLinkInput>>;
  /** Additional options to adjust agent behaviour */
  options?: InputMaybe<DevAiRovoDevCreateSessionOptionsInput>;
  /** Initial prompt for the agent in ADF (Atlassian Document Format) */
  promptAdf?: InputMaybe<Scalars['JSON']['input']>;
  /** The repository that Rovo Dev will be coding in */
  repository: DevAiRovoDevRepositoryInput;
  /** The use-case associated with this session */
  useCase?: InputMaybe<Scalars['String']['input']>;
  /** Experience ID for tracking user experience flows */
  xid?: InputMaybe<Scalars['String']['input']>;
};

/** Input for creating a new Rovo Dev Session */
export type DevAiRovoDevCreateSessionInput = {
  /** Atlassian Account ID of the automation user who triggered the rule */
  automationInvokerId?: InputMaybe<Scalars['String']['input']>;
  /** Conversation ID to link this session to an existing conversation */
  linkConversationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Related entities to provide additional context.
   * Add as many links as needed to satisfy query patterns.
   */
  links?: InputMaybe<Array<DevAiRovoDevSessionLinkInput>>;
  /** Additional options to adjust agent behaviour */
  options?: InputMaybe<DevAiRovoDevCreateSessionOptionsInput>;
  /** Initial prompt for the agent in ADF (Atlassian Document Format) */
  promptAdf?: InputMaybe<Scalars['JSON']['input']>;
  /** The repository that Rovo Dev will be coding in */
  repository: DevAiRovoDevRepositoryInput;
  /** The use-case associated with this session */
  useCase?: InputMaybe<Scalars['String']['input']>;
  /** The Rovo Dev Workspace the session belongs to */
  workspaceAri: Scalars['ID']['input'];
  /** Experience ID for tracking user experience entry points */
  xid?: InputMaybe<Scalars['String']['input']>;
};

/** Options for a session to change its behaviour (Input type) */
export type DevAiRovoDevCreateSessionOptionsInput = {
  /** Whether the agent should operate autonomously without user intervention. Defaults to false. */
  isAutonomous?: InputMaybe<Scalars['Boolean']['input']>;
  /** Under what conditions should the agent raise a pull request? */
  raisePullRequestOptions?: InputMaybe<DevAiRovoDevRaisePullRequestOption>;
  /** Whether to use deep planning for more comprehensive code analysis. Defaults to false. */
  useDeepPlan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to use restricted mode for Rovodev. Defaults to false. */
  useRovodevRestrictedMode?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Pr status states */
export enum DevAiRovoDevPrStatus {
  /** PR is declined */
  Declined = 'DECLINED',
  /** PR is open in draft */
  Draft = 'DRAFT',
  /** PR is merged */
  Merged = 'MERGED',
  /** PR is open */
  Open = 'OPEN'
}

export enum DevAiRovoDevRaisePullRequestOption {
  Always = 'ALWAYS',
  Draft = 'DRAFT',
  DraftOnBuildPass = 'DRAFT_ON_BUILD_PASS',
  Never = 'NEVER',
  OnBuildPass = 'ON_BUILD_PASS'
}

/** Repositories and their specific config required by Rovo Dev (Input type) */
export type DevAiRovoDevRepositoryInput = {
  /** Rovo Dev will checkout the source branch prior to coding */
  sourceBranch?: InputMaybe<Scalars['String']['input']>;
  /** Target branch code will be pushed to */
  targetBranch?: InputMaybe<Scalars['String']['input']>;
  /** Repository URL where agent will code */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Session status states */
export enum DevAiRovoDevSandboxStatus {
  Created = 'CREATED',
  Started = 'STARTED',
  Stopped = 'STOPPED'
}

export enum DevAiRovoDevSessionArchivedFilter {
  /** Return both archived and non-archived sessions (default) */
  All = 'ALL',
  /** Return only archived sessions */
  ArchivedOnly = 'ARCHIVED_ONLY',
  /** Return only non-archived sessions */
  NonArchivedOnly = 'NON_ARCHIVED_ONLY'
}

/** Links to additional resources for the session to use (Input type) */
export type DevAiRovoDevSessionLinkInput = {
  /** ARI to the entity */
  ari: Scalars['String']['input'];
  /** Relation of the ARI to the session */
  rel: DevAiRovoDevSessionLinkRel;
};

/** Link relationship types */
export enum DevAiRovoDevSessionLinkRel {
  /** CONTAINER is the container for the TARGET */
  Container = 'CONTAINER',
  /**
   * SITE is the cloud/site the CONTAINER belongs to. The site is part of the ARI
   * but for query efficiency, it needs to be pulled out.
   */
  Site = 'SITE',
  /** TARGET is an entity which the session was created for, the primary context */
  Target = 'TARGET'
}

/** Sort order of session */
export enum DevAiRovoDevSessionSort {
  /** Sort by ascending order */
  Asc = 'ASC',
  /** Sort by descending order */
  Desc = 'DESC'
}

/** Session status states */
export enum DevAiRovoDevSessionStatus {
  /** Agent is actively working */
  AgentWorking = 'AGENT_WORKING',
  /** Agent has been archived */
  Archived = 'ARCHIVED',
  /** Agent is cloning repository */
  Cloning = 'CLONING',
  /** Agent has been deleted */
  Deleted = 'DELETED',
  /** Agent has failed */
  Failed = 'FAILED',
  /** Agent is initialising */
  Initialising = 'INITIALISING',
  /** Agent is actively working */
  InProgress = 'IN_PROGRESS',
  /** Agent is pending to start */
  Pending = 'PENDING',
  /** Agent is ready for review */
  ReadyForReview = 'READY_FOR_REVIEW',
  /** Agent has completed coding, waiting for the user to review/answer questions */
  WaitingForUser = 'WAITING_FOR_USER'
}

/** Input for unarchiving a Rovo Dev Session */
export type DevAiRovoDevUnarchiveSessionInput = {
  /** The ID of the session to unarchive */
  sessionId: Scalars['ID']['input'];
};

export type DevAiRunAutofixScanInput = {
  repoUrl: Scalars['URL']['input'];
  /**
   * If a scan is currently running, this determines whether the mutation (a) does nothing
   * or (b) cancels the current scan and initiates another.
   */
  restartIfCurrentlyRunning?: InputMaybe<Scalars['Boolean']['input']>;
  workspaceId: Scalars['ID']['input'];
};

export enum DevAiSandboxReadiness {
  Creating = 'CREATING',
  Error = 'ERROR',
  Hibernated = 'HIBERNATED',
  /**  App is ready for user */
  Ready = 'READY',
  /**  App still starting up / restore in progress */
  Started = 'STARTED',
  /**  Either initial provisioning or restoring from hibernation */
  Starting = 'STARTING',
  Unknown = 'UNKNOWN'
}

export enum DevAiScanIntervalUnit {
  Days = 'DAYS',
  Months = 'MONTHS',
  Weeks = 'WEEKS'
}

/** Filter sessions by status category */
export enum DevAiSessionStatusCategoryFilter {
  /** All sessions regardless of status (default) */
  All = 'ALL',
  /** Sessions that have completed (READY_FOR_REVIEW, WAITING_FOR_USER, FAILED) */
  Completed = 'COMPLETED',
  /** Sessions that have been deleted or archived (DELETED, ARCHIVED) */
  Deleted = 'DELETED',
  /** Sessions that are currently in progress (PENDING, INITIALISING, CLONING, AGENT_WORKING) */
  Working = 'WORKING'
}

export type DevAiSetAutofixConfigurationForRepositoryInput = {
  codeCoverageCommand: Scalars['String']['input'];
  codeCoverageReportPath: Scalars['String']['input'];
  coveragePercentage: Scalars['Int']['input'];
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  maxPrOpenCount?: InputMaybe<Scalars['Int']['input']>;
  primaryLanguage: Scalars['String']['input'];
  repoUrl: Scalars['URL']['input'];
  runInitialScan?: InputMaybe<Scalars['Boolean']['input']>;
  scanIntervalFrequency?: InputMaybe<Scalars['Int']['input']>;
  scanIntervalUnit?: InputMaybe<DevAiScanIntervalUnit>;
  scanStartDate?: InputMaybe<Scalars['Date']['input']>;
  workspaceId: Scalars['ID']['input'];
};

/** Input to enable/disable Autofix for a repository. */
export type DevAiSetAutofixEnabledStateForRepositoryInput = {
  isEnabled: Scalars['Boolean']['input'];
  repoUrl: Scalars['URL']['input'];
  workspaceId: Scalars['ID']['input'];
};

export enum DevAiSupportedRepoFilterOption {
  All = 'ALL',
  DisabledOnly = 'DISABLED_ONLY',
  EnabledOnly = 'ENABLED_ONLY'
}

/** Input to trigger an autofix scan of a repository */
export type DevAiTriggerAutofixScanInput = {
  /** Command to run code coverage tool in this repository */
  codeCoverageCommand: Scalars['String']['input'];
  /** Directory where code coverage report is generated */
  codeCoverageReportPath: Scalars['String']['input'];
  /** Target code coverage percentage for the scan */
  coveragePercentage: Scalars['Int']['input'];
  /** Primary language */
  primaryLanguage: Scalars['String']['input'];
  repoUrl: Scalars['URL']['input'];
  /** User to add as a PR reviewer */
  reviewerUserId?: InputMaybe<Scalars['ID']['input']>;
  workspaceId: Scalars['ID']['input'];
};

export enum DevAiWorkflowRunStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING'
}

export type DevConsoleAppResourceUsageDetailedViewFiltersInput = {
  contextAris?: InputMaybe<Array<Scalars['ID']['input']>>;
  environment?: InputMaybe<Scalars['ID']['input']>;
  interval: DevConsoleDateIntervalInput;
  resource: DevConsoleResource;
};

export type DevConsoleAppResourceUsageFiltersInput = {
  contextAris?: InputMaybe<Array<Scalars['ID']['input']>>;
  environment?: InputMaybe<Scalars['ID']['input']>;
  interval: DevConsoleDateIntervalInput;
  page?: InputMaybe<Scalars['Int']['input']>;
  resource: DevConsoleResource;
};

export type DevConsoleAppUsageFiltersInput = {
  interval: DevConsoleDateIntervalInput;
  resource: Array<DevConsoleResource>;
};

export type DevConsoleAppUsageTopSitesFiltersInput = {
  interval: DevConsoleDateIntervalInput;
  page?: InputMaybe<Scalars['Int']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  resource: DevConsoleResource;
};

/**
 *  ===========================
 *  INPUT TYPES
 *  ===========================
 */
export type DevConsoleArchiveDeveloperSpaceInput = {
  developerSpaceId: Scalars['String']['input'];
};

export type DevConsoleAssignDeveloperSpaceInput = {
  appId: Scalars['String']['input'];
  developerSpaceId: Scalars['String']['input'];
};

export type DevConsoleCreateDeveloperSpaceInput = {
  name: Scalars['String']['input'];
};

export type DevConsoleDateIntervalInput = {
  end: Scalars['DateTime']['input'];
  start: Scalars['DateTime']['input'];
};

export enum DevConsoleDeveloperSpacePublishStatus {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

/**
 *  ===========================
 *  ENUMS
 *  ===========================
 */
export enum DevConsoleDeveloperSpaceType {
  AtlassianExternal = 'ATLASSIAN_EXTERNAL',
  AtlassianInternal = 'ATLASSIAN_INTERNAL'
}

/**
 *  ===========================
 *  CORE ENTITY TYPES
 *  ===========================
 */
export enum DevConsoleDownloadAppInstallationsStatus {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  NotStarted = 'NOT_STARTED',
  Processing = 'PROCESSING'
}

export enum DevConsoleGroupBy {
  ContextAri = 'CONTEXT_ARI',
  EnvironmentId = 'ENVIRONMENT_ID'
}

export type DevConsolePublishDeveloperSpaceInput = {
  developerSpaceId: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export enum DevConsoleResource {
  FunctionCompute = 'FUNCTION_COMPUTE',
  KvsRead = 'KVS_READ',
  KvsWrite = 'KVS_WRITE',
  LogsWrite = 'LOGS_WRITE',
  SqlCompute = 'SQL_COMPUTE',
  SqlRequests = 'SQL_REQUESTS',
  SqlStorage = 'SQL_STORAGE'
}

export enum DevConsoleTransactionAccountPaymentMethodStatus {
  Active = 'ACTIVE',
  NotFound = 'NOT_FOUND',
  NotPermitted = 'NOT_PERMITTED'
}

export type DevConsoleUpdateDeveloperSpaceMemberRolesInput = {
  addRoles: Array<Scalars['String']['input']>;
  developerSpaceId: Scalars['String']['input'];
  memberEmail?: InputMaybe<Scalars['String']['input']>;
  memberId?: InputMaybe<Scalars['String']['input']>;
  removeRoles: Array<Scalars['String']['input']>;
};

export type DevConsoleUpdateDeveloperSpaceSettingsInput = {
  developerSpaceId: Scalars['String']['input'];
  logo?: InputMaybe<Scalars['Upload']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export enum DevConsoleUsageResolution {
  OneDay = 'ONE_DAY',
  OneHour = 'ONE_HOUR',
  OneMonth = 'ONE_MONTH',
  OneWeek = 'ONE_WEEK'
}

/** The state of a build. */
export enum DevOpsBuildState {
  /** The build has been cancelled or stopped. */
  Cancelled = 'CANCELLED',
  /** The build failed. */
  Failed = 'FAILED',
  /** The build is currently running. */
  InProgress = 'IN_PROGRESS',
  /** The build is queued, or some manual action is required. */
  Pending = 'PENDING',
  /** The build completed successfully. */
  Successful = 'SUCCESSFUL',
  /** The build is in an unknown state. */
  Unknown = 'UNKNOWN'
}

export enum DevOpsComponentTier {
  Tier_1 = 'TIER_1',
  Tier_2 = 'TIER_2',
  Tier_3 = 'TIER_3',
  Tier_4 = 'TIER_4'
}

export enum DevOpsComponentType {
  Application = 'APPLICATION',
  Capability = 'CAPABILITY',
  CloudResource = 'CLOUD_RESOURCE',
  DataPipeline = 'DATA_PIPELINE',
  Library = 'LIBRARY',
  MachineLearningModel = 'MACHINE_LEARNING_MODEL',
  Other = 'OTHER',
  Service = 'SERVICE',
  UiElement = 'UI_ELEMENT',
  Website = 'WEBSITE'
}

export type DevOpsContainerRelationshipEntityPropertyInput = {
  /**
   * Keys must:
   * * Contain only the characters a-z, A-Z, 0-9, _ and -.
   * * Be no greater than 80 characters long.
   * * Not begin with an underscore.
   */
  key: Scalars['String']['input'];
  /**
   * * Can be no larger than 5KB for all properties for an entity.
   * * Can not be `null`.
   */
  value: Scalars['JSON']['input'];
};

export enum DevOpsDesignStatus {
  None = 'NONE',
  ReadyForDevelopment = 'READY_FOR_DEVELOPMENT',
  Unknown = 'UNKNOWN'
}

export enum DevOpsDesignType {
  Canvas = 'CANVAS',
  File = 'FILE',
  Group = 'GROUP',
  Node = 'NODE',
  Other = 'OTHER',
  Prototype = 'PROTOTYPE'
}

/**  Document Category  */
export enum DevOpsDocumentCategory {
  Archive = 'ARCHIVE',
  Audio = 'AUDIO',
  Code = 'CODE',
  Document = 'DOCUMENT',
  Folder = 'FOLDER',
  Form = 'FORM',
  Image = 'IMAGE',
  Other = 'OTHER',
  Pdf = 'PDF',
  Presentation = 'PRESENTATION',
  Shortcut = 'SHORTCUT',
  Spreadsheet = 'SPREADSHEET',
  Video = 'VIDEO'
}

/**
 * The types of environments that a code change can be released to.
 *
 * The release may be via a code deployment or via a feature flag change.
 */
export enum DevOpsEnvironmentCategory {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum DevOpsMetricsComparisonOperator {
  EqualTo = 'EQUAL_TO',
  GreaterThan = 'GREATER_THAN',
  LessThan = 'LESS_THAN',
  NotEqualTo = 'NOT_EQUAL_TO'
}

export enum DevOpsMetricsCycleTimePhase {
  /** Development phase from initial code commit to deployed code. */
  CommitToDeployment = 'COMMIT_TO_DEPLOYMENT',
  /** Development phase from initial code commit to opened pull request. */
  CommitToPr = 'COMMIT_TO_PR'
}

/** No results will be returned unless an association type is specified. Currently only 'jiraProjectIds' association type is supported. */
export type DevOpsMetricsFilterInput = {
  /** The identifier that indicates which cloud instance this data is to be fetched for. */
  cloudId: Scalars['ID']['input'];
  /** The end dateTime for overall time interval to return results for. The interval is exclusive of this value. */
  endAtExclusive: Scalars['DateTime']['input'];
  /** Issue level filters. Currently, in order to apply this filter, jiraProjectIds must also be provided */
  issueFilters?: InputMaybe<DevOpsMetricsIssueFilters>;
  /** List of Jira projectIds in the given 'cloudId' to fetch metrics for. Max limit of 10. */
  jiraProjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The size of time interval in which to rollup data points in. Default is 1 day.
   * E.g. Count of data over 2 weeks with 1 day resolution means rollup is number of datapoints per day over 2 weeks.
   */
  resolution?: InputMaybe<DevOpsMetricsResolutionInput>;
  /** The start dateTime for overall time interval to return results for. The interval is inclusive of this value. */
  startFromInclusive: Scalars['DateTime']['input'];
  /**
   * The Olson Timezone ID. E.g. 'Australia/Sydney'.
   * Specifies which timezone to aggregate data in so that daylight savings is taken into account if it occurred between request time range.
   */
  timezoneId?: InputMaybe<Scalars['String']['input']>;
};

export type DevOpsMetricsIssueFilters = {
  /**
   * Only issues in these epics will be returned.
   *
   * Note:
   * * If a null ID is included in the list, issues not in epics will be included in the results.
   * * If a subtask's parent issue is in one of the epics, the subtask will also be returned.
   */
  epicIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Only issues of these types will be returned. */
  issueTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** No results will be returned unless an association type is specified. Currently only 'jiraProjectIds' association type is supported. */
export type DevOpsMetricsPerDeploymentMetricsFilter = {
  /** The identifier that indicates which cloud instance this data is to be fetched for. */
  cloudId: Scalars['ID']['input'];
  /** The end dateTime for overall time interval to return results for. The interval is exclusive of this value. */
  endAtExclusive: Scalars['DateTime']['input'];
  /** List of environment categories to filter for - only deployments in these categories will be returned. */
  environmentCategories?: Array<DevOpsEnvironmentCategory>;
  /** List of Jira projectIds in the given 'cloudId' to fetch metrics for. Max limit of 10. */
  jiraProjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The start dateTime for overall time interval to return results for. The interval is inclusive of this value. */
  startFromInclusive: Scalars['DateTime']['input'];
};

/** No results will be returned unless an association type is specified. Currently only 'jiraProjectIds' association type is supported. */
export type DevOpsMetricsPerIssueMetricsFilter = {
  /** The identifier that indicates which cloud instance this data is to be fetched for. */
  cloudId: Scalars['ID']['input'];
  /** The end dateTime for overall time interval to return results for. The interval is exclusive of this value. */
  endAtExclusive: Scalars['DateTime']['input'];
  /** Issue level filters. Currently, in order to apply this filter, jiraProjectIds must also be provided */
  issueFilters?: InputMaybe<DevOpsMetricsIssueFilters>;
  /** List of Jira projectIds in the given 'cloudId' to fetch metrics for. Max limit of 10. */
  jiraProjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The start dateTime for overall time interval to return results for. The interval is inclusive of this value. */
  startFromInclusive: Scalars['DateTime']['input'];
};

/** No results will be returned unless an association type is specified. Currently only 'jiraProjectIds' association type is supported. */
export type DevOpsMetricsPerProjectPrCycleTimeMetricsFilter = {
  /** The identifier that indicates which cloud instance this data is to be fetched for. */
  cloudId: Scalars['ID']['input'];
  /** The end dateTime for overall time interval to return results for. The interval is exclusive of this value. */
  endAtExclusive: Scalars['DateTime']['input'];
  /** List of Jira projectIds in the given 'cloudId' to fetch metrics for. Max limit of 1. */
  jiraProjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The size of time interval in which to rollup data points in. Default is 1 day.
   * E.g. Count of data over 1 week with 1 day resolution means rollup is number of datapoints per day over 1 week.
   */
  resolution?: InputMaybe<DevOpsMetricsResolutionInput>;
  /** The start dateTime for overall time interval to return results for. The interval is inclusive of this value. */
  startFromInclusive: Scalars['DateTime']['input'];
};

export type DevOpsMetricsResolutionInput = {
  /** Input unit for specified resolution value. */
  unit: DevOpsMetricsResolutionUnit;
  /** Input value for resolution specified. */
  value: Scalars['Int']['input'];
};

/** Unit for specified resolution value. */
export enum DevOpsMetricsResolutionUnit {
  Day = 'DAY',
  Hour = 'HOUR',
  Week = 'WEEK'
}

export enum DevOpsMetricsRollupOption {
  Mean = 'MEAN',
  Percentile = 'PERCENTILE'
}

export type DevOpsMetricsRollupType = {
  /** Must only be specified if the rollup kind is PERCENTILE */
  percentile?: InputMaybe<Scalars['Int']['input']>;
  type: DevOpsMetricsRollupOption;
};

export enum DevOpsOperationsIncidentSeverity {
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export enum DevOpsOperationsIncidentStatus {
  Open = 'OPEN',
  Resolved = 'RESOLVED',
  Unknown = 'UNKNOWN'
}

export enum DevOpsPostIncidentReviewStatus {
  Completed = 'COMPLETED',
  InProgress = 'IN_PROGRESS',
  Todo = 'TODO'
}

export enum DevOpsProjectStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  InProgress = 'IN_PROGRESS',
  Paused = 'PAUSED',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export enum DevOpsProjectTargetDateType {
  Day = 'DAY',
  Month = 'MONTH',
  Quarter = 'QUARTER',
  Unknown = 'UNKNOWN'
}

export enum DevOpsProviderNamespace {
  Asap = 'ASAP',
  Classic = 'CLASSIC',
  Forge = 'FORGE',
  Oauth = 'OAUTH'
}

/**
 * Type of a data-depot provider.
 * A provider may belongs to multiple types (e.g an connect-app can send both build and deployment info).
 */
export enum DevOpsProviderType {
  Build = 'BUILD',
  Deployment = 'DEPLOYMENT',
  Design = 'DESIGN',
  DevopsComponents = 'DEVOPS_COMPONENTS',
  DevInfo = 'DEV_INFO',
  Documentation = 'DOCUMENTATION',
  FeatureFlag = 'FEATURE_FLAG',
  Operations = 'OPERATIONS',
  Project = 'PROJECT',
  RemoteLinks = 'REMOTE_LINKS',
  Security = 'SECURITY'
}

export enum DevOpsPullRequestApprovalStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  Unapproved = 'UNAPPROVED'
}

export enum DevOpsPullRequestStatus {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum DevOpsRelationshipCertainty {
  /** The relationship was created by a user. */
  Explicit = 'EXPLICIT',
  /** The relationship was inferred by a system. */
  Implicit = 'IMPLICIT'
}

export enum DevOpsRelationshipCertaintyFilter {
  /** Return all relationships. */
  All = 'ALL',
  /** Return only relationships created by a user. */
  Explicit = 'EXPLICIT',
  /** Return only relationships inferred by a system. */
  Implicit = 'IMPLICIT'
}

/** #################### Enums ##################### */
export enum DevOpsRepositoryHostingProviderFilter {
  All = 'ALL',
  BitbucketCloud = 'BITBUCKET_CLOUD',
  ThirdParty = 'THIRD_PARTY'
}

export enum DevOpsSecurityVulnerabilitySeverity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  Unknown = 'UNKNOWN'
}

export enum DevOpsSecurityVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

/** #################### Filtering and Sorting Inputs ##################### */
export type DevOpsServiceAndJiraProjectRelationshipFilter = {
  /** Include only relationships with the specified certainty */
  certainty?: InputMaybe<DevOpsRelationshipCertaintyFilter>;
  /** Include only relationships with the specified relationship type */
  relationshipTypeIn?: InputMaybe<Array<DevOpsServiceAndJiraProjectRelationshipType>>;
};

export enum DevOpsServiceAndJiraProjectRelationshipType {
  /** A relationship created for the change management feature */
  ChangeManagement = 'CHANGE_MANAGEMENT',
  /** A standard relationship */
  Default = 'DEFAULT'
}

export type DevOpsServiceAndRepositoryRelationshipFilter = {
  /** Include only relationships with the specified certainty */
  certainty?: InputMaybe<DevOpsRelationshipCertaintyFilter>;
  /** Include only relationships with the specified repository hosting provider type */
  hostingProvider?: InputMaybe<DevOpsRepositoryHostingProviderFilter>;
  /**
   * Include only relationships with all of the specified property keys.
   * If this is omitted, no filtering by 'all property keys' is applied.
   */
  withAllPropertyKeys?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type DevOpsServiceAndRepositoryRelationshipSort = {
  /** The field to apply sorting on */
  by: DevOpsServiceAndRepositoryRelationshipSortBy;
  /** The direction of sorting */
  order?: SortDirection;
};

export enum DevOpsServiceAndRepositoryRelationshipSortBy {
  LastInferredAt = 'LAST_INFERRED_AT'
}

/** The request input for DevOps Service Entity Property */
export type DevOpsServiceEntityPropertyInput = {
  /**
   * Keys must:
   * * Contain only the characters a-z, A-Z, 0-9, _ and -
   * * Be no greater than 80 characters long
   * * Not begin with an underscore
   */
  key: Scalars['String']['input'];
  /**
   * * Can be no larger than 5KB for all properties for an entity
   * * Can not be `null`
   */
  value: Scalars['JSON']['input'];
};

/** #################### Enums ##################### */
export enum DevOpsServiceRelationshipType {
  Contains = 'CONTAINS',
  DependsOn = 'DEPENDS_ON'
}

export type DevOpsServiceTierInput = {
  level: Scalars['Int']['input'];
};

export type DevOpsServiceTypeInput = {
  key: Scalars['String']['input'];
};

/** The filtering input for retrieving services. tierLevelIn must not be empty if provided. */
export type DevOpsServicesFilterInput = {
  /** Case insensitive string to filter service names with */
  nameContains?: InputMaybe<Scalars['String']['input']>;
  /** Integer numbers to filter service tier levels with */
  tierLevelIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export enum DevStatusActivity {
  BranchOpen = 'BRANCH_OPEN',
  Commit = 'COMMIT',
  Deployment = 'DEPLOYMENT',
  Design = 'DESIGN',
  PrDeclined = 'PR_DECLINED',
  PrMerged = 'PR_MERGED',
  PrOpen = 'PR_OPEN'
}

export enum DistributionStatus {
  Development = 'DEVELOPMENT',
  Public = 'PUBLIC'
}

export enum DocumentRepresentation {
  AtlasDocFormat = 'ATLAS_DOC_FORMAT',
  Html = 'HTML',
  Storage = 'STORAGE',
  View = 'VIEW'
}

export enum EcosystemAppInstallationConfigIdType {
  Cloud = 'CLOUD',
  /**  Config applies to all installations belonging to a specific site (cloud ID) */
  Installation = 'INSTALLATION'
}

export type EcosystemAppInstallationOverridesInput = {
  /**
   * Override the license mode for the installation.
   * This is used for app developers to test the app behaviour in different license modes.
   * This field is only allowed by Forge CLI for non-production environments.
   * This field will only be accepted when the user agent is Forge CLI
   */
  licenseModes?: InputMaybe<Array<EcosystemLicenseMode>>;
  /**
   * Set the user with access when the license mode is 'USER_ACCESS'.
   * This field is only allowed when licenseMode='USER_ACCESS'.
   * This is a temporary field to support the license mode 'USER_ACCESS'. It will be removed
   * after user access configuration is supported in Admin Hub.
   * See https://hello.atlassian.net/wiki/spaces/ECON/pages/4352978134/RFC+How+will+developers+test+license+de-coupling+in+their+apps?focusedCommentId=4365058508
   * We can clean up once https://hello.jira.atlassian.cloud/browse/COMMIT-12345 is delivered and the 6-month deprecation period is over.
   */
  usersWithAccess?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum EcosystemAppNetworkPermissionType {
  Connect = 'CONNECT'
}

export type EcosystemAppsInstalledInContextsFilter = {
  type: EcosystemAppsInstalledInContextsFilterType;
  values: Array<Scalars['String']['input']>;
};

export enum EcosystemAppsInstalledInContextsFilterType {
  /**
   * Only supports one name in the values list for now, otherwise will fail
   * validation.
   */
  Name = 'NAME',
  /**
   * Returns apps filtered by the ARIs passed in the values list, as an exact match with its id
   * or the ARI generated from its latest migration keys for harmonised apps
   */
  OnlyAppIds = 'ONLY_APP_IDS'
}

export type EcosystemAppsInstalledInContextsOptions = {
  groupByBaseApp?: InputMaybe<Scalars['Boolean']['input']>;
  shouldExcludeFirstPartyApps?: InputMaybe<Scalars['Boolean']['input']>;
  shouldIncludePrivateApps?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EcosystemAppsInstalledInContextsOrderBy = {
  direction: SortDirection;
  sortKey: EcosystemAppsInstalledInContextsSortKey;
};

export enum EcosystemAppsInstalledInContextsSortKey {
  Name = 'NAME',
  RelatedApps = 'RELATED_APPS'
}

/** Input payload to set global controls for installations. Multiple controls can be set at a given time. */
export type EcosystemGlobalInstallationConfigInput = {
  cloudId: Scalars['ID']['input'];
  config: Array<EcosystemGlobalInstallationOverrideInput>;
};

export type EcosystemGlobalInstallationOverrideInput = {
  key: EcosystemGlobalInstallationOverrideKeys;
  value: Scalars['Boolean']['input'];
};

export enum EcosystemGlobalInstallationOverrideKeys {
  AllowEgressAnalytics = 'ALLOW_EGRESS_ANALYTICS',
  AllowLlmCapability = 'ALLOW_LLM_CAPABILITY',
  AllowLogsAccess = 'ALLOW_LOGS_ACCESS',
  AllowRestApis = 'ALLOW_REST_APIS'
}

/**  this can be extended to support non-boolean config in future */
export type EcosystemInstallationConfigInput = {
  overrides: Array<EcosystemInstallationOverrides>;
};

export enum EcosystemInstallationOverrideKeys {
  AllowEgressAnalytics = 'ALLOW_EGRESS_ANALYTICS',
  AllowLlmCapability = 'ALLOW_LLM_CAPABILITY',
  AllowRestApis = 'ALLOW_REST_APIS'
}

export type EcosystemInstallationOverrides = {
  key: EcosystemInstallationOverrideKeys;
  value: Scalars['Boolean']['input'];
};

export enum EcosystemLicenseMode {
  UserAccess = 'USER_ACCESS'
}

export type EcosystemMarketplaceAppVersionFilter = {
  cloudAppVersionId?: InputMaybe<Scalars['ID']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
};

export enum EcosystemMarketplaceListingStatus {
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  ReadyToLaunch = 'READY_TO_LAUNCH',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED'
}

export enum EcosystemMarketplacePaymentModel {
  Free = 'FREE',
  PaidViaAtlassian = 'PAID_VIA_ATLASSIAN',
  PaidViaPartner = 'PAID_VIA_PARTNER'
}

export enum EcosystemRequiredProduct {
  Compass = 'COMPASS',
  Confluence = 'CONFLUENCE',
  Jira = 'JIRA'
}

export type EcosystemUpdateInstallationDetailsInput = {
  config: EcosystemInstallationConfigInput;
  id: Scalars['ID']['input'];
};

export type EcosystemUpdateInstallationRemoteRegionInput = {
  /** A flag to enable the cleaning of a region. If remoteInstallationRegion needs to be cleaned up by an undefined value, set allowCleanRegion to true */
  allowCleanRegion?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique Id representing the installationId */
  installationId: Scalars['ID']['input'];
  /** A new remoteInstallationRegion to be updated. If remoteInstallationRegion is not provided, it will be removed for an installation */
  remoteInstallationRegion?: InputMaybe<Scalars['String']['input']>;
};

/** Edit sprint */
export type EditSprintInput = {
  boardId: Scalars['ID']['input'];
  endDate?: InputMaybe<Scalars['String']['input']>;
  goal?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  sprintId: Scalars['ID']['input'];
  startDate?: InputMaybe<Scalars['String']['input']>;
};

export enum EditionValue {
  Advanced = 'ADVANCED',
  Standard = 'STANDARD'
}

export enum EditorConversionSetting {
  None = 'NONE',
  Supported = 'SUPPORTED'
}

export type EditorDraftSyncInput = {
  contentId: Scalars['ID']['input'];
  doSetRelations?: InputMaybe<Scalars['Boolean']['input']>;
  latestAdf?: InputMaybe<Scalars['String']['input']>;
  ncsStepVersion?: InputMaybe<Scalars['Int']['input']>;
};

export type EnabledContentTypesInput = {
  isBlogsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isDatabasesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isEmbedsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isFoldersEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isLivePagesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isWhiteboardsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EnabledFeaturesInput = {
  isAnalyticsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isAppsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isAutomationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isCalendarsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isContentManagerEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isQuestionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isShortcutsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum Environment {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING'
}

export enum EstimationType {
  CustomNumberField = 'CUSTOM_NUMBER_FIELD',
  IssueCount = 'ISSUE_COUNT',
  OriginalEstimate = 'ORIGINAL_ESTIMATE',
  StoryPoints = 'STORY_POINTS'
}

export enum ExperienceEventType {
  Custom = 'CUSTOM',
  Database = 'DATABASE',
  InlineResult = 'INLINE_RESULT',
  PageLoad = 'PAGE_LOAD',
  PageSegmentLoad = 'PAGE_SEGMENT_LOAD',
  WebVitals = 'WEB_VITALS'
}

export type ExtensionContextsFilter = {
  type: ExtensionContextsFilterType;
  value: Array<Scalars['String']['input']>;
};

export enum ExtensionContextsFilterType {
  /** Filters extensions by App ID and Environment ID. Format is 'appId:environmentId'. */
  AppIdEnvironmentId = 'APP_ID_ENVIRONMENT_ID',
  DataClassificationTag = 'DATA_CLASSIFICATION_TAG',
  /**  Filters extensions by Definition ID.  */
  DefinitionId = 'DEFINITION_ID',
  ExtensionType = 'EXTENSION_TYPE',
  /** Filters extensions by principal type. Supported values are: 'unlicensed', 'customer', 'anonymous'. */
  PrincipalType = 'PRINCIPAL_TYPE'
}

/**
 * Details about an extension.
 *
 * This information is used to look up the extension within CaaS so that the
 * correct function can be resolved.
 *
 * This will eventually be superseded by an Id.
 */
export type ExtensionDetailsInput = {
  /** The definition identifier as provided by CaaS */
  definitionId: Scalars['ID']['input'];
  /** The extension key as provided by CaaS */
  extensionKey: Scalars['String']['input'];
};

export enum ExternalApprovalStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  Unapproved = 'UNAPPROVED'
}

export enum ExternalAttendeeRsvpStatus {
  Accepted = 'ACCEPTED',
  Declined = 'DECLINED',
  NotResponded = 'NOT_RESPONDED',
  Other = 'OTHER',
  TenativelyAccepted = 'TENATIVELY_ACCEPTED'
}

export type ExternalAuthCredentialsInput = {
  /** The oAuth Client Id */
  clientId?: InputMaybe<Scalars['ID']['input']>;
  /** The shared secret */
  clientSecret?: InputMaybe<Scalars['String']['input']>;
};

export enum ExternalBuildState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum ExternalChangeType {
  Added = 'ADDED',
  Copied = 'COPIED',
  Deleted = 'DELETED',
  Modified = 'MODIFIED',
  Moved = 'MOVED',
  Unknown = 'UNKNOWN'
}

export enum ExternalCollaboratorsSortField {
  Name = 'NAME'
}

export type ExternalCollaboratorsSortType = {
  field?: InputMaybe<ExternalCollaboratorsSortField>;
  isAscending?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum ExternalCommentReactionType {
  Like = 'LIKE'
}

export enum ExternalCommitFlags {
  MergeCommit = 'MERGE_COMMIT'
}

export enum ExternalConversationType {
  Channel = 'CHANNEL',
  DirectMessage = 'DIRECT_MESSAGE',
  GroupDirectMessage = 'GROUP_DIRECT_MESSAGE',
  GroupMeeting = 'GROUP_MEETING'
}

export enum ExternalDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum ExternalDesignStatus {
  None = 'NONE',
  ReadyForDevelopment = 'READY_FOR_DEVELOPMENT',
  Unknown = 'UNKNOWN'
}

export enum ExternalDesignType {
  Canvas = 'CANVAS',
  File = 'FILE',
  Group = 'GROUP',
  Node = 'NODE',
  Other = 'OTHER',
  Prototype = 'PROTOTYPE'
}

export enum ExternalDocumentCategory {
  Archive = 'ARCHIVE',
  Audio = 'AUDIO',
  Blogpost = 'BLOGPOST',
  Code = 'CODE',
  Document = 'DOCUMENT',
  Folder = 'FOLDER',
  Form = 'FORM',
  Image = 'IMAGE',
  Notebook = 'NOTEBOOK',
  Other = 'OTHER',
  Page = 'PAGE',
  Pdf = 'PDF',
  Presentation = 'PRESENTATION',
  Shortcut = 'SHORTCUT',
  Spreadsheet = 'SPREADSHEET',
  Video = 'VIDEO',
  WebPage = 'WEB_PAGE'
}

export enum ExternalEnvironmentType {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum ExternalEventType {
  Appointment = 'APPOINTMENT',
  Birthday = 'BIRTHDAY',
  Default = 'DEFAULT',
  Event = 'EVENT',
  FocusTime = 'FOCUS_TIME',
  OutOfOffice = 'OUT_OF_OFFICE',
  Reminder = 'REMINDER',
  Task = 'TASK',
  WorkingLocation = 'WORKING_LOCATION'
}

export enum ExternalMembershipType {
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  Shared = 'SHARED'
}

export enum ExternalPullRequestStatus {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum ExternalSpaceSubtype {
  Business = 'BUSINESS',
  Drive = 'DRIVE',
  Project = 'PROJECT',
  ServiceDesk = 'SERVICE_DESK',
  Site = 'SITE',
  Software = 'SOFTWARE',
  Space = 'SPACE'
}

export enum ExternalVulnerabilitySeverityLevel {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  Unknown = 'UNKNOWN'
}

export enum ExternalVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum ExternalVulnerabilityType {
  Dast = 'DAST',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export enum ExternalWorkItemSubtype {
  Approval = 'APPROVAL',
  Bug = 'BUG',
  DefaultTask = 'DEFAULT_TASK',
  Epic = 'EPIC',
  Incident = 'INCIDENT',
  Issue = 'ISSUE',
  Milestone = 'MILESTONE',
  Other = 'OTHER',
  Problem = 'PROBLEM',
  Question = 'QUESTION',
  Section = 'SECTION',
  Story = 'STORY',
  Task = 'TASK',
  WorkItem = 'WORK_ITEM'
}

export type FaviconFileInput = {
  fileStoreId: Scalars['ID']['input'];
  filename: Scalars['String']['input'];
};

export type FavouritePageInput = {
  pageId: Scalars['ID']['input'];
};

export enum FeedEventType {
  Comment = 'COMMENT',
  Create = 'CREATE',
  Edit = 'EDIT',
  Editlive = 'EDITLIVE',
  Publishlive = 'PUBLISHLIVE'
}

export enum FeedItemSourceType {
  Person = 'PERSON',
  Space = 'SPACE'
}

export enum FeedType {
  Direct = 'DIRECT',
  Following = 'FOLLOWING',
  Popular = 'POPULAR'
}

export type FollowUserInput = {
  accountId: Scalars['String']['input'];
};

export type ForgeAlertsActivityLogsInput = {
  alertId: Scalars['Int']['input'];
};

export enum ForgeAlertsAlertActivityType {
  AlertClosed = 'ALERT_CLOSED',
  AlertOpen = 'ALERT_OPEN',
  EmailSent = 'EMAIL_SENT',
  SeverityUpdated = 'SEVERITY_UPDATED'
}

export type ForgeAlertsChartDetailsInput = {
  environment: Scalars['String']['input'];
  filters?: InputMaybe<Array<ForgeAlertsRuleFilters>>;
  interval?: InputMaybe<ForgeAlertsQueryIntervalInput>;
  metric: ForgeAlertsRuleMetricType;
  period?: InputMaybe<Scalars['Int']['input']>;
};

export type ForgeAlertsCreateRuleInput = {
  conditions: Array<ForgeAlertsRuleConditions>;
  description?: InputMaybe<Scalars['String']['input']>;
  envId: Scalars['String']['input'];
  filters?: InputMaybe<Array<ForgeAlertsRuleFilters>>;
  metric: ForgeAlertsRuleMetricType;
  name: Scalars['String']['input'];
  period: Scalars['Int']['input'];
  responders: Array<Scalars['String']['input']>;
  runbook?: InputMaybe<Scalars['String']['input']>;
  tolerance?: InputMaybe<Scalars['Int']['input']>;
};

export type ForgeAlertsDeleteRuleInput = {
  ruleId: Scalars['ID']['input'];
};

export enum ForgeAlertsListOrderByColumns {
  AlertId = 'alertId',
  ClosedAt = 'closedAt',
  CreatedAt = 'createdAt',
  Duration = 'duration',
  Severity = 'severity'
}

export enum ForgeAlertsListOrderOptions {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type ForgeAlertsListQueryInput = {
  closedAtEndDate?: InputMaybe<Scalars['String']['input']>;
  closedAtStartDate?: InputMaybe<Scalars['String']['input']>;
  createdAtEndDate?: InputMaybe<Scalars['String']['input']>;
  createdAtStartDate?: InputMaybe<Scalars['String']['input']>;
  limit: Scalars['Int']['input'];
  order: ForgeAlertsListOrderOptions;
  orderBy: ForgeAlertsListOrderByColumns;
  page: Scalars['Int']['input'];
  responders?: InputMaybe<Array<Scalars['String']['input']>>;
  ruleId?: InputMaybe<Scalars['ID']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  severities?: InputMaybe<Array<ForgeAlertsRuleSeverity>>;
  status?: InputMaybe<ForgeAlertsStatus>;
};

export enum ForgeAlertsMetricsDataType {
  DateTime = 'DATE_TIME'
}

export enum ForgeAlertsMetricsResolutionUnit {
  Day = 'DAY',
  Hours = 'HOURS',
  Minutes = 'MINUTES'
}

export type ForgeAlertsQueryIntervalInput = {
  end: Scalars['String']['input'];
  start: Scalars['String']['input'];
};

export enum ForgeAlertsRuleActivityAction {
  Created = 'CREATED',
  Deleted = 'DELETED',
  Disabled = 'DISABLED',
  Enabled = 'ENABLED',
  Updated = 'UPDATED'
}

export type ForgeAlertsRuleActivityLogsInput = {
  action?: InputMaybe<Array<InputMaybe<ForgeAlertsRuleActivityAction>>>;
  actor?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  endTime: Scalars['String']['input'];
  limit: Scalars['Int']['input'];
  page: Scalars['Int']['input'];
  ruleIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  startTime: Scalars['String']['input'];
};

export type ForgeAlertsRuleConditions = {
  severity: ForgeAlertsRuleSeverity;
  threshold: Scalars['String']['input'];
  when: ForgeAlertsRuleWhenConditions;
};

export enum ForgeAlertsRuleFilterActions {
  Exclude = 'EXCLUDE',
  Include = 'INCLUDE'
}

export enum ForgeAlertsRuleFilterDimensions {
  ErrorTypes = 'ERROR_TYPES',
  Functions = 'FUNCTIONS',
  Sites = 'SITES',
  Versions = 'VERSIONS'
}

export type ForgeAlertsRuleFilters = {
  action: ForgeAlertsRuleFilterActions;
  dimension: ForgeAlertsRuleFilterDimensions;
  value: Array<Scalars['String']['input']>;
};

export type ForgeAlertsRuleFiltersInput = {
  environment: Scalars['String']['input'];
};

export enum ForgeAlertsRuleMetricType {
  InvocationCount = 'INVOCATION_COUNT',
  InvocationErrors = 'INVOCATION_ERRORS',
  InvocationLatency = 'INVOCATION_LATENCY',
  InvocationSuccessRate = 'INVOCATION_SUCCESS_RATE'
}

export enum ForgeAlertsRuleSeverity {
  Critical = 'CRITICAL',
  Major = 'MAJOR',
  Minor = 'MINOR'
}

export enum ForgeAlertsRuleWhenConditions {
  Above = 'ABOVE',
  AboveOrEqualTo = 'ABOVE_OR_EQUAL_TO',
  Below = 'BELOW',
  BelowOrEqualTo = 'BELOW_OR_EQUAL_TO'
}

export enum ForgeAlertsStatus {
  Closed = 'CLOSED',
  Open = 'OPEN'
}

export type ForgeAlertsUpdateRuleInput = {
  input: ForgeAlertsUpdateRuleInputType;
  ruleId: Scalars['ID']['input'];
};

export type ForgeAlertsUpdateRuleInputType = {
  conditions?: InputMaybe<Array<ForgeAlertsRuleConditions>>;
  description?: InputMaybe<Scalars['String']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  filters?: InputMaybe<Array<ForgeAlertsRuleFilters>>;
  metric?: InputMaybe<ForgeAlertsRuleMetricType>;
  name?: InputMaybe<Scalars['String']['input']>;
  period?: InputMaybe<Scalars['Int']['input']>;
  responders?: InputMaybe<Array<Scalars['String']['input']>>;
  runbook?: InputMaybe<Scalars['String']['input']>;
  tolerance?: InputMaybe<Scalars['Int']['input']>;
};

export enum ForgeAuditLogsActionType {
  ContributorAdded = 'CONTRIBUTOR_ADDED',
  ContributorRemoved = 'CONTRIBUTOR_REMOVED',
  ContributorRoleUpdated = 'CONTRIBUTOR_ROLE_UPDATED',
  OwnershipTransferred = 'OWNERSHIP_TRANSFERRED'
}

export type ForgeAuditLogsDaResQueryInput = {
  endTime?: InputMaybe<Scalars['String']['input']>;
  startTime?: InputMaybe<Scalars['String']['input']>;
};

export enum ForgeAuditLogsFeatureFlagsActionType {
  FeatureFlagCreated = 'FEATURE_FLAG_CREATED',
  FeatureFlagDeleted = 'FEATURE_FLAG_DELETED',
  FeatureFlagToggled = 'FEATURE_FLAG_TOGGLED',
  FeatureFlagUpdated = 'FEATURE_FLAG_UPDATED'
}

export type ForgeAuditLogsFeatureFlagsQueryInput = {
  action?: InputMaybe<ForgeAuditLogsFeatureFlagsActionType>;
  /** pagination related params */
  after?: InputMaybe<Scalars['String']['input']>;
  endTime?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  flagId: Scalars['ID']['input'];
  startTime?: InputMaybe<Scalars['String']['input']>;
};

export type ForgeAuditLogsQueryInput = {
  actions?: InputMaybe<Array<ForgeAuditLogsActionType>>;
  after?: InputMaybe<Scalars['String']['input']>;
  contributorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  endTime?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  startTime?: InputMaybe<Scalars['String']['input']>;
};

export enum ForgeMetricsApiRequestGroupByDimensions {
  ContextAri = 'CONTEXT_ARI',
  Status = 'STATUS',
  Url = 'URL'
}

export type ForgeMetricsApiRequestQueryFilters = {
  apiRequestType?: InputMaybe<ForgeMetricsApiRequestType>;
  contextAris?: InputMaybe<Array<Scalars['ID']['input']>>;
  contexts?: InputMaybe<Array<ForgeMetricsContexts>>;
  environment: Scalars['ID']['input'];
  interval: ForgeMetricsIntervalInput;
  status?: InputMaybe<ForgeMetricsApiRequestStatus>;
  urls?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type ForgeMetricsApiRequestQueryInput = {
  filters: ForgeMetricsApiRequestQueryFilters;
  groupBy?: InputMaybe<Array<ForgeMetricsApiRequestGroupByDimensions>>;
};

export enum ForgeMetricsApiRequestStatus {
  '2Xx' = '_2XX',
  '4Xx' = '_4XX',
  '5Xx' = '_5XX'
}

export enum ForgeMetricsApiRequestType {
  Cache = 'CACHE',
  External = 'EXTERNAL',
  Product = 'PRODUCT',
  Sql = 'SQL'
}

export enum ForgeMetricsContexts {
  Compass = 'COMPASS',
  Confluence = 'CONFLUENCE',
  Graph = 'GRAPH',
  Jira = 'JIRA'
}

export type ForgeMetricsCustomCreateQueryInput = {
  customMetricName: Scalars['String']['input'];
  description: Scalars['String']['input'];
};

export type ForgeMetricsCustomDeleteQueryInput = {
  nodeId: Scalars['ID']['input'];
};

export enum ForgeMetricsCustomGroupByDimensions {
  CustomMetricName = 'CUSTOM_METRIC_NAME'
}

export type ForgeMetricsCustomQueryFilters = {
  /**
   * List of appVersions to be filtered by.
   * E.g.: ["8.1.0", "2.7.0"]
   * If the appVersions is omitted or provided as an empty list, no filtering on app versions will be applied.
   */
  appVersions?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * List of ARIs to filter metrics by
   * E.g.: ["ari:cloud:jira::site/{siteId}", ...]
   */
  contextAris?: InputMaybe<Array<Scalars['ID']['input']>>;
  environment?: InputMaybe<Scalars['ID']['input']>;
  /**
   * List of function names to be filtered by.
   * E.g.: ["functionA", "functionB"]
   * If the functionNames is omitted or provided as an empty list, no filtering on function names will be applied.
   */
  functionNames?: InputMaybe<Array<Scalars['String']['input']>>;
  interval: ForgeMetricsIntervalInput;
};

export type ForgeMetricsCustomQueryInput = {
  filters: ForgeMetricsCustomQueryFilters;
  groupBy?: InputMaybe<Array<ForgeMetricsCustomGroupByDimensions>>;
};

export type ForgeMetricsCustomUpdateQueryInput = {
  customMetricName?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  nodeId: Scalars['ID']['input'];
};

export enum ForgeMetricsDataType {
  Category = 'CATEGORY',
  DateTime = 'DATE_TIME',
  Numeric = 'NUMERIC'
}

export enum ForgeMetricsGroupByDimensions {
  ContextAri = 'CONTEXT_ARI',
  EnvironmentId = 'ENVIRONMENT_ID',
  ErrorType = 'ERROR_TYPE',
  Function = 'FUNCTION',
  UserTier = 'USER_TIER',
  Version = 'VERSION'
}

export type ForgeMetricsIntervalInput = {
  end: Scalars['DateTime']['input'];
  /** "start" and "end" are ISO-8601 formatted timestamps */
  start: Scalars['DateTime']['input'];
};

export type ForgeMetricsInvocationLatencySummaryQueryFilters = {
  contextAris?: InputMaybe<Array<Scalars['ID']['input']>>;
  contexts?: InputMaybe<Array<ForgeMetricsContexts>>;
  environment: Scalars['ID']['input'];
  functionNames?: InputMaybe<Array<Scalars['String']['input']>>;
  interval: ForgeMetricsIntervalInput;
};

export type ForgeMetricsInvocationLatencySummaryQueryInput = {
  filters: ForgeMetricsInvocationLatencySummaryQueryFilters;
  groupBy?: InputMaybe<Array<ForgeMetricsGroupByDimensions>>;
};

export enum ForgeMetricsLabels {
  ForgeApiRequestCount = 'FORGE_API_REQUEST_COUNT',
  ForgeApiRequestLatency = 'FORGE_API_REQUEST_LATENCY',
  ForgeBackendInvocationCount = 'FORGE_BACKEND_INVOCATION_COUNT',
  ForgeBackendInvocationErrors = 'FORGE_BACKEND_INVOCATION_ERRORS',
  ForgeBackendInvocationLatency = 'FORGE_BACKEND_INVOCATION_LATENCY'
}

export type ForgeMetricsLatencyBucketsQueryFilters = {
  /**
   * List of ARIs to filter metrics by
   * E.g.: ["ari:cloud:jira::site/{siteId}", ...]
   */
  contextAris?: InputMaybe<Array<Scalars['ID']['input']>>;
  contexts?: InputMaybe<Array<ForgeMetricsContexts>>;
  environment?: InputMaybe<Scalars['ID']['input']>;
  /**
   * List of function names to be filtered by.
   * E.g.: ["functionA", "functionB"]
   * If the functionNames is omitted or provided as an empty list, no filtering on function names will be applied.
   */
  functionNames?: InputMaybe<Array<Scalars['String']['input']>>;
  interval: ForgeMetricsIntervalInput;
};

export type ForgeMetricsLatencyBucketsQueryInput = {
  filters: ForgeMetricsLatencyBucketsQueryFilters;
  groupBy?: InputMaybe<Array<ForgeMetricsGroupByDimensions>>;
};

export type ForgeMetricsOtlpQueryFilters = {
  environments: Array<Scalars['ID']['input']>;
  interval: ForgeMetricsIntervalInput;
  metrics: Array<ForgeMetricsLabels>;
};

export type ForgeMetricsOtlpQueryInput = {
  filters: ForgeMetricsOtlpQueryFilters;
};

export type ForgeMetricsQueryFilters = {
  /**
   * List of ARIs to filter metrics by
   * E.g.: ["ari:cloud:jira::site/{siteId}", ...]
   */
  contextAris?: InputMaybe<Array<Scalars['ID']['input']>>;
  contexts?: InputMaybe<Array<ForgeMetricsContexts>>;
  environment?: InputMaybe<Scalars['ID']['input']>;
  interval: ForgeMetricsIntervalInput;
};

export type ForgeMetricsQueryInput = {
  filters: ForgeMetricsQueryFilters;
  groupBy?: InputMaybe<Array<ForgeMetricsGroupByDimensions>>;
};

export enum ForgeMetricsResolutionUnit {
  Hours = 'HOURS',
  Minutes = 'MINUTES'
}

export enum ForgeMetricsSiteFilterCategory {
  All = 'ALL',
  HighestInvocationCount = 'HIGHEST_INVOCATION_COUNT',
  HighestNumberOfErrors = 'HIGHEST_NUMBER_OF_ERRORS',
  HighestNumberOfUsers = 'HIGHEST_NUMBER_OF_USERS',
  LowestSuccessRate = 'LOWEST_SUCCESS_RATE'
}

export enum FormStatus {
  Approved = 'APPROVED',
  Rejected = 'REJECTED',
  Saved = 'SAVED',
  Submitted = 'SUBMITTED'
}

export type FortifiedMetricsIntervalInput = {
  /** The end of the interval. Inclusive. */
  end: Scalars['DateTime']['input'];
  /** The start of the interval. Inclusive. */
  start: Scalars['DateTime']['input'];
};

export type FortifiedMetricsQueryFilters = {
  /** The interval to query metrics for. */
  interval: FortifiedMetricsIntervalInput;
};

export type FortifiedMetricsQueryInput = {
  filters: FortifiedMetricsQueryFilters;
};

export enum FortifiedMetricsResolutionUnit {
  Hours = 'HOURS',
  Minutes = 'MINUTES'
}

/** Which type of trigger */
export enum FunctionTriggerType {
  Frontend = 'FRONTEND',
  Manual = 'MANUAL',
  Product = 'PRODUCT',
  Web = 'WEB'
}

export enum GlanceEnvironment {
  Dev = 'DEV',
  Prod = 'PROD',
  Staging = 'STAGING'
}

export type GlobalInstallationConfigFilter = {
  keys: Array<EcosystemGlobalInstallationOverrideKeys>;
};

export enum GrantCheckProduct {
  Compass = 'COMPASS',
  Confluence = 'CONFLUENCE',
  Feedback = 'FEEDBACK',
  Jira = 'JIRA',
  JiraServicedesk = 'JIRA_SERVICEDESK',
  Mercury = 'MERCURY',
  /** Don't check whether a user has been granted access to a specific site(cloudId) */
  NoGrantChecks = 'NO_GRANT_CHECKS',
  Townsquare = 'TOWNSQUARE'
}

export type GrantContentAccessInput = {
  accessType: AccessType;
  accountIdOrUsername: Scalars['String']['input'];
  contentId: Scalars['String']['input'];
};

export type GraphCreateIncidentAssociatedPostIncidentReviewLinkInput = {
  /** An ARI of any of the following: [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following: [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphCreateIncidentHasActionItemInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphCreateIncidentLinkedJswIssueInput = {
  /** An ARI of any of the following: [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphCreateIssueAssociatedDesignInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:design */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphCreateIssueAssociatedPrInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:pull-request */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export enum GraphCreateMetadataProjectAssociatedBuildJiraBuildOutputBuildStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataProjectAssociatedDeploymentJiraDeploymentOutputDeploymentStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataProjectAssociatedDeploymentJiraDeploymentOutputEnvironmentTypeEnum {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum GraphCreateMetadataProjectAssociatedPrJiraPullRequestOutputPullRequestStatusEnum {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataProjectAssociatedPrJiraPullRequestOutputReviewerReviewerStatusEnum {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphCreateMetadataProjectAssociatedVulnerabilityJiraVulnerabilityOutputVulnerabilitySeverityEnum {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataProjectAssociatedVulnerabilityJiraVulnerabilityOutputVulnerabilityStatusEnum {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataProjectAssociatedVulnerabilityJiraVulnerabilityOutputVulnerabilityTypeEnum {
  Dast = 'DAST',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataSprintAssociatedBuildJiraBuildOutputBuildStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataSprintAssociatedDeploymentJiraDeploymentOutputDeploymentStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataSprintAssociatedPrJiraPullRequestOutputPullRequestStatusEnum {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataSprintAssociatedPrJiraPullRequestOutputReviewerReviewerStatusEnum {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphCreateMetadataSprintAssociatedVulnerabilityJiraVulnerabilityOutputVulnerabilitySeverityEnum {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataSprintAssociatedVulnerabilityJiraVulnerabilityOutputVulnerabilityStatusEnum {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphCreateMetadataSprintAssociatedVulnerabilityOutputStatusCategoryEnum {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphCreateMetadataSprintContainsIssueInput = {
  issueLastUpdatedOn?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphCreateMetadataSprintContainsIssueJiraIssueInput = {
  assigneeAri?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInputAri>;
  creatorAri?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInputAri>;
  issueAri?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInputAri>;
  reporterAri?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInputAri>;
  statusAri?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInputAri>;
  statusCategory?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInputStatusCategoryEnum>;
};

export type GraphCreateMetadataSprintContainsIssueJiraIssueInputAri = {
  value?: InputMaybe<Scalars['String']['input']>;
};

export enum GraphCreateMetadataSprintContainsIssueJiraIssueInputStatusCategoryEnum {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export enum GraphCreateMetadataSprintContainsIssueJiraIssueOutputStatusCategoryEnum {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphCreateParentDocumentHasChildDocumentInput = {
  /** An ARI of type ati:cloud:jira:document */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:document */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphCreateSprintContainsIssueInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  relationshipMetadata?: InputMaybe<GraphCreateMetadataSprintContainsIssueInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  toMetadata?: InputMaybe<GraphCreateMetadataSprintContainsIssueJiraIssueInput>;
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphCreateSprintRetrospectivePageInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

/**
 * ===========================
 * Mutation Input Types
 * ===========================
 */
export type GraphIntegrationActionAdminManagementActionConfigurationInput = {
  /** The action ARI */
  actionId: Scalars['ID']['input'];
  /**
   * The status of the Action.
   * If not provided, the status will not be updated.
   */
  status?: InputMaybe<GraphIntegrationActionAdminManagementActionStatus>;
};

export enum GraphIntegrationActionAdminManagementActionStatus {
  Allow = 'ALLOW',
  Deny = 'DENY',
  NewActionAllow = 'NEW_ACTION_ALLOW'
}

export type GraphIntegrationActionAdminManagementUpdateActionConfigurationInput = {
  /** A list of Action configurations to update. */
  actionConfigurations: Array<GraphIntegrationActionAdminManagementActionConfigurationInput>;
  /** The context ARI where the operation is being performed, currently only support site ARI. */
  contextAri: Scalars['ID']['input'];
  /** The presented 3P product (3P App) ARI */
  productAri: Scalars['ID']['input'];
};

/** Input for adding a TWG capability container to a context */
export type GraphIntegrationAddTwgCapabilityContainerInput = {
  /** Context ARI (site ARI) where the TWG capability container should be added */
  contextAri: Scalars['ID']['input'];
  /** Product ARI of the TWG capability container to add */
  productAri: Scalars['ID']['input'];
};

/** Graph integration app capabilities */
export enum GraphIntegrationAppCapability {
  Action = 'ACTION',
  DataConnector = 'DATA_CONNECTOR'
}

/** Types of Directory Item that can be returned by the GraphIntegrationItemsQuery */
export enum GraphIntegrationDirectoryItemType {
  Action = 'ACTION',
  McpServer = 'MCP_SERVER',
  McpTool = 'MCP_TOOL',
  Skill = 'SKILL'
}

export enum GraphIntegrationMcpAdminManagementMcpServerStatus {
  Deleting = 'DELETING',
  Provisioning = 'PROVISIONING',
  Registered = 'REGISTERED',
  Suspended = 'SUSPENDED',
  ToolConfigurationPending = 'TOOL_CONFIGURATION_PENDING'
}

export enum GraphIntegrationMcpAdminManagementMcpServerType {
  Http = 'HTTP',
  Sse = 'SSE'
}

export type GraphIntegrationMcpAdminManagementMcpToolConfigurationInput = {
  /**
   * The status of the MCP tool.
   * If not provided, the status will not be updated.
   */
  status?: InputMaybe<GraphIntegrationMcpAdminManagementMcpToolStatus>;
  /** The ARI of the MCP tool to update. */
  toolId: Scalars['ID']['input'];
};

export enum GraphIntegrationMcpAdminManagementMcpToolStatus {
  Allow = 'ALLOW',
  Deny = 'DENY',
  NewToolDeny = 'NEW_TOOL_DENY'
}

export type GraphIntegrationMcpAdminManagementRegisterMcpServerInput = {
  /** The cloudId where the operation is being performed. */
  cloudId: Scalars['ID']['input'];
  /** The display name of the MCP server */
  displayName: Scalars['String']['input'];
  /** The MCP endpoint of the server. If not provided, the default based on convention will be used. */
  endpointPath?: InputMaybe<Scalars['String']['input']>;
  /** The key for the icon of the MCP server */
  icon?: InputMaybe<Scalars['String']['input']>;
  /** The type of the MCP server. If not provided, the default based on convention will be used. */
  serverType?: InputMaybe<GraphIntegrationMcpAdminManagementMcpServerType>;
  /** A list of tags for the MCP server */
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The ID of the Gallery template used for registering the server */
  templateId?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the MCP server */
  url: Scalars['URL']['input'];
};

export type GraphIntegrationMcpAdminManagementTriggerToolSyncInput = {
  /** The cloudId where the operation is being performed. */
  cloudId: Scalars['ID']['input'];
  /** The ARI of the MCP server to sync tools for. */
  serverId: Scalars['ID']['input'];
};

export type GraphIntegrationMcpAdminManagementUnregisterMcpServerInput = {
  /** The cloudId where the operation is being performed. */
  cloudId: Scalars['ID']['input'];
  /** The ARI of the MCP server to unregister */
  serverId: Scalars['ID']['input'];
};

export type GraphIntegrationMcpAdminManagementUpdateMcpToolConfigurationInput = {
  /** The cloudId where the operation is being performed. */
  cloudId: Scalars['ID']['input'];
  /** The ARI of the MCP server where the tools are configured. */
  serverId: Scalars['ID']['input'];
  /** A list of MCP tool configurations to update. */
  toolConfigurations: Array<GraphIntegrationMcpAdminManagementMcpToolConfigurationInput>;
};

/** Input for removing a TWG capability container from a context */
export type GraphIntegrationRemoveTwgCapabilityContainerInput = {
  /** Context ARI (site ARI) where the TWG capability container should be removed */
  contextAri: Scalars['ID']['input'];
  /** Unique identifier for the installed TWG capability container instance */
  id: Scalars['String']['input'];
};

export enum GraphIntegrationSkillColor {
  Blue = 'BLUE',
  Default = 'DEFAULT',
  Gray = 'GRAY',
  Green = 'GREEN',
  Lime = 'LIME',
  Magenta = 'MAGENTA',
  Orange = 'ORANGE',
  Purple = 'PURPLE',
  Red = 'RED',
  Teal = 'TEAL',
  Yellow = 'YELLOW'
}

export enum GraphIntegrationStatus {
  Disabled = 'DISABLED',
  Enabled = 'ENABLED'
}

/** Surface types that can be used to filter actions based on their surface tool action mapping */
export enum GraphIntegrationSurface {
  Automation = 'AUTOMATION',
  Pollinator = 'POLLINATOR',
  Rovo = 'ROVO',
  Studio = 'STUDIO'
}

export enum GraphQlContentStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Deleted = 'DELETED',
  Draft = 'DRAFT'
}

export enum GraphQlContentTemplateType {
  Blueprint = 'BLUEPRINT',
  Page = 'PAGE'
}

export enum GraphQlCoverPictureWidth {
  Fixed = 'FIXED',
  Full = 'FULL'
}

export enum GraphQlDateFormat {
  Global = 'GLOBAL',
  Millis = 'MILLIS',
  User = 'USER',
  UserFriendly = 'USER_FRIENDLY'
}

export enum GraphQlFrontCoverState {
  Hidden = 'HIDDEN',
  Shown = 'SHOWN',
  Transition = 'TRANSITION',
  Unset = 'UNSET'
}

export enum GraphQlLabelSortDirection {
  Ascending = 'ASCENDING',
  Descending = 'DESCENDING'
}

export enum GraphQlLabelSortField {
  LabellingCreationdate = 'LABELLING_CREATIONDATE',
  LabellingId = 'LABELLING_ID'
}

export enum GraphQlPageStatus {
  Current = 'CURRENT',
  Draft = 'DRAFT',
  Historical = 'HISTORICAL',
  Trashed = 'TRASHED'
}

export enum GraphQlReactionContentType {
  Blogpost = 'BLOGPOST',
  Comment = 'COMMENT',
  Page = 'PAGE'
}

export type GraphQlSpaceShortcutsInput = {
  iconUrl?: InputMaybe<Scalars['String']['input']>;
  isPinnedPage: Scalars['Boolean']['input'];
  shortcutId: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export enum GraphQlTemplateContentAppearance {
  Default = 'DEFAULT',
  FullWidth = 'FULL_WIDTH',
  Max = 'MAX'
}

export type GraphQueryMetadataProjectAssociatedBuildInput = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedBuildInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedBuildInputOr>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedBuildInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToState>;
  to_testInfo?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfo>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToState>;
  to_testInfo?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfo>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputCreatedAt = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputCreatedAtMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputLastUpdated = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputLastUpdatedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedBuildInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToState>;
  to_testInfo?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfo>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToState>;
  to_testInfo?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfo>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAriValue>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataProjectAssociatedBuildInputToBuildStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataProjectAssociatedBuildInputToState = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedBuildInputToBuildStateEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToStateMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedBuildInputToBuildStateEnum>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToStateMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfo = {
  numberFailed?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberFailed>;
  numberPassed?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberPassed>;
  numberSkipped?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberSkipped>;
  totalNumber?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoTotalNumber>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberFailed = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberFailedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberFailedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberFailedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberFailedRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberPassed = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberPassedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberPassedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberPassedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberPassedRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberSkipped = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberSkippedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberSkippedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberSkippedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoNumberSkippedRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoTotalNumber = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoTotalNumberRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedBuildInputToTestInfoTotalNumberMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoTotalNumberMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedBuildInputToTestInfoTotalNumberRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInput = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputOr>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIds>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIds>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAt = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAtMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdated = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdatedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIds>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIds>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAriValue>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIds = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIdsRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIdsMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIdsMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipFixVersionIdsRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToAuthor = {
  authorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthorAri>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToAuthorAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthorAriValue>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToAuthorAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToAuthorAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToAuthorAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataProjectAssociatedDeploymentInputToDeploymentStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentType = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentTypeEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentTypeMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentTypeEnum>>;
};

export enum GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentTypeEnum {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphQueryMetadataProjectAssociatedDeploymentInputToEnvironmentTypeMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToState = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputToDeploymentStateEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedDeploymentInputToStateMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedDeploymentInputToDeploymentStateEnum>>;
};

export type GraphQueryMetadataProjectAssociatedDeploymentInputToStateMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInput = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedIncidentInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedIncidentInputOr>>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedIncidentInputOrInner>>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputLastUpdated>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedIncidentInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputLastUpdated>;
};

export type GraphQueryMetadataProjectAssociatedIncidentInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedIncidentInputLastUpdated>;
};

export type GraphQueryMetadataProjectAssociatedPrInput = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputOr>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataProjectAssociatedPrInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataProjectAssociatedPrInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataProjectAssociatedPrInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataProjectAssociatedPrInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataProjectAssociatedPrInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAri>;
  to_author?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataProjectAssociatedPrInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAriValue>;
};

export type GraphQueryMetadataProjectAssociatedPrInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToAuthor = {
  authorAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthorAri>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToAuthorAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthorAriValue>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToAuthorAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToAuthorAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToAuthorAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataProjectAssociatedPrInputToPullRequestStatusEnum {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataProjectAssociatedPrInputToReviewer = {
  approvalStatus?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewerApprovalStatus>;
  matchType?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewermatchTypeEnum>;
  reviewerAri?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewerAri>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToReviewerApprovalStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputToReviewerReviewerStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewerApprovalStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputToReviewerReviewerStatusEnum>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToReviewerApprovalStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToReviewerAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewerAriValue>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToReviewerAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToReviewerAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToReviewerAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataProjectAssociatedPrInputToReviewerReviewerStatusEnum {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphQueryMetadataProjectAssociatedPrInputToReviewermatchTypeEnum {
  All = 'ALL',
  Any = 'ANY',
  None = 'NONE'
}

export type GraphQueryMetadataProjectAssociatedPrInputToStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputToPullRequestStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedPrInputToPullRequestStatusEnum>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToTaskCount = {
  notValues?: InputMaybe<Array<Scalars['Int']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToTaskCountRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedPrInputToTaskCountMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToTaskCountMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedPrInputToTaskCountRangeField = {
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInput = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputOr>>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputOrInner>>;
  to_container?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToType>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdated>;
  to_container?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToType>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdated>;
  to_container?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToType>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputLastUpdated>;
  to_container?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToType>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainer = {
  containerAri?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainerAri>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainerAri = {
  value?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainerAriValue>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainerAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainerAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToContainerAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverity = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilitySeverityEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverityMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilitySeverityEnum>>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToSeverityMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilityStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilityStatusEnum>>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToType = {
  notValues?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilityTypeEnum>>;
  sort?: InputMaybe<GraphQueryMetadataProjectAssociatedVulnerabilityInputToTypeMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilityTypeEnum>>;
};

export type GraphQueryMetadataProjectAssociatedVulnerabilityInputToTypeMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilitySeverityEnum {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  Unknown = 'UNKNOWN'
}

export enum GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilityStatusEnum {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphQueryMetadataProjectAssociatedVulnerabilityInputToVulnerabilityTypeEnum {
  Dast = 'DAST',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataProjectHasIssueInput = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectHasIssueInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectHasIssueInputOr>>;
};

export type GraphQueryMetadataProjectHasIssueInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectHasIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectHasIssueInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataProjectHasIssueInputOrInner>>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOn>;
  relationship_sprintAris?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipAri>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToFixVersionIds>;
  to_issueAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
};

export type GraphQueryMetadataProjectHasIssueInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectHasIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectHasIssueInputLastUpdated>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOn>;
  relationship_sprintAris?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipAri>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToFixVersionIds>;
  to_issueAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
};

export type GraphQueryMetadataProjectHasIssueInputCreatedAt = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectHasIssueInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectHasIssueInputCreatedAtMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataProjectHasIssueInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputLastUpdated = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectHasIssueInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectHasIssueInputLastUpdatedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataProjectHasIssueInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataProjectHasIssueInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataProjectHasIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectHasIssueInputLastUpdated>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOn>;
  relationship_sprintAris?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipAri>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToFixVersionIds>;
  to_issueAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
};

export type GraphQueryMetadataProjectHasIssueInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataProjectHasIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataProjectHasIssueInputLastUpdated>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOn>;
  relationship_sprintAris?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipAri>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_fixVersionIds?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToFixVersionIds>;
  to_issueAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_issueTypeAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAri>;
};

export type GraphQueryMetadataProjectHasIssueInputRelationshipAri = {
  matchType?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipArimatchTypeEnum>;
  value?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipAriValue>;
};

export type GraphQueryMetadataProjectHasIssueInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectHasIssueInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataProjectHasIssueInputRelationshipArimatchTypeEnum {
  All = 'ALL',
  Any = 'ANY',
  None = 'NONE'
}

export type GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputToAri = {
  value?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAriValue>;
};

export type GraphQueryMetadataProjectHasIssueInputToAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataProjectHasIssueInputToAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputToFixVersionIds = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToFixVersionIdsRangeField>;
  sort?: InputMaybe<GraphQueryMetadataProjectHasIssueInputToFixVersionIdsMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataProjectHasIssueInputToFixVersionIdsMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataProjectHasIssueInputToFixVersionIdsRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInput = {
  and?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputOr>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAt>;
  fromAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAti>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputOrInner>>;
  toAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAti>;
  to_container?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToType>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAt>;
  fromAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAti>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdated>;
  toAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAti>;
  to_container?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToType>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAt = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAtMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdated = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdatedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAt>;
  fromAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAti>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdated>;
  toAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAti>;
  to_container?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToType>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputCreatedAt>;
  fromAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputFromAti>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputLastUpdated>;
  toAti?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAti>;
  to_container?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainer>;
  to_severity?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatus>;
  to_type?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToType>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainer = {
  containerAri?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainerAri>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainerAri = {
  value?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainerAriValue>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainerAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainerAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToContainerAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverity = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilitySeverityEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverityMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilitySeverityEnum>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToSeverityMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilityStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilityStatusEnum>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToType = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilityTypeEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToTypeMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilityTypeEnum>>;
};

export type GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToTypeMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilitySeverityEnum {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilityStatusEnum {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphQueryMetadataSecurityContainerAssociatedToVulnerabilityInputToVulnerabilityTypeEnum {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataServiceLinkedIncidentInput = {
  and?: InputMaybe<Array<GraphQueryMetadataServiceLinkedIncidentInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataServiceLinkedIncidentInputOr>>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataServiceLinkedIncidentInputOrInner>>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputLastUpdated>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataServiceLinkedIncidentInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputLastUpdated>;
};

export type GraphQueryMetadataServiceLinkedIncidentInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataServiceLinkedIncidentInputLastUpdated>;
};

export enum GraphQueryMetadataServiceLinkedIncidentInputToJiraServiceManagementIncidentPriorityEnum {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5'
}

export enum GraphQueryMetadataSortEnum {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type GraphQueryMetadataSprintAssociatedBuildInput = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedBuildInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedBuildInputOr>>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedBuildInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToState>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToState>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedBuildInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToState>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToAti>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToState>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAriValue>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataSprintAssociatedBuildInputToBuildStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataSprintAssociatedBuildInputToState = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedBuildInputToBuildStateEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedBuildInputToStateMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedBuildInputToBuildStateEnum>>;
};

export type GraphQueryMetadataSprintAssociatedBuildInputToStateMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInput = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputOr>>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthor>;
  to_environmentType?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentType>;
  to_state?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToState>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAriValue>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToAuthor = {
  authorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthorAri>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToAuthorAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthorAriValue>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToAuthorAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToAuthorAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToAuthorAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataSprintAssociatedDeploymentInputToDeploymentStateEnum {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentType = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentTypeEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentTypeMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentTypeEnum>>;
};

export enum GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentTypeEnum {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphQueryMetadataSprintAssociatedDeploymentInputToEnvironmentTypeMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToState = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputToDeploymentStateEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedDeploymentInputToStateMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedDeploymentInputToDeploymentStateEnum>>;
};

export type GraphQueryMetadataSprintAssociatedDeploymentInputToStateMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInput = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputOr>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataSprintAssociatedPrInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataSprintAssociatedPrInputCreatedAt = {
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputCreatedAtMetadataSortField>;
};

export type GraphQueryMetadataSprintAssociatedPrInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputLastUpdated = {
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputLastUpdatedMetadataSortField>;
};

export type GraphQueryMetadataSprintAssociatedPrInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataSprintAssociatedPrInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_creatorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOn>;
  relationship_reporterAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAri>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAti>;
  to_author?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthor>;
  to_reviewers?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewer>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToStatus>;
  to_taskCount?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToTaskCount>;
};

export type GraphQueryMetadataSprintAssociatedPrInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAriValue>;
};

export type GraphQueryMetadataSprintAssociatedPrInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToAuthor = {
  authorAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthorAri>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToAuthorAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthorAriValue>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToAuthorAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToAuthorAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToAuthorAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataSprintAssociatedPrInputToPullRequestStatusEnum {
  Declined = 'DECLINED',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataSprintAssociatedPrInputToReviewer = {
  approvalStatus?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewerApprovalStatus>;
  matchType?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewermatchTypeEnum>;
  reviewerAri?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewerAri>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToReviewerApprovalStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputToReviewerReviewerStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewerApprovalStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputToReviewerReviewerStatusEnum>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToReviewerApprovalStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToReviewerAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewerAriValue>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToReviewerAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToReviewerAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToReviewerAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataSprintAssociatedPrInputToReviewerReviewerStatusEnum {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphQueryMetadataSprintAssociatedPrInputToReviewermatchTypeEnum {
  All = 'ALL',
  Any = 'ANY',
  None = 'NONE'
}

export type GraphQueryMetadataSprintAssociatedPrInputToStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputToPullRequestStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedPrInputToPullRequestStatusEnum>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToTaskCount = {
  notValues?: InputMaybe<Array<Scalars['Int']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToTaskCountRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedPrInputToTaskCountMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToTaskCountMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedPrInputToTaskCountRangeField = {
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInput = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputOr>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputOrInner>>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusCategory?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategory>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToAti>;
  to_introducedDate?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDate>;
  to_severity?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatus>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusCategory?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategory>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToAti>;
  to_introducedDate?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDate>;
  to_severity?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatus>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAt = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAtMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdated = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdatedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusCategory?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategory>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToAti>;
  to_introducedDate?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDate>;
  to_severity?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatus>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputLastUpdated>;
  relationship_assigneeAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusAri?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri>;
  relationship_statusCategory?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategory>;
  toAti?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToAti>;
  to_introducedDate?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDate>;
  to_severity?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverity>;
  to_status?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatus>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAri = {
  value?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAriValue>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategory = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategoryEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategoryMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategoryEnum>>;
};

export enum GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategoryEnum {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputRelationshipStatusCategoryMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToAti = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToAtiMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToAtiMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDate = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDateRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDateMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDateMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToIntroducedDateRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverity = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputToVulnerabilitySeverityEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverityMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputToVulnerabilitySeverityEnum>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToSeverityMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatus = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputToVulnerabilityStatusEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatusMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintAssociatedVulnerabilityInputToVulnerabilityStatusEnum>>;
};

export type GraphQueryMetadataSprintAssociatedVulnerabilityInputToStatusMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphQueryMetadataSprintAssociatedVulnerabilityInputToVulnerabilitySeverityEnum {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphQueryMetadataSprintAssociatedVulnerabilityInputToVulnerabilityStatusEnum {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphQueryMetadataSprintContainsIssueInput = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintContainsIssueInputAnd>>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintContainsIssueInputOr>>;
};

export type GraphQueryMetadataSprintContainsIssueInputAnd = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputLastUpdated>;
  or?: InputMaybe<Array<GraphQueryMetadataSprintContainsIssueInputOrInner>>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOn>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_issueAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusCategory?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToStatusCategory>;
};

export type GraphQueryMetadataSprintContainsIssueInputAndInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputLastUpdated>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOn>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_issueAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusCategory?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToStatusCategory>;
};

export type GraphQueryMetadataSprintContainsIssueInputCreatedAt = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputCreatedAtRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputCreatedAtMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataSprintContainsIssueInputCreatedAtMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputCreatedAtRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputLastUpdated = {
  notValues?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputLastUpdatedRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputLastUpdatedMetadataSortField>;
  values?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type GraphQueryMetadataSprintContainsIssueInputLastUpdatedMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputLastUpdatedRangeField = {
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputOr = {
  and?: InputMaybe<Array<GraphQueryMetadataSprintContainsIssueInputAndInner>>;
  createdAt?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputLastUpdated>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOn>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_issueAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusCategory?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToStatusCategory>;
};

export type GraphQueryMetadataSprintContainsIssueInputOrInner = {
  createdAt?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputCreatedAt>;
  lastUpdated?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputLastUpdated>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOn>;
  to_assigneeAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_creatorAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_issueAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_reporterAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusAri?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAri>;
  to_statusCategory?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToStatusCategory>;
};

export type GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOn = {
  notValues?: InputMaybe<Array<Scalars['Long']['input']>>;
  range?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOnRangeField>;
  sort?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOnMetadataSortField>;
  values?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOnMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputRelationshipIssueLastUpdatedOnRangeField = {
  gt?: InputMaybe<Scalars['Long']['input']>;
  gte?: InputMaybe<Scalars['Long']['input']>;
  lt?: InputMaybe<Scalars['Long']['input']>;
  lte?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputToAri = {
  value?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAriValue>;
};

export type GraphQueryMetadataSprintContainsIssueInputToAriValue = {
  notValues?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToAriValueMetadataSortField>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphQueryMetadataSprintContainsIssueInputToAriValueMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphQueryMetadataSprintContainsIssueInputToStatusCategory = {
  notValues?: InputMaybe<Array<GraphQueryMetadataSprintContainsIssueInputToStatusCategoryEnum>>;
  sort?: InputMaybe<GraphQueryMetadataSprintContainsIssueInputToStatusCategoryMetadataSortField>;
  values?: InputMaybe<Array<GraphQueryMetadataSprintContainsIssueInputToStatusCategoryEnum>>;
};

export enum GraphQueryMetadataSprintContainsIssueInputToStatusCategoryEnum {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphQueryMetadataSprintContainsIssueInputToStatusCategoryMetadataSortField = {
  order?: InputMaybe<GraphQueryMetadataSortEnum>;
  priority?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphStoreAriFilterInput = {
  is?: InputMaybe<Array<Scalars['String']['input']>>;
  isNot?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphStoreAskHasImpactedWorkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAskHasOwnerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAskHasReceivingTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAskHasSubmitterSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAskHasSubmittingTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtiFilterInput = {
  is?: InputMaybe<Array<Scalars['String']['input']>>;
  isNot?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GraphStoreAtlasGoalHasAtlasTagSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasGoalHasContributorSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasGoalHasFollowerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasGoalHasGoalUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasGoalHasJiraAlignProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasGoalHasOwnerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasGoalHasSubAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasHomeRankingCriteria = {
  /** An enum representing the ranking criteria used to pick `limit` feed items among all the sources */
  criteria: GraphStoreAtlasHomeRankingCriteriaEnum;
  /** The maximum number of feed items to return after ranking; defaults to 5 */
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export enum GraphStoreAtlasHomeRankingCriteriaEnum {
  /** From the prioritized list of sources pick one item (at random from each source) at a time until we reach the target / limit */
  RoundRobinRandom = 'ROUND_ROBIN_RANDOM'
}

export enum GraphStoreAtlasHomeSourcesEnum {
  JiraEpicWithoutProject = 'JIRA_EPIC_WITHOUT_PROJECT',
  JiraIssueAssigned = 'JIRA_ISSUE_ASSIGNED',
  JiraIssueNearOverdue = 'JIRA_ISSUE_NEAR_OVERDUE',
  JiraIssueOverdue = 'JIRA_ISSUE_OVERDUE',
  UserJoinFirstTeam = 'USER_JOIN_FIRST_TEAM',
  UserPageNotViewedByOthers = 'USER_PAGE_NOT_VIEWED_BY_OTHERS',
  UserShouldFollowGoal = 'USER_SHOULD_FOLLOW_GOAL',
  UserShouldViewSharedPage = 'USER_SHOULD_VIEW_SHARED_PAGE',
  UserViewAssignedIssue = 'USER_VIEW_ASSIGNED_ISSUE',
  UserViewNegativeGoal = 'USER_VIEW_NEGATIVE_GOAL',
  UserViewNegativeProject = 'USER_VIEW_NEGATIVE_PROJECT',
  UserViewPageComments = 'USER_VIEW_PAGE_COMMENTS',
  UserViewSharedVideo = 'USER_VIEW_SHARED_VIDEO',
  UserViewTaggedVideoComment = 'USER_VIEW_TAGGED_VIDEO_COMMENT',
  UserViewUpdatedGoal = 'USER_VIEW_UPDATED_GOAL',
  UserViewUpdatedPriorityIssue = 'USER_VIEW_UPDATED_PRIORITY_ISSUE',
  UserViewUpdatedProject = 'USER_VIEW_UPDATED_PROJECT'
}

export type GraphStoreAtlasProjectContributesToAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasProjectDependsOnAtlasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasProjectHasAtlasTagSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasProjectHasContributorSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasProjectHasFollowerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasProjectHasOwnerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasProjectHasProjectUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasProjectIsRelatedToAtlasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasProjectIsTrackedOnJiraEpicSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasProjectLinksJiraSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlasProjectTrackedOnJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserCreatedAtlassianGoalUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserCreatedAtlassianProjectUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserCreatedExternalCustomerContactSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserCreatedExternalCustomerOrgCategorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserCreatedExternalTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserCreatedExternalTestExecutionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserCreatedExternalTestPlanSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserCreatedExternalTestRunSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserCreatedExternalTestStatusSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalFilterInput>>>;
  category?: InputMaybe<GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategoryFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalFilterInput>>>;
};

export enum GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategory {
  CommentAssigned = 'COMMENT_ASSIGNED',
  CommentMention = 'COMMENT_MENTION',
  CommentReply = 'COMMENT_REPLY',
  IssueApproval = 'ISSUE_APPROVAL',
  IssueDueSoon = 'ISSUE_DUE_SOON',
  NotSet = 'NOT_SET',
  ProjectInviterContext = 'PROJECT_INVITER_CONTEXT',
  ProjectPopularity = 'PROJECT_POPULARITY',
  PrReview = 'PR_REVIEW',
  TeamCollaboratorsCreate = 'TEAM_COLLABORATORS_CREATE',
  TeamCollaboratorsJoin = 'TEAM_COLLABORATORS_JOIN',
  TeamInviterContext = 'TEAM_INVITER_CONTEXT',
  TeamPopularity = 'TEAM_POPULARITY'
}

export type GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategoryFilterInput = {
  is?: InputMaybe<Array<GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategory>>;
  isNot?: InputMaybe<Array<GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategory>>;
};

export type GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalSortInput = {
  category?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_dismissedCategories?: InputMaybe<GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_dismissedCategories?: InputMaybe<GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalFilterInput>;
};

/** Conditional selection for filter field of atlassian-user-dismissed-jira-for-you-recommendation-entity relationship queries */
export type GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityConditionalFilterInput>>>;
};

export type GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_dismissedCategories?: InputMaybe<GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_dismissedCategories?: InputMaybe<GraphStoreAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalSortInput>;
};

export type GraphStoreAtlassianUserInvitedToLoomMeetingSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserLinksExternalCustomerContactSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserOwnsExternalCustomerContactSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserOwnsExternalCustomerOrgCategorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserOwnsExternalTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserOwnsExternalTestExecutionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserOwnsExternalTestPlanSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserOwnsExternalTestRunSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserOwnsExternalTestStatusSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserUpdatedExternalCustomerContactSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserUpdatedExternalCustomerOrgCategorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserUpdatedExternalTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserUpdatedExternalTestExecutionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserUpdatedExternalTestPlanSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserUpdatedExternalTestRunSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreAtlassianUserUpdatedExternalTestStatusSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreBoardBelongsToProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreBooleanFilterInput = {
  is?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreBranchInRepoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreCalendarHasLinkedDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreChangeProposalHasAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreCommitBelongsToPullRequestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreCommitInRepoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreComponentHasComponentLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreComponentImpactedByIncidentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreComponentLinkIsJiraProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreComponentLinkedJswIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConfluenceBlogpostHasCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConfluenceBlogpostSharedWithUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConfluencePageHasCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConfluencePageHasConfluenceCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConfluencePageHasConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConfluencePageHasParentPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConfluencePageSharedWithGroupSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConfluencePageSharedWithUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConfluenceSpaceHasConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConfluenceSpaceHasConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConfluenceSpaceHasConfluenceFolderSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConfluenceSpaceHasConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreContentReferencedEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreConversationHasMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreCreateAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalInput = {
  category?: InputMaybe<GraphStoreCreateAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategoryInput>;
};

export enum GraphStoreCreateAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategoryInput {
  CommentAssigned = 'COMMENT_ASSIGNED',
  CommentMention = 'COMMENT_MENTION',
  CommentReply = 'COMMENT_REPLY',
  IssueApproval = 'ISSUE_APPROVAL',
  IssueDueSoon = 'ISSUE_DUE_SOON',
  NotSet = 'NOT_SET',
  ProjectInviterContext = 'PROJECT_INVITER_CONTEXT',
  ProjectPopularity = 'PROJECT_POPULARITY',
  PrReview = 'PR_REVIEW',
  TeamCollaboratorsCreate = 'TEAM_COLLABORATORS_CREATE',
  TeamCollaboratorsJoin = 'TEAM_COLLABORATORS_JOIN',
  TeamInviterContext = 'TEAM_INVITER_CONTEXT',
  TeamPopularity = 'TEAM_POPULARITY'
}

export type GraphStoreCreateAtlassianUserDismissedJiraForYouRecommendationEntityInput = {
  /** The list of relationships of type atlassian-user-dismissed-jira-for-you-recommendation-entity to persist */
  relationships: Array<GraphStoreCreateAtlassianUserDismissedJiraForYouRecommendationEntityRelationshipInput>;
  /** If true, the request will wait until the relationship is created before returning. This will make the request twice as expensive and should not be used unless absolutely necessary. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreCreateAtlassianUserDismissedJiraForYouRecommendationEntityRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:project, ati:cloud:jira:issue-comment, ati:cloud:identity:team, ati:cloud:jira:pull-request, ati:cloud:graph:pull-request] */
  from: Scalars['ID']['input'];
  /** Object metadata for this relationship */
  objectMetadata?: InputMaybe<GraphStoreCreateAtlassianUserDismissedJiraForYouRecommendationEntityRelationshipObjectMetadataInput>;
  /** Relationship specific metadata */
  relationshipMetadata?: InputMaybe<GraphStoreCreateAtlassianUserDismissedJiraForYouRecommendationEntityRelationshipMetadataInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:project, ati:cloud:jira:issue-comment, ati:cloud:identity:team, ati:cloud:jira:pull-request, ati:cloud:graph:pull-request] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateAtlassianUserDismissedJiraForYouRecommendationEntityRelationshipMetadataInput = {
  dismissedCategories?: InputMaybe<GraphStoreCreateAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalInput>;
};

export type GraphStoreCreateAtlassianUserDismissedJiraForYouRecommendationEntityRelationshipObjectMetadataInput = {
  dismissedCategories?: InputMaybe<GraphStoreCreateAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalInput>;
};

export type GraphStoreCreateComponentImpactedByIncidentInput = {
  /** The list of relationships of type component-impacted-by-incident to persist */
  relationships: Array<GraphStoreCreateComponentImpactedByIncidentRelationshipInput>;
};

export enum GraphStoreCreateComponentImpactedByIncidentJiraIncidentPriorityInput {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreCreateComponentImpactedByIncidentJiraIncidentStatusInput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export type GraphStoreCreateComponentImpactedByIncidentRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** Object metadata for this relationship */
  objectMetadata?: InputMaybe<GraphStoreCreateComponentImpactedByIncidentRelationshipObjectMetadataInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateComponentImpactedByIncidentRelationshipObjectMetadataInput = {
  affectedServiceAris?: InputMaybe<Scalars['String']['input']>;
  assigneeAri?: InputMaybe<Scalars['String']['input']>;
  majorIncident?: InputMaybe<Scalars['Boolean']['input']>;
  priority?: InputMaybe<GraphStoreCreateComponentImpactedByIncidentJiraIncidentPriorityInput>;
  reporterAri?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<GraphStoreCreateComponentImpactedByIncidentJiraIncidentStatusInput>;
};

export type GraphStoreCreateIncidentAssociatedPostIncidentReviewLinkInput = {
  /** The list of relationships of type incident-associated-post-incident-review-link to persist */
  relationships: Array<GraphStoreCreateIncidentAssociatedPostIncidentReviewLinkRelationshipInput>;
};

export type GraphStoreCreateIncidentAssociatedPostIncidentReviewLinkRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link, ati:cloud:jira:post-incident-review, ati:cloud:graph:post-incident-review] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link, ati:cloud:jira:post-incident-review, ati:cloud:graph:post-incident-review] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateIncidentHasActionItemInput = {
  /** The list of relationships of type incident-has-action-item to persist */
  relationships: Array<GraphStoreCreateIncidentHasActionItemRelationshipInput>;
};

export type GraphStoreCreateIncidentHasActionItemRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateIncidentLinkedJswIssueInput = {
  /** The list of relationships of type incident-linked-jsw-issue to persist */
  relationships: Array<GraphStoreCreateIncidentLinkedJswIssueRelationshipInput>;
};

export type GraphStoreCreateIncidentLinkedJswIssueRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateIssueToWhiteboardInput = {
  /** The list of relationships of type issue-to-whiteboard to persist */
  relationships: Array<GraphStoreCreateIssueToWhiteboardRelationshipInput>;
};

export type GraphStoreCreateIssueToWhiteboardRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:whiteboard */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export enum GraphStoreCreateJcsIssueAssociatedSupportEscalationEscalationLinkTypeInput {
  ExistingWorkItem = 'EXISTING_WORK_ITEM',
  NewWorkItem = 'NEW_WORK_ITEM',
  NotSet = 'NOT_SET'
}

export enum GraphStoreCreateJcsIssueAssociatedSupportEscalationEscalationStatusInput {
  Accepted = 'ACCEPTED',
  Open = 'OPEN',
  Rejected = 'REJECTED'
}

export type GraphStoreCreateJcsIssueAssociatedSupportEscalationInput = {
  /** The list of relationships of type jcs-issue-associated-support-escalation to persist */
  relationships: Array<GraphStoreCreateJcsIssueAssociatedSupportEscalationRelationshipInput>;
};

export type GraphStoreCreateJcsIssueAssociatedSupportEscalationRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:jira:issue] */
  from: Scalars['ID']['input'];
  /** Relationship specific metadata */
  relationshipMetadata?: InputMaybe<GraphStoreCreateJcsIssueAssociatedSupportEscalationRelationshipMetadataInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:jira:issue] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateJcsIssueAssociatedSupportEscalationRelationshipMetadataInput = {
  SupportEscalationLastUpdated?: InputMaybe<Scalars['Long']['input']>;
  creatorAri?: InputMaybe<Scalars['String']['input']>;
  linkType?: InputMaybe<GraphStoreCreateJcsIssueAssociatedSupportEscalationEscalationLinkTypeInput>;
  status?: InputMaybe<GraphStoreCreateJcsIssueAssociatedSupportEscalationEscalationStatusInput>;
};

export type GraphStoreCreateJswProjectAssociatedComponentInput = {
  /** The list of relationships of type jsw-project-associated-component to persist */
  relationships: Array<GraphStoreCreateJswProjectAssociatedComponentRelationshipInput>;
};

export type GraphStoreCreateJswProjectAssociatedComponentRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:graph:service, ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:graph:service, ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateLoomVideoHasConfluencePageInput = {
  /** The list of relationships of type loom-video-has-confluence-page to persist */
  relationships: Array<GraphStoreCreateLoomVideoHasConfluencePageRelationshipInput>;
};

export type GraphStoreCreateLoomVideoHasConfluencePageRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:page */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateMeetingHasJiraProjectInput = {
  /** The list of relationships of type meeting-has-jira-project to persist */
  relationships: Array<GraphStoreCreateMeetingHasJiraProjectRelationshipInput>;
};

export type GraphStoreCreateMeetingHasJiraProjectRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateMeetingRecordingOwnerHasMeetingNotesFolderInput = {
  /** The list of relationships of type meeting-recording-owner-has-meeting-notes-folder to persist */
  relationships: Array<GraphStoreCreateMeetingRecordingOwnerHasMeetingNotesFolderRelationshipInput>;
};

export type GraphStoreCreateMeetingRecordingOwnerHasMeetingNotesFolderRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:confluence:folder, ati:cloud:confluence:content] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:confluence:folder, ati:cloud:confluence:content] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateMeetingRecurrenceHasJiraProjectInput = {
  /** The list of relationships of type meeting-recurrence-has-jira-project to persist */
  relationships: Array<GraphStoreCreateMeetingRecurrenceHasJiraProjectRelationshipInput>;
};

export type GraphStoreCreateMeetingRecurrenceHasJiraProjectRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateMeetingRecurrenceHasMeetingRecurrenceNotesPageInput = {
  /** The list of relationships of type meeting-recurrence-has-meeting-recurrence-notes-page to persist */
  relationships: Array<GraphStoreCreateMeetingRecurrenceHasMeetingRecurrenceNotesPageRelationshipInput>;
};

export type GraphStoreCreateMeetingRecurrenceHasMeetingRecurrenceNotesPageRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:page */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateParentTeamHasChildTeamInput = {
  /** The list of relationships of type parent-team-has-child-team to persist */
  relationships: Array<GraphStoreCreateParentTeamHasChildTeamRelationshipInput>;
};

export type GraphStoreCreateParentTeamHasChildTeamRelationshipInput = {
  /** An ARI of type ati:cloud:identity:team */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:identity:team */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectAssociatedOpsgenieTeamInput = {
  /** The list of relationships of type project-associated-opsgenie-team to persist */
  relationships: Array<GraphStoreCreateProjectAssociatedOpsgenieTeamRelationshipInput>;
};

export type GraphStoreCreateProjectAssociatedOpsgenieTeamRelationshipInput = {
  /** An ARI of type ati:cloud:opsgenie:team */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:opsgenie:team */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectAssociatedToSecurityContainerInput = {
  /** The list of relationships of type project-associated-to-security-container to persist */
  relationships: Array<GraphStoreCreateProjectAssociatedToSecurityContainerRelationshipInput>;
};

export type GraphStoreCreateProjectAssociatedToSecurityContainerRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:security-container, ati:cloud:graph:security-container] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:security-container, ati:cloud:graph:security-container] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectDisassociatedRepoInput = {
  /** The list of relationships of type project-disassociated-repo to persist */
  relationships: Array<GraphStoreCreateProjectDisassociatedRepoRelationshipInput>;
};

export type GraphStoreCreateProjectDisassociatedRepoRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:repository, ati:cloud:graph:repository] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:repository, ati:cloud:graph:repository] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectDocumentationEntityInput = {
  /** The list of relationships of type project-documentation-entity to persist */
  relationships: Array<GraphStoreCreateProjectDocumentationEntityRelationshipInput>;
};

export type GraphStoreCreateProjectDocumentationEntityRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:confluence:space, ati:cloud:confluence:page, ati:cloud:confluence:folder, ati:cloud:confluence:content, ati:cloud:confluence:whiteboard, ati:cloud:jira:document, ati:cloud:graph:document] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:confluence:space, ati:cloud:confluence:page, ati:cloud:confluence:folder, ati:cloud:confluence:content, ati:cloud:confluence:whiteboard, ati:cloud:jira:document, ati:cloud:graph:document] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectDocumentationPageInput = {
  /** The list of relationships of type project-documentation-page to persist */
  relationships: Array<GraphStoreCreateProjectDocumentationPageRelationshipInput>;
};

export type GraphStoreCreateProjectDocumentationPageRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:page */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectDocumentationSpaceInput = {
  /** The list of relationships of type project-documentation-space to persist */
  relationships: Array<GraphStoreCreateProjectDocumentationSpaceRelationshipInput>;
};

export type GraphStoreCreateProjectDocumentationSpaceRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:space */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:space */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectHasRelatedWorkWithProjectInput = {
  /** The list of relationships of type project-has-related-work-with-project to persist */
  relationships: Array<GraphStoreCreateProjectHasRelatedWorkWithProjectRelationshipInput>;
};

export type GraphStoreCreateProjectHasRelatedWorkWithProjectRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectHasSharedVersionWithInput = {
  /** The list of relationships of type project-has-shared-version-with to persist */
  relationships: Array<GraphStoreCreateProjectHasSharedVersionWithRelationshipInput>;
};

export type GraphStoreCreateProjectHasSharedVersionWithRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateProjectHasVersionInput = {
  /** The list of relationships of type project-has-version to persist */
  relationships: Array<GraphStoreCreateProjectHasVersionRelationshipInput>;
};

export type GraphStoreCreateProjectHasVersionRelationshipInput = {
  /** An ARI of type ati:cloud:jira:version */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:version */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateSprintRetrospectivePageInput = {
  /** The list of relationships of type sprint-retrospective-page to persist */
  relationships: Array<GraphStoreCreateSprintRetrospectivePageRelationshipInput>;
};

export type GraphStoreCreateSprintRetrospectivePageRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:page */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateSprintRetrospectiveWhiteboardInput = {
  /** The list of relationships of type sprint-retrospective-whiteboard to persist */
  relationships: Array<GraphStoreCreateSprintRetrospectiveWhiteboardRelationshipInput>;
};

export type GraphStoreCreateSprintRetrospectiveWhiteboardRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:whiteboard */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateTeamConnectedToContainerInput = {
  /** The list of relationships of type team-connected-to-container to persist */
  relationships: Array<GraphStoreCreateTeamConnectedToContainerRelationshipInput>;
  /** If true, the request will wait until the relationship is created before returning. This will make the request twice as expensive and should not be used unless absolutely necessary. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreCreateTeamConnectedToContainerRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:confluence:space, ati:cloud:loom:space] */
  from: Scalars['ID']['input'];
  /** Relationship specific metadata */
  relationshipMetadata?: InputMaybe<GraphStoreCreateTeamConnectedToContainerRelationshipMetadataInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:confluence:space, ati:cloud:loom:space] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateTeamConnectedToContainerRelationshipMetadataInput = {
  createdFromAutocreate?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreCreateTownsquareTagIsAliasOfTownsquareTagInput = {
  /** The list of relationships of type townsquare-tag-is-alias-of-townsquare-tag to persist */
  relationships: Array<GraphStoreCreateTownsquareTagIsAliasOfTownsquareTagRelationshipInput>;
};

export type GraphStoreCreateTownsquareTagIsAliasOfTownsquareTagRelationshipInput = {
  /** An ARI of type ati:cloud:townsquare:tag */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:townsquare:tag */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateUserFavoritedTeamInput = {
  /** The list of relationships of type user-favorited-team to persist */
  relationships: Array<GraphStoreCreateUserFavoritedTeamRelationshipInput>;
};

export type GraphStoreCreateUserFavoritedTeamRelationshipInput = {
  /** An ARI of type ati:cloud:identity:team */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:identity:team */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateUserFavoritedTownsquareGoalInput = {
  /** The list of relationships of type user-favorited-townsquare-goal to persist */
  relationships: Array<GraphStoreCreateUserFavoritedTownsquareGoalRelationshipInput>;
};

export type GraphStoreCreateUserFavoritedTownsquareGoalRelationshipInput = {
  /** An ARI of type ati:cloud:townsquare:goal */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:townsquare:goal */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateUserFavoritedTownsquareProjectInput = {
  /** The list of relationships of type user-favorited-townsquare-project to persist */
  relationships: Array<GraphStoreCreateUserFavoritedTownsquareProjectRelationshipInput>;
};

export type GraphStoreCreateUserFavoritedTownsquareProjectRelationshipInput = {
  /** An ARI of type ati:cloud:townsquare:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:townsquare:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateUserHasRelevantProjectInput = {
  /** The list of relationships of type user-has-relevant-project to persist */
  relationships: Array<GraphStoreCreateUserHasRelevantProjectRelationshipInput>;
};

export type GraphStoreCreateUserHasRelevantProjectRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateVersionUserAssociatedFeatureFlagInput = {
  /** The list of relationships of type version-user-associated-feature-flag to persist */
  relationships: Array<GraphStoreCreateVersionUserAssociatedFeatureFlagRelationshipInput>;
};

export type GraphStoreCreateVersionUserAssociatedFeatureFlagRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:feature-flag, ati:cloud:graph:feature-flag] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:feature-flag, ati:cloud:graph:feature-flag] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateVulnerabilityAssociatedIssueContainerInput = {
  containerAri?: InputMaybe<Scalars['String']['input']>;
};

export type GraphStoreCreateVulnerabilityAssociatedIssueInput = {
  /** The list of relationships of type vulnerability-associated-issue to persist */
  relationships: Array<GraphStoreCreateVulnerabilityAssociatedIssueRelationshipInput>;
};

export type GraphStoreCreateVulnerabilityAssociatedIssueRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** Subject metadata for this relationship */
  subjectMetadata?: InputMaybe<GraphStoreCreateVulnerabilityAssociatedIssueRelationshipSubjectMetadataInput>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreCreateVulnerabilityAssociatedIssueRelationshipSubjectMetadataInput = {
  container?: InputMaybe<GraphStoreCreateVulnerabilityAssociatedIssueContainerInput>;
  introducedDate?: InputMaybe<Scalars['DateTime']['input']>;
  severity?: InputMaybe<GraphStoreCreateVulnerabilityAssociatedIssueVulnerabilitySeverityInput>;
  status?: InputMaybe<GraphStoreCreateVulnerabilityAssociatedIssueVulnerabilityStatusInput>;
  type?: InputMaybe<GraphStoreCreateVulnerabilityAssociatedIssueVulnerabilityTypeInput>;
};

export enum GraphStoreCreateVulnerabilityAssociatedIssueVulnerabilitySeverityInput {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreCreateVulnerabilityAssociatedIssueVulnerabilityStatusInput {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreCreateVulnerabilityAssociatedIssueVulnerabilityTypeInput {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type GraphStoreCsmCustomerHasJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreCsmOrganizationHasCsmCustomerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreCsmOrganizationHasJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreCustomerAssociatedIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreCustomerHasExternalConversationSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

/** A single query request containing the query and pagination parameters */
export type GraphStoreCypherQueryV2BatchQueryRequestInput = {
  /** Cursor for where to start fetching the page */
  after?: InputMaybe<Scalars['String']['input']>;
  /**
   * How many rows to include in the result.
   * Note the response could include less rows than requested (including be empty), and still have more pages to be fetched.
   * Must not exceed 1000, default is 100
   */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Cypher query to execute */
  query: Scalars['String']['input'];
};

export enum GraphStoreCypherQueryV2BatchVersionEnum {
  /** V2 */
  V2 = 'V2',
  /** V3 */
  V3 = 'V3'
}

export enum GraphStoreCypherQueryV2VersionEnum {
  /** V2 */
  V2 = 'V2',
  /** V3 */
  V3 = 'V3'
}

export type GraphStoreDateFilterInput = {
  after?: InputMaybe<Scalars['DateTime']['input']>;
  before?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreDeleteAtlassianUserDismissedJiraForYouRecommendationEntityInput = {
  /** The list of relationships of type atlassian-user-dismissed-jira-for-you-recommendation-entity to delete */
  relationships: Array<GraphStoreDeleteAtlassianUserDismissedJiraForYouRecommendationEntityRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteAtlassianUserDismissedJiraForYouRecommendationEntityRelationshipInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:project, ati:cloud:jira:issue-comment, ati:cloud:identity:team, ati:cloud:jira:pull-request, ati:cloud:graph:pull-request] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteComponentImpactedByIncidentInput = {
  /** The list of relationships of type component-impacted-by-incident to delete */
  relationships: Array<GraphStoreDeleteComponentImpactedByIncidentRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteComponentImpactedByIncidentRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteIncidentAssociatedPostIncidentReviewLinkInput = {
  /** The list of relationships of type incident-associated-post-incident-review-link to delete */
  relationships: Array<GraphStoreDeleteIncidentAssociatedPostIncidentReviewLinkRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteIncidentAssociatedPostIncidentReviewLinkRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link, ati:cloud:jira:post-incident-review, ati:cloud:graph:post-incident-review] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteIncidentHasActionItemInput = {
  /** The list of relationships of type incident-has-action-item to delete */
  relationships: Array<GraphStoreDeleteIncidentHasActionItemRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteIncidentHasActionItemRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteIncidentLinkedJswIssueInput = {
  /** The list of relationships of type incident-linked-jsw-issue to delete */
  relationships: Array<GraphStoreDeleteIncidentLinkedJswIssueRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteIncidentLinkedJswIssueRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteIssueToWhiteboardInput = {
  /** The list of relationships of type issue-to-whiteboard to delete */
  relationships: Array<GraphStoreDeleteIssueToWhiteboardRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteIssueToWhiteboardRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteJcsIssueAssociatedSupportEscalationInput = {
  /** The list of relationships of type jcs-issue-associated-support-escalation to delete */
  relationships: Array<GraphStoreDeleteJcsIssueAssociatedSupportEscalationRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteJcsIssueAssociatedSupportEscalationRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:jira:issue] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteJswProjectAssociatedComponentInput = {
  /** The list of relationships of type jsw-project-associated-component to delete */
  relationships: Array<GraphStoreDeleteJswProjectAssociatedComponentRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteJswProjectAssociatedComponentRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:graph:service, ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteLoomVideoHasConfluencePageInput = {
  /** The list of relationships of type loom-video-has-confluence-page to delete */
  relationships: Array<GraphStoreDeleteLoomVideoHasConfluencePageRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteLoomVideoHasConfluencePageRelationshipInput = {
  /** An ARI of type ati:cloud:loom:video */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteMeetingHasJiraProjectInput = {
  /** The list of relationships of type meeting-has-jira-project to delete */
  relationships: Array<GraphStoreDeleteMeetingHasJiraProjectRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteMeetingHasJiraProjectRelationshipInput = {
  /** An ARI of type ati:cloud:loom:meeting */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteMeetingRecordingOwnerHasMeetingNotesFolderInput = {
  /** The list of relationships of type meeting-recording-owner-has-meeting-notes-folder to delete */
  relationships: Array<GraphStoreDeleteMeetingRecordingOwnerHasMeetingNotesFolderRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteMeetingRecordingOwnerHasMeetingNotesFolderRelationshipInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:confluence:folder, ati:cloud:confluence:content] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteMeetingRecurrenceHasJiraProjectInput = {
  /** The list of relationships of type meeting-recurrence-has-jira-project to delete */
  relationships: Array<GraphStoreDeleteMeetingRecurrenceHasJiraProjectRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteMeetingRecurrenceHasJiraProjectRelationshipInput = {
  /** An ARI of type ati:cloud:loom:meeting-recurrence */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteMeetingRecurrenceHasMeetingRecurrenceNotesPageInput = {
  /** The list of relationships of type meeting-recurrence-has-meeting-recurrence-notes-page to delete */
  relationships: Array<GraphStoreDeleteMeetingRecurrenceHasMeetingRecurrenceNotesPageRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteMeetingRecurrenceHasMeetingRecurrenceNotesPageRelationshipInput = {
  /** An ARI of type ati:cloud:loom:meeting-recurrence */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteParentTeamHasChildTeamInput = {
  /** The list of relationships of type parent-team-has-child-team to delete */
  relationships: Array<GraphStoreDeleteParentTeamHasChildTeamRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteParentTeamHasChildTeamRelationshipInput = {
  /** An ARI of type ati:cloud:identity:team */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:identity:team */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectAssociatedOpsgenieTeamInput = {
  /** The list of relationships of type project-associated-opsgenie-team to delete */
  relationships: Array<GraphStoreDeleteProjectAssociatedOpsgenieTeamRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectAssociatedOpsgenieTeamRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:opsgenie:team */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectAssociatedToSecurityContainerInput = {
  /** The list of relationships of type project-associated-to-security-container to delete */
  relationships: Array<GraphStoreDeleteProjectAssociatedToSecurityContainerRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectAssociatedToSecurityContainerRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:security-container, ati:cloud:graph:security-container] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectDisassociatedRepoInput = {
  /** The list of relationships of type project-disassociated-repo to delete */
  relationships: Array<GraphStoreDeleteProjectDisassociatedRepoRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectDisassociatedRepoRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:repository, ati:cloud:graph:repository] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectDocumentationEntityInput = {
  /** The list of relationships of type project-documentation-entity to delete */
  relationships: Array<GraphStoreDeleteProjectDocumentationEntityRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectDocumentationEntityRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:confluence:space, ati:cloud:confluence:page, ati:cloud:confluence:folder, ati:cloud:confluence:content, ati:cloud:confluence:whiteboard, ati:cloud:jira:document, ati:cloud:graph:document] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectDocumentationPageInput = {
  /** The list of relationships of type project-documentation-page to delete */
  relationships: Array<GraphStoreDeleteProjectDocumentationPageRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectDocumentationPageRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectDocumentationSpaceInput = {
  /** The list of relationships of type project-documentation-space to delete */
  relationships: Array<GraphStoreDeleteProjectDocumentationSpaceRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectDocumentationSpaceRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:space */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectHasRelatedWorkWithProjectInput = {
  /** The list of relationships of type project-has-related-work-with-project to delete */
  relationships: Array<GraphStoreDeleteProjectHasRelatedWorkWithProjectRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectHasRelatedWorkWithProjectRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectHasSharedVersionWithInput = {
  /** The list of relationships of type project-has-shared-version-with to delete */
  relationships: Array<GraphStoreDeleteProjectHasSharedVersionWithRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectHasSharedVersionWithRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteProjectHasVersionInput = {
  /** The list of relationships of type project-has-version to delete */
  relationships: Array<GraphStoreDeleteProjectHasVersionRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteProjectHasVersionRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:version */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteSprintRetrospectivePageInput = {
  /** The list of relationships of type sprint-retrospective-page to delete */
  relationships: Array<GraphStoreDeleteSprintRetrospectivePageRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteSprintRetrospectivePageRelationshipInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteSprintRetrospectiveWhiteboardInput = {
  /** The list of relationships of type sprint-retrospective-whiteboard to delete */
  relationships: Array<GraphStoreDeleteSprintRetrospectiveWhiteboardRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteSprintRetrospectiveWhiteboardRelationshipInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteTeamConnectedToContainerInput = {
  /** The list of relationships of type team-connected-to-container to delete */
  relationships: Array<GraphStoreDeleteTeamConnectedToContainerRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteTeamConnectedToContainerRelationshipInput = {
  /** An ARI of type ati:cloud:identity:team */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:confluence:space, ati:cloud:loom:space] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteTownsquareTagIsAliasOfTownsquareTagInput = {
  /** The list of relationships of type townsquare-tag-is-alias-of-townsquare-tag to delete */
  relationships: Array<GraphStoreDeleteTownsquareTagIsAliasOfTownsquareTagRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteTownsquareTagIsAliasOfTownsquareTagRelationshipInput = {
  /** An ARI of type ati:cloud:townsquare:tag */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:townsquare:tag */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteUserFavoritedTeamInput = {
  /** The list of relationships of type user-favorited-team to delete */
  relationships: Array<GraphStoreDeleteUserFavoritedTeamRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteUserFavoritedTeamRelationshipInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:identity:team */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteUserFavoritedTownsquareGoalInput = {
  /** The list of relationships of type user-favorited-townsquare-goal to delete */
  relationships: Array<GraphStoreDeleteUserFavoritedTownsquareGoalRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteUserFavoritedTownsquareGoalRelationshipInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:townsquare:goal */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteUserFavoritedTownsquareProjectInput = {
  /** The list of relationships of type user-favorited-townsquare-project to delete */
  relationships: Array<GraphStoreDeleteUserFavoritedTownsquareProjectRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteUserFavoritedTownsquareProjectRelationshipInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:townsquare:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteUserHasRelevantProjectInput = {
  /** The list of relationships of type user-has-relevant-project to delete */
  relationships: Array<GraphStoreDeleteUserHasRelevantProjectRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteUserHasRelevantProjectRelationshipInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteVersionUserAssociatedFeatureFlagInput = {
  /** The list of relationships of type version-user-associated-feature-flag to delete */
  relationships: Array<GraphStoreDeleteVersionUserAssociatedFeatureFlagRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteVersionUserAssociatedFeatureFlagRelationshipInput = {
  /** An ARI of type ati:cloud:jira:version */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:feature-flag, ati:cloud:graph:feature-flag] */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeleteVulnerabilityAssociatedIssueInput = {
  /** The list of relationships of type vulnerability-associated-issue to delete */
  relationships: Array<GraphStoreDeleteVulnerabilityAssociatedIssueRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreDeleteVulnerabilityAssociatedIssueRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:vulnerability, ati:cloud:graph:vulnerability] */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
};

export type GraphStoreDeploymentAssociatedDeploymentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreDeploymentAssociatedRepoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreDeploymentContainsCommitSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreDynamicRelationshipAssetToAssetSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreDynamicRelationshipAssetToGroupSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreDynamicRelationshipAssetToProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreDynamicRelationshipAssetToRepoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreDynamicRelationshipAssetToUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreEntityIsRelatedToEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalCustomerOrgHasChildExternalCustomerOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalCustomerOrgHasExternalCustomerContactSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalCustomerOrgHasExternalDealSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalCustomerOrgLinksExternalCustomerOrgCategorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalCustomerOrgWorksOnJiraWorkItemWorklogSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalOrgHasExternalPositionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalOrgHasExternalWorkerSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalOrgHasUserAsMemberSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalOrgIsParentOfExternalOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalPositionIsFilledByExternalWorkerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalPositionManagesExternalOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalPositionManagesExternalPositionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalTeamWorksOnJiraWorkItemWorklogSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalWorkerConflatesToIdentity3pUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreExternalWorkerConflatesToUserSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreFloatFilterInput = {
  greaterThan?: InputMaybe<Scalars['Float']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['Float']['input']>;
  is?: InputMaybe<Array<Scalars['Float']['input']>>;
  isNot?: InputMaybe<Array<Scalars['Float']['input']>>;
  lessThan?: InputMaybe<Scalars['Float']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['Float']['input']>;
};

export type GraphStoreFocusAreaAssociatedToProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreFocusAreaHasAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreFocusAreaHasFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreFocusAreaHasPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreFocusAreaHasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreFocusAreaHasStatusUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreFocusAreaHasThirdPartyDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreFocusAreaHasWatcherSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreFullComponentImpactedByIncidentJiraIncidentPriorityOutput {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullComponentImpactedByIncidentJiraIncidentStatusOutput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export enum GraphStoreFullIssueAssociatedBuildBuildStateOutput {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullIssueAssociatedDeploymentDeploymentStateOutput {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullIssueAssociatedDeploymentEnvironmentTypeOutput {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum GraphStoreFullIssueAssociatedDesignDesignStatusOutput {
  None = 'NONE',
  NotSet = 'NOT_SET',
  ReadyForDevelopment = 'READY_FOR_DEVELOPMENT',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullIssueAssociatedDesignDesignTypeOutput {
  Canvas = 'CANVAS',
  File = 'FILE',
  Group = 'GROUP',
  Node = 'NODE',
  NotSet = 'NOT_SET',
  Other = 'OTHER',
  Prototype = 'PROTOTYPE'
}

export enum GraphStoreFullIssueAssociatedIssueRemoteLinkLinkApplicationTypeOutput {
  Bamboo = 'BAMBOO',
  BbPrComment = 'BB_PR_COMMENT',
  ConfluencePage = 'CONFLUENCE_PAGE',
  Jira = 'JIRA',
  NotSet = 'NOT_SET',
  Snyk = 'SNYK',
  Trello = 'TRELLO',
  WebLink = 'WEB_LINK'
}

export enum GraphStoreFullIssueAssociatedIssueRemoteLinkLinkRelationshipOutput {
  AddedToIdea = 'ADDED_TO_IDEA',
  Blocks = 'BLOCKS',
  Causes = 'CAUSES',
  Clones = 'CLONES',
  CreatedFrom = 'CREATED_FROM',
  Duplicates = 'DUPLICATES',
  Implements = 'IMPLEMENTS',
  IsBlockedBy = 'IS_BLOCKED_BY',
  IsCausedBy = 'IS_CAUSED_BY',
  IsClonedBy = 'IS_CLONED_BY',
  IsDuplicatedBy = 'IS_DUPLICATED_BY',
  IsIdeaFor = 'IS_IDEA_FOR',
  IsImplementedBy = 'IS_IMPLEMENTED_BY',
  IsReviewedBy = 'IS_REVIEWED_BY',
  MentionedIn = 'MENTIONED_IN',
  MergedFrom = 'MERGED_FROM',
  MergedInto = 'MERGED_INTO',
  NotSet = 'NOT_SET',
  RelatesTo = 'RELATES_TO',
  Reviews = 'REVIEWS',
  SplitFrom = 'SPLIT_FROM',
  SplitTo = 'SPLIT_TO',
  WikiPage = 'WIKI_PAGE'
}

export enum GraphStoreFullIssueAssociatedPrPullRequestStatusOutput {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullIssueAssociatedPrReviewerReviewerStatusOutput {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphStoreFullJswProjectAssociatedIncidentJiraIncidentPriorityOutput {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullJswProjectAssociatedIncidentJiraIncidentStatusOutput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export enum GraphStoreFullParentDocumentHasChildDocumentCategoryOutput {
  Archive = 'ARCHIVE',
  Audio = 'AUDIO',
  Blogpost = 'BLOGPOST',
  Code = 'CODE',
  Document = 'DOCUMENT',
  Folder = 'FOLDER',
  Form = 'FORM',
  Image = 'IMAGE',
  NotSet = 'NOT_SET',
  Other = 'OTHER',
  Page = 'PAGE',
  Pdf = 'PDF',
  Presentation = 'PRESENTATION',
  Shortcut = 'SHORTCUT',
  Spreadsheet = 'SPREADSHEET',
  Video = 'VIDEO',
  WebPage = 'WEB_PAGE'
}

export enum GraphStoreFullPrInRepoPullRequestStatusOutput {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullPrInRepoReviewerReviewerStatusOutput {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphStoreFullProjectAssociatedBuildBuildStateOutput {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullProjectAssociatedDeploymentDeploymentStateOutput {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullProjectAssociatedDeploymentEnvironmentTypeOutput {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum GraphStoreFullProjectAssociatedPrPullRequestStatusOutput {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullProjectAssociatedPrReviewerReviewerStatusOutput {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphStoreFullProjectAssociatedVulnerabilityVulnerabilitySeverityOutput {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullProjectAssociatedVulnerabilityVulnerabilityStatusOutput {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullProjectAssociatedVulnerabilityVulnerabilityTypeOutput {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSecurityContainerAssociatedToVulnerabilityVulnerabilitySeverityOutput {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSecurityContainerAssociatedToVulnerabilityVulnerabilityStatusOutput {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSecurityContainerAssociatedToVulnerabilityVulnerabilityTypeOutput {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullServiceLinkedIncidentJiraServiceManagementIncidentPriorityOutput {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5'
}

export enum GraphStoreFullServiceLinkedIncidentJiraServiceManagementIncidentStatusOutput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export enum GraphStoreFullSprintAssociatedDeploymentDeploymentStateOutput {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSprintAssociatedDeploymentEnvironmentTypeOutput {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum GraphStoreFullSprintAssociatedPrPullRequestStatusOutput {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSprintAssociatedPrReviewerReviewerStatusOutput {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export enum GraphStoreFullSprintAssociatedVulnerabilityStatusCategoryOutput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export enum GraphStoreFullSprintAssociatedVulnerabilityVulnerabilitySeverityOutput {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSprintAssociatedVulnerabilityVulnerabilityStatusOutput {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullSprintContainsIssueStatusCategoryOutput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export enum GraphStoreFullVersionAssociatedDesignDesignStatusOutput {
  None = 'NONE',
  NotSet = 'NOT_SET',
  ReadyForDevelopment = 'READY_FOR_DEVELOPMENT',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullVersionAssociatedDesignDesignTypeOutput {
  Canvas = 'CANVAS',
  File = 'FILE',
  Group = 'GROUP',
  Node = 'NODE',
  NotSet = 'NOT_SET',
  Other = 'OTHER',
  Prototype = 'PROTOTYPE'
}

export enum GraphStoreFullVulnerabilityAssociatedIssueVulnerabilitySeverityOutput {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullVulnerabilityAssociatedIssueVulnerabilityStatusOutput {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreFullVulnerabilityAssociatedIssueVulnerabilityTypeOutput {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type GraphStoreGraphDocument3pDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreGraphEntityReplicates3pEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreGroupCanViewConfluenceSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIncidentAssociatedPostIncidentReviewLinkSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIncidentAssociatedPostIncidentReviewSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIncidentHasActionItemSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIncidentLinkedJswIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIntFilterInput = {
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['Int']['input']>;
  is?: InputMaybe<Array<Scalars['Int']['input']>>;
  isNot?: InputMaybe<Array<Scalars['Int']['input']>>;
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['Int']['input']>;
};

export type GraphStoreIssueAssociatedBranchSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedBuildSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedCommitSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedDeploymentAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreIssueAssociatedDeploymentAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreIssueAssociatedDeploymentAuthorFilterInput>>>;
};

export type GraphStoreIssueAssociatedDeploymentAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreIssueAssociatedDeploymentAuthorFilterInput>;
  to_environmentType?: InputMaybe<GraphStoreIssueAssociatedDeploymentEnvironmentTypeFilterInput>;
  to_state?: InputMaybe<GraphStoreIssueAssociatedDeploymentDeploymentStateFilterInput>;
};

export enum GraphStoreIssueAssociatedDeploymentDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreIssueAssociatedDeploymentDeploymentStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreIssueAssociatedDeploymentDeploymentState>>;
  isNot?: InputMaybe<Array<GraphStoreIssueAssociatedDeploymentDeploymentState>>;
};

export enum GraphStoreIssueAssociatedDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphStoreIssueAssociatedDeploymentEnvironmentTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreIssueAssociatedDeploymentEnvironmentType>>;
  isNot?: InputMaybe<Array<GraphStoreIssueAssociatedDeploymentEnvironmentType>>;
};

/** Conditional selection for filter field of issue-associated-deployment relationship queries */
export type GraphStoreIssueAssociatedDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreIssueAssociatedDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreIssueAssociatedDeploymentConditionalFilterInput>>>;
};

export type GraphStoreIssueAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreIssueAssociatedDeploymentAuthorSortInput>;
  to_environmentType?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedDesignSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_type?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedIssueRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedPrSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueAssociatedRemoteLinkSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueChangesComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueHasAssigneeSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreIssueHasAutodevJobAutodevJobStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export type GraphStoreIssueHasAutodevJobAutodevJobStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreIssueHasAutodevJobAutodevJobStatus>>;
  isNot?: InputMaybe<Array<GraphStoreIssueHasAutodevJobAutodevJobStatus>>;
};

export type GraphStoreIssueHasAutodevJobConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_agentAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_createdAt?: InputMaybe<GraphStoreLongFilterInput>;
  to_jobOwnerAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_status?: InputMaybe<GraphStoreIssueHasAutodevJobAutodevJobStatusFilterInput>;
  to_updatedAt?: InputMaybe<GraphStoreLongFilterInput>;
};

/** Conditional selection for filter field of issue-has-autodev-job relationship queries */
export type GraphStoreIssueHasAutodevJobFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreIssueHasAutodevJobConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreIssueHasAutodevJobConditionalFilterInput>>>;
};

export type GraphStoreIssueHasAutodevJobSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_agentAri?: InputMaybe<GraphStoreSortInput>;
  to_createdAt?: InputMaybe<GraphStoreSortInput>;
  to_jobOwnerAri?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_updatedAt?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueHasChangedPrioritySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueHasChangedStatusSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueHasCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueMentionedInConversationSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueMentionedInMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueRecursiveAssociatedPrSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueRelatedToIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreIssueToWhiteboardConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of issue-to-whiteboard relationship queries */
export type GraphStoreIssueToWhiteboardFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreIssueToWhiteboardConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreIssueToWhiteboardConditionalFilterInput>>>;
};

export type GraphStoreIssueToWhiteboardSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJcsIssueAssociatedSupportEscalationConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_SupportEscalationLastUpdated?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_linkType?: InputMaybe<GraphStoreJcsIssueAssociatedSupportEscalationEscalationLinkTypeFilterInput>;
  relationship_status?: InputMaybe<GraphStoreJcsIssueAssociatedSupportEscalationEscalationStatusFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
};

export enum GraphStoreJcsIssueAssociatedSupportEscalationEscalationLinkType {
  ExistingWorkItem = 'EXISTING_WORK_ITEM',
  NewWorkItem = 'NEW_WORK_ITEM',
  NotSet = 'NOT_SET'
}

export type GraphStoreJcsIssueAssociatedSupportEscalationEscalationLinkTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreJcsIssueAssociatedSupportEscalationEscalationLinkType>>;
  isNot?: InputMaybe<Array<GraphStoreJcsIssueAssociatedSupportEscalationEscalationLinkType>>;
};

export enum GraphStoreJcsIssueAssociatedSupportEscalationEscalationStatus {
  Accepted = 'ACCEPTED',
  Open = 'OPEN',
  Rejected = 'REJECTED'
}

export type GraphStoreJcsIssueAssociatedSupportEscalationEscalationStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreJcsIssueAssociatedSupportEscalationEscalationStatus>>;
  isNot?: InputMaybe<Array<GraphStoreJcsIssueAssociatedSupportEscalationEscalationStatus>>;
};

/** Conditional selection for filter field of jcs-issue-associated-support-escalation relationship queries */
export type GraphStoreJcsIssueAssociatedSupportEscalationFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreJcsIssueAssociatedSupportEscalationConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreJcsIssueAssociatedSupportEscalationConditionalFilterInput>>>;
};

export type GraphStoreJcsIssueAssociatedSupportEscalationSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_SupportEscalationLastUpdated?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_linkType?: InputMaybe<GraphStoreSortInput>;
  relationship_status?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJiraEpicContributesToAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJiraIssueBlockedByJiraIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJiraIssueToJiraPrioritySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJiraProjectAssociatedAtlasGoalSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJiraRepoIsProviderRepoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJiraWorkItemCommentHasChildCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJiraWorkItemLinksAssetObjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJsmProjectAssociatedServiceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJsmProjectLinkedKbSourcesSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJswProjectAssociatedComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJswProjectAssociatedIncidentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_affectedServiceAris?: InputMaybe<GraphStoreAriFilterInput>;
  to_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_majorIncident?: InputMaybe<GraphStoreBooleanFilterInput>;
  to_priority?: InputMaybe<GraphStoreJswProjectAssociatedIncidentJiraIncidentPriorityFilterInput>;
  to_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_status?: InputMaybe<GraphStoreJswProjectAssociatedIncidentJiraIncidentStatusFilterInput>;
};

/** Conditional selection for filter field of jsw-project-associated-incident relationship queries */
export type GraphStoreJswProjectAssociatedIncidentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreJswProjectAssociatedIncidentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreJswProjectAssociatedIncidentConditionalFilterInput>>>;
};

export enum GraphStoreJswProjectAssociatedIncidentJiraIncidentPriority {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export type GraphStoreJswProjectAssociatedIncidentJiraIncidentPriorityFilterInput = {
  is?: InputMaybe<Array<GraphStoreJswProjectAssociatedIncidentJiraIncidentPriority>>;
  isNot?: InputMaybe<Array<GraphStoreJswProjectAssociatedIncidentJiraIncidentPriority>>;
};

export enum GraphStoreJswProjectAssociatedIncidentJiraIncidentStatus {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export type GraphStoreJswProjectAssociatedIncidentJiraIncidentStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreJswProjectAssociatedIncidentJiraIncidentStatus>>;
  isNot?: InputMaybe<Array<GraphStoreJswProjectAssociatedIncidentJiraIncidentStatus>>;
};

export type GraphStoreJswProjectAssociatedIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_affectedServiceAris?: InputMaybe<GraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  to_majorIncident?: InputMaybe<GraphStoreSortInput>;
  to_priority?: InputMaybe<GraphStoreSortInput>;
  to_reporterAri?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreJswProjectSharesComponentWithJsmProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreLinkedProjectHasVersionSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreLongFilterInput = {
  greaterThan?: InputMaybe<Scalars['Long']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['Long']['input']>;
  is?: InputMaybe<Array<Scalars['Long']['input']>>;
  isNot?: InputMaybe<Array<Scalars['Long']['input']>>;
  lessThan?: InputMaybe<Scalars['Long']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['Long']['input']>;
};

export type GraphStoreLoomMeetingRecurrenceHasLoomMeetingSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreLoomVideoHasConfluencePageSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreMediaAttachedToContentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreMeetingHasJiraProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreMeetingHasMeetingNotesPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreMeetingHasVideoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreMeetingRecordingOwnerHasMeetingNotesFolderSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreMeetingRecurrenceHasJiraProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreMeetingRecurrenceHasMeetingRecurrenceNotesPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreOperationsContainerImpactedByIncidentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreOperationsContainerImprovedByActionItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreParentCommentHasChildCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreParentDocumentHasChildDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreParentIssueHasChildIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreParentMessageHasChildMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreParentTeamHasChildTeamSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStorePlanHasPortfolioSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStorePlanHasScenarioSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStorePlanScenarioHasInvestmentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStorePlanScenarioInvestmentHasInvestmentEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStorePositionAllocatedToFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStorePositionAssociatedExternalPositionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStorePrHasCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStorePrInProviderRepoSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStorePrInRepoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreProjectAssociatedAutodevJobAutodevJobStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedAutodevJobAutodevJobStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedAutodevJobAutodevJobStatus>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedAutodevJobAutodevJobStatus>>;
};

export type GraphStoreProjectAssociatedAutodevJobConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_agentAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_createdAt?: InputMaybe<GraphStoreLongFilterInput>;
  to_jobOwnerAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_status?: InputMaybe<GraphStoreProjectAssociatedAutodevJobAutodevJobStatusFilterInput>;
  to_updatedAt?: InputMaybe<GraphStoreLongFilterInput>;
};

/** Conditional selection for filter field of project-associated-autodev-job relationship queries */
export type GraphStoreProjectAssociatedAutodevJobFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedAutodevJobConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedAutodevJobConditionalFilterInput>>>;
};

export type GraphStoreProjectAssociatedAutodevJobSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_agentAri?: InputMaybe<GraphStoreSortInput>;
  to_createdAt?: InputMaybe<GraphStoreSortInput>;
  to_jobOwnerAri?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_updatedAt?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedBranchSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreProjectAssociatedBuildBuildState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedBuildBuildStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedBuildBuildState>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedBuildBuildState>>;
};

export type GraphStoreProjectAssociatedBuildConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_state?: InputMaybe<GraphStoreProjectAssociatedBuildBuildStateFilterInput>;
  to_testInfo?: InputMaybe<GraphStoreProjectAssociatedBuildTestInfoFilterInput>;
};

/** Conditional selection for filter field of project-associated-build relationship queries */
export type GraphStoreProjectAssociatedBuildFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedBuildConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedBuildConditionalFilterInput>>>;
};

export type GraphStoreProjectAssociatedBuildSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
  to_testInfo?: InputMaybe<GraphStoreProjectAssociatedBuildTestInfoSortInput>;
};

export type GraphStoreProjectAssociatedBuildTestInfoFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedBuildTestInfoFilterInput>>>;
  numberFailed?: InputMaybe<GraphStoreLongFilterInput>;
  numberPassed?: InputMaybe<GraphStoreLongFilterInput>;
  numberSkipped?: InputMaybe<GraphStoreLongFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedBuildTestInfoFilterInput>>>;
  totalNumber?: InputMaybe<GraphStoreLongFilterInput>;
};

export type GraphStoreProjectAssociatedBuildTestInfoSortInput = {
  numberFailed?: InputMaybe<GraphStoreSortInput>;
  numberPassed?: InputMaybe<GraphStoreSortInput>;
  numberSkipped?: InputMaybe<GraphStoreSortInput>;
  totalNumber?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedDeploymentAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedDeploymentAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedDeploymentAuthorFilterInput>>>;
};

export type GraphStoreProjectAssociatedDeploymentAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_fixVersionIds?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_issueTypeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreProjectAssociatedDeploymentAuthorFilterInput>;
  to_deploymentLastUpdated?: InputMaybe<GraphStoreLongFilterInput>;
  to_environmentType?: InputMaybe<GraphStoreProjectAssociatedDeploymentEnvironmentTypeFilterInput>;
  to_state?: InputMaybe<GraphStoreProjectAssociatedDeploymentDeploymentStateFilterInput>;
};

export enum GraphStoreProjectAssociatedDeploymentDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedDeploymentDeploymentStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedDeploymentDeploymentState>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedDeploymentDeploymentState>>;
};

export enum GraphStoreProjectAssociatedDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphStoreProjectAssociatedDeploymentEnvironmentTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedDeploymentEnvironmentType>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedDeploymentEnvironmentType>>;
};

/** Conditional selection for filter field of project-associated-deployment relationship queries */
export type GraphStoreProjectAssociatedDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedDeploymentConditionalFilterInput>>>;
};

export type GraphStoreProjectAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_fixVersionIds?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_issueTypeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreProjectAssociatedDeploymentAuthorSortInput>;
  to_deploymentLastUpdated?: InputMaybe<GraphStoreSortInput>;
  to_environmentType?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedIncidentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of project-associated-incident relationship queries */
export type GraphStoreProjectAssociatedIncidentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedIncidentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedIncidentConditionalFilterInput>>>;
};

export type GraphStoreProjectAssociatedIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedOpsgenieTeamSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedPrAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedPrAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedPrAuthorFilterInput>>>;
};

export type GraphStoreProjectAssociatedPrAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedPrConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreProjectAssociatedPrAuthorFilterInput>;
  to_reviewers?: InputMaybe<GraphStoreProjectAssociatedPrReviewerFilterInput>;
  to_status?: InputMaybe<GraphStoreProjectAssociatedPrPullRequestStatusFilterInput>;
  to_taskCount?: InputMaybe<GraphStoreFloatFilterInput>;
};

/** Conditional selection for filter field of project-associated-pr relationship queries */
export type GraphStoreProjectAssociatedPrFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedPrConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedPrConditionalFilterInput>>>;
};

export enum GraphStoreProjectAssociatedPrPullRequestStatus {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedPrPullRequestStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedPrPullRequestStatus>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedPrPullRequestStatus>>;
};

export type GraphStoreProjectAssociatedPrReviewerFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedPrReviewerFilterInput>>>;
  approvalStatus?: InputMaybe<GraphStoreProjectAssociatedPrReviewerReviewerStatusFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedPrReviewerFilterInput>>>;
  reviewerAri?: InputMaybe<GraphStoreAriFilterInput>;
};

export enum GraphStoreProjectAssociatedPrReviewerReviewerStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export type GraphStoreProjectAssociatedPrReviewerReviewerStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedPrReviewerReviewerStatus>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedPrReviewerReviewerStatus>>;
};

export type GraphStoreProjectAssociatedPrReviewerSortInput = {
  approvalStatus?: InputMaybe<GraphStoreSortInput>;
  reviewerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedPrSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreProjectAssociatedPrAuthorSortInput>;
  to_reviewers?: InputMaybe<GraphStoreProjectAssociatedPrReviewerSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_taskCount?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedRepoConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_providerAri?: InputMaybe<GraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of project-associated-repo relationship queries */
export type GraphStoreProjectAssociatedRepoFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedRepoConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedRepoConditionalFilterInput>>>;
};

export type GraphStoreProjectAssociatedRepoSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_providerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedServiceConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of project-associated-service relationship queries */
export type GraphStoreProjectAssociatedServiceFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedServiceConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedServiceConditionalFilterInput>>>;
};

export type GraphStoreProjectAssociatedServiceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedToIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedToOperationsContainerSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedToSecurityContainerSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectAssociatedVulnerabilityConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_container?: InputMaybe<GraphStoreProjectAssociatedVulnerabilityContainerFilterInput>;
  to_severity?: InputMaybe<GraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverityFilterInput>;
  to_status?: InputMaybe<GraphStoreProjectAssociatedVulnerabilityVulnerabilityStatusFilterInput>;
  to_type?: InputMaybe<GraphStoreProjectAssociatedVulnerabilityVulnerabilityTypeFilterInput>;
};

export type GraphStoreProjectAssociatedVulnerabilityContainerFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedVulnerabilityContainerFilterInput>>>;
  containerAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedVulnerabilityContainerFilterInput>>>;
};

export type GraphStoreProjectAssociatedVulnerabilityContainerSortInput = {
  containerAri?: InputMaybe<GraphStoreSortInput>;
};

/** Conditional selection for filter field of project-associated-vulnerability relationship queries */
export type GraphStoreProjectAssociatedVulnerabilityFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedVulnerabilityConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectAssociatedVulnerabilityConditionalFilterInput>>>;
};

export type GraphStoreProjectAssociatedVulnerabilitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_container?: InputMaybe<GraphStoreProjectAssociatedVulnerabilityContainerSortInput>;
  to_severity?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_type?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverityFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverity>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverity>>;
};

export enum GraphStoreProjectAssociatedVulnerabilityVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedVulnerabilityVulnerabilityStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedVulnerabilityVulnerabilityStatus>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedVulnerabilityVulnerabilityStatus>>;
};

export enum GraphStoreProjectAssociatedVulnerabilityVulnerabilityType {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type GraphStoreProjectAssociatedVulnerabilityVulnerabilityTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreProjectAssociatedVulnerabilityVulnerabilityType>>;
  isNot?: InputMaybe<Array<GraphStoreProjectAssociatedVulnerabilityVulnerabilityType>>;
};

export type GraphStoreProjectDisassociatedRepoSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectDocumentationEntitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectDocumentationPageSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectDocumentationSpaceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectExplicitlyAssociatedRepoSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_providerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectHasAvpDashboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectHasIssueConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_fixVersionIds?: InputMaybe<GraphStoreLongFilterInput>;
  to_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_issueTypeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of project-has-issue relationship queries */
export type GraphStoreProjectHasIssueFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreProjectHasIssueConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreProjectHasIssueConditionalFilterInput>>>;
};

export type GraphStoreProjectHasIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  to_creatorAri?: InputMaybe<GraphStoreSortInput>;
  to_fixVersionIds?: InputMaybe<GraphStoreSortInput>;
  to_issueAri?: InputMaybe<GraphStoreSortInput>;
  to_issueTypeAri?: InputMaybe<GraphStoreSortInput>;
  to_reporterAri?: InputMaybe<GraphStoreSortInput>;
  to_statusAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectHasRelatedWorkWithProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectHasSharedVersionWithSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectHasVersionSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectLinkedToCompassComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreProjectLinksToEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStorePullRequestLinksToServiceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreScorecardHasAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSecurityContainerAssociatedToVulnerabilitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreServiceAssociatedBranchSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreServiceAssociatedBuildSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreServiceAssociatedCommitSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreServiceAssociatedDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of service-associated-deployment relationship queries */
export type GraphStoreServiceAssociatedDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreServiceAssociatedDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreServiceAssociatedDeploymentConditionalFilterInput>>>;
};

export type GraphStoreServiceAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreServiceAssociatedFeatureFlagSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreServiceAssociatedPrSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreServiceAssociatedRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreServiceAssociatedRepositorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreServiceAssociatedTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreServiceLinkedIncidentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_affectedServiceAris?: InputMaybe<GraphStoreAriFilterInput>;
  to_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_majorIncident?: InputMaybe<GraphStoreBooleanFilterInput>;
  to_priority?: InputMaybe<GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriorityFilterInput>;
  to_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_status?: InputMaybe<GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatusFilterInput>;
};

/** Conditional selection for filter field of service-linked-incident relationship queries */
export type GraphStoreServiceLinkedIncidentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreServiceLinkedIncidentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreServiceLinkedIncidentConditionalFilterInput>>>;
};

export enum GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriority {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5'
}

export type GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriorityFilterInput = {
  is?: InputMaybe<Array<GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriority>>;
  isNot?: InputMaybe<Array<GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriority>>;
};

export enum GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatus {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export type GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatus>>;
  isNot?: InputMaybe<Array<GraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatus>>;
};

export type GraphStoreServiceLinkedIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_affectedServiceAris?: InputMaybe<GraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  to_majorIncident?: InputMaybe<GraphStoreSortInput>;
  to_priority?: InputMaybe<GraphStoreSortInput>;
  to_reporterAri?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSortInput = {
  /** The direction of the sort. For enums the order is determined by the order of enum values in the protobuf schema. */
  direction: SortDirection;
  /** The priority of the field. Higher keys are used to resolve ties when lower keys have the same value. If there is only one sorting option, the priority value becomes irrelevant. */
  priority: Scalars['Int']['input'];
};

export type GraphStoreSpaceAssociatedWithProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSpaceHasPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintAssociatedDeploymentAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedDeploymentAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedDeploymentAuthorFilterInput>>>;
};

export type GraphStoreSprintAssociatedDeploymentAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintAssociatedDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreSprintAssociatedDeploymentAuthorFilterInput>;
  to_environmentType?: InputMaybe<GraphStoreSprintAssociatedDeploymentEnvironmentTypeFilterInput>;
  to_state?: InputMaybe<GraphStoreSprintAssociatedDeploymentDeploymentStateFilterInput>;
};

export enum GraphStoreSprintAssociatedDeploymentDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreSprintAssociatedDeploymentDeploymentStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedDeploymentDeploymentState>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedDeploymentDeploymentState>>;
};

export enum GraphStoreSprintAssociatedDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphStoreSprintAssociatedDeploymentEnvironmentTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedDeploymentEnvironmentType>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedDeploymentEnvironmentType>>;
};

/** Conditional selection for filter field of sprint-associated-deployment relationship queries */
export type GraphStoreSprintAssociatedDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedDeploymentConditionalFilterInput>>>;
};

export type GraphStoreSprintAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreSprintAssociatedDeploymentAuthorSortInput>;
  to_environmentType?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintAssociatedPrAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedPrAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedPrAuthorFilterInput>>>;
};

export type GraphStoreSprintAssociatedPrAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintAssociatedPrConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreSprintAssociatedPrAuthorFilterInput>;
  to_reviewers?: InputMaybe<GraphStoreSprintAssociatedPrReviewerFilterInput>;
  to_status?: InputMaybe<GraphStoreSprintAssociatedPrPullRequestStatusFilterInput>;
  to_taskCount?: InputMaybe<GraphStoreFloatFilterInput>;
};

/** Conditional selection for filter field of sprint-associated-pr relationship queries */
export type GraphStoreSprintAssociatedPrFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedPrConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedPrConditionalFilterInput>>>;
};

export enum GraphStoreSprintAssociatedPrPullRequestStatus {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphStoreSprintAssociatedPrPullRequestStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedPrPullRequestStatus>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedPrPullRequestStatus>>;
};

export type GraphStoreSprintAssociatedPrReviewerFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedPrReviewerFilterInput>>>;
  approvalStatus?: InputMaybe<GraphStoreSprintAssociatedPrReviewerReviewerStatusFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedPrReviewerFilterInput>>>;
  reviewerAri?: InputMaybe<GraphStoreAriFilterInput>;
};

export enum GraphStoreSprintAssociatedPrReviewerReviewerStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export type GraphStoreSprintAssociatedPrReviewerReviewerStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedPrReviewerReviewerStatus>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedPrReviewerReviewerStatus>>;
};

export type GraphStoreSprintAssociatedPrReviewerSortInput = {
  approvalStatus?: InputMaybe<GraphStoreSortInput>;
  reviewerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintAssociatedPrSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreSprintAssociatedPrAuthorSortInput>;
  to_reviewers?: InputMaybe<GraphStoreSprintAssociatedPrReviewerSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_taskCount?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintAssociatedVulnerabilityConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusCategory?: InputMaybe<GraphStoreSprintAssociatedVulnerabilityStatusCategoryFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_introducedDate?: InputMaybe<GraphStoreLongFilterInput>;
  to_severity?: InputMaybe<GraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverityFilterInput>;
  to_status?: InputMaybe<GraphStoreSprintAssociatedVulnerabilityVulnerabilityStatusFilterInput>;
};

/** Conditional selection for filter field of sprint-associated-vulnerability relationship queries */
export type GraphStoreSprintAssociatedVulnerabilityFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedVulnerabilityConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintAssociatedVulnerabilityConditionalFilterInput>>>;
};

export type GraphStoreSprintAssociatedVulnerabilitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusCategory?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_introducedDate?: InputMaybe<GraphStoreSortInput>;
  to_severity?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreSprintAssociatedVulnerabilityStatusCategory {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphStoreSprintAssociatedVulnerabilityStatusCategoryFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedVulnerabilityStatusCategory>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedVulnerabilityStatusCategory>>;
};

export enum GraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export type GraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverityFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverity>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverity>>;
};

export enum GraphStoreSprintAssociatedVulnerabilityVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphStoreSprintAssociatedVulnerabilityVulnerabilityStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintAssociatedVulnerabilityVulnerabilityStatus>>;
  isNot?: InputMaybe<Array<GraphStoreSprintAssociatedVulnerabilityVulnerabilityStatus>>;
};

export type GraphStoreSprintContainsIssueConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_statusCategory?: InputMaybe<GraphStoreSprintContainsIssueStatusCategoryFilterInput>;
};

/** Conditional selection for filter field of sprint-contains-issue relationship queries */
export type GraphStoreSprintContainsIssueFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreSprintContainsIssueConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreSprintContainsIssueConditionalFilterInput>>>;
};

export type GraphStoreSprintContainsIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  to_creatorAri?: InputMaybe<GraphStoreSortInput>;
  to_issueAri?: InputMaybe<GraphStoreSortInput>;
  to_reporterAri?: InputMaybe<GraphStoreSortInput>;
  to_statusAri?: InputMaybe<GraphStoreSortInput>;
  to_statusCategory?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreSprintContainsIssueStatusCategory {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphStoreSprintContainsIssueStatusCategoryFilterInput = {
  is?: InputMaybe<Array<GraphStoreSprintContainsIssueStatusCategory>>;
  isNot?: InputMaybe<Array<GraphStoreSprintContainsIssueStatusCategory>>;
};

export type GraphStoreSprintRetrospectivePageSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreSprintRetrospectiveWhiteboardSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreTeamConnectedToContainerSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_createdFromAutocreate?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreTeamHasAgentsSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreTeamHasCustomFieldValueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreTeamIsOfTypeSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreTeamOwnsComponentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreTeamWorksOnProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreThirdPartyToGraphRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreTopicHasRelatedEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserApprovesPlanSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserAssignedIncidentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserAssignedIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserAssignedPirSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserAssignedWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserAttendedCalendarEventConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_isRecurringEvent?: InputMaybe<GraphStoreBooleanFilterInput>;
  relationship_rsvpStatus?: InputMaybe<GraphStoreUserAttendedCalendarEventRsvpStatusFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_eventEndTime?: InputMaybe<GraphStoreLongFilterInput>;
  to_eventStartTime?: InputMaybe<GraphStoreLongFilterInput>;
};

/** Conditional selection for filter field of user-attended-calendar-event relationship queries */
export type GraphStoreUserAttendedCalendarEventFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreUserAttendedCalendarEventConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreUserAttendedCalendarEventConditionalFilterInput>>>;
};

export enum GraphStoreUserAttendedCalendarEventRsvpStatus {
  Accepted = 'ACCEPTED',
  Declined = 'DECLINED',
  NotResponded = 'NOT_RESPONDED',
  NotSet = 'NOT_SET',
  Other = 'OTHER',
  TentativelyAccepted = 'TENTATIVELY_ACCEPTED'
}

export type GraphStoreUserAttendedCalendarEventRsvpStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreUserAttendedCalendarEventRsvpStatus>>;
  isNot?: InputMaybe<Array<GraphStoreUserAttendedCalendarEventRsvpStatus>>;
};

export type GraphStoreUserAttendedCalendarEventSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_isRecurringEvent?: InputMaybe<GraphStoreSortInput>;
  relationship_rsvpStatus?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_eventEndTime?: InputMaybe<GraphStoreSortInput>;
  to_eventStartTime?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserAuthoredCommitSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserAuthoredPrSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserAuthoritativelyLinkedThirdPartyUserConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_graphworkspaceAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_integrationAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_graphworkspaceAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_integrationAri?: InputMaybe<GraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of user-authoritatively-linked-third-party-user relationship queries */
export type GraphStoreUserAuthoritativelyLinkedThirdPartyUserFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreUserAuthoritativelyLinkedThirdPartyUserConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreUserAuthoritativelyLinkedThirdPartyUserConditionalFilterInput>>>;
};

export type GraphStoreUserAuthoritativelyLinkedThirdPartyUserSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_graphworkspaceAri?: InputMaybe<GraphStoreSortInput>;
  relationship_integrationAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_graphworkspaceAri?: InputMaybe<GraphStoreSortInput>;
  to_integrationAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCanViewConfluenceSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCollaboratedOnDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserContributedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserContributedConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserContributedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserContributedConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedAtlasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedBranchSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedCalendarEventConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_eventEndTime?: InputMaybe<GraphStoreLongFilterInput>;
  to_eventStartTime?: InputMaybe<GraphStoreLongFilterInput>;
};

/** Conditional selection for filter field of user-created-calendar-event relationship queries */
export type GraphStoreUserCreatedCalendarEventFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreUserCreatedCalendarEventConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreUserCreatedCalendarEventConditionalFilterInput>>>;
};

export type GraphStoreUserCreatedCalendarEventSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_eventEndTime?: InputMaybe<GraphStoreSortInput>;
  to_eventStartTime?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedConfluenceCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedConfluenceEmbedSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedConfluenceSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedDesignSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedExternalCustomerOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedExternalDashboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedExternalDataTableSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedExternalDealSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedExternalSoftwareServiceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedExternalSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedExternalTestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedIssueCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedIssueWorklogSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedPrCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedReleaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedRepositorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedTownsquareCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedVideoCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedVideoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserCreatedWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserFavoritedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserFavoritedConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserFavoritedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserFavoritedConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserFavoritedFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserFavoritedTeamSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserFavoritedTownsquareGoalSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserFavoritedTownsquareProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserHasExternalPositionSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserHasRelevantProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserHasTopProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserIsInTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserLastUpdatedDesignSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserLaunchedReleaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserLikedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserLinkedThirdPartyUserConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_graphworkspaceAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_integrationAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_graphworkspaceAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_integrationAri?: InputMaybe<GraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of user-linked-third-party-user relationship queries */
export type GraphStoreUserLinkedThirdPartyUserFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreUserLinkedThirdPartyUserConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreUserLinkedThirdPartyUserConditionalFilterInput>>>;
};

export type GraphStoreUserLinkedThirdPartyUserSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_graphworkspaceAri?: InputMaybe<GraphStoreSortInput>;
  relationship_integrationAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_graphworkspaceAri?: InputMaybe<GraphStoreSortInput>;
  to_integrationAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserMemberOfConversationSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserMentionedInConversationSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserMentionedInMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserMentionedInVideoCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnedBranchSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnedCalendarEventSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnedDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnedExternalCustomerOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnedExternalDashboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnedExternalDataTableSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnedExternalDealSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnedExternalSoftwareServiceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnedExternalSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnedExternalTestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnedRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnedRepositorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnsComponentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of user-owns-component relationship queries */
export type GraphStoreUserOwnsComponentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreUserOwnsComponentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreUserOwnsComponentConditionalFilterInput>>>;
};

export type GraphStoreUserOwnsComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnsFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnsPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserOwnsPlanSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserReactedToIssueCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserReactionVideoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserReportedIncidentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserReportsIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserReviewsPrSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserSnapshottedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserTaggedInCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserTaggedInConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserTaggedInIssueCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserTaggedInIssueDescriptionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserTrashedConfluenceContentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserTriggeredDeploymentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedAtlasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedConfluenceSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedExternalCustomerOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedExternalDashboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedExternalDataTableSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedExternalDealSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedExternalSoftwareServiceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedExternalSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedExternalTestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedGraphDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserUpdatedIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserViewed3pRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserViewedAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserViewedAtlasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserViewedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserViewedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserViewedDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserViewedGoalUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserViewedJiraIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserViewedProjectUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserViewedVideoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserWatchesConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserWatchesConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserWatchesConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreUserWatchesTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianGoalHasAtlassianGoalUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianGoalHasAtlassianHomeTagSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianGoalHasChildAtlassianGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianGoalHasFocusChangeProposalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianGoalLinksJiraAlignProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianGroupCanViewConfluenceSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianProjectContributesToAtlassianGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianProjectDependsOnAtlassianProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianProjectHasAtlassianHomeTagSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianProjectHasAtlassianProjectUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianProjectLinksAtlassianProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianTeamHasAtlassianAgentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianTeamHasAtlassianTeamCustomFieldValueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianTeamHasChildAtlassianTeamSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianTeamIsAtlassianTeamTypeSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianTeamLinksSpaceEntitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_createdFromAutocreate?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianTeamOwnsCompassComponentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianTeamReceivedFocusAskSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianTeamSubmittedFocusAskSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserApprovesFocusStrategicPlanSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserAssignedJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserAssignedJsmIncidentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserAssignedJsmPostIncidentReviewSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserAuthoritativelyLinkedExternalUserConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_graphworkspaceAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_integrationAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_graphworkspaceAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_integrationAri?: InputMaybe<GraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of AtlassianUserAuthoritativelyLinkedExternalUser alias queries */
export type GraphStoreV2AtlassianUserAuthoritativelyLinkedExternalUserFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2AtlassianUserAuthoritativelyLinkedExternalUserConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2AtlassianUserAuthoritativelyLinkedExternalUserConditionalFilterInput>>>;
};

export type GraphStoreV2AtlassianUserAuthoritativelyLinkedExternalUserSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_graphworkspaceAri?: InputMaybe<GraphStoreSortInput>;
  relationship_integrationAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_graphworkspaceAri?: InputMaybe<GraphStoreSortInput>;
  to_integrationAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCanViewConfluenceSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserContributedToConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserContributedToConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserContributedToConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserContributedToConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserContributesToAtlassianGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserContributesToAtlassianProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedAtlassianGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedAtlassianGoalUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedAtlassianHomeCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedAtlassianProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedAtlassianProjectUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedConfluenceCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedConfluenceEmbedSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedConfluenceSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedExternalCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedExternalRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedExternalRepositorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedJiraReleaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedJiraWorkItemCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedJiraWorkItemWorklogSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedLoomVideoCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserCreatedLoomVideoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalFilterInput>>>;
  category?: InputMaybe<GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategoryFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalFilterInput>>>;
};

export enum GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategory {
  CommentAssigned = 'COMMENT_ASSIGNED',
  CommentMention = 'COMMENT_MENTION',
  CommentReply = 'COMMENT_REPLY',
  IssueApproval = 'ISSUE_APPROVAL',
  IssueDueSoon = 'ISSUE_DUE_SOON',
  NotSet = 'NOT_SET',
  ProjectInviterContext = 'PROJECT_INVITER_CONTEXT',
  ProjectPopularity = 'PROJECT_POPULARITY',
  PrReview = 'PR_REVIEW',
  TeamCollaboratorsCreate = 'TEAM_COLLABORATORS_CREATE',
  TeamCollaboratorsJoin = 'TEAM_COLLABORATORS_JOIN',
  TeamInviterContext = 'TEAM_INVITER_CONTEXT',
  TeamPopularity = 'TEAM_POPULARITY'
}

export type GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategoryFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategory>>;
  isNot?: InputMaybe<Array<GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategory>>;
};

export type GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalSortInput = {
  category?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_dismissedCategories?: InputMaybe<GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_dismissedCategories?: InputMaybe<GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalFilterInput>;
};

/** Conditional selection for filter field of AtlassianUserDismissedJiraForYouRecommendationEntity alias queries */
export type GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityConditionalFilterInput>>>;
};

export type GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_dismissedCategories?: InputMaybe<GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_dismissedCategories?: InputMaybe<GraphStoreV2AtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalSortInput>;
};

export type GraphStoreV2AtlassianUserFavoritedAtlassianGoalSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserFavoritedAtlassianProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserFavoritedAtlassianTeamSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserFavoritedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserFavoritedConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserFavoritedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserFavoritedConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserFavoritedFocusFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserFollowsAtlassianGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserFollowsAtlassianProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserHasConfluenceMeetingNotesFolderSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserHasExternalPositionSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserHasRelevantJiraSpaceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserInvitedToLoomMeetingSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserIsInAtlassianTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserLaunchedJiraReleaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserLikedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserLinksExternalCustomerContactSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserLinksExternalUserConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_graphworkspaceAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_integrationAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_graphworkspaceAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_integrationAri?: InputMaybe<GraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of AtlassianUserLinksExternalUser alias queries */
export type GraphStoreV2AtlassianUserLinksExternalUserFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2AtlassianUserLinksExternalUserConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2AtlassianUserLinksExternalUserConditionalFilterInput>>>;
};

export type GraphStoreV2AtlassianUserLinksExternalUserSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_graphworkspaceAri?: InputMaybe<GraphStoreSortInput>;
  relationship_integrationAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_graphworkspaceAri?: InputMaybe<GraphStoreSortInput>;
  to_integrationAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserMentionedInConfluenceCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserMentionedInConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserMentionedInJiraWorkItemCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserMentionedInJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserMentionedInLoomVideoCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserOwnsAtlassianGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserOwnsAtlassianProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserOwnsCompassComponentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of AtlassianUserOwnsCompassComponent alias queries */
export type GraphStoreV2AtlassianUserOwnsCompassComponentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2AtlassianUserOwnsCompassComponentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2AtlassianUserOwnsCompassComponentConditionalFilterInput>>>;
};

export type GraphStoreV2AtlassianUserOwnsCompassComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserOwnsConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserOwnsExternalBranchSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserOwnsExternalRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserOwnsFocusAskSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserOwnsFocusFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserOwnsFocusStrategicPlanSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserReactedToJiraWorkItemCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserReactedToLoomVideoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserReportedJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserReportedJsmIncidentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserSnapshottedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserSubmittedFocusAskSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserTrashedConfluenceContentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserTriggeredExternalDeploymentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserUpdatedAtlassianGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserUpdatedAtlassianProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserUpdatedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserUpdatedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserUpdatedConfluenceSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserUpdatedConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserUpdatedJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserViewedAtlassianGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserViewedAtlassianGoalUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserViewedAtlassianProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserViewedAtlassianProjectUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserViewedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserViewedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserViewedJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserViewedLoomVideoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserViewedThirdPartyDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserViewedThirdPartyRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserWatchesAtlassianTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserWatchesConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserWatchesConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserWatchesConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2AtlassianUserWatchesFocusFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2BitbucketRepositoryHasExternalPullRequestSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2CompassComponentHasCompassComponentLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2CompassComponentLinkIsJiraSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2CompassScorecardHasAtlassianGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluenceBlogpostHasConfluenceCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluenceBlogpostSharedWithAtlassianUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluenceCommentHasChildConfluenceCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluencePageHasChildConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluencePageHasConfluenceCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluencePageHasConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluencePageSharedWithAtlassianGroupSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluencePageSharedWithAtlassianUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluenceSpaceHasConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluenceSpaceHasConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluenceSpaceHasConfluenceFolderSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluenceSpaceHasConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluenceSpaceHasConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ConfluenceSpaceLinksJiraSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ContentEntityLinksEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2CreateAtlassianHomeTagIsAliasOfAtlassianHomeTagAliasInput = {
  /** An ARI of type ati:cloud:townsquare:tag */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:townsquare:tag */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateAtlassianHomeTagIsAliasOfAtlassianHomeTagInput = {
  /** The list of relationships of alias AtlassianHomeTagIsAliasOfAtlassianHomeTag to create */
  aliases: Array<GraphStoreV2CreateAtlassianHomeTagIsAliasOfAtlassianHomeTagAliasInput>;
};

export type GraphStoreV2CreateAtlassianTeamHasChildAtlassianTeamAliasInput = {
  /** An ARI of type ati:cloud:identity:team */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:identity:team */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateAtlassianTeamHasChildAtlassianTeamInput = {
  /** The list of relationships of alias AtlassianTeamHasChildAtlassianTeam to create */
  aliases: Array<GraphStoreV2CreateAtlassianTeamHasChildAtlassianTeamAliasInput>;
};

export type GraphStoreV2CreateAtlassianTeamLinksSpaceEntityAliasInput = {
  /** An ARI of type ati:cloud:identity:team */
  from: Scalars['ID']['input'];
  /** Relationship specific metadata */
  relationshipMetadata?: InputMaybe<GraphStoreV2CreateAtlassianTeamLinksSpaceEntityRelationshipMetadataInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:confluence:space, ati:cloud:loom:space] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateAtlassianTeamLinksSpaceEntityInput = {
  /** The list of relationships of alias AtlassianTeamLinksSpaceEntity to create */
  aliases: Array<GraphStoreV2CreateAtlassianTeamLinksSpaceEntityAliasInput>;
  /** If true, the request will wait until the relationship is created before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreV2CreateAtlassianTeamLinksSpaceEntityRelationshipMetadataInput = {
  createdFromAutocreate?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreV2CreateAtlassianUserDismissedJiraForYouRecommendationEntityAliasInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** Object metadata for this relationship */
  objectMetadata?: InputMaybe<GraphStoreV2CreateAtlassianUserDismissedJiraForYouRecommendationEntityRelationshipObjectMetadataInput>;
  /** Relationship specific metadata */
  relationshipMetadata?: InputMaybe<GraphStoreV2CreateAtlassianUserDismissedJiraForYouRecommendationEntityRelationshipMetadataInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:project, ati:cloud:jira:issue-comment, ati:cloud:identity:team, ati:cloud:jira:pull-request, ati:cloud:graph:pull-request] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalInput = {
  category?: InputMaybe<GraphStoreV2CreateAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategoryInput>;
};

export enum GraphStoreV2CreateAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalRecommendationCategoryInput {
  CommentAssigned = 'COMMENT_ASSIGNED',
  CommentMention = 'COMMENT_MENTION',
  CommentReply = 'COMMENT_REPLY',
  IssueApproval = 'ISSUE_APPROVAL',
  IssueDueSoon = 'ISSUE_DUE_SOON',
  NotSet = 'NOT_SET',
  ProjectInviterContext = 'PROJECT_INVITER_CONTEXT',
  ProjectPopularity = 'PROJECT_POPULARITY',
  PrReview = 'PR_REVIEW',
  TeamCollaboratorsCreate = 'TEAM_COLLABORATORS_CREATE',
  TeamCollaboratorsJoin = 'TEAM_COLLABORATORS_JOIN',
  TeamInviterContext = 'TEAM_INVITER_CONTEXT',
  TeamPopularity = 'TEAM_POPULARITY'
}

export type GraphStoreV2CreateAtlassianUserDismissedJiraForYouRecommendationEntityInput = {
  /** The list of relationships of alias AtlassianUserDismissedJiraForYouRecommendationEntity to create */
  aliases: Array<GraphStoreV2CreateAtlassianUserDismissedJiraForYouRecommendationEntityAliasInput>;
  /** If true, the request will wait until the relationship is created before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreV2CreateAtlassianUserDismissedJiraForYouRecommendationEntityRelationshipMetadataInput = {
  dismissedCategories?: InputMaybe<GraphStoreV2CreateAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalInput>;
};

export type GraphStoreV2CreateAtlassianUserDismissedJiraForYouRecommendationEntityRelationshipObjectMetadataInput = {
  dismissedCategories?: InputMaybe<GraphStoreV2CreateAtlassianUserDismissedJiraForYouRecommendationEntityCategoryDismissalInput>;
};

export type GraphStoreV2CreateAtlassianUserFavoritedAtlassianGoalAliasInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:townsquare:goal */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateAtlassianUserFavoritedAtlassianGoalInput = {
  /** The list of relationships of alias AtlassianUserFavoritedAtlassianGoal to create */
  aliases: Array<GraphStoreV2CreateAtlassianUserFavoritedAtlassianGoalAliasInput>;
};

export type GraphStoreV2CreateAtlassianUserFavoritedAtlassianProjectAliasInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:townsquare:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateAtlassianUserFavoritedAtlassianProjectInput = {
  /** The list of relationships of alias AtlassianUserFavoritedAtlassianProject to create */
  aliases: Array<GraphStoreV2CreateAtlassianUserFavoritedAtlassianProjectAliasInput>;
};

export type GraphStoreV2CreateAtlassianUserFavoritedAtlassianTeamAliasInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:identity:team */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateAtlassianUserFavoritedAtlassianTeamInput = {
  /** The list of relationships of alias AtlassianUserFavoritedAtlassianTeam to create */
  aliases: Array<GraphStoreV2CreateAtlassianUserFavoritedAtlassianTeamAliasInput>;
};

export type GraphStoreV2CreateAtlassianUserHasConfluenceMeetingNotesFolderAliasInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:confluence:folder, ati:cloud:confluence:content] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateAtlassianUserHasConfluenceMeetingNotesFolderInput = {
  /** The list of relationships of alias AtlassianUserHasConfluenceMeetingNotesFolder to create */
  aliases: Array<GraphStoreV2CreateAtlassianUserHasConfluenceMeetingNotesFolderAliasInput>;
};

export type GraphStoreV2CreateAtlassianUserHasRelevantJiraSpaceAliasInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateAtlassianUserHasRelevantJiraSpaceInput = {
  /** The list of relationships of alias AtlassianUserHasRelevantJiraSpace to create */
  aliases: Array<GraphStoreV2CreateAtlassianUserHasRelevantJiraSpaceAliasInput>;
};

export type GraphStoreV2CreateExternalMeetingRecurrenceHasJiraSpaceAliasInput = {
  /** An ARI of type ati:cloud:loom:meeting-recurrence */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateExternalMeetingRecurrenceHasJiraSpaceInput = {
  /** The list of relationships of alias ExternalMeetingRecurrenceHasJiraSpace to create */
  aliases: Array<GraphStoreV2CreateExternalMeetingRecurrenceHasJiraSpaceAliasInput>;
};

export type GraphStoreV2CreateJiraSpaceHasJiraReleaseVersionAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:version */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJiraSpaceHasJiraReleaseVersionInput = {
  /** The list of relationships of alias JiraSpaceHasJiraReleaseVersion to create */
  aliases: Array<GraphStoreV2CreateJiraSpaceHasJiraReleaseVersionAliasInput>;
};

export type GraphStoreV2CreateJiraSpaceLinksDocumentEntityAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:confluence:space, ati:cloud:confluence:page, ati:cloud:confluence:folder, ati:cloud:confluence:content, ati:cloud:confluence:whiteboard, ati:cloud:jira:document, ati:cloud:graph:document] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJiraSpaceLinksDocumentEntityInput = {
  /** The list of relationships of alias JiraSpaceLinksDocumentEntity to create */
  aliases: Array<GraphStoreV2CreateJiraSpaceLinksDocumentEntityAliasInput>;
};

export type GraphStoreV2CreateJiraSpaceLinksExternalSecurityContainerAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:security-container, ati:cloud:graph:security-container] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJiraSpaceLinksExternalSecurityContainerInput = {
  /** The list of relationships of alias JiraSpaceLinksExternalSecurityContainer to create */
  aliases: Array<GraphStoreV2CreateJiraSpaceLinksExternalSecurityContainerAliasInput>;
};

export type GraphStoreV2CreateJiraSpaceLinksOpsgenieTeamAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:opsgenie:team */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJiraSpaceLinksOpsgenieTeamInput = {
  /** The list of relationships of alias JiraSpaceLinksOpsgenieTeam to create */
  aliases: Array<GraphStoreV2CreateJiraSpaceLinksOpsgenieTeamAliasInput>;
};

export type GraphStoreV2CreateJiraSpaceRelatedWorkWithJiraSpaceAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJiraSpaceRelatedWorkWithJiraSpaceInput = {
  /** The list of relationships of alias JiraSpaceRelatedWorkWithJiraSpace to create */
  aliases: Array<GraphStoreV2CreateJiraSpaceRelatedWorkWithJiraSpaceAliasInput>;
};

export type GraphStoreV2CreateJiraSpaceSharedVersionJiraSpaceAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJiraSpaceSharedVersionJiraSpaceInput = {
  /** The list of relationships of alias JiraSpaceSharedVersionJiraSpace to create */
  aliases: Array<GraphStoreV2CreateJiraSpaceSharedVersionJiraSpaceAliasInput>;
};

export type GraphStoreV2CreateJiraSpaceUnlinkedExternalBranchAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:repository, ati:cloud:graph:repository] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJiraSpaceUnlinkedExternalBranchInput = {
  /** The list of relationships of alias JiraSpaceUnlinkedExternalBranch to create */
  aliases: Array<GraphStoreV2CreateJiraSpaceUnlinkedExternalBranchAliasInput>;
};

export type GraphStoreV2CreateJiraSprintHasRetroConfluencePageAliasInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJiraSprintHasRetroConfluencePageInput = {
  /** The list of relationships of alias JiraSprintHasRetroConfluencePage to create */
  aliases: Array<GraphStoreV2CreateJiraSprintHasRetroConfluencePageAliasInput>;
};

export type GraphStoreV2CreateJiraSprintHasRetroConfluenceWhiteboardAliasInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJiraSprintHasRetroConfluenceWhiteboardInput = {
  /** The list of relationships of alias JiraSprintHasRetroConfluenceWhiteboard to create */
  aliases: Array<GraphStoreV2CreateJiraSprintHasRetroConfluenceWhiteboardAliasInput>;
};

export type GraphStoreV2CreateJiraVersionLinksExternalFeatureFlagAliasInput = {
  /** An ARI of type ati:cloud:jira:version */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:feature-flag, ati:cloud:graph:feature-flag] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJiraVersionLinksExternalFeatureFlagInput = {
  /** The list of relationships of alias JiraVersionLinksExternalFeatureFlag to create */
  aliases: Array<GraphStoreV2CreateJiraVersionLinksExternalFeatureFlagAliasInput>;
};

export type GraphStoreV2CreateJiraWorkItemLinksConfluenceWhiteboardAliasInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJiraWorkItemLinksConfluenceWhiteboardInput = {
  /** The list of relationships of alias JiraWorkItemLinksConfluenceWhiteboard to create */
  aliases: Array<GraphStoreV2CreateJiraWorkItemLinksConfluenceWhiteboardAliasInput>;
};

export type GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityAliasInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Object metadata for this relationship */
  objectMetadata?: InputMaybe<GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityRelationshipObjectMetadataInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:vulnerability, ati:cloud:graph:vulnerability] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityContainerInput = {
  containerAri?: InputMaybe<Scalars['String']['input']>;
};

export type GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityInput = {
  /** The list of relationships of alias JiraWorkItemLinksExternalVulnerability to create */
  aliases: Array<GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityAliasInput>;
};

export type GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityRelationshipObjectMetadataInput = {
  container?: InputMaybe<GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityContainerInput>;
  introducedDate?: InputMaybe<Scalars['DateTime']['input']>;
  severity?: InputMaybe<GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityVulnerabilitySeverityInput>;
  status?: InputMaybe<GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityVulnerabilityStatusInput>;
  type?: InputMaybe<GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityVulnerabilityTypeInput>;
};

export enum GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityVulnerabilitySeverityInput {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityVulnerabilityStatusInput {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreV2CreateJiraWorkItemLinksExternalVulnerabilityVulnerabilityTypeInput {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2CreateJiraWorkItemLinksSupportEscalationEntityAliasInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Relationship specific metadata */
  relationshipMetadata?: InputMaybe<GraphStoreV2CreateJiraWorkItemLinksSupportEscalationEntityRelationshipMetadataInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:jira:issue] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export enum GraphStoreV2CreateJiraWorkItemLinksSupportEscalationEntityEscalationLinkTypeInput {
  ExistingWorkItem = 'EXISTING_WORK_ITEM',
  NewWorkItem = 'NEW_WORK_ITEM',
  NotSet = 'NOT_SET'
}

export enum GraphStoreV2CreateJiraWorkItemLinksSupportEscalationEntityEscalationStatusInput {
  Accepted = 'ACCEPTED',
  Open = 'OPEN',
  Rejected = 'REJECTED'
}

export type GraphStoreV2CreateJiraWorkItemLinksSupportEscalationEntityInput = {
  /** The list of relationships of alias JiraWorkItemLinksSupportEscalationEntity to create */
  aliases: Array<GraphStoreV2CreateJiraWorkItemLinksSupportEscalationEntityAliasInput>;
};

export type GraphStoreV2CreateJiraWorkItemLinksSupportEscalationEntityRelationshipMetadataInput = {
  SupportEscalationLastUpdated?: InputMaybe<Scalars['Long']['input']>;
  creatorAri?: InputMaybe<Scalars['String']['input']>;
  linkType?: InputMaybe<GraphStoreV2CreateJiraWorkItemLinksSupportEscalationEntityEscalationLinkTypeInput>;
  status?: InputMaybe<GraphStoreV2CreateJiraWorkItemLinksSupportEscalationEntityEscalationStatusInput>;
};

export type GraphStoreV2CreateJsmIncidentImpactsCompassComponentAliasInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** Subject metadata for this relationship */
  subjectMetadata?: InputMaybe<GraphStoreV2CreateJsmIncidentImpactsCompassComponentRelationshipSubjectMetadataInput>;
  /** An ARI of any of the following [ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJsmIncidentImpactsCompassComponentInput = {
  /** The list of relationships of alias JsmIncidentImpactsCompassComponent to create */
  aliases: Array<GraphStoreV2CreateJsmIncidentImpactsCompassComponentAliasInput>;
};

export enum GraphStoreV2CreateJsmIncidentImpactsCompassComponentJiraIncidentPriorityInput {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export enum GraphStoreV2CreateJsmIncidentImpactsCompassComponentJiraIncidentStatusInput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export type GraphStoreV2CreateJsmIncidentImpactsCompassComponentRelationshipSubjectMetadataInput = {
  affectedServiceAris?: InputMaybe<Scalars['String']['input']>;
  assigneeAri?: InputMaybe<Scalars['String']['input']>;
  majorIncident?: InputMaybe<Scalars['Boolean']['input']>;
  priority?: InputMaybe<GraphStoreV2CreateJsmIncidentImpactsCompassComponentJiraIncidentPriorityInput>;
  reporterAri?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<GraphStoreV2CreateJsmIncidentImpactsCompassComponentJiraIncidentStatusInput>;
};

export type GraphStoreV2CreateJsmIncidentLinksJiraWorkItemAliasInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJsmIncidentLinksJiraWorkItemInput = {
  /** The list of relationships of alias JsmIncidentLinksJiraWorkItem to create */
  aliases: Array<GraphStoreV2CreateJsmIncidentLinksJiraWorkItemAliasInput>;
};

export type GraphStoreV2CreateJsmIncidentLinksJsmPostIncidentReviewLinkAliasInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link, ati:cloud:jira:post-incident-review, ati:cloud:graph:post-incident-review] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateJsmIncidentLinksJsmPostIncidentReviewLinkInput = {
  /** The list of relationships of alias JsmIncidentLinksJsmPostIncidentReviewLink to create */
  aliases: Array<GraphStoreV2CreateJsmIncidentLinksJsmPostIncidentReviewLinkAliasInput>;
};

export type GraphStoreV2CreateLoomMeetingHasJiraSpaceAliasInput = {
  /** An ARI of type ati:cloud:loom:meeting */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateLoomMeetingHasJiraSpaceInput = {
  /** The list of relationships of alias LoomMeetingHasJiraSpace to create */
  aliases: Array<GraphStoreV2CreateLoomMeetingHasJiraSpaceAliasInput>;
};

export type GraphStoreV2CreateLoomMeetingRecurrenceHasConfluenceMeetingNotesPageAliasInput = {
  /** An ARI of type ati:cloud:loom:meeting-recurrence */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateLoomMeetingRecurrenceHasConfluenceMeetingNotesPageInput = {
  /** The list of relationships of alias LoomMeetingRecurrenceHasConfluenceMeetingNotesPage to create */
  aliases: Array<GraphStoreV2CreateLoomMeetingRecurrenceHasConfluenceMeetingNotesPageAliasInput>;
};

export type GraphStoreV2CreateLoomVideoHasConfluencePageAliasInput = {
  /** An ARI of type ati:cloud:loom:video */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GraphStoreV2CreateLoomVideoHasConfluencePageInput = {
  /** The list of relationships of alias LoomVideoHasConfluencePage to create */
  aliases: Array<GraphStoreV2CreateLoomVideoHasConfluencePageAliasInput>;
};

export type GraphStoreV2CsmCustomerLinksJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2CsmOrganizationLinksCsmCustomerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2CsmOrganizationLinksJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2Customer360CustomerHasExternalConversationSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2Customer360CustomerLinksJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreV2CypherQueryV2VersionEnum {
  /** V2 */
  V2 = 'V2',
  /** V3 */
  V3 = 'V3'
}

export type GraphStoreV2DeleteAtlassianHomeTagIsAliasOfAtlassianHomeTagAliasInput = {
  /** An ARI of type ati:cloud:townsquare:tag */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:townsquare:tag */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteAtlassianHomeTagIsAliasOfAtlassianHomeTagInput = {
  /** The list of relationships of alias AtlassianHomeTagIsAliasOfAtlassianHomeTag to delete */
  aliases: Array<GraphStoreV2DeleteAtlassianHomeTagIsAliasOfAtlassianHomeTagAliasInput>;
};

export type GraphStoreV2DeleteAtlassianTeamHasChildAtlassianTeamAliasInput = {
  /** An ARI of type ati:cloud:identity:team */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:identity:team */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteAtlassianTeamHasChildAtlassianTeamInput = {
  /** The list of relationships of alias AtlassianTeamHasChildAtlassianTeam to delete */
  aliases: Array<GraphStoreV2DeleteAtlassianTeamHasChildAtlassianTeamAliasInput>;
};

export type GraphStoreV2DeleteAtlassianTeamLinksSpaceEntityAliasInput = {
  /** An ARI of type ati:cloud:identity:team */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:confluence:space, ati:cloud:loom:space] */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteAtlassianTeamLinksSpaceEntityInput = {
  /** The list of relationships of alias AtlassianTeamLinksSpaceEntity to delete */
  aliases: Array<GraphStoreV2DeleteAtlassianTeamLinksSpaceEntityAliasInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreV2DeleteAtlassianUserDismissedJiraForYouRecommendationEntityAliasInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:project, ati:cloud:jira:issue-comment, ati:cloud:identity:team, ati:cloud:jira:pull-request, ati:cloud:graph:pull-request] */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteAtlassianUserDismissedJiraForYouRecommendationEntityInput = {
  /** The list of relationships of alias AtlassianUserDismissedJiraForYouRecommendationEntity to delete */
  aliases: Array<GraphStoreV2DeleteAtlassianUserDismissedJiraForYouRecommendationEntityAliasInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GraphStoreV2DeleteAtlassianUserFavoritedAtlassianGoalAliasInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:townsquare:goal */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteAtlassianUserFavoritedAtlassianGoalInput = {
  /** The list of relationships of alias AtlassianUserFavoritedAtlassianGoal to delete */
  aliases: Array<GraphStoreV2DeleteAtlassianUserFavoritedAtlassianGoalAliasInput>;
};

export type GraphStoreV2DeleteAtlassianUserFavoritedAtlassianProjectAliasInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:townsquare:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteAtlassianUserFavoritedAtlassianProjectInput = {
  /** The list of relationships of alias AtlassianUserFavoritedAtlassianProject to delete */
  aliases: Array<GraphStoreV2DeleteAtlassianUserFavoritedAtlassianProjectAliasInput>;
};

export type GraphStoreV2DeleteAtlassianUserFavoritedAtlassianTeamAliasInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:identity:team */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteAtlassianUserFavoritedAtlassianTeamInput = {
  /** The list of relationships of alias AtlassianUserFavoritedAtlassianTeam to delete */
  aliases: Array<GraphStoreV2DeleteAtlassianUserFavoritedAtlassianTeamAliasInput>;
};

export type GraphStoreV2DeleteAtlassianUserHasConfluenceMeetingNotesFolderAliasInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:confluence:folder, ati:cloud:confluence:content] */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteAtlassianUserHasConfluenceMeetingNotesFolderInput = {
  /** The list of relationships of alias AtlassianUserHasConfluenceMeetingNotesFolder to delete */
  aliases: Array<GraphStoreV2DeleteAtlassianUserHasConfluenceMeetingNotesFolderAliasInput>;
};

export type GraphStoreV2DeleteAtlassianUserHasRelevantJiraSpaceAliasInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteAtlassianUserHasRelevantJiraSpaceInput = {
  /** The list of relationships of alias AtlassianUserHasRelevantJiraSpace to delete */
  aliases: Array<GraphStoreV2DeleteAtlassianUserHasRelevantJiraSpaceAliasInput>;
};

export type GraphStoreV2DeleteExternalMeetingRecurrenceHasJiraSpaceAliasInput = {
  /** An ARI of type ati:cloud:loom:meeting-recurrence */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteExternalMeetingRecurrenceHasJiraSpaceInput = {
  /** The list of relationships of alias ExternalMeetingRecurrenceHasJiraSpace to delete */
  aliases: Array<GraphStoreV2DeleteExternalMeetingRecurrenceHasJiraSpaceAliasInput>;
};

export type GraphStoreV2DeleteJiraSpaceHasJiraReleaseVersionAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:version */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraSpaceHasJiraReleaseVersionInput = {
  /** The list of relationships of alias JiraSpaceHasJiraReleaseVersion to delete */
  aliases: Array<GraphStoreV2DeleteJiraSpaceHasJiraReleaseVersionAliasInput>;
};

export type GraphStoreV2DeleteJiraSpaceLinksDocumentEntityAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:confluence:space, ati:cloud:confluence:page, ati:cloud:confluence:folder, ati:cloud:confluence:content, ati:cloud:confluence:whiteboard, ati:cloud:jira:document, ati:cloud:graph:document] */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraSpaceLinksDocumentEntityInput = {
  /** The list of relationships of alias JiraSpaceLinksDocumentEntity to delete */
  aliases: Array<GraphStoreV2DeleteJiraSpaceLinksDocumentEntityAliasInput>;
};

export type GraphStoreV2DeleteJiraSpaceLinksExternalSecurityContainerAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:security-container, ati:cloud:graph:security-container] */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraSpaceLinksExternalSecurityContainerInput = {
  /** The list of relationships of alias JiraSpaceLinksExternalSecurityContainer to delete */
  aliases: Array<GraphStoreV2DeleteJiraSpaceLinksExternalSecurityContainerAliasInput>;
};

export type GraphStoreV2DeleteJiraSpaceLinksOpsgenieTeamAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:opsgenie:team */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraSpaceLinksOpsgenieTeamInput = {
  /** The list of relationships of alias JiraSpaceLinksOpsgenieTeam to delete */
  aliases: Array<GraphStoreV2DeleteJiraSpaceLinksOpsgenieTeamAliasInput>;
};

export type GraphStoreV2DeleteJiraSpaceRelatedWorkWithJiraSpaceAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraSpaceRelatedWorkWithJiraSpaceInput = {
  /** The list of relationships of alias JiraSpaceRelatedWorkWithJiraSpace to delete */
  aliases: Array<GraphStoreV2DeleteJiraSpaceRelatedWorkWithJiraSpaceAliasInput>;
};

export type GraphStoreV2DeleteJiraSpaceSharedVersionJiraSpaceAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraSpaceSharedVersionJiraSpaceInput = {
  /** The list of relationships of alias JiraSpaceSharedVersionJiraSpace to delete */
  aliases: Array<GraphStoreV2DeleteJiraSpaceSharedVersionJiraSpaceAliasInput>;
};

export type GraphStoreV2DeleteJiraSpaceUnlinkedExternalBranchAliasInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:repository, ati:cloud:graph:repository] */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraSpaceUnlinkedExternalBranchInput = {
  /** The list of relationships of alias JiraSpaceUnlinkedExternalBranch to delete */
  aliases: Array<GraphStoreV2DeleteJiraSpaceUnlinkedExternalBranchAliasInput>;
};

export type GraphStoreV2DeleteJiraSprintHasRetroConfluencePageAliasInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraSprintHasRetroConfluencePageInput = {
  /** The list of relationships of alias JiraSprintHasRetroConfluencePage to delete */
  aliases: Array<GraphStoreV2DeleteJiraSprintHasRetroConfluencePageAliasInput>;
};

export type GraphStoreV2DeleteJiraSprintHasRetroConfluenceWhiteboardAliasInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraSprintHasRetroConfluenceWhiteboardInput = {
  /** The list of relationships of alias JiraSprintHasRetroConfluenceWhiteboard to delete */
  aliases: Array<GraphStoreV2DeleteJiraSprintHasRetroConfluenceWhiteboardAliasInput>;
};

export type GraphStoreV2DeleteJiraVersionLinksExternalFeatureFlagAliasInput = {
  /** An ARI of type ati:cloud:jira:version */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:feature-flag, ati:cloud:graph:feature-flag] */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraVersionLinksExternalFeatureFlagInput = {
  /** The list of relationships of alias JiraVersionLinksExternalFeatureFlag to delete */
  aliases: Array<GraphStoreV2DeleteJiraVersionLinksExternalFeatureFlagAliasInput>;
};

export type GraphStoreV2DeleteJiraWorkItemLinksConfluenceWhiteboardAliasInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraWorkItemLinksConfluenceWhiteboardInput = {
  /** The list of relationships of alias JiraWorkItemLinksConfluenceWhiteboard to delete */
  aliases: Array<GraphStoreV2DeleteJiraWorkItemLinksConfluenceWhiteboardAliasInput>;
};

export type GraphStoreV2DeleteJiraWorkItemLinksExternalVulnerabilityAliasInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:vulnerability, ati:cloud:graph:vulnerability] */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraWorkItemLinksExternalVulnerabilityInput = {
  /** The list of relationships of alias JiraWorkItemLinksExternalVulnerability to delete */
  aliases: Array<GraphStoreV2DeleteJiraWorkItemLinksExternalVulnerabilityAliasInput>;
};

export type GraphStoreV2DeleteJiraWorkItemLinksSupportEscalationEntityAliasInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:jira:issue] */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJiraWorkItemLinksSupportEscalationEntityInput = {
  /** The list of relationships of alias JiraWorkItemLinksSupportEscalationEntity to delete */
  aliases: Array<GraphStoreV2DeleteJiraWorkItemLinksSupportEscalationEntityAliasInput>;
};

export type GraphStoreV2DeleteJsmIncidentImpactsCompassComponentAliasInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJsmIncidentImpactsCompassComponentInput = {
  /** The list of relationships of alias JsmIncidentImpactsCompassComponent to delete */
  aliases: Array<GraphStoreV2DeleteJsmIncidentImpactsCompassComponentAliasInput>;
};

export type GraphStoreV2DeleteJsmIncidentLinksJiraWorkItemAliasInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJsmIncidentLinksJiraWorkItemInput = {
  /** The list of relationships of alias JsmIncidentLinksJiraWorkItem to delete */
  aliases: Array<GraphStoreV2DeleteJsmIncidentLinksJiraWorkItemAliasInput>;
};

export type GraphStoreV2DeleteJsmIncidentLinksJsmPostIncidentReviewLinkAliasInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link, ati:cloud:jira:post-incident-review, ati:cloud:graph:post-incident-review] */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteJsmIncidentLinksJsmPostIncidentReviewLinkInput = {
  /** The list of relationships of alias JsmIncidentLinksJsmPostIncidentReviewLink to delete */
  aliases: Array<GraphStoreV2DeleteJsmIncidentLinksJsmPostIncidentReviewLinkAliasInput>;
};

export type GraphStoreV2DeleteLoomMeetingHasJiraSpaceAliasInput = {
  /** An ARI of type ati:cloud:loom:meeting */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteLoomMeetingHasJiraSpaceInput = {
  /** The list of relationships of alias LoomMeetingHasJiraSpace to delete */
  aliases: Array<GraphStoreV2DeleteLoomMeetingHasJiraSpaceAliasInput>;
};

export type GraphStoreV2DeleteLoomMeetingRecurrenceHasConfluenceMeetingNotesPageAliasInput = {
  /** An ARI of type ati:cloud:loom:meeting-recurrence */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteLoomMeetingRecurrenceHasConfluenceMeetingNotesPageInput = {
  /** The list of relationships of alias LoomMeetingRecurrenceHasConfluenceMeetingNotesPage to delete */
  aliases: Array<GraphStoreV2DeleteLoomMeetingRecurrenceHasConfluenceMeetingNotesPageAliasInput>;
};

export type GraphStoreV2DeleteLoomVideoHasConfluencePageAliasInput = {
  /** An ARI of type ati:cloud:loom:video */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
};

export type GraphStoreV2DeleteLoomVideoHasConfluencePageInput = {
  /** The list of relationships of alias LoomVideoHasConfluencePage to delete */
  aliases: Array<GraphStoreV2DeleteLoomVideoHasConfluencePageAliasInput>;
};

export type GraphStoreV2EntityLinksEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalCalendarHasLinkedExternalDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalConversationHasExternalMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalConversationMentionsJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalCustomerOrgHasChildExternalCustomerOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalCustomerOrgHasExternalCustomerContactSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalCustomerOrgHasExternalDealSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalCustomerOrgLinksExternalCustomerOrgCategorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalCustomerOrgWorksOnJiraWorkItemWorklogSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalDeploymentHasExternalCommitSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalDeploymentLinksExternalDeploymentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalDeploymentLinksExternalRepositorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalDocumentHasChildExternalDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalDocumentLinksThirdPartyDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalEntityIsThirdPartyEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalMeetingRecurrenceHasJiraSpaceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalMessageHasChildExternalMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalMessageMentionsJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalOrgHasAtlassianUserSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalOrgHasChildExternalOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalOrgHasExternalPositionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalOrgHasExternalWorkerSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalPositionManagesExternalOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalPositionManagesExternalPositionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalPullRequestHasExternalCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalPullRequestHasExternalCommitSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalPullRequestLinksExternalServiceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalPullRequestLinksJiraWorkItemSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalRepositoryHasExternalBranchSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalRepositoryHasExternalCommitSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalRepositoryHasExternalPullRequestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalSecurityContainerHasExternalVulnerabilitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalServiceLinksExternalBranchSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalServiceLinksExternalBuildSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalServiceLinksExternalCommitSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalServiceLinksExternalDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of ExternalServiceLinksExternalDeployment alias queries */
export type GraphStoreV2ExternalServiceLinksExternalDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2ExternalServiceLinksExternalDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2ExternalServiceLinksExternalDeploymentConditionalFilterInput>>>;
};

export type GraphStoreV2ExternalServiceLinksExternalDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalServiceLinksExternalFeatureFlagSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalServiceLinksExternalPullRequestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalServiceLinksExternalRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalServiceLinksExternalRepositorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalServiceLinksOpsgenieTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalTeamWorksOnJiraWorkItemWorklogSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserAssignedExternalWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserAttendedExternalCalendarEventConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_isRecurringEvent?: InputMaybe<GraphStoreBooleanFilterInput>;
  relationship_rsvpStatus?: InputMaybe<GraphStoreV2ExternalUserAttendedExternalCalendarEventRsvpStatusFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_eventEndTime?: InputMaybe<GraphStoreLongFilterInput>;
  to_eventStartTime?: InputMaybe<GraphStoreLongFilterInput>;
};

/** Conditional selection for filter field of ExternalUserAttendedExternalCalendarEvent alias queries */
export type GraphStoreV2ExternalUserAttendedExternalCalendarEventFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2ExternalUserAttendedExternalCalendarEventConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2ExternalUserAttendedExternalCalendarEventConditionalFilterInput>>>;
};

export enum GraphStoreV2ExternalUserAttendedExternalCalendarEventRsvpStatus {
  Accepted = 'ACCEPTED',
  Declined = 'DECLINED',
  NotResponded = 'NOT_RESPONDED',
  NotSet = 'NOT_SET',
  Other = 'OTHER',
  TentativelyAccepted = 'TENTATIVELY_ACCEPTED'
}

export type GraphStoreV2ExternalUserAttendedExternalCalendarEventRsvpStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2ExternalUserAttendedExternalCalendarEventRsvpStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2ExternalUserAttendedExternalCalendarEventRsvpStatus>>;
};

export type GraphStoreV2ExternalUserAttendedExternalCalendarEventSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_isRecurringEvent?: InputMaybe<GraphStoreSortInput>;
  relationship_rsvpStatus?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_eventEndTime?: InputMaybe<GraphStoreSortInput>;
  to_eventStartTime?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCollaboratedOnExternalDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalBranchSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalCalendarEventConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_eventEndTime?: InputMaybe<GraphStoreLongFilterInput>;
  to_eventStartTime?: InputMaybe<GraphStoreLongFilterInput>;
};

/** Conditional selection for filter field of ExternalUserCreatedExternalCalendarEvent alias queries */
export type GraphStoreV2ExternalUserCreatedExternalCalendarEventFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2ExternalUserCreatedExternalCalendarEventConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2ExternalUserCreatedExternalCalendarEventConditionalFilterInput>>>;
};

export type GraphStoreV2ExternalUserCreatedExternalCalendarEventSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_eventEndTime?: InputMaybe<GraphStoreSortInput>;
  to_eventStartTime?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalCommitSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalCustomerContactSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalCustomerOrgCategorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalCustomerOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalDashboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalDataTableSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalDealSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalDesignSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalPullRequestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalSoftwareServiceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalTestExecutionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalTestPlanSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalTestRunSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalTestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalTestStatusSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserCreatedExternalWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserLastUpdatedExternalDesignSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserMemberOfExternalConversationSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserMentionedInExternalConversationSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserMentionedInExternalMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalCalendarEventSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalCustomerContactSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalCustomerOrgCategorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalCustomerOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalDashboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalDataTableSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalDealSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalRepositorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalSoftwareServiceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalTestExecutionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalTestPlanSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalTestRunSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalTestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserOwnsExternalTestStatusSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserReviewedExternalPullRequestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalCustomerContactSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalCustomerOrgCategorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalCustomerOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalDashboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalDataTableSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalDealSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalSoftwareServiceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalTestExecutionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalTestPlanSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalTestRunSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalTestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalUserUpdatedExternalTestStatusSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalWorkerFillsExternalPositionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalWorkerLinksAtlassianUserSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ExternalWorkerLinksThirdPartyUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2FocusAskImpactsWorkEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2FocusFocusAreaHasAtlassianGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2FocusFocusAreaHasChildFocusFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2FocusFocusAreaHasConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2FocusFocusAreaHasExternalPositionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2FocusFocusAreaHasFocusFocusAreaStatusUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2FocusFocusAreaHasThirdPartyDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2FocusFocusAreaHasWorkEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2FocusStrategicPlanContributesToFocusFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2FocusStrategicPlanHasFocusStrategicPlanScenarioSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2FocusStrategicPlanScenarioHasFocusStrategicPlanScenarioInvestmentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2FocusStrategicPlanScenarioInvestmentHasInvestmentEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraEpicTracksAtlassianProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceExplicitlyLinksExternalRepositorySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_providerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceHasAvpDashboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceHasJiraBoardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceHasJiraReleaseVersionSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceHasJiraWorkItemConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_fixVersionIds?: InputMaybe<GraphStoreLongFilterInput>;
  to_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_issueTypeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of JiraSpaceHasJiraWorkItem alias queries */
export type GraphStoreV2JiraSpaceHasJiraWorkItemFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceHasJiraWorkItemConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceHasJiraWorkItemConditionalFilterInput>>>;
};

export type GraphStoreV2JiraSpaceHasJiraWorkItemSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  to_creatorAri?: InputMaybe<GraphStoreSortInput>;
  to_fixVersionIds?: InputMaybe<GraphStoreSortInput>;
  to_issueAri?: InputMaybe<GraphStoreSortInput>;
  to_issueTypeAri?: InputMaybe<GraphStoreSortInput>;
  to_reporterAri?: InputMaybe<GraphStoreSortInput>;
  to_statusAri?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreV2JiraSpaceLinksAtlassianAutodevJobAutodevJobStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraSpaceLinksAtlassianAutodevJobAutodevJobStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksAtlassianAutodevJobAutodevJobStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksAtlassianAutodevJobAutodevJobStatus>>;
};

export type GraphStoreV2JiraSpaceLinksAtlassianAutodevJobConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_agentAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_createdAt?: InputMaybe<GraphStoreLongFilterInput>;
  to_jobOwnerAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_status?: InputMaybe<GraphStoreV2JiraSpaceLinksAtlassianAutodevJobAutodevJobStatusFilterInput>;
  to_updatedAt?: InputMaybe<GraphStoreLongFilterInput>;
};

/** Conditional selection for filter field of JiraSpaceLinksAtlassianAutodevJob alias queries */
export type GraphStoreV2JiraSpaceLinksAtlassianAutodevJobFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksAtlassianAutodevJobConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksAtlassianAutodevJobConditionalFilterInput>>>;
};

export type GraphStoreV2JiraSpaceLinksAtlassianAutodevJobSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_agentAri?: InputMaybe<GraphStoreSortInput>;
  to_createdAt?: InputMaybe<GraphStoreSortInput>;
  to_jobOwnerAri?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_updatedAt?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksAtlassianGoalSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksAtlassianProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksCompassComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksDocumentEntitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalBranchSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreV2JiraSpaceLinksExternalBuildBuildState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraSpaceLinksExternalBuildBuildStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalBuildBuildState>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalBuildBuildState>>;
};

export type GraphStoreV2JiraSpaceLinksExternalBuildConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_state?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalBuildBuildStateFilterInput>;
  to_testInfo?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalBuildTestInfoFilterInput>;
};

/** Conditional selection for filter field of JiraSpaceLinksExternalBuild alias queries */
export type GraphStoreV2JiraSpaceLinksExternalBuildFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalBuildConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalBuildConditionalFilterInput>>>;
};

export type GraphStoreV2JiraSpaceLinksExternalBuildSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
  to_testInfo?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalBuildTestInfoSortInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalBuildTestInfoFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalBuildTestInfoFilterInput>>>;
  numberFailed?: InputMaybe<GraphStoreLongFilterInput>;
  numberPassed?: InputMaybe<GraphStoreLongFilterInput>;
  numberSkipped?: InputMaybe<GraphStoreLongFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalBuildTestInfoFilterInput>>>;
  totalNumber?: InputMaybe<GraphStoreLongFilterInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalBuildTestInfoSortInput = {
  numberFailed?: InputMaybe<GraphStoreSortInput>;
  numberPassed?: InputMaybe<GraphStoreSortInput>;
  numberSkipped?: InputMaybe<GraphStoreSortInput>;
  totalNumber?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalDeploymentAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalDeploymentAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalDeploymentAuthorFilterInput>>>;
};

export type GraphStoreV2JiraSpaceLinksExternalDeploymentAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_fixVersionIds?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_issueTypeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalDeploymentAuthorFilterInput>;
  to_deploymentLastUpdated?: InputMaybe<GraphStoreLongFilterInput>;
  to_environmentType?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalDeploymentEnvironmentTypeFilterInput>;
  to_state?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalDeploymentDeploymentStateFilterInput>;
};

export enum GraphStoreV2JiraSpaceLinksExternalDeploymentDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraSpaceLinksExternalDeploymentDeploymentStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalDeploymentDeploymentState>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalDeploymentDeploymentState>>;
};

export enum GraphStoreV2JiraSpaceLinksExternalDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphStoreV2JiraSpaceLinksExternalDeploymentEnvironmentTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalDeploymentEnvironmentType>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalDeploymentEnvironmentType>>;
};

/** Conditional selection for filter field of JiraSpaceLinksExternalDeployment alias queries */
export type GraphStoreV2JiraSpaceLinksExternalDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalDeploymentConditionalFilterInput>>>;
};

export type GraphStoreV2JiraSpaceLinksExternalDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_fixVersionIds?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_issueTypeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalDeploymentAuthorSortInput>;
  to_deploymentLastUpdated?: InputMaybe<GraphStoreSortInput>;
  to_environmentType?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalPullRequestAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalPullRequestAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalPullRequestAuthorFilterInput>>>;
};

export type GraphStoreV2JiraSpaceLinksExternalPullRequestAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalPullRequestConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalPullRequestAuthorFilterInput>;
  to_reviewers?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalPullRequestReviewerFilterInput>;
  to_status?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalPullRequestPullRequestStatusFilterInput>;
  to_taskCount?: InputMaybe<GraphStoreFloatFilterInput>;
};

/** Conditional selection for filter field of JiraSpaceLinksExternalPullRequest alias queries */
export type GraphStoreV2JiraSpaceLinksExternalPullRequestFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalPullRequestConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalPullRequestConditionalFilterInput>>>;
};

export enum GraphStoreV2JiraSpaceLinksExternalPullRequestPullRequestStatus {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraSpaceLinksExternalPullRequestPullRequestStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalPullRequestPullRequestStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalPullRequestPullRequestStatus>>;
};

export type GraphStoreV2JiraSpaceLinksExternalPullRequestReviewerFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalPullRequestReviewerFilterInput>>>;
  approvalStatus?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalPullRequestReviewerReviewerStatusFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalPullRequestReviewerFilterInput>>>;
  reviewerAri?: InputMaybe<GraphStoreAriFilterInput>;
};

export enum GraphStoreV2JiraSpaceLinksExternalPullRequestReviewerReviewerStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export type GraphStoreV2JiraSpaceLinksExternalPullRequestReviewerReviewerStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalPullRequestReviewerReviewerStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalPullRequestReviewerReviewerStatus>>;
};

export type GraphStoreV2JiraSpaceLinksExternalPullRequestReviewerSortInput = {
  approvalStatus?: InputMaybe<GraphStoreSortInput>;
  reviewerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalPullRequestSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalPullRequestAuthorSortInput>;
  to_reviewers?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalPullRequestReviewerSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_taskCount?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalRepositoryConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_providerAri?: InputMaybe<GraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of JiraSpaceLinksExternalRepository alias queries */
export type GraphStoreV2JiraSpaceLinksExternalRepositoryFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalRepositoryConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalRepositoryConditionalFilterInput>>>;
};

export type GraphStoreV2JiraSpaceLinksExternalRepositorySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_providerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalSecurityContainerSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalServiceConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of JiraSpaceLinksExternalService alias queries */
export type GraphStoreV2JiraSpaceLinksExternalServiceFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalServiceConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalServiceConditionalFilterInput>>>;
};

export type GraphStoreV2JiraSpaceLinksExternalServiceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalVulnerabilityConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_container?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalVulnerabilityContainerFilterInput>;
  to_severity?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilitySeverityFilterInput>;
  to_status?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilityStatusFilterInput>;
  to_type?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilityTypeFilterInput>;
};

export type GraphStoreV2JiraSpaceLinksExternalVulnerabilityContainerFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalVulnerabilityContainerFilterInput>>>;
  containerAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalVulnerabilityContainerFilterInput>>>;
};

export type GraphStoreV2JiraSpaceLinksExternalVulnerabilityContainerSortInput = {
  containerAri?: InputMaybe<GraphStoreSortInput>;
};

/** Conditional selection for filter field of JiraSpaceLinksExternalVulnerability alias queries */
export type GraphStoreV2JiraSpaceLinksExternalVulnerabilityFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalVulnerabilityConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksExternalVulnerabilityConditionalFilterInput>>>;
};

export type GraphStoreV2JiraSpaceLinksExternalVulnerabilitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_container?: InputMaybe<GraphStoreV2JiraSpaceLinksExternalVulnerabilityContainerSortInput>;
  to_severity?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_type?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilitySeverity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilitySeverityFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilitySeverity>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilitySeverity>>;
};

export enum GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilityStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilityStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilityStatus>>;
};

export enum GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilityType {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilityTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilityType>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksExternalVulnerabilityVulnerabilityType>>;
};

export type GraphStoreV2JiraSpaceLinksIncidentEntityConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_affectedServiceAris?: InputMaybe<GraphStoreAriFilterInput>;
  to_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_majorIncident?: InputMaybe<GraphStoreBooleanFilterInput>;
  to_priority?: InputMaybe<GraphStoreV2JiraSpaceLinksIncidentEntityJiraIncidentPriorityFilterInput>;
  to_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_status?: InputMaybe<GraphStoreV2JiraSpaceLinksIncidentEntityJiraIncidentStatusFilterInput>;
};

/** Conditional selection for filter field of JiraSpaceLinksIncidentEntity alias queries */
export type GraphStoreV2JiraSpaceLinksIncidentEntityFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksIncidentEntityConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksIncidentEntityConditionalFilterInput>>>;
};

export enum GraphStoreV2JiraSpaceLinksIncidentEntityJiraIncidentPriority {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraSpaceLinksIncidentEntityJiraIncidentPriorityFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksIncidentEntityJiraIncidentPriority>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksIncidentEntityJiraIncidentPriority>>;
};

export enum GraphStoreV2JiraSpaceLinksIncidentEntityJiraIncidentStatus {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export type GraphStoreV2JiraSpaceLinksIncidentEntityJiraIncidentStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksIncidentEntityJiraIncidentStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSpaceLinksIncidentEntityJiraIncidentStatus>>;
};

export type GraphStoreV2JiraSpaceLinksIncidentEntitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_affectedServiceAris?: InputMaybe<GraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  to_majorIncident?: InputMaybe<GraphStoreSortInput>;
  to_priority?: InputMaybe<GraphStoreSortInput>;
  to_reporterAri?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksJsmIncidentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of JiraSpaceLinksJsmIncident alias queries */
export type GraphStoreV2JiraSpaceLinksJsmIncidentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksJsmIncidentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSpaceLinksJsmIncidentConditionalFilterInput>>>;
};

export type GraphStoreV2JiraSpaceLinksJsmIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceLinksOpsgenieTeamSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceRelatedWorkWithJiraSpaceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceSharedVersionJiraSpaceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceSharesComponentWithJsmSpaceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSpaceUnlinkedExternalBranchSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSprintHasExternalDeploymentAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasExternalDeploymentAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasExternalDeploymentAuthorFilterInput>>>;
};

export type GraphStoreV2JiraSprintHasExternalDeploymentAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSprintHasExternalDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreV2JiraSprintHasExternalDeploymentAuthorFilterInput>;
  to_environmentType?: InputMaybe<GraphStoreV2JiraSprintHasExternalDeploymentEnvironmentTypeFilterInput>;
  to_state?: InputMaybe<GraphStoreV2JiraSprintHasExternalDeploymentDeploymentStateFilterInput>;
};

export enum GraphStoreV2JiraSprintHasExternalDeploymentDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraSprintHasExternalDeploymentDeploymentStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalDeploymentDeploymentState>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalDeploymentDeploymentState>>;
};

export enum GraphStoreV2JiraSprintHasExternalDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphStoreV2JiraSprintHasExternalDeploymentEnvironmentTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalDeploymentEnvironmentType>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalDeploymentEnvironmentType>>;
};

/** Conditional selection for filter field of JiraSprintHasExternalDeployment alias queries */
export type GraphStoreV2JiraSprintHasExternalDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasExternalDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasExternalDeploymentConditionalFilterInput>>>;
};

export type GraphStoreV2JiraSprintHasExternalDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreV2JiraSprintHasExternalDeploymentAuthorSortInput>;
  to_environmentType?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSprintHasExternalPullRequestAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasExternalPullRequestAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasExternalPullRequestAuthorFilterInput>>>;
};

export type GraphStoreV2JiraSprintHasExternalPullRequestAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSprintHasExternalPullRequestConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreV2JiraSprintHasExternalPullRequestAuthorFilterInput>;
  to_reviewers?: InputMaybe<GraphStoreV2JiraSprintHasExternalPullRequestReviewerFilterInput>;
  to_status?: InputMaybe<GraphStoreV2JiraSprintHasExternalPullRequestPullRequestStatusFilterInput>;
  to_taskCount?: InputMaybe<GraphStoreFloatFilterInput>;
};

/** Conditional selection for filter field of JiraSprintHasExternalPullRequest alias queries */
export type GraphStoreV2JiraSprintHasExternalPullRequestFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasExternalPullRequestConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasExternalPullRequestConditionalFilterInput>>>;
};

export enum GraphStoreV2JiraSprintHasExternalPullRequestPullRequestStatus {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraSprintHasExternalPullRequestPullRequestStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalPullRequestPullRequestStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalPullRequestPullRequestStatus>>;
};

export type GraphStoreV2JiraSprintHasExternalPullRequestReviewerFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasExternalPullRequestReviewerFilterInput>>>;
  approvalStatus?: InputMaybe<GraphStoreV2JiraSprintHasExternalPullRequestReviewerReviewerStatusFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasExternalPullRequestReviewerFilterInput>>>;
  reviewerAri?: InputMaybe<GraphStoreAriFilterInput>;
};

export enum GraphStoreV2JiraSprintHasExternalPullRequestReviewerReviewerStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export type GraphStoreV2JiraSprintHasExternalPullRequestReviewerReviewerStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalPullRequestReviewerReviewerStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalPullRequestReviewerReviewerStatus>>;
};

export type GraphStoreV2JiraSprintHasExternalPullRequestReviewerSortInput = {
  approvalStatus?: InputMaybe<GraphStoreSortInput>;
  reviewerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSprintHasExternalPullRequestSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreV2JiraSprintHasExternalPullRequestAuthorSortInput>;
  to_reviewers?: InputMaybe<GraphStoreV2JiraSprintHasExternalPullRequestReviewerSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_taskCount?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSprintHasExternalVulnerabilityConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_statusCategory?: InputMaybe<GraphStoreV2JiraSprintHasExternalVulnerabilityStatusCategoryFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_introducedDate?: InputMaybe<GraphStoreLongFilterInput>;
  to_severity?: InputMaybe<GraphStoreV2JiraSprintHasExternalVulnerabilityVulnerabilitySeverityFilterInput>;
  to_status?: InputMaybe<GraphStoreV2JiraSprintHasExternalVulnerabilityVulnerabilityStatusFilterInput>;
};

/** Conditional selection for filter field of JiraSprintHasExternalVulnerability alias queries */
export type GraphStoreV2JiraSprintHasExternalVulnerabilityFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasExternalVulnerabilityConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasExternalVulnerabilityConditionalFilterInput>>>;
};

export type GraphStoreV2JiraSprintHasExternalVulnerabilitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<GraphStoreSortInput>;
  relationship_statusCategory?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_introducedDate?: InputMaybe<GraphStoreSortInput>;
  to_severity?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreV2JiraSprintHasExternalVulnerabilityStatusCategory {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphStoreV2JiraSprintHasExternalVulnerabilityStatusCategoryFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalVulnerabilityStatusCategory>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalVulnerabilityStatusCategory>>;
};

export enum GraphStoreV2JiraSprintHasExternalVulnerabilityVulnerabilitySeverity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraSprintHasExternalVulnerabilityVulnerabilitySeverityFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalVulnerabilityVulnerabilitySeverity>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalVulnerabilityVulnerabilitySeverity>>;
};

export enum GraphStoreV2JiraSprintHasExternalVulnerabilityVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraSprintHasExternalVulnerabilityVulnerabilityStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalVulnerabilityVulnerabilityStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSprintHasExternalVulnerabilityVulnerabilityStatus>>;
};

export type GraphStoreV2JiraSprintHasJiraWorkItemConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreLongFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_issueAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_statusAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_statusCategory?: InputMaybe<GraphStoreV2JiraSprintHasJiraWorkItemStatusCategoryFilterInput>;
};

/** Conditional selection for filter field of JiraSprintHasJiraWorkItem alias queries */
export type GraphStoreV2JiraSprintHasJiraWorkItemFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasJiraWorkItemConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraSprintHasJiraWorkItemConditionalFilterInput>>>;
};

export type GraphStoreV2JiraSprintHasJiraWorkItemSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  to_creatorAri?: InputMaybe<GraphStoreSortInput>;
  to_issueAri?: InputMaybe<GraphStoreSortInput>;
  to_reporterAri?: InputMaybe<GraphStoreSortInput>;
  to_statusAri?: InputMaybe<GraphStoreSortInput>;
  to_statusCategory?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreV2JiraSprintHasJiraWorkItemStatusCategory {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type GraphStoreV2JiraSprintHasJiraWorkItemStatusCategoryFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraSprintHasJiraWorkItemStatusCategory>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraSprintHasJiraWorkItemStatusCategory>>;
};

export type GraphStoreV2JiraSprintHasRetroConfluencePageSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraSprintHasRetroConfluenceWhiteboardSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraVersionLinksExternalBranchSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraVersionLinksExternalBuildSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraVersionLinksExternalDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraVersionLinksExternalDesignConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_designLastUpdated?: InputMaybe<GraphStoreLongFilterInput>;
  to_status?: InputMaybe<GraphStoreV2JiraVersionLinksExternalDesignDesignStatusFilterInput>;
  to_type?: InputMaybe<GraphStoreV2JiraVersionLinksExternalDesignDesignTypeFilterInput>;
};

export enum GraphStoreV2JiraVersionLinksExternalDesignDesignStatus {
  None = 'NONE',
  NotSet = 'NOT_SET',
  ReadyForDevelopment = 'READY_FOR_DEVELOPMENT',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraVersionLinksExternalDesignDesignStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraVersionLinksExternalDesignDesignStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraVersionLinksExternalDesignDesignStatus>>;
};

export enum GraphStoreV2JiraVersionLinksExternalDesignDesignType {
  Canvas = 'CANVAS',
  File = 'FILE',
  Group = 'GROUP',
  Node = 'NODE',
  NotSet = 'NOT_SET',
  Other = 'OTHER',
  Prototype = 'PROTOTYPE'
}

export type GraphStoreV2JiraVersionLinksExternalDesignDesignTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraVersionLinksExternalDesignDesignType>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraVersionLinksExternalDesignDesignType>>;
};

/** Conditional selection for filter field of JiraVersionLinksExternalDesign alias queries */
export type GraphStoreV2JiraVersionLinksExternalDesignFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraVersionLinksExternalDesignConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraVersionLinksExternalDesignConditionalFilterInput>>>;
};

export type GraphStoreV2JiraVersionLinksExternalDesignSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_designLastUpdated?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_type?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraVersionLinksExternalFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraVersionLinksExternalPullRequestSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraVersionLinksExternalRemoteLinkSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraVersionLinksJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemBlocksJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemChangesCompassComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemCommentHasChildJiraWorkItemCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemContributesToAtlassianGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export enum GraphStoreV2JiraWorkItemHasAtlassianAutodevJobAutodevJobStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraWorkItemHasAtlassianAutodevJobAutodevJobStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraWorkItemHasAtlassianAutodevJobAutodevJobStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraWorkItemHasAtlassianAutodevJobAutodevJobStatus>>;
};

export type GraphStoreV2JiraWorkItemHasAtlassianAutodevJobConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_agentAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_createdAt?: InputMaybe<GraphStoreLongFilterInput>;
  to_jobOwnerAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_status?: InputMaybe<GraphStoreV2JiraWorkItemHasAtlassianAutodevJobAutodevJobStatusFilterInput>;
  to_updatedAt?: InputMaybe<GraphStoreLongFilterInput>;
};

/** Conditional selection for filter field of JiraWorkItemHasAtlassianAutodevJob alias queries */
export type GraphStoreV2JiraWorkItemHasAtlassianAutodevJobFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraWorkItemHasAtlassianAutodevJobConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraWorkItemHasAtlassianAutodevJobConditionalFilterInput>>>;
};

export type GraphStoreV2JiraWorkItemHasAtlassianAutodevJobSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_agentAri?: InputMaybe<GraphStoreSortInput>;
  to_createdAt?: InputMaybe<GraphStoreSortInput>;
  to_jobOwnerAri?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_updatedAt?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemHasChangedJiraPrioritySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemHasChangedJiraStatusSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemHasChildJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemHasJiraPrioritySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemHasJiraWorkItemCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksAssetObjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksConfluenceWhiteboardConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of JiraWorkItemLinksConfluenceWhiteboard alias queries */
export type GraphStoreV2JiraWorkItemLinksConfluenceWhiteboardFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraWorkItemLinksConfluenceWhiteboardConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraWorkItemLinksConfluenceWhiteboardConditionalFilterInput>>>;
};

export type GraphStoreV2JiraWorkItemLinksConfluenceWhiteboardSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksExternalBranchSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksExternalBuildSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksExternalCommitSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksExternalDeploymentAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraWorkItemLinksExternalDeploymentAuthorFilterInput>>>;
  authorAri?: InputMaybe<GraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraWorkItemLinksExternalDeploymentAuthorFilterInput>>>;
};

export type GraphStoreV2JiraWorkItemLinksExternalDeploymentAuthorSortInput = {
  authorAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksExternalDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_author?: InputMaybe<GraphStoreV2JiraWorkItemLinksExternalDeploymentAuthorFilterInput>;
  to_environmentType?: InputMaybe<GraphStoreV2JiraWorkItemLinksExternalDeploymentEnvironmentTypeFilterInput>;
  to_state?: InputMaybe<GraphStoreV2JiraWorkItemLinksExternalDeploymentDeploymentStateFilterInput>;
};

export enum GraphStoreV2JiraWorkItemLinksExternalDeploymentDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type GraphStoreV2JiraWorkItemLinksExternalDeploymentDeploymentStateFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraWorkItemLinksExternalDeploymentDeploymentState>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraWorkItemLinksExternalDeploymentDeploymentState>>;
};

export enum GraphStoreV2JiraWorkItemLinksExternalDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type GraphStoreV2JiraWorkItemLinksExternalDeploymentEnvironmentTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraWorkItemLinksExternalDeploymentEnvironmentType>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraWorkItemLinksExternalDeploymentEnvironmentType>>;
};

/** Conditional selection for filter field of JiraWorkItemLinksExternalDeployment alias queries */
export type GraphStoreV2JiraWorkItemLinksExternalDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraWorkItemLinksExternalDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraWorkItemLinksExternalDeploymentConditionalFilterInput>>>;
};

export type GraphStoreV2JiraWorkItemLinksExternalDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_author?: InputMaybe<GraphStoreV2JiraWorkItemLinksExternalDeploymentAuthorSortInput>;
  to_environmentType?: InputMaybe<GraphStoreSortInput>;
  to_state?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksExternalDesignSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_type?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksExternalFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksExternalPullRequestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksExternalRemoteLinkSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksExternalVulnerabilityContainerSortInput = {
  containerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksExternalVulnerabilitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  from_container?: InputMaybe<GraphStoreV2JiraWorkItemLinksExternalVulnerabilityContainerSortInput>;
  from_introducedDate?: InputMaybe<GraphStoreSortInput>;
  from_severity?: InputMaybe<GraphStoreSortInput>;
  from_status?: InputMaybe<GraphStoreSortInput>;
  from_type?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksJiraWorkItemRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksJiraWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemLinksSupportEscalationEntityConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  relationship_SupportEscalationLastUpdated?: InputMaybe<GraphStoreLongFilterInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreAriFilterInput>;
  relationship_linkType?: InputMaybe<GraphStoreV2JiraWorkItemLinksSupportEscalationEntityEscalationLinkTypeFilterInput>;
  relationship_status?: InputMaybe<GraphStoreV2JiraWorkItemLinksSupportEscalationEntityEscalationStatusFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
};

export enum GraphStoreV2JiraWorkItemLinksSupportEscalationEntityEscalationLinkType {
  ExistingWorkItem = 'EXISTING_WORK_ITEM',
  NewWorkItem = 'NEW_WORK_ITEM',
  NotSet = 'NOT_SET'
}

export type GraphStoreV2JiraWorkItemLinksSupportEscalationEntityEscalationLinkTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraWorkItemLinksSupportEscalationEntityEscalationLinkType>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraWorkItemLinksSupportEscalationEntityEscalationLinkType>>;
};

export enum GraphStoreV2JiraWorkItemLinksSupportEscalationEntityEscalationStatus {
  Accepted = 'ACCEPTED',
  Open = 'OPEN',
  Rejected = 'REJECTED'
}

export type GraphStoreV2JiraWorkItemLinksSupportEscalationEntityEscalationStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JiraWorkItemLinksSupportEscalationEntityEscalationStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2JiraWorkItemLinksSupportEscalationEntityEscalationStatus>>;
};

/** Conditional selection for filter field of JiraWorkItemLinksSupportEscalationEntity alias queries */
export type GraphStoreV2JiraWorkItemLinksSupportEscalationEntityFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraWorkItemLinksSupportEscalationEntityConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JiraWorkItemLinksSupportEscalationEntityConditionalFilterInput>>>;
};

export type GraphStoreV2JiraWorkItemLinksSupportEscalationEntitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  relationship_SupportEscalationLastUpdated?: InputMaybe<GraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<GraphStoreSortInput>;
  relationship_linkType?: InputMaybe<GraphStoreSortInput>;
  relationship_status?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JiraWorkItemTracksAtlassianProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JsmIncidentImpactsCompassComponentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JsmIncidentLinksExternalServiceConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_affectedServiceAris?: InputMaybe<GraphStoreAriFilterInput>;
  to_assigneeAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_majorIncident?: InputMaybe<GraphStoreBooleanFilterInput>;
  to_priority?: InputMaybe<GraphStoreV2JsmIncidentLinksExternalServiceJiraServiceManagementIncidentPriorityFilterInput>;
  to_reporterAri?: InputMaybe<GraphStoreAriFilterInput>;
  to_status?: InputMaybe<GraphStoreV2JsmIncidentLinksExternalServiceJiraServiceManagementIncidentStatusFilterInput>;
};

/** Conditional selection for filter field of JsmIncidentLinksExternalService alias queries */
export type GraphStoreV2JsmIncidentLinksExternalServiceFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreV2JsmIncidentLinksExternalServiceConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreV2JsmIncidentLinksExternalServiceConditionalFilterInput>>>;
};

export enum GraphStoreV2JsmIncidentLinksExternalServiceJiraServiceManagementIncidentPriority {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5'
}

export type GraphStoreV2JsmIncidentLinksExternalServiceJiraServiceManagementIncidentPriorityFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JsmIncidentLinksExternalServiceJiraServiceManagementIncidentPriority>>;
  isNot?: InputMaybe<Array<GraphStoreV2JsmIncidentLinksExternalServiceJiraServiceManagementIncidentPriority>>;
};

export enum GraphStoreV2JsmIncidentLinksExternalServiceJiraServiceManagementIncidentStatus {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export type GraphStoreV2JsmIncidentLinksExternalServiceJiraServiceManagementIncidentStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreV2JsmIncidentLinksExternalServiceJiraServiceManagementIncidentStatus>>;
  isNot?: InputMaybe<Array<GraphStoreV2JsmIncidentLinksExternalServiceJiraServiceManagementIncidentStatus>>;
};

export type GraphStoreV2JsmIncidentLinksExternalServiceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_affectedServiceAris?: InputMaybe<GraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<GraphStoreSortInput>;
  to_majorIncident?: InputMaybe<GraphStoreSortInput>;
  to_priority?: InputMaybe<GraphStoreSortInput>;
  to_reporterAri?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JsmIncidentLinksJiraPostIncidentReviewSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JsmIncidentLinksJiraWorkItemSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JsmIncidentLinksJsmPostIncidentReviewLinkSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JsmSpaceLinksExternalServiceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2JsmSpaceLinksKnowledgeBaseEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2LoomMeetingHasConfluenceMeetingNotesPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2LoomMeetingHasJiraSpaceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2LoomMeetingHasLoomVideoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2LoomMeetingRecurrenceHasConfluenceMeetingNotesPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2LoomMeetingRecurrenceHasLoomMeetingSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2LoomVideoHasConfluencePageSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2LoomVideoHasLoomVideoCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2LoomVideoSharedWithAtlassianUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2MediaFileAttachedToContentEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2RepositoryEntityIsBitbucketRepositorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2TalentPositionLinksExternalPositionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2TalentWorkerLinksExternalWorkerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2ThirdPartyRemoteLinkLinksExternalRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreV2TopicHasRelatedEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedBranchSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedBuildSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedCommitSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedDesignConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreAtiFilterInput>;
  to_designLastUpdated?: InputMaybe<GraphStoreLongFilterInput>;
  to_status?: InputMaybe<GraphStoreVersionAssociatedDesignDesignStatusFilterInput>;
  to_type?: InputMaybe<GraphStoreVersionAssociatedDesignDesignTypeFilterInput>;
};

export enum GraphStoreVersionAssociatedDesignDesignStatus {
  None = 'NONE',
  NotSet = 'NOT_SET',
  ReadyForDevelopment = 'READY_FOR_DEVELOPMENT',
  Unknown = 'UNKNOWN'
}

export type GraphStoreVersionAssociatedDesignDesignStatusFilterInput = {
  is?: InputMaybe<Array<GraphStoreVersionAssociatedDesignDesignStatus>>;
  isNot?: InputMaybe<Array<GraphStoreVersionAssociatedDesignDesignStatus>>;
};

export enum GraphStoreVersionAssociatedDesignDesignType {
  Canvas = 'CANVAS',
  File = 'FILE',
  Group = 'GROUP',
  Node = 'NODE',
  NotSet = 'NOT_SET',
  Other = 'OTHER',
  Prototype = 'PROTOTYPE'
}

export type GraphStoreVersionAssociatedDesignDesignTypeFilterInput = {
  is?: InputMaybe<Array<GraphStoreVersionAssociatedDesignDesignType>>;
  isNot?: InputMaybe<Array<GraphStoreVersionAssociatedDesignDesignType>>;
};

/** Conditional selection for filter field of version-associated-design relationship queries */
export type GraphStoreVersionAssociatedDesignFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<GraphStoreVersionAssociatedDesignConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<GraphStoreVersionAssociatedDesignConditionalFilterInput>>>;
};

export type GraphStoreVersionAssociatedDesignSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
  to_designLastUpdated?: InputMaybe<GraphStoreSortInput>;
  to_status?: InputMaybe<GraphStoreSortInput>;
  to_type?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedPullRequestSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionAssociatedRemoteLinkSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVersionUserAssociatedFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVideoHasCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVideoSharedWithUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVulnerabilityAssociatedIssueContainerSortInput = {
  containerAri?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreVulnerabilityAssociatedIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<GraphStoreSortInput>;
  from_container?: InputMaybe<GraphStoreVulnerabilityAssociatedIssueContainerSortInput>;
  from_introducedDate?: InputMaybe<GraphStoreSortInput>;
  from_severity?: InputMaybe<GraphStoreSortInput>;
  from_status?: InputMaybe<GraphStoreSortInput>;
  from_type?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<GraphStoreSortInput>;
};

export type GraphStoreWorkerAssociatedExternalWorkerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<GraphStoreSortInput>;
};

export type GroupWithPermissionsInput = {
  id: Scalars['ID']['input'];
  operations: Array<InputMaybe<OperationCheckResultInput>>;
};

/**
 * The context object provides essential insights into the users' current experience and operations.
 *
 * The supported product and subproduct keys can be found at https://hello.atlassian.net/wiki/spaces/ECON/pages/2339030895/App+Identifiers
 */
export type GrowthRecContext = {
  anonymousId?: InputMaybe<Scalars['ID']['input']>;
  containers?: InputMaybe<Scalars['JSON']['input']>;
  /** Any custom context associated with this request */
  custom?: InputMaybe<Scalars['JSON']['input']>;
  /** Language-Sub language identifier format (ISO 639-1 and ISO 639-2) */
  locale?: InputMaybe<Scalars['String']['input']>;
  orgId?: InputMaybe<Scalars['ID']['input']>;
  product?: InputMaybe<Scalars['String']['input']>;
  /** This is an identifier for tagging analytics events, useful for correlating across frontend and backend */
  sessionId?: InputMaybe<Scalars['ID']['input']>;
  subproduct?: InputMaybe<Scalars['String']['input']>;
  /** The tenant id is also well known as the cloud id */
  tenantId?: InputMaybe<Scalars['ID']['input']>;
  useCase?: InputMaybe<Scalars['String']['input']>;
  workspaceId?: InputMaybe<Scalars['ID']['input']>;
};

export type GrowthRecRerankCandidate = {
  context?: InputMaybe<Scalars['JSON']['input']>;
  entityId: Scalars['String']['input'];
};

export enum GrowthUnifiedProfileAnchorType {
  Pfm = 'PFM',
  Seo = 'SEO'
}

export enum GrowthUnifiedProfileChannel {
  PaidContent = 'PAID_CONTENT',
  PaidDisplay = 'PAID_DISPLAY',
  PaidReviewSites = 'PAID_REVIEW_SITES',
  PaidSearch = 'PAID_SEARCH',
  PaidSocial = 'PAID_SOCIAL'
}

export enum GrowthUnifiedProfileCompanySize {
  Large = 'LARGE',
  Medium = 'MEDIUM',
  Small = 'SMALL',
  Unknown = 'UNKNOWN'
}

export enum GrowthUnifiedProfileCompanyType {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

export enum GrowthUnifiedProfileConfluenceFamiliarity {
  Experience = 'EXPERIENCE',
  Middle = 'MIDDLE',
  New = 'NEW'
}

export type GrowthUnifiedProfileConfluenceOnboardingContextInput = {
  confluenceFamiliarity?: InputMaybe<GrowthUnifiedProfileConfluenceFamiliarity>;
  experienceLevel?: InputMaybe<Scalars['String']['input']>;
  jobsToBeDone?: InputMaybe<Array<InputMaybe<GrowthUnifiedProfileJtbd>>>;
  teamType?: InputMaybe<GrowthUnifiedProfileTeamType>;
  template?: InputMaybe<Scalars['String']['input']>;
};

/** Create Entitlement Profile input */
export type GrowthUnifiedProfileCreateEntitlementProfileInput = {
  /** If the auto provisioning modal has been dismissed for this entitlement before */
  autoProvisioningEditionParityDialogDismissed?: InputMaybe<Scalars['Boolean']['input']>;
  entitlementId: Scalars['ID']['input'];
  firstProductOnSite?: InputMaybe<Scalars['Boolean']['input']>;
  trial?: InputMaybe<GrowthUnifiedProfileEntitlementContextTrialInput>;
};

export type GrowthUnifiedProfileCreateOrgProfileInput = {
  /** org id of the org */
  orgId: Scalars['ID']['input'];
  /** Team Work Collection Onboarding context */
  twcOnboardingContext?: InputMaybe<Array<InputMaybe<GrowthUnifiedProfileTwcOnboardingContextInput>>>;
};

export type GrowthUnifiedProfileCreateProfileInput = {
  /** The account ID for the user. */
  accountId?: InputMaybe<Scalars['ID']['input']>;
  /** The anonymous ID for the user. */
  anonymousId?: InputMaybe<Scalars['ID']['input']>;
  /** The tenant ID for the user. */
  tenantId?: InputMaybe<Scalars['ID']['input']>;
  /** Unified profile which needs to be created for the user. */
  unifiedProfile: GrowthUnifiedProfileInput;
};

export enum GrowthUnifiedProfileDomainType {
  Business = 'BUSINESS',
  Personal = 'PERSONAL'
}

export enum GrowthUnifiedProfileEnrichmentStatus {
  Complete = 'COMPLETE',
  Error = 'ERROR',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING'
}

export enum GrowthUnifiedProfileEnterpriseAccountStatus {
  Bronze = 'BRONZE',
  Gam = 'GAM',
  Gold = 'GOLD',
  Platimun = 'PLATIMUN',
  Silver = 'SILVER'
}

export type GrowthUnifiedProfileEntitlementContextTrialInput = {
  /** If the customer had payment details on file when they started the trial */
  hadPaymentDetails?: InputMaybe<Scalars['Boolean']['input']>;
  /** The offering id that is being trialed */
  offeringId?: InputMaybe<Scalars['String']['input']>;
  /** When the trial ends */
  trialEndTimeStamp?: InputMaybe<Scalars['Float']['input']>;
  /** What triggered the trial */
  trialTrigger?: InputMaybe<GrowthUnifiedProfileTrialTrigger>;
  /** Type of trial (direct or reverse) */
  trialType?: InputMaybe<GrowthUnifiedProfileTrialType>;
};

export enum GrowthUnifiedProfileEntityType {
  /** anonymous entity type */
  AjsAnonymousUser = 'AJS_ANONYMOUS_USER',
  /** atlassian account entity type */
  AtlassianAccount = 'ATLASSIAN_ACCOUNT',
  /** organization entity type */
  Org = 'ORG',
  /** site of tenant entity type */
  Site = 'SITE'
}

export enum GrowthUnifiedProfileEntryType {
  Existing = 'EXISTING',
  New = 'NEW'
}

/** Feature engagement level for the usage data */
export enum GrowthUnifiedProfileFeatureEngagementLevel {
  Activation = 'ACTIVATION',
  Config = 'CONFIG',
  Interaction = 'INTERACTION',
  View = 'VIEW'
}

/** Feature type enumeration */
export enum GrowthUnifiedProfileFeatureType {
  Stateful = 'STATEFUL',
  Stateless = 'STATELESS'
}

export type GrowthUnifiedProfileGetUnifiedUserProfileWhereInput = {
  tenantId: Scalars['String']['input'];
};

export type GrowthUnifiedProfileInput = {
  /** marketing context for campaigns */
  marketingContext?: InputMaybe<GrowthUnifiedProfileMarketingContextInput>;
  /** onboardingContext for jira or confluence */
  onboardingContext?: InputMaybe<GrowthUnifiedProfileOnboardingContextInput>;
  /** linked products for the user */
  trialContext?: InputMaybe<Array<InputMaybe<GrowthUnifiedProfileTrialContextInput>>>;
};

/** Issue type input to be used for the first onboarding Jira project */
export type GrowthUnifiedProfileIssueTypeInput = {
  /** Issue type avatar */
  avatarId?: InputMaybe<Scalars['String']['input']>;
  /** Issue type name */
  name?: InputMaybe<Scalars['String']['input']>;
};

export enum GrowthUnifiedProfileJtbd {
  AdHocTaskAndIncidentManagement = 'AD_HOC_TASK_AND_INCIDENT_MANAGEMENT',
  Brainstorming = 'BRAINSTORMING',
  Budgets = 'BUDGETS',
  CampaignPlanning = 'CAMPAIGN_PLANNING',
  CdWrtng = 'CD_WRTNG',
  CentralizedDocumentation = 'CENTRALIZED_DOCUMENTATION',
  ComplianceAndRiskManagement = 'COMPLIANCE_AND_RISK_MANAGEMENT',
  CreativeBriefs = 'CREATIVE_BRIEFS',
  CustomerJourneys = 'CUSTOMER_JOURNEYS',
  EstimateTimeAndEffort = 'ESTIMATE_TIME_AND_EFFORT',
  FlowchartAndDiagrams = 'FLOWCHART_AND_DIAGRAMS',
  GanttChart = 'GANTT_CHART',
  ImproveTeamProcesses = 'IMPROVE_TEAM_PROCESSES',
  ImproveWorkflow = 'IMPROVE_WORKFLOW',
  KnowledgeHub = 'KNOWLEDGE_HUB',
  LaunchCampaigns = 'LAUNCH_CAMPAIGNS',
  ManageTasks = 'MANAGE_TASKS',
  ManagingClientAndVendorRelationships = 'MANAGING_CLIENT_AND_VENDOR_RELATIONSHIPS',
  MapWorkDependencies = 'MAP_WORK_DEPENDENCIES',
  MarketingContent = 'MARKETING_CONTENT',
  MeetingNotes = 'MEETING_NOTES',
  PlanAndManage = 'PLAN_AND_MANAGE',
  PrioritizeWork = 'PRIORITIZE_WORK',
  ProcessMapping = 'PROCESS_MAPPING',
  ProjectPlan = 'PROJECT_PLAN',
  ProjectPlanning = 'PROJECT_PLANNING',
  ProjectPlanningAndCoordination = 'PROJECT_PLANNING_AND_COORDINATION',
  ProjectProgress = 'PROJECT_PROGRESS',
  RequirementsDoc = 'REQUIREMENTS_DOC',
  RunSprints = 'RUN_SPRINTS',
  Stakeholders = 'STAKEHOLDERS',
  StrategiesAndGoals = 'STRATEGIES_AND_GOALS',
  SystemAndToolEvaluations = 'SYSTEM_AND_TOOL_EVALUATIONS',
  TaskTracking = 'TASK_TRACKING',
  TeamStatusUpdate = 'TEAM_STATUS_UPDATE',
  TrackingRprtng = 'TRACKING_RPRTNG',
  TrackBugs = 'TRACK_BUGS',
  UseKanbanBoard = 'USE_KANBAN_BOARD',
  WorkInScrum = 'WORK_IN_SCRUM'
}

export enum GrowthUnifiedProfileJiraFamiliarity {
  Experience = 'EXPERIENCE',
  Middle = 'MIDDLE',
  New = 'NEW'
}

/** onboarding context input for jira */
export type GrowthUnifiedProfileJiraOnboardingContextInput = {
  experienceLevel?: InputMaybe<Scalars['String']['input']>;
  /** Issue types to be used for the first onboarding Jira project */
  issueTypes?: InputMaybe<Array<InputMaybe<GrowthUnifiedProfileIssueTypeInput>>>;
  jiraFamiliarity?: InputMaybe<GrowthUnifiedProfileJiraFamiliarity>;
  /** jobs to be done */
  jobsToBeDone?: InputMaybe<Array<InputMaybe<GrowthUnifiedProfileJtbd>>>;
  persona?: InputMaybe<Scalars['String']['input']>;
  /** Project landing selection */
  projectLandingSelection?: InputMaybe<GrowthUnifiedProfileOnboardingContextProjectLandingSelection>;
  /** name of the jira project */
  projectName?: InputMaybe<Scalars['String']['input']>;
  /** Status names to be used for the first onboarding Jira project */
  statusNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** team type of the user */
  teamType?: InputMaybe<GrowthUnifiedProfileTeamType>;
  template?: InputMaybe<Scalars['String']['input']>;
  /** third party tools */
  thirdPartyTools?: InputMaybe<Array<InputMaybe<GrowthUnifiedProfileThirdPartyTools>>>;
};

/** Marketing context input for campaigns */
export type GrowthUnifiedProfileMarketingContextInput = {
  domain?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  utm?: InputMaybe<GrowthUnifiedProfileMarketingUtmInput>;
};

/** Marketing utm values will be extracted from the url query parameters */
export type GrowthUnifiedProfileMarketingUtmInput = {
  campaign?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
  medium?: InputMaybe<Scalars['String']['input']>;
  sfdcCampaignId?: InputMaybe<Scalars['String']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
};

/** Metric type */
export enum GrowthUnifiedProfileMetric {
  Mau = 'MAU',
  MauVariation = 'MAU_VARIATION'
}

/** onboarding context input for jira or confluence */
export type GrowthUnifiedProfileOnboardingContextInput = {
  confluence?: InputMaybe<GrowthUnifiedProfileConfluenceOnboardingContextInput>;
  jira?: InputMaybe<GrowthUnifiedProfileJiraOnboardingContextInput>;
};

export enum GrowthUnifiedProfileOnboardingContextProjectLandingSelection {
  CreateProject = 'CREATE_PROJECT',
  SampleProject = 'SAMPLE_PROJECT'
}

export type GrowthUnifiedProfileOrgProfileFilterInput = {
  entitlementId?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['String']['input']>;
};

/** Filter input for paid feature usage data */
export type GrowthUnifiedProfilePfuFilter = {
  /** End date for the usage data. Empty Value indicates current date */
  endDate?: InputMaybe<Scalars['String']['input']>;
  featureEngagementLevels?: InputMaybe<Array<GrowthUnifiedProfileFeatureEngagementLevel>>;
  /** Feature name for the usage data */
  featureName?: InputMaybe<Scalars['String']['input']>;
  /** Feature supported edition for the usage data */
  featureSupportedEditions?: InputMaybe<Array<GrowthUnifiedProfileProductEdition>>;
  /** Feature type for the usage data */
  featureType?: InputMaybe<GrowthUnifiedProfileFeatureType>;
  /** Product key for the usage data */
  productKeys?: InputMaybe<Array<GrowthUnifiedProfileProductKey>>;
  /** Start date for the usage data, YYYY-MM-DD */
  startDate: Scalars['String']['input'];
  /** Tenant for the usage data. Empty list means all tenants. */
  tenants?: InputMaybe<Array<GrowthUnifiedProfileTenant>>;
};

/** Filter input for paid feature usage data */
export type GrowthUnifiedProfilePaidFeatureUsageFilterInput = {
  /** End date for the usage data */
  endDate?: InputMaybe<Scalars['String']['input']>;
  /** Start date for the usage data */
  startDate?: InputMaybe<Scalars['String']['input']>;
};

export enum GrowthUnifiedProfileProduct {
  Compass = 'compass',
  Confluence = 'confluence',
  Csm = 'csm',
  Jira = 'jira',
  Jpd = 'jpd',
  Jsm = 'jsm',
  Jwm = 'jwm',
  Servco = 'servco',
  Trello = 'trello'
}

export enum GrowthUnifiedProfileProductEdition {
  Business = 'BUSINESS',
  BusinessAi = 'BUSINESS_AI',
  Enterprise = 'ENTERPRISE',
  Free = 'FREE',
  Premium = 'PREMIUM',
  Standard = 'STANDARD',
  Starter = 'STARTER'
}

export enum GrowthUnifiedProfileProductKey {
  Confluence = 'CONFLUENCE',
  Jira = 'JIRA',
  JiraProductDiscovery = 'JIRA_PRODUCT_DISCOVERY',
  JiraServiceManagement = 'JIRA_SERVICE_MANAGEMENT',
  Loom = 'LOOM'
}

export enum GrowthUnifiedProfileRollingDateIntervalInput {
  Days_1 = 'DAYS_1',
  Days_7 = 'DAYS_7',
  Days_30 = 'DAYS_30',
  Days_90 = 'DAYS_90',
  Days_180 = 'DAYS_180',
  Days_270 = 'DAYS_270',
  Days_365 = 'DAYS_365'
}

export enum GrowthUnifiedProfileTeamType {
  CustomerService = 'CUSTOMER_SERVICE',
  DataScience = 'DATA_SCIENCE',
  Design = 'DESIGN',
  Finance = 'FINANCE',
  HumanResources = 'HUMAN_RESOURCES',
  ItSupport = 'IT_SUPPORT',
  Legal = 'LEGAL',
  Marketing = 'MARKETING',
  Operations = 'OPERATIONS',
  Other = 'OTHER',
  ProductManagement = 'PRODUCT_MANAGEMENT',
  ProgramManagement = 'PROGRAM_MANAGEMENT',
  ProjectManagement = 'PROJECT_MANAGEMENT',
  Sales = 'SALES',
  SoftwareDevelopment = 'SOFTWARE_DEVELOPMENT',
  SoftwareEngineering = 'SOFTWARE_ENGINEERING'
}

/** Tenant for the usage data */
export type GrowthUnifiedProfileTenant = {
  /** Tenant id for the usage data */
  tenantId: Scalars['String']['input'];
  /** Tenant Type for the usage data */
  tenantType: GrowthUnifiedProfileTenantType;
};

/** Tenant type for the usage data */
export enum GrowthUnifiedProfileTenantType {
  CloudId = 'CLOUD_ID',
  OrgId = 'ORG_ID'
}

export enum GrowthUnifiedProfileThirdPartyTools {
  Asana = 'ASANA',
  Bitbucket = 'BITBUCKET',
  Canva = 'CANVA',
  Confluence = 'CONFLUENCE',
  Dropbox = 'DROPBOX',
  Figma = 'FIGMA',
  Github = 'GITHUB',
  Gitlab = 'GITLAB',
  Google = 'GOOGLE',
  Microsoft = 'MICROSOFT',
  Monday = 'MONDAY',
  Notion = 'NOTION',
  Slack = 'SLACK',
  Trello = 'TRELLO'
}

export type GrowthUnifiedProfileTrialContextInput = {
  /** first product on site */
  firstProductOnSite?: InputMaybe<Scalars['Boolean']['input']>;
  /** payment details on file */
  paymentDetailsOnFile?: InputMaybe<Scalars['Boolean']['input']>;
  /** GUPS product */
  product: GrowthUnifiedProfileProduct;
  /** when the trial ends */
  trialEndTimeStamp: Scalars['String']['input'];
  /** trial trigger */
  trialTrigger?: InputMaybe<GrowthUnifiedProfileTrialTrigger>;
  /** trial type */
  trialType: GrowthUnifiedProfileTrialType;
};

/** Filter input for trial history data */
export type GrowthUnifiedProfileTrialHistoryFilterInput = {
  /** Filter by trial type */
  trialType?: InputMaybe<GrowthUnifiedProfileTrialType>;
};

/** What triggered the trial */
export enum GrowthUnifiedProfileTrialTrigger {
  AutoUpgradeUserLimit = 'AUTO_UPGRADE_USER_LIMIT',
  CrossflowUserLimit = 'CROSSFLOW_USER_LIMIT',
  EditionParity = 'EDITION_PARITY',
  EditionParityAutoProvisioning = 'EDITION_PARITY_AUTO_PROVISIONING',
  Reactivation = 'REACTIVATION',
  ReverseTrial = 'REVERSE_TRIAL',
  Ui = 'UI'
}

/** Type of trial */
export enum GrowthUnifiedProfileTrialType {
  AutoUpgrade = 'AUTO_UPGRADE',
  DirectTrial = 'DIRECT_TRIAL',
  ManualTrial = 'MANUAL_TRIAL',
  ReverseTrial = 'REVERSE_TRIAL'
}

export enum GrowthUnifiedProfileTwcCreatedFrom {
  AdminHub = 'ADMIN_HUB',
  CrossFlow = 'CROSS_FLOW',
  SignUp = 'SIGN_UP'
}

export enum GrowthUnifiedProfileTwcEdition {
  Enterprise = 'ENTERPRISE',
  Free = 'FREE',
  Premium = 'PREMIUM',
  Standard = 'STANDARD'
}

/** TWC Onboarding Context Input */
export type GrowthUnifiedProfileTwcOnboardingContextInput = {
  createdAt?: InputMaybe<Scalars['String']['input']>;
  createdFrom?: InputMaybe<GrowthUnifiedProfileTwcCreatedFrom>;
  edition?: InputMaybe<GrowthUnifiedProfileTwcEdition>;
  entitlementId: Scalars['ID']['input'];
  existingProducts?: InputMaybe<Array<InputMaybe<GrowthUnifiedProfileTwcProductDetailsInput>>>;
  newProducts?: InputMaybe<Array<InputMaybe<GrowthUnifiedProfileTwcProductDetailsInput>>>;
  onboardingUrl?: InputMaybe<Scalars['String']['input']>;
};

/** TWC Product Details Input */
export type GrowthUnifiedProfileTwcProductDetailsInput = {
  productKey: Scalars['String']['input'];
  productUrl?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['String']['input']>;
};

export enum GrowthUnifiedProfileUserIdType {
  AccountId = 'ACCOUNT_ID',
  AnonymousId = 'ANONYMOUS_ID'
}

export enum HelpCenterAccessControlType {
  /** Help center is accessible to external customers */
  External = 'EXTERNAL',
  /** Help center is accessible to specific groups */
  GroupBased = 'GROUP_BASED',
  /** Help center is accessible to internal customers */
  Internal = 'INTERNAL',
  /** Help center is accessible to all */
  Public = 'PUBLIC'
}

export type HelpCenterAddProjectMappingInput = {
  /** List of project Ids to be linked */
  projectIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Automatically map newly created projects to this Help center */
  syncNewProjects?: InputMaybe<Scalars['Boolean']['input']>;
};

export type HelpCenterAnnouncementInput = {
  /** Description and its all translations in raw format */
  descriptionTranslations?: InputMaybe<Array<HelpCenterTranslationInput>>;
  /** Type in which announcements are stored */
  descriptionType: HelpCenterDescriptionType;
  /** HelpCenterARI can be used to get the correct help center node */
  helpCenterAri: Scalars['String']['input'];
  /** Name and its all translations in raw format */
  nameTranslations?: InputMaybe<Array<HelpCenterTranslationInput>>;
};

export type HelpCenterBannerInput = {
  filedId?: InputMaybe<Scalars['String']['input']>;
  useDefaultBanner?: InputMaybe<Scalars['Boolean']['input']>;
};

export type HelpCenterBrandingColorsInput = {
  /** Banner text color of the Help Center */
  bannerTextColor?: InputMaybe<Scalars['String']['input']>;
  /** primary brand color of the Help Center */
  primary?: InputMaybe<Scalars['String']['input']>;
  /** primary color of the Top Bar */
  topBarColor?: InputMaybe<Scalars['String']['input']>;
  /** Top bar text color */
  topBarTextColor?: InputMaybe<Scalars['String']['input']>;
};

export type HelpCenterBrandingInput = {
  banner?: InputMaybe<HelpCenterBannerInput>;
  /** Brand colors of the Help Center */
  colors?: InputMaybe<HelpCenterBrandingColorsInput>;
  /** Title of the Help Center */
  homePageTitle?: InputMaybe<HelpCenterHomePageTitleInput>;
  /** Logo of Help Center */
  logo?: InputMaybe<HelpCenterLogoInput>;
};

export type HelpCenterBulkCreateTopicsInput = {
  /** Actual set of topics to be created in the given help center */
  helpCenterCreateTopicInputItem: Array<HelpCenterCreateTopicInput>;
};

export type HelpCenterBulkDeleteTopicInput = {
  helpCenterTopicDeleteInput: Array<HelpCenterTopicDeleteInput>;
};

export type HelpCenterBulkUpdateTopicInput = {
  /** The new updated topic for the given help center */
  helpCenterUpdateTopicInputItem: Array<HelpCenterUpdateTopicInput>;
};

/**
 * #########################
 *  Mutation Inputs
 * #########################
 */
export type HelpCenterCreateInput = {
  /** Help Center Type */
  helpCenterType?: InputMaybe<HelpCenterTypeInput>;
  /** Layout Input */
  homePageLayout?: InputMaybe<HelpCenterHomePageLayoutInput>;
  /** Name of the help center. */
  name: HelpCenterNameInput;
  /** Add Project Mapping */
  projectMapping?: InputMaybe<HelpCenterAddProjectMappingInput>;
  /** Rovo Config */
  rovoConfig?: InputMaybe<HelpCenterRovoConfig>;
  /** Slug of the help center. */
  slug: Scalars['String']['input'];
  /** workspaceARI can be used to get the correct help center node */
  workspaceARI: Scalars['String']['input'];
};

export type HelpCenterCreateTopicInput = {
  /** Description about the topic as visible on help center page */
  description?: InputMaybe<Scalars['String']['input']>;
  /** HelpCenterARI can be used to retrieve helpCenterId */
  helpCenterAri?: InputMaybe<Scalars['String']['input']>;
  /** The help objects ARI which this topic contains */
  items: Array<HelpCenterTopicItemInput>;
  /** Name about the topic as visible on the help center page */
  name: Scalars['String']['input'];
  /** The id of help center where the topics needs to be created */
  productName?: InputMaybe<Scalars['String']['input']>;
  /**
   *  This includes additional properties to the topics.
   * Such as whether the topic is visible to the helpseekers on help center or not etc.
   */
  properties?: InputMaybe<Scalars['JSON']['input']>;
};

export type HelpCenterDeleteInput = {
  /** HelpCenterARI can be used to get the correct help center node */
  helpCenterAri: Scalars['String']['input'];
};

export enum HelpCenterDescriptionType {
  PlainText = 'PLAIN_TEXT',
  RichText = 'RICH_TEXT',
  WikiMarkup = 'WIKI_MARKUP'
}

export type HelpCenterFilter = {
  type?: InputMaybe<HelpCenterType>;
};

export type HelpCenterHomePageLayoutInput = {
  /** Adf Content */
  layoutAdf?: InputMaybe<Scalars['String']['input']>;
  /** Metadata for the page layout */
  metadata?: InputMaybe<Scalars['String']['input']>;
};

export type HelpCenterHomePageTitleInput = {
  /** Default name of the helpcenter. */
  default: Scalars['String']['input'];
  /** Translations of title the helpcenter. */
  translations?: InputMaybe<Array<InputMaybe<HelpCenterTranslationInput>>>;
};

export type HelpCenterLogoInput = {
  fileId?: InputMaybe<Scalars['String']['input']>;
};

/**  This describes the type of operation for which mediaConfig needs to be generated */
export enum HelpCenterMediaConfigOperationType {
  /** indicates banner upload */
  BannerUpload = 'BANNER_UPLOAD',
  /** indicates logo upload */
  LogoUpload = 'LOGO_UPLOAD',
  /** for fetching read collection media config */
  Read = 'READ'
}

export type HelpCenterNameInput = {
  /** Default name of the helpcenter to be updated */
  default: Scalars['String']['input'];
  /** Translations of description the helpcenter. */
  translations?: InputMaybe<Array<InputMaybe<HelpCenterTranslationInput>>>;
};

export type HelpCenterPageCreateInput = {
  /** Ari of existing page, if page is being cloned */
  clonePageAri?: InputMaybe<Scalars['String']['input']>;
  /** Description of the help center page. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** helpCenterAri for the Help center under which page is being created */
  helpCenterAri: Scalars['String']['input'];
  /** Name of the help center page. */
  name: Scalars['String']['input'];
  /** Layout Input */
  pageLayout?: InputMaybe<HelpCenterPageLayoutInput>;
};

export type HelpCenterPageDeleteInput = {
  /** HelpCenterARI can be used to get the correct help center node */
  helpCenterPageAri: Scalars['String']['input'];
};

export type HelpCenterPageLayoutInput = {
  /** Adf Content */
  layoutAdf?: InputMaybe<Scalars['String']['input']>;
  /** Metadata for the page layout */
  metadata?: InputMaybe<Scalars['String']['input']>;
};

export enum HelpCenterPageType {
  /** indicates Custom help center page */
  Custom = 'CUSTOM'
}

export type HelpCenterPageUpdateInput = {
  /** Description of the help center page. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** helpCenterPageAri for the Help center page being updated */
  helpCenterPageAri: Scalars['String']['input'];
  /** Name of the help center page. */
  name: Scalars['String']['input'];
  /** Layout Input */
  pageLayout?: InputMaybe<HelpCenterPageLayoutInput>;
};

/** The ids can be Help Center ARI or Page ARI */
export type HelpCenterPagesFilter = {
  ids: Array<Scalars['ID']['input']>;
};

export type HelpCenterPermissionSettingsInput = {
  /** Type of access control for Help Center */
  accessControlType: HelpCenterAccessControlType;
  /** List of groups that needs to be added for Help Center access */
  addedAllowedAccessGroups?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List of groups whose access to Help Center needs to be deleted */
  deletedAllowedAccessGroups?: InputMaybe<Array<Scalars['String']['input']>>;
  /** HelpCenterARI can be used to get the correct help center node */
  helpCenterAri: Scalars['String']['input'];
};

export type HelpCenterPortalFilter = {
  /** Give a list of type of portals to be given */
  typeFilter?: InputMaybe<Array<HelpCenterPortalsType>>;
};

export type HelpCenterPortalsConfigurationUpdateInput = {
  /** List of final featured portals. Max limit is 15 */
  featuredPortals: Array<Scalars['String']['input']>;
  /** HelpCenterARI can be used to get the correct help center node */
  helpCenterAri: Scalars['String']['input'];
  /** List of hidden portals. */
  hiddenPortals: Array<Scalars['String']['input']>;
  /** Sorting order of portals */
  sortOrder: HelpCenterPortalsSortOrder;
};

export enum HelpCenterPortalsSortOrder {
  NameAscending = 'NAME_ASCENDING',
  Popularity = 'POPULARITY'
}

export enum HelpCenterPortalsType {
  /** Featured Portals */
  Featured = 'FEATURED',
  /** Hidden Portals */
  Hidden = 'HIDDEN',
  /** Visible Portals */
  Visible = 'VISIBLE'
}

export type HelpCenterProductEntityFilter = {
  /**
   * For JSM_HELP_OBJECTS: SpaceId/ Project Id
   * For suggested request types: helpCenterAri
   */
  parentId?: InputMaybe<Scalars['String']['input']>;
  /** For JSM_HELP_OBJECTS: REQUEST_TYPES, KB_ARTICLES, EXT_RESOURCES */
  subEntityTypes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type HelpCenterProductEntityImageInput = {
  /** Entity id for which the image is being set */
  entityId: Scalars['String']['input'];
  /** Entity type for which the image is being set */
  entityType: HelpCenterProductEntityType;
  /** FileId of the image to be set for the product */
  fileId?: InputMaybe<Scalars['String']['input']>;
  /** imageUrl of the image to be set for the product */
  imageUrl?: InputMaybe<Scalars['String']['input']>;
};

export type HelpCenterProductEntityRequestInput = {
  /** Cursor for pagination */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Number of entities to return */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Filters to be applied */
  parentFilters?: InputMaybe<Array<HelpCenterProductEntityFilter>>;
  /** Sort configuration */
  sortConfig?: InputMaybe<HelpCenterProductEntitySortConfig>;
  /** Entity type to determine which underlying product query to call */
  type: HelpCenterProductEntityType;
};

export type HelpCenterProductEntitySortConfig = {
  /** For JSM_HELP_OBJECTS with sortMode MANUAL, manualSortOrder array of entityIds("subEntityType|id") is required. */
  additionalConfig?: InputMaybe<Scalars['JSON']['input']>;
  sortMode?: InputMaybe<HelpCenterSortMode>;
};

export enum HelpCenterProductEntityType {
  /** indicates common request types suggested for a help center */
  CommonRequestTypes = 'COMMON_REQUEST_TYPES',
  /**
   * Unified entity type for all JSM entities (request types, KB articles, external resources).
   * Aggregation and merging handled by help-object-store.
   */
  JsmHelpObjects = 'JSM_HELP_OBJECTS',
  /** indicates knowledge cards as an entity */
  KnowledgeCards = 'KNOWLEDGE_CARDS'
}

export enum HelpCenterProjectMappingOperationType {
  /** Indicates the mapping of projects to Help Center */
  MapProjects = 'MAP_PROJECTS',
  /** Indicates the un-mapping of projects to a Help Center */
  UnmapProjects = 'UNMAP_PROJECTS'
}

export type HelpCenterProjectMappingUpdateInput = {
  /** HelpCenterARI can be used to get the correct help center node */
  helpCenterAri: Scalars['String']['input'];
  /** Operation to be performed on provided projectsIds */
  operationType?: InputMaybe<HelpCenterProjectMappingOperationType>;
  /** List of project Ids to be linked or un-linked based on the operationType */
  projectIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Automatically map newly created projects to this Help center */
  syncNewProjects?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum HelpCenterProjectType {
  CustomerService = 'CUSTOMER_SERVICE',
  ServiceDesk = 'SERVICE_DESK'
}

export type HelpCenterRovoConfig = {
  /** Rovo Agent Id */
  agentId?: InputMaybe<Scalars['String']['input']>;
};

export enum HelpCenterSortMode {
  Manual = 'MANUAL',
  Parent = 'PARENT',
  SubEntityType = 'SUB_ENTITY_TYPE'
}

export enum HelpCenterSortOrder {
  CreatedDateAscending = 'CREATED_DATE_ASCENDING',
  CreatedDateDescending = 'CREATED_DATE_DESCENDING'
}

export type HelpCenterTopicDeleteInput = {
  /** HelpCenterARI can be used to retrieve helpCenterId */
  helpCenterAri?: InputMaybe<Scalars['String']['input']>;
  /** The id of help center where the topic that needs to be deleted is part of */
  productName?: InputMaybe<Scalars['String']['input']>;
  /** The id of the topic which needs to be deleted */
  topicId: Scalars['ID']['input'];
};

export type HelpCenterTopicItemInput = {
  /** ARI of the help object which is included in this topic */
  ari: Scalars['ID']['input'];
};

export type HelpCenterTranslationInput = {
  locale: Scalars['String']['input'];
  localeDisplayName?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

export enum HelpCenterType {
  /** indicates Advanced help center */
  Advanced = 'ADVANCED',
  /** indicates Basic help center */
  Basic = 'BASIC',
  /** indicates Customer Service help center */
  CustomerService = 'CUSTOMER_SERVICE',
  /** indicates Help Hub */
  HelpHub = 'HELP_HUB',
  /** indicates Unified help center */
  Unified = 'UNIFIED'
}

export enum HelpCenterTypeInput {
  /** indicates Basic help center */
  Basic = 'BASIC',
  /** indicates Customer Service help center */
  CustomerService = 'CUSTOMER_SERVICE',
  /** indicates Help Hub */
  HelpHub = 'HELP_HUB'
}

export type HelpCenterUpdateInput = {
  /** HelpCenterARI can be used to get the correct helpCenter node */
  helpCenterAri: Scalars['String']['input'];
  /** Branding of the help center */
  helpCenterBranding?: InputMaybe<HelpCenterBrandingInput>;
  /** Layout Input */
  homePageLayout?: InputMaybe<HelpCenterHomePageLayoutInput>;
  /** Name of the helpcenter */
  name?: InputMaybe<HelpCenterNameInput>;
  /** To Update ProductEntityImages */
  productEntityImages?: InputMaybe<Array<HelpCenterProductEntityImageInput>>;
  /** Slug(identifier in the url) of the helpcenter. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** whether Virtual Agent is enabled for HelpCenter */
  virtualAgentEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type HelpCenterUpdateTopicInput = {
  /** Description of the topic */
  description?: InputMaybe<Scalars['String']['input']>;
  /** HelpCenterARI can be used to retrieve helpCenterId */
  helpCenterAri?: InputMaybe<Scalars['String']['input']>;
  /** The set of ARIs which this topic contains. */
  items: Array<HelpCenterTopicItemInput>;
  /** Name of the topic */
  name: Scalars['String']['input'];
  /** The id of help center where the topic that needs to be update is part of */
  productName?: InputMaybe<Scalars['String']['input']>;
  /** Additional properties of topics. Such as whether the topic is visible to the helpseekers on help center or not etc. */
  properties?: InputMaybe<Scalars['JSON']['input']>;
  /** The id of the already created topic */
  topicId: Scalars['ID']['input'];
};

export type HelpCenterUpdateTopicsOrderInput = {
  /** HelpCenterARI can be used to retrieve helpCenterId */
  helpCenterAri?: InputMaybe<Scalars['String']['input']>;
  /** The id of help center where the topic that needs to be reordered is part of */
  productName?: InputMaybe<Scalars['String']['input']>;
  /** The set of ids in the order you want them to be sorted */
  topicIds: Array<Scalars['ID']['input']>;
};

export type HelpExternalResourceCreateInput = {
  /**  The container ATI  */
  containerAti: Scalars['String']['input'];
  /**  The containerId  */
  containerId: Scalars['String']['input'];
  /**  The description  */
  description: Scalars['String']['input'];
  /**  The external resource link  */
  link: Scalars['String']['input'];
  /**  The resource type of the external resource  */
  resourceType: HelpExternalResourceLinkResourceType;
  /**  The external resource title  */
  title: Scalars['String']['input'];
};

export enum HelpExternalResourceLinkResourceType {
  Channel = 'CHANNEL',
  Knowledge = 'KNOWLEDGE',
  RequestForm = 'REQUEST_FORM'
}

export type HelpExternalResourceUpdateInput = {
  /**  The description  */
  description: Scalars['String']['input'];
  /**  The external resource id  */
  id: Scalars['ID']['input'];
  /**  The external resource link  */
  link: Scalars['String']['input'];
  /**  The external resource title  */
  title: Scalars['String']['input'];
};

export type HelpLayoutAlignmentSettingsInput = {
  horizontalAlignment?: InputMaybe<HelpLayoutHorizontalAlignment>;
  verticalAlignment?: InputMaybe<HelpLayoutVerticalAlignment>;
};

/** Portals List Input */
export type HelpLayoutAnnouncementInput = {
  useGlobalSettings?: InputMaybe<Scalars['Boolean']['input']>;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/**
 * This input type will be used to mutate Atomic Elements inside Composite Elements.
 * This type is used only inside a Composite Element
 */
export type HelpLayoutAtomicElementInput = {
  announcementInput?: InputMaybe<HelpLayoutAnnouncementInput>;
  breadcrumbInput?: InputMaybe<HelpLayoutBreadcrumbElementInput>;
  connectInput?: InputMaybe<HelpLayoutConnectInput>;
  editorInput?: InputMaybe<HelpLayoutEditorInput>;
  elementTypeKey: HelpLayoutAtomicElementKey;
  forgeInput?: InputMaybe<HelpLayoutForgeInput>;
  headingConfigInput?: InputMaybe<HelpLayoutHeadingConfigInput>;
  heroElementInput?: InputMaybe<HelpLayoutHeroElementInput>;
  imageConfigInput?: InputMaybe<HelpLayoutImageConfigInput>;
  knowledgeCardsInput?: InputMaybe<HelpLayoutKnowledgeCardsElementInput>;
  noContentElementInput?: InputMaybe<HelpLayoutNoContentElementInput>;
  paragraphConfigInput?: InputMaybe<HelpLayoutParagraphConfigInput>;
  portalsListInput?: InputMaybe<HelpLayoutPortalsListInput>;
  searchConfigInput?: InputMaybe<HelpLayoutSearchConfigInput>;
  suggestedRequestFormsListInput?: InputMaybe<HelpLayoutSuggestedRequestFormsListInput>;
  topicListInput?: InputMaybe<HelpLayoutTopicsListInput>;
};

/** This enum represents all the atomic element keys. */
export enum HelpLayoutAtomicElementKey {
  Announcement = 'ANNOUNCEMENT',
  Breadcrumb = 'BREADCRUMB',
  Connect = 'CONNECT',
  Editor = 'EDITOR',
  Forge = 'FORGE',
  Heading = 'HEADING',
  Hero = 'HERO',
  Image = 'IMAGE',
  KnowledgeCards = 'KNOWLEDGE_CARDS',
  NoContent = 'NO_CONTENT',
  Paragraph = 'PARAGRAPH',
  PortalsList = 'PORTALS_LIST',
  Search = 'SEARCH',
  SuggestedRequestFormsList = 'SUGGESTED_REQUEST_FORMS_LIST',
  TopicsList = 'TOPICS_LIST'
}

export type HelpLayoutBackgroundImageInput = {
  fileId?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export enum HelpLayoutBackgroundImageObjectFit {
  Contain = 'CONTAIN',
  Cover = 'COVER',
  Fill = 'FILL'
}

export enum HelpLayoutBackgroundType {
  Color = 'COLOR',
  Image = 'IMAGE',
  Transparent = 'TRANSPARENT'
}

/** Breadcrumb Input */
export type HelpLayoutBreadcrumbElementInput = {
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** This enum represents all the composite element keys. */
export enum HelpLayoutCompositeElementKey {
  LinkCard = 'LINK_CARD'
}

/** Connect App Element */
export enum HelpLayoutConnectElementPages {
  Approvals = 'APPROVALS',
  CreateRequest = 'CREATE_REQUEST',
  HelpCenter = 'HELP_CENTER',
  MyRequest = 'MY_REQUEST',
  Portal = 'PORTAL',
  Profile = 'PROFILE',
  ViewRequest = 'VIEW_REQUEST'
}

export enum HelpLayoutConnectElementType {
  DetailsPanels = 'detailsPanels',
  FooterPanels = 'footerPanels',
  HeaderAndSubheaderPanels = 'headerAndSubheaderPanels',
  HeaderPanels = 'headerPanels',
  OptionPanels = 'optionPanels',
  ProfilePagePanel = 'profilePagePanel',
  PropertyPanels = 'propertyPanels',
  RequestCreatePanel = 'requestCreatePanel',
  SubheaderPanels = 'subheaderPanels'
}

/** Connect App Input */
export type HelpLayoutConnectInput = {
  pages: HelpLayoutConnectElementPages;
  type: HelpLayoutConnectElementType;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export type HelpLayoutCreationInput = {
  parentAri: Scalars['ID']['input'];
  sections: Array<HelpLayoutSectionInput>;
  type: HelpLayoutType;
};

/** Editor Input */
export type HelpLayoutEditorInput = {
  adf: Scalars['String']['input'];
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** This enum represents all the element category. */
export enum HelpLayoutElementCategory {
  Basic = 'BASIC',
  Navigation = 'NAVIGATION'
}

/**
 * This input type can mutate both atomic and composite elements. Since there is no polymorphism in input types in graphql.
 * Client will have to send the Key to the element they are mutating and respective config.
 * Only one of the config fields will be specified. "elementTypeKey" should match the config provided.
 */
export type HelpLayoutElementInput = {
  announcementInput?: InputMaybe<HelpLayoutAnnouncementInput>;
  breadcrumbInput?: InputMaybe<HelpLayoutBreadcrumbElementInput>;
  connectInput?: InputMaybe<HelpLayoutConnectInput>;
  editorInput?: InputMaybe<HelpLayoutEditorInput>;
  elementTypeKey: HelpLayoutElementKey;
  forgeInput?: InputMaybe<HelpLayoutForgeInput>;
  headingConfigInput?: InputMaybe<HelpLayoutHeadingConfigInput>;
  heroElementInput?: InputMaybe<HelpLayoutHeroElementInput>;
  imageConfigInput?: InputMaybe<HelpLayoutImageConfigInput>;
  knowledgeCardsInput?: InputMaybe<HelpLayoutKnowledgeCardsElementInput>;
  linkCardInput?: InputMaybe<HelpLayoutLinkCardInput>;
  noContentElementInput?: InputMaybe<HelpLayoutNoContentElementInput>;
  paragraphConfigInput?: InputMaybe<HelpLayoutParagraphConfigInput>;
  portalsListInput?: InputMaybe<HelpLayoutPortalsListInput>;
  searchConfigInput?: InputMaybe<HelpLayoutSearchConfigInput>;
  suggestedRequestFormsListInput?: InputMaybe<HelpLayoutSuggestedRequestFormsListInput>;
  topicListInput?: InputMaybe<HelpLayoutTopicsListInput>;
};

/** Enum of all the supported element types, atomic and composite. */
export enum HelpLayoutElementKey {
  Announcement = 'ANNOUNCEMENT',
  Breadcrumb = 'BREADCRUMB',
  Connect = 'CONNECT',
  Editor = 'EDITOR',
  Forge = 'FORGE',
  Heading = 'HEADING',
  Hero = 'HERO',
  Image = 'IMAGE',
  KnowledgeCards = 'KNOWLEDGE_CARDS',
  LinkCard = 'LINK_CARD',
  NoContent = 'NO_CONTENT',
  Paragraph = 'PARAGRAPH',
  PortalsList = 'PORTALS_LIST',
  Search = 'SEARCH',
  SuggestedRequestFormsList = 'SUGGESTED_REQUEST_FORMS_LIST',
  TopicsList = 'TOPICS_LIST'
}

export type HelpLayoutFilter = {
  isEditMode?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Forge App Element */
export enum HelpLayoutForgeElementPages {
  Approvals = 'approvals',
  CreateRequest = 'create_request',
  HelpCenter = 'help_center',
  MyRequests = 'my_requests',
  Portal = 'portal',
  Profile = 'profile',
  ViewRequest = 'view_request'
}

export enum HelpLayoutForgeElementType {
  Footer = 'FOOTER',
  HeaderAndSubheader = 'HEADER_AND_SUBHEADER'
}

/** Forge App Input */
export type HelpLayoutForgeInput = {
  pages: HelpLayoutForgeElementPages;
  type: HelpLayoutForgeElementType;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** Heading Input */
export type HelpLayoutHeadingConfigInput = {
  headingType: HelpLayoutHeadingType;
  text: Scalars['String']['input'];
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export enum HelpLayoutHeadingType {
  H1 = 'h1',
  H2 = 'h2',
  H3 = 'h3',
  H4 = 'h4',
  H5 = 'h5',
  H6 = 'h6'
}

/** Hero Element Input */
export type HelpLayoutHeroElementInput = {
  hideSearchBar?: InputMaybe<Scalars['Boolean']['input']>;
  hideTitle?: InputMaybe<Scalars['Boolean']['input']>;
  useGlobalSettings?: InputMaybe<Scalars['Boolean']['input']>;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export enum HelpLayoutHorizontalAlignment {
  Center = 'CENTER',
  Left = 'LEFT',
  Right = 'RIGHT'
}

/** Image Input */
export type HelpLayoutImageConfigInput = {
  altText?: InputMaybe<Scalars['String']['input']>;
  fileId?: InputMaybe<Scalars['String']['input']>;
  fit?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['String']['input']>;
  scale?: InputMaybe<Scalars['Int']['input']>;
  size?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** KnowledgeCards Input */
export type HelpLayoutKnowledgeCardsElementInput = {
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** Link card input */
export type HelpLayoutLinkCardInput = {
  children: Array<HelpLayoutAtomicElementInput>;
  config: Scalars['String']['input'];
  type: HelpLayoutCompositeElementKey;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** No Content Element Input */
export type HelpLayoutNoContentElementInput = {
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** Paragraph Input */
export type HelpLayoutParagraphConfigInput = {
  adf: Scalars['String']['input'];
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** Announcement Input */
export type HelpLayoutPortalsListInput = {
  elementTitle?: InputMaybe<Scalars['String']['input']>;
  expandButtonTextColor?: InputMaybe<Scalars['String']['input']>;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export enum HelpLayoutProjectType {
  CustomerService = 'CUSTOMER_SERVICE',
  ServiceDesk = 'SERVICE_DESK'
}

/** Search Input */
export type HelpLayoutSearchConfigInput = {
  placeHolderText: Scalars['String']['input'];
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export type HelpLayoutSectionInput = {
  subsections: Array<HelpLayoutSubsectionInput>;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export type HelpLayoutSubsectionConfigInput = {
  span: Scalars['Int']['input'];
};

export type HelpLayoutSubsectionInput = {
  config: HelpLayoutSubsectionConfigInput;
  elements: Array<HelpLayoutElementInput>;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** Suggested Request Forms List Input */
export type HelpLayoutSuggestedRequestFormsListInput = {
  elementTitle?: InputMaybe<Scalars['String']['input']>;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** Topics List Input */
export type HelpLayoutTopicsListInput = {
  elementTitle?: InputMaybe<Scalars['String']['input']>;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

/** This enum represents the type of layout available. */
export enum HelpLayoutType {
  CustomPage = 'CUSTOM_PAGE',
  HomePage = 'HOME_PAGE'
}

export type HelpLayoutUpdateInput = {
  layoutId: Scalars['ID']['input'];
  sections: Array<HelpLayoutSectionInput>;
  visualConfig?: InputMaybe<HelpLayoutVisualConfigInput>;
};

export enum HelpLayoutVerticalAlignment {
  Bottom = 'BOTTOM',
  Middle = 'MIDDLE',
  Top = 'TOP'
}

/** This represents the visual config input required during mutation */
export type HelpLayoutVisualConfigInput = {
  alignment?: InputMaybe<HelpLayoutAlignmentSettingsInput>;
  backgroundColor?: InputMaybe<Scalars['String']['input']>;
  backgroundImage?: InputMaybe<HelpLayoutBackgroundImageInput>;
  backgroundType?: InputMaybe<HelpLayoutBackgroundType>;
  foregroundColor?: InputMaybe<Scalars['String']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  objectFit?: InputMaybe<HelpLayoutBackgroundImageObjectFit>;
  themeTemplateId?: InputMaybe<Scalars['String']['input']>;
  titleColor?: InputMaybe<Scalars['String']['input']>;
};

export enum HelpObjectStoreArticleContentType {
  Folder = 'FOLDER',
  Page = 'PAGE'
}

export enum HelpObjectStoreArticleSearchExpandType {
  Ancestors = 'ANCESTORS',
  ViewCount = 'VIEW_COUNT'
}

export enum HelpObjectStoreArticleSearchStrategy {
  ContentSearch = 'CONTENT_SEARCH',
  /**  Search Strategy used to obtain the search result  */
  Cql = 'CQL',
  Proxy = 'PROXY'
}

export enum HelpObjectStoreArticleSourceSystem {
  Confluence = 'CONFLUENCE',
  CrossSiteConfluence = 'CROSS_SITE_CONFLUENCE',
  External = 'EXTERNAL',
  GoogleDrive = 'GOOGLE_DRIVE',
  Sharepoint = 'SHAREPOINT'
}

export type HelpObjectStoreBulkCreateEntityMappingInput = {
  helpObjectStoreCreateEntityMappingInputItems: Array<HelpObjectStoreCreateEntityMappingInput>;
};

export type HelpObjectStoreCreateEntityMappingInput = {
  /**  Id of the container through which help object is associated. Could be projectId / Help Center Id etc.  */
  containerId?: InputMaybe<Scalars['String']['input']>;
  /**  Container Key which identifies the type of the container. ex- jira:project / external:forge  */
  containerKey?: InputMaybe<Scalars['String']['input']>;
  /**  Id of the Request Type / Article / Channel / External Link in jira  */
  entityId: Scalars['String']['input'];
  /**  Namespace of the entity in product. Like jira:request-form, notion:article, jira:external-resource  */
  entityKey?: InputMaybe<Scalars['String']['input']>;
  /**  Type of entity  */
  type: HelpObjectStoreJsmEntityType;
};

export enum HelpObjectStoreEntityTypes {
  ExtResources = 'EXT_RESOURCES',
  KbArticles = 'KB_ARTICLES',
  RequestTypes = 'REQUEST_TYPES'
}

/** Filter criteria for querying help object store entities */
export type HelpObjectStoreFilter = {
  /** Project ID */
  parentId?: InputMaybe<Scalars['String']['input']>;
  /** List of sub-entity types to filter by, REQUEST_TYPES, KB_ARTICLES, EXT_RESOURCES */
  subEntityTypes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type HelpObjectStoreFilters = {
  filters?: InputMaybe<Array<HelpObjectStoreFilter>>;
};

export enum HelpObjectStoreHelpObjectType {
  Article = 'ARTICLE',
  Channel = 'CHANNEL',
  Portal = 'PORTAL',
  RequestForm = 'REQUEST_FORM'
}

export enum HelpObjectStoreJsmEntityType {
  Article = 'ARTICLE',
  Channel = 'CHANNEL',
  Portal = 'PORTAL',
  RequestForm = 'REQUEST_FORM'
}

export enum HelpObjectStorePortalSearchStrategy {
  /**  Search Strategy used to obtain the search result  */
  Jira = 'JIRA',
  SearchPlatform = 'SEARCH_PLATFORM'
}

export type HelpObjectStoreProductEntityInput = {
  /** Cursor for pagination */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Cloud ID */
  cloudId: Scalars['ID']['input'];
  /** Number of entities to return */
  first?: InputMaybe<Scalars['Int']['input']>;
};

export enum HelpObjectStoreRequestTypeSearchStrategy {
  JiraIssueBasedSearch = 'JIRA_ISSUE_BASED_SEARCH',
  /**  Search Strategy used to obtain the search result  */
  JiraKeywordBased = 'JIRA_KEYWORD_BASED',
  SearchPlatformKeywordBased = 'SEARCH_PLATFORM_KEYWORD_BASED',
  SearchPlatformKeywordBasedEr = 'SEARCH_PLATFORM_KEYWORD_BASED_ER'
}

export enum HelpObjectStoreSearchAlgorithm {
  KeywordSearchOnIssues = 'KEYWORD_SEARCH_ON_ISSUES',
  KeywordSearchOnPortalsBm25 = 'KEYWORD_SEARCH_ON_PORTALS_BM25',
  KeywordSearchOnPortalsExactMatch = 'KEYWORD_SEARCH_ON_PORTALS_EXACT_MATCH',
  KeywordSearchOnRequestTypesBm25 = 'KEYWORD_SEARCH_ON_REQUEST_TYPES_BM25',
  KeywordSearchOnRequestTypesExactMatch = 'KEYWORD_SEARCH_ON_REQUEST_TYPES_EXACT_MATCH'
}

export enum HelpObjectStoreSearchBackend {
  Jira = 'JIRA',
  SearchPlatform = 'SEARCH_PLATFORM'
}

export enum HelpObjectStoreSearchEntityType {
  Article = 'ARTICLE',
  Channel = 'CHANNEL',
  Portal = 'PORTAL',
  RequestForm = 'REQUEST_FORM'
}

export type HelpObjectStoreSearchInput = {
  categoryIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  cloudId: Scalars['ID']['input'];
  entityType: HelpObjectStoreSearchEntityType;
  helpCenterAri?: InputMaybe<Scalars['String']['input']>;
  highlightArticles?: InputMaybe<Scalars['Boolean']['input']>;
  portalIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  queryTerm: Scalars['String']['input'];
  resultLimit?: InputMaybe<Scalars['Int']['input']>;
  skipSearchingRestrictedPages?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum HelpObjectStoreSearchableEntityType {
  Article = 'ARTICLE',
  RequestForm = 'REQUEST_FORM'
}

/** Configuration for sorting help object store query results */
export type HelpObjectStoreSortConfig = {
  /**
   * Additional configuration options for sorting, provided as JSON.
   * Key: manualSortOrder for MANUAL sort mode with value as array of entityIds in format "subEntityType|Id"
   */
  additionalConfig?: InputMaybe<Scalars['JSON']['input']>;
  /** he mode of sorting to apply (e.g., PARENT to sort by Projects, SUB_ENTITY_TYPE to sort by subEntityTypes, MANUAL for manual ordering ) */
  sortMode?: InputMaybe<Scalars['String']['input']>;
};

export type HelpObjectStoreSupportSiteArticleSearchInput = {
  /**  Article Ids to search for, if provided  */
  articleIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  The content type of the articles to search for, defaults to PAGE and FOLDER  */
  contentTypes?: InputMaybe<Array<HelpObjectStoreArticleContentType>>;
  /**  Available expand options for the search results  */
  expand?: InputMaybe<Array<HelpObjectStoreArticleSearchExpandType>>;
  /**  Ordering of the results  */
  orderBy?: InputMaybe<Scalars['String']['input']>;
  /**  The parent pageID to scope the search to, if provided  */
  parentId?: InputMaybe<Scalars['Long']['input']>;
  /**  The search term to query articles  */
  query?: InputMaybe<Scalars['String']['input']>;
  /**  Whether to include only top-level articles or all articles, defaults to false  */
  topLevelArticlesOnly?: InputMaybe<Scalars['Boolean']['input']>;
};

export type HomeUserSettingsInput = {
  shouldShowActivityFeed?: InputMaybe<Scalars['Boolean']['input']>;
  shouldShowSpaces?: InputMaybe<Scalars['Boolean']['input']>;
};

export type HomeWidgetInput = {
  id: Scalars['ID']['input'];
  state: HomeWidgetState;
};

export enum HomeWidgetState {
  Collapsed = 'COLLAPSED',
  Expanded = 'EXPANDED'
}

export type IndividualInlineTaskNotificationInput = {
  notificationAction?: InputMaybe<NotificationAction>;
  operation: Operation;
  recipientAccountId: Scalars['ID']['input'];
  recipientMentionLocalId?: InputMaybe<Scalars['ID']['input']>;
  taskId: Scalars['ID']['input'];
};

export type InfluentsNotificationActorFilter = {
  afterTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  beforeTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  categoryFilter?: InputMaybe<InfluentsNotificationCategory>;
  productFilter?: InputMaybe<Scalars['String']['input']>;
  readStateFilter?: InputMaybe<InfluentsNotificationReadState>;
};

export enum InfluentsNotificationActorType {
  Animated = 'animated',
  Url = 'url'
}

export enum InfluentsNotificationAppearance {
  Danger = 'DANGER',
  Default = 'DEFAULT',
  Link = 'LINK',
  Primary = 'PRIMARY',
  Subtle = 'SUBTLE',
  Warning = 'WARNING'
}

export enum InfluentsNotificationCategory {
  Direct = 'direct',
  Watching = 'watching'
}

export type InfluentsNotificationFilter = {
  afterTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  beforeTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  categoryFilter?: InputMaybe<InfluentsNotificationCategory>;
  eventTypeFilter?: InputMaybe<Scalars['String']['input']>;
  excludeActor?: InputMaybe<Array<Scalars['String']['input']>>;
  includeActor?: InputMaybe<Array<Scalars['String']['input']>>;
  productFilter?: InputMaybe<Scalars['String']['input']>;
  readStateFilter?: InputMaybe<InfluentsNotificationReadState>;
  workspaceId?: InputMaybe<Scalars['String']['input']>;
};

export enum InfluentsNotificationReadState {
  Read = 'read',
  Unread = 'unread'
}

export enum InitialPermissionOptions {
  CopyFromSpace = 'COPY_FROM_SPACE',
  Default = 'DEFAULT',
  Private = 'PRIVATE'
}

export type InlineTask = {
  status: TaskStatus;
  taskId: Scalars['ID']['input'];
};

export type InlineTasksByMetadata = {
  accountIds?: InputMaybe<InlineTasksQueryAccountIds>;
  after?: InputMaybe<Scalars['String']['input']>;
  /** The date range for an Inline Tasks' Completed Date. Start dates and end dates can be null-able to represent no specified start or end boundary. */
  completedDateRange?: InputMaybe<InlineTasksQueryDateRange>;
  /** The date range for an Inline Tasks' Created Date. Start dates and end dates can be null-able to represent no specified start or end boundary. */
  createdDateRange?: InputMaybe<InlineTasksQueryDateRange>;
  /** The date range for an Inline Tasks' Due Date. Start dates and end dates can be null-able to represent no specified start or end boundary. */
  dueDate?: InputMaybe<InlineTasksQueryDateRange>;
  first: Scalars['Int']['input'];
  /** A boolean value representing whether to return task on current page or on child pages as well */
  forCurrentPageOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** A boolean value representing whether or not a Task has a set due date. False indicates no due date set for a given task. */
  isNoDueDate?: InputMaybe<Scalars['Boolean']['input']>;
  pageIds?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  /** Supported sort columns for a Task query are: `due date`, `assignee`, and `page title`. Supported sort columns are `ASC` or `DESC`. */
  sortParameters?: InputMaybe<InlineTasksQuerySortParameters>;
  spaceIds?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  status?: InputMaybe<TaskStatus>;
};

export type InlineTasksInput = {
  cid: Scalars['ID']['input'];
  status: TaskStatus;
  taskId: Scalars['ID']['input'];
  trigger?: InputMaybe<PageUpdateTrigger>;
};

export type InlineTasksQueryAccountIds = {
  assigneeAccountIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  completedByAccountIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  creatorAccountIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** The date range for an Inline Tasks Query Date. Start dates and end dates can be null-able to represent no specified boundary. */
export type InlineTasksQueryDateRange = {
  endDate?: InputMaybe<Scalars['Long']['input']>;
  startDate?: InputMaybe<Scalars['Long']['input']>;
};

export enum InlineTasksQuerySortColumn {
  Assignee = 'ASSIGNEE',
  DueDate = 'DUE_DATE',
  PageTitle = 'PAGE_TITLE'
}

export enum InlineTasksQuerySortOrder {
  Ascending = 'ASCENDING',
  Descending = 'DESCENDING'
}

export type InlineTasksQuerySortParameters = {
  sortColumn: InlineTasksQuerySortColumn;
  sortOrder: InlineTasksQuerySortOrder;
};

/** Input for the mutation operations (snooze and remove). */
export type InsightsActionNextBestTaskInput = {
  /** Next best task id */
  taskId: Scalars['String']['input'];
};

/** Input for the onboarding mutation operations (purge / snooze / remove). */
export type InsightsGithubOnboardingActionInput = {
  /** Cloud id */
  cloudId: Scalars['ID']['input'];
};

export enum InsightsNextBestTaskAction {
  Remove = 'REMOVE',
  Snooze = 'SNOOZE'
}

/**
 * Defines whether we show the github onboarding UX
 * VISIBLE means JFE should render the onboarding UX
 * HIDDEN means user is already onboarded, do not show UX
 * SNOOZED means user snoozed the recommendation
 * REMOVED means user explicitly hid the recommendation
 */
export enum InsightsRecommendationVisibility {
  Hidden = 'HIDDEN',
  Removed = 'REMOVED',
  Snoozed = 'SNOOZED',
  Visible = 'VISIBLE'
}

export enum InspectPermissions {
  Comment = 'COMMENT',
  Edit = 'EDIT',
  View = 'VIEW'
}

/**
 * #################### RESULTS: SQLSchemaSize #####################
 * #################### INPUT InstallationContextWithInstallationIdInput #####################
 */
export type InstallationContextWithInstallationIdInput = {
  /** The context ARI */
  contextAri: Scalars['String']['input'];
  /** The environment type for this context-installation pair */
  envType: AppEnvironmentType;
  /** The installation ID */
  installationId: Scalars['String']['input'];
};

export type InstallationsListFilterByAppEnvironments = {
  types: Array<AppEnvironmentType>;
};

export type InstallationsListFilterByAppInstallations = {
  /** An array of unique ARI's representing app installation contexts */
  contexts?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** An array of unique ARI's representing apps */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type InstallationsListFilterByAppInstallationsWithCompulsoryContexts = {
  /** An array of unique ARI's representing app installation contexts */
  contexts: Array<Scalars['ID']['input']>;
  /** An array of unique environment identifiers */
  environmentIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** An array of unique installation identifiers */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type InstallationsListFilterByApps = {
  /** An array of unique ARI's representing apps */
  ids: Array<Scalars['ID']['input']>;
};

/** Enum that specifies the sub intents detected in a search query */
export enum IntentDetectionSubType {
  Command = 'COMMAND',
  Confluence = 'CONFLUENCE',
  Evaluate = 'EVALUATE',
  Jira = 'JIRA',
  JobTitle = 'JOB_TITLE',
  Llm = 'LLM',
  Question = 'QUESTION'
}

/** Enum that specifies the top level intent of a search query */
export enum IntentDetectionTopLevelIntent {
  JobTitle = 'JOB_TITLE',
  KeywordOrAcronym = 'KEYWORD_OR_ACRONYM',
  NaturalLanguageQuery = 'NATURAL_LANGUAGE_QUERY',
  Navigational = 'NAVIGATIONAL',
  None = 'NONE',
  Person = 'PERSON',
  Team = 'TEAM'
}

export type IntervalFilter = {
  /**
   * Query end time as an ISO-8601 timestamp e.g. "2022-11-24T15:00:00.000Z"
   * See https://date-fns.org/v2.29.3/docs/parseISO
   */
  end: Scalars['String']['input'];
  /**
   * Query start time as an ISO-8601 timestamp e.g. "2022-11-24T15:00:00.000Z"
   * See https://date-fns.org/v2.29.3/docs/parseISO
   */
  start: Scalars['String']['input'];
};

export type IntervalInput = {
  endTime: Scalars['DateTime']['input'];
  startTime: Scalars['DateTime']['input'];
};

export enum InvitationUrlsStatus {
  Active = 'ACTIVE',
  Deleted = 'DELETED',
  Expired = 'EXPIRED'
}

/** Input payload for the invoke aux mutation */
export type InvokeAuxEffectsInput = {
  /**
   * The list of applicable context Ids
   * Context Ids are used within the ecosystem platform to identify product
   * controlled areas into which apps can be installed. Host products should
   * determine how this list of contexts is constructed.
   *
   * *Important:* this should start with the most specific context as the
   * most specific extension will be the selected extension.
   */
  contextIds: Array<Scalars['ID']['input']>;
  /** An identifier for an alternative entry point function to invoke */
  entryPoint?: InputMaybe<Scalars['String']['input']>;
  /**
   * An identifier for the extension to invoke
   *
   * Note: Either `extensionDetails` or `extensionId` must be provided
   */
  extensionId?: InputMaybe<Scalars['ID']['input']>;
  /** The payload to invoke an AUX Effect */
  payload: AuxEffectsInvocationPayload;
};

/** Input payload for the invoke mutation */
export type InvokeExtensionInput = {
  /** Whether to invoke the function asynchronously if possible */
  async?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The list of applicable context Ids
   * Context Ids are used within the ecosystem platform to identify product
   * controlled areas into which apps can be installed. Host products should
   * determine how this list of contexts is constructed.
   *
   * *Important:* this should start with the most specific context as the
   * most specific extension will be the selected extension.
   */
  contextIds: Array<Scalars['ID']['input']>;
  /** An identifier for an alternative entry point function to invoke */
  entryPoint?: InputMaybe<Scalars['String']['input']>;
  /**
   * An identifier for the extension to invoke
   *
   * Note: Either `extensionDetails` or `extensionId` must be provided
   */
  extensionId?: InputMaybe<Scalars['ID']['input']>;
  /** The payload to send as part of the invocation */
  payload: Scalars['JSON']['input'];
  /**
   * An array of OAuth scopes that are required for a product event, if any
   *
   * Note: This field should ONLY be used by webhooks-processor
   */
  productEventScopes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type InvokePolarisObjectInput = {
  /** Snippet action */
  action: Scalars['JSON']['input'];
  /** Custom auth token that will be used in unfurl request and saved if request was successful */
  authToken?: InputMaybe<Scalars['String']['input']>;
  /** Snippet data */
  data: Scalars['JSON']['input'];
  /** Issue ARI */
  issue: Scalars['ID']['input'];
  /** OauthClientId of CaaS app */
  oauthClientId: Scalars['String']['input'];
  /** Project ARI */
  project: Scalars['ID']['input'];
  /** Resource url that will be used to unfurl data */
  resourceUrl: Scalars['String']['input'];
};

export enum IssueDevOpsCommitChangeType {
  Added = 'ADDED',
  Copied = 'COPIED',
  Deleted = 'DELETED',
  Modified = 'MODIFIED',
  /** Deprecated - use MODIFIED instead. */
  Modify = 'MODIFY',
  Moved = 'MOVED',
  Unknown = 'UNKNOWN'
}

export enum IssueDevOpsDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export enum IssueDevOpsDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export enum IssueDevOpsPullRequestStatus {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

/** Input type for ADF values on fields */
export type JiraAdfInput = {
  /** ADF based input for rich text field */
  jsonValue?: InputMaybe<Scalars['JSON']['input']>;
  /** A numeric id for the version */
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** The different action types that a user can perform on a global level */
export enum JiraActionType {
  /** Can current user create a Company Managed project */
  CreateCompanyManagedProject = 'CREATE_COMPANY_MANAGED_PROJECT',
  /** Can current user create any project */
  CreateProject = 'CREATE_PROJECT',
  /** Can current user create a Team Managed project */
  CreateTeamManagedProject = 'CREATE_TEAM_MANAGED_PROJECT',
  /** Can current user see the UI elements such as Create Project button/icon */
  ViewProjectCreationEntry = 'VIEW_PROJECT_CREATION_ENTRY'
}

export type JiraActivityFieldValueKeyValuePairInput = {
  key: Scalars['String']['input'];
  value: Array<InputMaybe<Scalars['String']['input']>>;
};

/**  Filters of All activity items */
export enum JiraActivityFilter {
  AnyComment = 'ANY_COMMENT',
  Approval = 'APPROVAL',
  HiddenCustomEntries = 'HIDDEN_CUSTOM_ENTRIES',
  History = 'HISTORY',
  HistoryIncludeIssueCreated = 'HISTORY_INCLUDE_ISSUE_CREATED',
  IccSessionDetails = 'ICC_SESSION_DETAILS',
  IccSessionLifecycle = 'ICC_SESSION_LIFECYCLE',
  Incident = 'INCIDENT',
  ResponderAlert = 'RESPONDER_ALERT',
  StakeholderUpdate = 'STAKEHOLDER_UPDATE',
  WorkLog = 'WORK_LOG'
}

export type JiraAddAttachmentInput = {
  fileId: Scalars['String']['input'];
  issue: Scalars['ID']['input'];
};

/** Input for adding an attachment to an issue. */
export type JiraAddAttachmentsInput = {
  /** List of file IDs representing the uploaded attachments. */
  fileIds: Array<Scalars['String']['input']>;
  /** The ID of the issue to which the attachment will be added. */
  issueId: Scalars['ID']['input'];
};

/** The input for adding a comment. */
export type JiraAddCommentInput = {
  /** To indicates whether the comment author can see the request or not. */
  authorCanSeeRequest?: InputMaybe<Scalars['Boolean']['input']>;
  /** Accept ADF (Atlassian Document Format) of comment content */
  content: JiraAdfInput;
  /** Timestamp at which the event corresponding to the comment occurred. */
  eventOccurredAt?: InputMaybe<Scalars['DateTime']['input']>;
  /**
   * Set True when sync is on, False when unsync.
   * This should be non-null if the comment was made from a third-party source, and null if it was made from Jira.
   */
  isThirdPartySyncOn?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Jira issue ARI. */
  issueId: Scalars['ID']['input'];
  /** Indicates whether the comment is hidden from Incident activity timeline or not. */
  jsdIncidentActivityViewHidden?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Either the group or the project role to associate with this comment, but not both.
   * Null means the permission level is unspecified, i.e. the comment is public.
   */
  permissionLevel?: InputMaybe<JiraPermissionLevelInput>;
  /** The link to the third-party message, and null if the comment is from Jira. */
  thirdPartyLink?: InputMaybe<Scalars['URL']['input']>;
  /**
   * ID of the parent comment. This should be non-null if a child comment is added on a thread or
   * null if a root comment is added.
   */
  threadParentId?: InputMaybe<Scalars['ID']['input']>;
  /** The JSM visibility property to associate with this comment. */
  visibility?: InputMaybe<JiraServiceManagementCommentVisibility>;
};

export type JiraAddFieldsToFieldSchemeInput = {
  fieldIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  schemeId: Scalars['ID']['input'];
};

export type JiraAddFieldsToProjectInput = {
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId: Scalars['ID']['input'];
  /** Unique identifiers of the fields to be added. */
  fieldIds: Array<Scalars['ID']['input']>;
  /** Unique identifier of the project. */
  projectId: Scalars['ID']['input'];
};

/** The input to associate issues with a fix version. */
export type JiraAddIssuesToFixVersionInput = {
  /** The IDs of the issues to be associated with the fix version. */
  issueIds: Array<Scalars['ID']['input']>;
  /** The ID of the version to be associated with the issues. */
  versionId: Scalars['ID']['input'];
};

export type JiraAddPostIncidentReviewLinkMutationInput = {
  /**
   * The ID of the incident the PIR link will be added to. Initially only Jira Service Management
   * incidents are supported, but eventually 3rd party / Data Depot incidents will follow.
   */
  incidentId: Scalars['ID']['input'];
  /**
   * The title of the post-incident review. May be null, in which case the frontend can use either
   * a generic title or a smart link for display purposes.
   */
  postIncidentReviewTitle?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the post-incident review (e.g. a Confluence page or Google Doc URL). */
  postIncidentReviewUrl: Scalars['URL']['input'];
  /**
   * Project whose permissions the PIR link will be tied to. Users with access to this project
   * will be able to view/edit/remove this PIR link.
   */
  projectId: Scalars['ID']['input'];
};

/** Input to create a new related work item and associated with a version. */
export type JiraAddRelatedWorkToVersionInput = {
  /** Category for the related work item. */
  category: Scalars['String']['input'];
  /** Client-generated ID for the related work item. */
  relatedWorkId: Scalars['ID']['input'];
  /** Related work title; can be null if a `url` was given. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Related work URL. Pass null to create a placeholder work item (a non-null `title` must be given in this case). */
  url?: InputMaybe<Scalars['URL']['input']>;
  /** The identifier of the Jira version. */
  versionId: Scalars['ID']['input'];
};

export type JiraAddTimelineIssueLinkInput = {
  /** Accepts ARI(s): issue */
  inwardItemId: Scalars['ID']['input'];
  /** Accepts ARI(s): issue */
  outwardItemId: Scalars['ID']['input'];
};

/** Operations that can be performed on fields like attachments and issuelinks etc. */
export enum JiraAddValueFieldOperations {
  /** Overrides single value field. */
  Add = 'ADD'
}

export type JiraAdjustmentEstimate = {
  adjustEstimateType: JiraWorklogAdjustmentEstimateOperation;
  /** this field will be ignored for auto and leave adjustEstimate. */
  adjustTimeInMinutes?: InputMaybe<Scalars['Long']['input']>;
};

/** Input type for affected services field */
export type JiraAffectedServicesFieldInput = {
  /** List of affected services */
  affectedServices: Array<JiraAffectedServicesInput>;
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

/** Input type for defining the operation on Affected Services(Service Entity) field of a Jira issue. */
export type JiraAffectedServicesFieldOperationInput = {
  /** Accept ARI(s): service */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The operations to perform on Affected Services field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
};

/** Input type representing a single affected service */
export type JiraAffectedServicesInput = {
  /** An identifier for the affected service */
  serviceId: Scalars['ID']['input'];
};

/**
 * Input for identifying an agent. Must provide exactly one of the available identifiers.
 * Uses @oneOf directive to enforce mutual exclusivity.
 */
export type JiraAgentAssignableInput = {
  /** ARI of the agent account in the form of ARI: ari:cloud:identity::user/{userId}. */
  agentAccountId?: InputMaybe<Scalars['ID']['input']>;
  /** The agent's unique identifier (ARI format). */
  agentId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraAiAgentSessionEnrichmentInput = {
  /** Agent identity account ID */
  agentIdentityAccountId: Scalars['String']['input'];
  /** Indentifer for the cloud instance, used for routing */
  cloudId: Scalars['ID']['input'];
  /** Identifier for the conversation within convo-ai */
  conversationId: Scalars['String']['input'];
  /** ERS sort key for the agent session */
  sortKey?: InputMaybe<Scalars['String']['input']>;
};

/** An input representing an issue */
export type JiraAiEnablementIssueInput = {
  /** The ID of the issue */
  issueId?: InputMaybe<Scalars['ID']['input']>;
  /** The key of the issue */
  issueKey?: InputMaybe<Scalars['String']['input']>;
};

export enum JiraAlignAggProjectType {
  Capability = 'CAPABILITY',
  Epic = 'EPIC',
  Theme = 'THEME'
}

/**  Allowed format configuration type for a Jira field. */
export enum JiraAllowedFieldFormatConfig {
  NumberFieldFormatConfig = 'NUMBER_FIELD_FORMAT_CONFIG'
}

/** Visibility settings for an announcement banner. */
export enum JiraAnnouncementBannerVisibility {
  /** The announcement banner is shown to logged in users only. */
  Private = 'PRIVATE',
  /** The announcement banner is shown to anyone on the internet. */
  Public = 'PUBLIC'
}

/** The approval decision input */
export type JiraAnswerApprovalDecisionInput = {
  approvalId: Scalars['Int']['input'];
  decision: JiraApprovalDecision;
};

/** List of values identifying the different app types */
export enum JiraAppType {
  Connect = 'CONNECT',
  Forge = 'FORGE'
}

/** Representation of each Jira application/sub-product. */
export enum JiraApplicationKey {
  /** Jira Work Management application key */
  JiraCore = 'JIRA_CORE',
  /** Jira Product Discovery application key */
  JiraProductDiscovery = 'JIRA_PRODUCT_DISCOVERY',
  /** Jira Service Management application key */
  JiraServiceDesk = 'JIRA_SERVICE_DESK',
  /** Jira Software application key */
  JiraSoftware = 'JIRA_SOFTWARE'
}

/** Source where the applink is configured e.g. Cloud or DC */
export enum JiraApplicationLinkTargetType {
  Cloud = 'CLOUD',
  Dc = 'DC'
}

/** The input for applying an action to a suggestion group */
export type JiraApplySuggestionGroupInput = {
  /** The action to apply to all suggestions in the group */
  action: JiraSuggestionActionType;
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The IDs of the suggestions in the group to apply the action to */
  suggestionIds: Array<Scalars['ID']['input']>;
};

/** The input for applying an action to a single suggestion */
export type JiraApplySuggestionInput = {
  /** The action to apply to the suggestion */
  action: JiraSuggestionActionType;
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The ID of the suggestion to apply the action to */
  suggestionId: Scalars['ID']['input'];
};

export enum JiraApprovalDecision {
  Approved = 'APPROVED',
  Rejected = 'REJECTED'
}

/** The input type to approve access request of connected workspace(organization in Jira term) */
export type JiraApproveJiraBitbucketWorkspaceAccessRequestInput = {
  /** The approval location for the analytics and Jira's organization approval event. If not given, it will default to UNKNOWN */
  approvalLocation?: InputMaybe<JiraOrganizationApprovalLocation>;
  /** The workspace id(organization in Jira term) to approve the access request */
  workspaceId: Scalars['ID']['input'];
};

export type JiraArchiveJourneyConfigurationInput = {
  /** The entity tag of the journey configuration */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
  /** The version number of the entity. */
  version: Scalars['Long']['input'];
};

/** Input type to filter archived issues */
export type JiraArchivedIssuesFilterInput = {
  /** Filter By archival date range. */
  byArchivalDateRange?: InputMaybe<JiraArchivedOnDateRange>;
  /** Filter by the user who archived the issue. */
  byArchivedBy?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filter by the assignee of the issue. */
  byAssignee?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filter by the create date of the issue. */
  byCreatedOn?: InputMaybe<Scalars['Date']['input']>;
  /** Filter by the issue type. */
  byIssueType?: InputMaybe<Array<JiraIssueTypeInput>>;
  /** Filter by the name of the project. */
  byProject?: InputMaybe<Scalars['String']['input']>;
  /** Filter by the reporter of the issue. */
  byReporter?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Input type for archival date range */
export type JiraArchivedOnDateRange = {
  /** The date from which archived issues are to be fetched. */
  from?: InputMaybe<Scalars['Date']['input']>;
  /** The date till which archived issues are to be fetched. */
  to?: InputMaybe<Scalars['Date']['input']>;
};

/** Input type for asset field */
export type JiraAssetFieldInput = {
  /** List of jira assets on which the operation will be performed */
  assets: Array<JiraAssetInput>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

/** Input type for asset value */
export type JiraAssetInput = {
  /** String representing application key */
  appKey: Scalars['String']['input'];
  /** An identifier for the origin */
  originId: Scalars['String']['input'];
  /** Serialized value of origin */
  serializedOrigin: Scalars['String']['input'];
  /** Value of the asset field */
  value: Scalars['String']['input'];
};

/**
 * DEPRECATED: Superseded by issue linking
 *
 * Input to assign/unassign a related work item to a user.
 */
export type JiraAssignRelatedWorkInput = {
  /**
   * The account ID of the user the related work item is being assigned to. Pass `null` to unassign the
   * item from its current assignee.
   */
  assigneeId?: InputMaybe<Scalars['ID']['input']>;
  /** The related work item's ID (not applicable for the NATIVE_RELEASE_NOTES type - pass `null` in that case). */
  relatedWorkId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The type of related work item being assigned. If the type is not NATIVE_RELEASE_NOTES, the work
   * item's ID must also be passed in via `relatedWorkId`.
   */
  relatedWorkType: JiraVersionRelatedWorkType;
  /** The ARI of the version the related work lives in. */
  versionId: Scalars['ID']['input'];
};

/**
 * Include either `fieldSchemeId` or `fieldConfigSchemeId`, but not both.
 * - if `fieldSchemeId` is defined, the association will be made to a JiraFieldScheme
 * - if `fieldConfigSchemeId` is present, the association will be made to a legacy JiraFieldConfigScheme
 */
export type JiraAssociateProjectToFieldSchemeInput = {
  fieldConfigSchemeId?: InputMaybe<Scalars['ID']['input']>;
  fieldSchemeId?: InputMaybe<Scalars['ID']['input']>;
  projectIds: Array<Scalars['ID']['input']>;
};

export type JiraAssociatedProjectSearchInput = {
  name: Scalars['String']['input'];
};

/** Features that Atlassian Intelligence can be enabled for. */
export enum JiraAtlassianIntelligenceFeatureEnum {
  AiMate = 'AI_MATE',
  NaturalLanguageToJql = 'NATURAL_LANGUAGE_TO_JQL'
}

/** Input used to specify which product or feature to check for Atlassian Intelligence. */
export type JiraAtlassianIntelligenceProductFeatureInput = {
  /** The feature for Atlassian Intelligence. */
  feature?: InputMaybe<JiraAtlassianIntelligenceFeatureEnum>;
  /** The product for Atlassian Intelligence. */
  product?: InputMaybe<JiraProductEnum>;
};

/** Input type for Atlassian team field */
export type JiraAtlassianTeamFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Represents an Atlassian team field's data */
  team: JiraAtlassianTeamInput;
};

/** Input type for Atlassian team data */
export type JiraAtlassianTeamInput = {
  /** An identifier for the team */
  teamId: Scalars['String']['input'];
};

/** Input type for defining the operation on the Attachment field of a Jira issue. */
export type JiraAttachmentFieldOperationInput = {
  /** Only ADD operation is supported for attachments field in purview of Issue Transition Modernisation flow. */
  operation: JiraAddValueFieldOperations;
  /** Accepts : Temporary Attachment UUIDs */
  temporaryAttachmentIds: Array<Scalars['String']['input']>;
};

export type JiraAttachmentFilterInput = {
  /** Filters attachments based on the author's AAID. */
  authorIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Defines the date range for the attachment's upload date to be included in the response. */
  dateRange?: InputMaybe<JiraDateTimeRange>;
  /** Filters attachments based on matching filename (case-insensitive). */
  fileName?: InputMaybe<Scalars['String']['input']>;
  /**
   * List of mime types to be used as filters. Attachments matching these types will be included in the response.
   * eg. ["JPEG", "PNG", "GIF"]
   */
  mimeTypes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum JiraAttachmentOrderField {
  Created = 'CREATED',
  Filename = 'FILENAME',
  Filesize = 'FILESIZE',
  Mimetype = 'MIMETYPE'
}

/** Represents a fixed set of attachments' parents */
export enum JiraAttachmentParentName {
  Comment = 'COMMENT',
  Customfield = 'CUSTOMFIELD',
  Description = 'DESCRIPTION',
  Environment = 'ENVIRONMENT',
  Form = 'FORM',
  Issue = 'ISSUE',
  Worklog = 'WORKLOG'
}

export type JiraAttachmentSearchViewContextInput = {
  /** A list of user AAIDs to limit searched attachments. */
  authorIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only returns attachments created after this date (exclusive) */
  createdAfter?: InputMaybe<Scalars['DateTime']['input']>;
  /** Only returns attachments created before this date (exclusive) */
  createdBefore?: InputMaybe<Scalars['DateTime']['input']>;
  /** Filters attachments by file name (case-insensitive) */
  fileName?: InputMaybe<Scalars['String']['input']>;
  /**
   * A list of mime types to filter attachments
   * e.g. text/plain, image/jpeg
   */
  mimeTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Project keys to search for attachments in */
  projectKeys: Array<Scalars['String']['input']>;
};

/** The field for sorting attachments. */
export enum JiraAttachmentSortField {
  /** sorts by the created date */
  Created = 'CREATED'
}

export type JiraAttachmentSortInput = {
  /** The field to sort on. */
  field: JiraAttachmentSortField;
  /** The sort direction. */
  order?: SortDirection;
};

export type JiraAttachmentWithFiltersInput = {
  /** custom filters to apply to the attachments. */
  filters?: InputMaybe<JiraIssueAttachmentFilterInput>;
  /** maximum number of results to return. */
  maxResults?: InputMaybe<Scalars['Long']['input']>;
  /** The direction in which the results are ordered. */
  orderDirection?: InputMaybe<SortDirection>;
  /** The field by which the results are ordered. */
  orderField?: InputMaybe<JiraAttachmentOrderField>;
  /** The pagination offset for the results. */
  startAt?: InputMaybe<Scalars['Long']['input']>;
};

export type JiraAttachmentsOrderField = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export enum JiraAttachmentsPermissions {
  /** Allows the user to create atachments on the correspondig Issue. */
  CreateAttachments = 'CREATE_ATTACHMENTS',
  /** Allows the user to delete attachments on the corresponding Issue. */
  DeleteOwnAttachments = 'DELETE_OWN_ATTACHMENTS'
}

/** Renamed to JiraAutodevCodeChangeEnumType to be compatible with jira/gira prefix validation */
export enum JiraAutodevCodeChangeEnumType {
  Add = 'ADD',
  Delete = 'DELETE',
  Edit = 'EDIT',
  Other = 'OTHER'
}

/** JiraAutodevCreatePullRequestOptionEnumType represents the option of whether or not to create a pull request for an autodev job */
export enum JiraAutodevCreatePullRequestOptionEnumType {
  Always = 'ALWAYS',
  Draft = 'DRAFT',
  DraftOnBuildPass = 'DRAFT_ON_BUILD_PASS',
  Never = 'NEVER',
  OnBuildPass = 'ON_BUILD_PASS'
}

/** Autodev job state */
export enum JiraAutodevPhase {
  /** transitions to CODE_REVIEW upon success */
  CodeGenerating = 'CODE_GENERATING',
  /** When code is generated successfully --> CODE_RE_GENERATING */
  CodeReview = 'CODE_REVIEW',
  /** When user press regenerate code button --> CODE_REVIEW */
  CodeReGenerating = 'CODE_RE_GENERATING',
  /** When job is created --> PLAN_REVIEW */
  PlanGenerating = 'PLAN_GENERATING',
  /** When plan is generated successfully --> PLAN_RE_GENERATING || CODE_GENERATING */
  PlanReview = 'PLAN_REVIEW',
  /** When user press button to regenerate plan --> PLAN_REVIEW */
  PlanReGenerating = 'PLAN_RE_GENERATING'
}

/** Autodev job state */
export enum JiraAutodevState {
  /** When an autodev job is cancelled by the user. */
  Cancelled = 'CANCELLED',
  /** This state is entered when the code is being generated */
  CodeGenerating = 'CODE_GENERATING',
  /** This state is entered when the code generation fails */
  CodeGenerationFail = 'CODE_GENERATION_FAIL',
  /** This state is entered when user confirm to say that plan looks okay, now generate code. */
  CodeGenerationReady = 'CODE_GENERATION_READY',
  /** This state is entered when the code generation is successful */
  CodeGenerationSuccess = 'CODE_GENERATION_SUCCESS',
  /** When an autodev job is first created, it will enter this state. */
  Created = 'CREATED',
  /** This state will be automatically enter when backend service started work on the job id. */
  PlanGenerating = 'PLAN_GENERATING',
  /** This state will be be entered when the plan generation fails */
  PlanGenerationFail = 'PLAN_GENERATION_FAIL',
  /** This state will be be entered when the plan generation succeeds */
  PlanGenerationSuccess = 'PLAN_GENERATION_SUCCESS',
  /** This state should be automatically enter when backend service pick up the CODE_GENERATION_SUCCESS state. */
  PullrequestCreating = 'PULLREQUEST_CREATING',
  /** This state should be entered when pull request fails to be created */
  PullrequestCreationFail = 'PULLREQUEST_CREATION_FAIL',
  /** This state should be entered when pull request creation has succeeded */
  PullrequestCreationSuccess = 'PULLREQUEST_CREATION_SUCCESS',
  /** Fallback state for any unexpected error */
  Unknown = 'UNKNOWN'
}

/** Autodev job status */
export enum JiraAutodevStatus {
  /** The autodev job was cancelled */
  Cancelled = 'CANCELLED',
  /** The autodev job completed successfully */
  Completed = 'COMPLETED',
  /** The autodev job stopped running because of an error */
  Failed = 'FAILED',
  /** The autodev job is currently running */
  InProgress = 'IN_PROGRESS',
  /** The autodev job hasn't started yet */
  Pending = 'PENDING'
}

export type JiraAvailableProjectSearchInput = {
  name: Scalars['String']['input'];
};

/** The supported background types */
export enum JiraBackgroundType {
  Attachment = 'ATTACHMENT',
  Color = 'COLOR',
  Custom = 'CUSTOM',
  Gradient = 'GRADIENT',
  Unsplash = 'UNSPLASH'
}

/** Card density options for backlog view */
export enum JiraBacklogCardDensity {
  Compact = 'COMPACT',
  Default = 'DEFAULT'
}

export enum JiraBacklogStrategy {
  IssueList = 'ISSUE_LIST',
  KanbanBacklog = 'KANBAN_BACKLOG',
  None = 'NONE',
  Sprint = 'SPRINT'
}

/** The card field input in backlog views. */
export type JiraBacklogViewCardFieldInput = {
  enabled: Scalars['Boolean']['input'];
  id: Scalars['ID']['input'];
};

/** Input to retrieve a Jira backlog view. */
export type JiraBacklogViewInput = {
  /**
   * Input to retrieve a Jira backlog view using its view ARI which should
   * be a boardscoped view ARI
   */
  jiraBacklogViewQueryInput: JiraBacklogViewQueryInput;
};

/** Input to retrieve a Jira backlog view */
export type JiraBacklogViewQueryInput = {
  /** ARI of the backlog view to query. */
  viewId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * Defines how issues are organized in the backlog
 * Renamed because jira-backlogs.nadel has taken the name JiraBacklogStrategy
 */
export enum JiraBacklogViewStrategy {
  /** Issues grouped by lists */
  IssueList = 'ISSUE_LIST',
  /** Issues grouped for Kanban backlog view, no sprints */
  KanbanBacklog = 'KANBAN_BACKLOG',
  /** Backlog is not enabled */
  None = 'NONE',
  /** Issues grouped by sprints, with a non-sprint backlog at the end. */
  Sprint = 'SPRINT'
}

export enum JiraBatchWindowPreference {
  DefaultBatching = 'DEFAULT_BATCHING',
  FifteenMinutes = 'FIFTEEN_MINUTES',
  FiveMinutes = 'FIVE_MINUTES',
  NoBatching = 'NO_BATCHING',
  OncePerDay = 'ONCE_PER_DAY',
  OneDay = 'ONE_DAY',
  OneHour = 'ONE_HOUR',
  TenMinutes = 'TEN_MINUTES',
  ThirtyMinutes = 'THIRTY_MINUTES'
}

export enum JiraBitbucketWorkspaceApprovalState {
  Approved = 'APPROVED',
  PendingApproval = 'PENDING_APPROVAL'
}

export type JiraBoardLocation = {
  /** Id of the project on which the board located in. Applicable for PROJECT location type only. Null otherwise. */
  locationId?: InputMaybe<Scalars['String']['input']>;
  /** Location type of the board */
  locationType: JiraBoardLocationType;
};

/** Types of containers that boards can be located in */
export enum JiraBoardLocationType {
  /** Boards located in a project */
  Project = 'PROJECT',
  /** Boards located under a user */
  User = 'USER'
}

/** Strategies for grouping issues into swimlanes on a board */
export enum JiraBoardSwimlaneStrategy {
  AssigneeUnassignedFirst = 'ASSIGNEE_UNASSIGNED_FIRST',
  AssigneeUnassignedLast = 'ASSIGNEE_UNASSIGNED_LAST',
  Custom = 'CUSTOM',
  Epic = 'EPIC',
  IssueChildren = 'ISSUE_CHILDREN',
  IssueParent = 'ISSUE_PARENT',
  None = 'NONE',
  ParentChild = 'PARENT_CHILD',
  Project = 'PROJECT',
  RequestType = 'REQUEST_TYPE',
  TownsquareProject = 'TOWNSQUARE_PROJECT'
}

/** Types of Jira boards */
export enum JiraBoardType {
  /** The board type without sprints */
  Kanban = 'KANBAN',
  /** The board type with sprints */
  Scrum = 'SCRUM'
}

/**
 * Input to retrieve a Jira board view.
 * Note: Only used by deprecated field jira_boardView.
 */
export type JiraBoardViewInput = {
  /** Input for settings applied to the board view. This is deprecated but not declared to allow the graphql schema to validate */
  settings?: InputMaybe<JiraBoardViewSettings>;
};

/**
 * Input to query a Jira board view by its project key and item id.
 * Note: Only used by deprecated field jira_boardView.
 */
export type JiraBoardViewProjectKeyAndItemIdQuery = {
  /** The identifier which indicates the cloud instance this data is to be fetched for, required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /**
   * Item ID of the view in the project. This is the identifier following the `/board/` view type path prefix in the url.
   * The value should not include the path prefix so it must be an empty string if the view path is simply `/board`.
   */
  itemId: Scalars['String']['input'];
  /** Key of the project which the board view is associated with. */
  projectKey: Scalars['String']['input'];
};

/**
 * Input to retrieve a Jira board view. As per the oneOf directive, the board can either be fetched by its ARI,
 * or by its project key and item id.
 * Note: Only used by deprecated field jira_boardView.
 */
export type JiraBoardViewQueryInput = {
  /** Input to retrieve a Jira board view by its project key and item id. */
  projectKeyAndItemIdQuery?: InputMaybe<JiraBoardViewProjectKeyAndItemIdQuery>;
  /** ARI of the board view to query. */
  viewId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input for settings applied to the board view. */
export type JiraBoardViewSettings = {
  /** JQL of the filter applied to the board view. Null when no filter is explicitly applied. */
  filterJql?: InputMaybe<Scalars['String']['input']>;
  /** The fieldId of the field to group the board view by. Null when no grouping is explicitly applied. */
  groupBy?: InputMaybe<Scalars['String']['input']>;
  /** Temporary setting to indicate if the calling client supports grouping issues in swimlanes. */
  swimlanesSupported?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Input describing one status column mapping. */
export type JiraBoardViewStatusColumnMapping = {
  /**
   * ID of an existing column to keep or update, as returned by `JiraBoardViewColumn.id`.
   * Leave unset to create a new column, and an ID will be assigned.
   */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Name of the column. */
  name: Scalars['String']['input'];
  /**
   * Ordered list of IDs of the statuses mapped to the column.
   * May also include the JiraSetBoardViewStatusColumnMappingCreateStatusInput.reference of newly created statuses.
   */
  statusIds: Array<Scalars['ID']['input']>;
};

/** The input type for scheduling the execution of project cleanup recommendations */
export type JiraBulkCleanupProjectsInput = {
  /** Recommendation action for the stale project. */
  projectCleanupAction?: InputMaybe<JiraProjectCleanupRecommendationAction>;
  /** List of recommendation identifiers to be archived */
  recommendationIds?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type JiraBulkCreateIssueLinksInput = {
  /** The direction of the issue link. Default is OUTWARD. */
  direction?: InputMaybe<JiraIssueLinkDirection>;
  /** The ID of the type of issue link being created. */
  issueLinkTypeId: Scalars['ID']['input'];
  /** The ID of the source issue. */
  sourceIssueId: Scalars['ID']['input'];
  /** The IDs of the target issues. */
  targetIssueIds: Array<Scalars['ID']['input']>;
};

/** Input type for bulk delete */
export type JiraBulkDeleteInput = {
  /** Refers to issue IDs selected by user for bulk delete */
  selectedIssueIds: Array<Scalars['ID']['input']>;
};

/** Specifies inputs for search on fields and a boolean to override them */
export type JiraBulkEditFieldsSearch = {
  /** Specifies the search text for fields */
  searchByText?: InputMaybe<Scalars['String']['input']>;
};

/** Specified bulk edit operation input */
export type JiraBulkEditInput = {
  /** Info of the fields edited by user. It will contain the values of edited field */
  editedFieldsInput: JiraIssueFieldsInput;
  /** Refers to the fields selected by user to bulk edit */
  selectedActions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Refers to issue IDs selected by user for bulk edit */
  selectedIssueIds: Array<Scalars['ID']['input']>;
};

/**
 * Contains all options available for fields with multi select options available
 * This field is required only for 4 system field: Fix Versions, Affects Versions, Label and Component
 */
export enum JiraBulkEditMultiSelectFieldOptions {
  /** Represents the Bulk Edit multi select field option for which the field values provided in Bulk Edit will be added to the already set field values */
  Add = 'ADD',
  /** Represents the Bulk Edit multi select field option for which the field values provided in Bulk Edit will be removed from the already set field values (if they exist) */
  Remove = 'REMOVE',
  /** Represents Bulk Edit multi select field option for which the already set field values will be all removed */
  RemoveAll = 'REMOVE_ALL',
  /** Represents the Bulk Edit multi select field option for which the field values provided in Bulk Edit will replace the already set field values */
  Replace = 'REPLACE'
}

export type JiraBulkLabelColorUpdateInput = {
  /** Color update for the labels */
  labelColorUpdate: Array<JiraBulkLabelColorUpdateInputItem>;
  /** ARI for the project */
  projectId: Scalars['ID']['input'];
};

export type JiraBulkLabelColorUpdateInputItem = {
  /** The color of the label */
  color?: InputMaybe<JiraOptionColorInput>;
  /** fieldId for the label field. */
  fieldId: Scalars['ID']['input'];
  /** Label name for the color update */
  label: Scalars['String']['input'];
};

/** Enum representing form fields that can have validation errors */
export enum JiraBulkMergeValidationFormField {
  Attachments = 'ATTACHMENTS',
  Comments = 'COMMENTS',
  Fields = 'FIELDS',
  Links = 'LINKS',
  Subtasks = 'SUBTASKS'
}

/** input for the jira_bulkMergeValidation query */
export type JiraBulkMergeValidationInput = {
  /** The ARI of the issues to validate for bulk merge */
  issues: Array<Scalars['ID']['input']>;
};

/** Specified bulk operation input */
export type JiraBulkOperationInput = {
  /** Specifies bulk delete payload. Payload which comes as an input for bulk delete */
  bulkDeleteInput?: InputMaybe<JiraBulkDeleteInput>;
  /** Specifies bulk edit input. Payload which comes as an input for bulk edit */
  bulkEditInput?: InputMaybe<JiraBulkEditInput>;
  /** Specifies bulk transitions payload. Payload which comes as an input for bulk transition */
  bulkTransitionsInput?: InputMaybe<Array<JiraBulkTransitionsInput>>;
  /** Specifies bulk watch or unwatch payload. Payload which comes as an input for bulk watch or unwatch operations */
  bulkWatchOrUnwatchInput?: InputMaybe<JiraBulkWatchOrUnwatchInput>;
  /**
   * Refers to whether to send bulk change notification or not.
   * This flag is not applicable to bulk watch or unwatch operations.
   */
  sendBulkNotification?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Specified the type of bulk operation */
export enum JiraBulkOperationType {
  /** Specified bulk delete operation type */
  BulkDelete = 'BULK_DELETE',
  /** Specified bulk edit operation type */
  BulkEdit = 'BULK_EDIT',
  /** Specified bulk transition operation type */
  BulkTransition = 'BULK_TRANSITION',
  /** Specified bulk unwatch operation type */
  BulkUnwatch = 'BULK_UNWATCH',
  /** Specified bulk watch operation type */
  BulkWatch = 'BULK_WATCH'
}

/** Input to bulk set the collapsed/expanded state of all columns within the board view. */
export type JiraBulkSetBoardViewColumnStateInput = {
  /** Whether all the columns on the board view are to be collapsed or expanded. */
  collapsed: Scalars['Boolean']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input type for bulk transition */
export type JiraBulkTransitionsInput = {
  /** Refers to issue IDs selected by user for bulk transition */
  selectedIssueIds: Array<Scalars['ID']['input']>;
  /** Refers to a unique transition */
  transitionId: Scalars['String']['input'];
  /** Refers to any fields which need to be edited due to the transition */
  transitionScreenInput?: InputMaybe<JiraTransitionScreenInput>;
};

/** Input type for bulk watch or unwatch */
export type JiraBulkWatchOrUnwatchInput = {
  /** Refers to issue IDs selected by user for bulk watch or unwatch */
  selectedIssueIds: Array<Scalars['ID']['input']>;
};

/** Input for configuring metric aggregation. */
export type JiraCfoAggregationInput = {
  /** Type of aggregation to apply. */
  type: JiraCfoAggregationType;
  /** Value for percentile aggregation (required when type is PERCENTILE). */
  value?: InputMaybe<Scalars['Float']['input']>;
};

/** Aggregation types available for JiraCFO metrics. */
export enum JiraCfoAggregationType {
  /** Average aggregation. */
  Avg = 'AVG',
  /** Count aggregation. */
  Count = 'COUNT',
  /** Count distinct aggregation. */
  CountDistinct = 'COUNT_DISTINCT',
  /** Maximum value aggregation. */
  Max = 'MAX',
  /** Minimum value aggregation. */
  Min = 'MIN',
  /** Percentile aggregation. */
  Percentile = 'PERCENTILE',
  /** Sum aggregation. */
  Sum = 'SUM'
}

/** Board-specific filter input for JiraCFO analytics. */
export type JiraCfoBoardFilterInput = {
  /** Account IDs of board creators to filter by. */
  creatorAccountId?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Board search parameter to filter on(supports board name or creator name). */
  keyword?: InputMaybe<Scalars['String']['input']>;
  /** Performance status categories to filter by. */
  performanceStatus?: InputMaybe<Array<InputMaybe<JiraCfoBoardPerformanceStatus>>>;
  /** Sort options for board performance data. */
  sortInput?: InputMaybe<Array<InputMaybe<JiraCfoBoardPerformanceSortInput>>>;
};

export type JiraCfoBoardPerformanceSortInput = {
  key?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<JiraCfoBoardPerformanceSortOrder>;
};

export enum JiraCfoBoardPerformanceSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

/** Performance status categories for boards. */
export enum JiraCfoBoardPerformanceStatus {
  /** Board is performing fast. */
  Fast = 'FAST',
  /** Board is performing at moderate speed. */
  Moderate = 'MODERATE',
  /** Board is performing slowly. */
  Slow = 'SLOW'
}

/** Dimension-specific filter input for JiraCFO analytics. */
export type JiraCfoDimensionFilterInput = {
  /** Name of the dimension to filter on. */
  name: Scalars['String']['input'];
  /** Filter operator to apply. */
  operator: JiraCfoFilterOperator;
  /** Values to filter by. */
  values: Array<Scalars['String']['input']>;
};

/** Input for specifying a dimension in JiraCFO analytics queries. */
export type JiraCfoDimensionInput = {
  /** Optional alias for the dimension in the response. */
  alias?: InputMaybe<Scalars['String']['input']>;
  /** Name of the dimension to include. */
  name: Scalars['String']['input'];
};

/** Input for filtering JiraCFO analytics data. */
export type JiraCfoFilterInput = {
  boardFilter?: InputMaybe<JiraCfoBoardFilterInput>;
  dimensionFilter?: InputMaybe<JiraCfoDimensionFilterInput>;
};

/** Filter operators for JiraCFO analytics filtering. */
export enum JiraCfoFilterOperator {
  /** Exact match filter. */
  Equals = 'EQUALS',
  /** Match any value in the provided list. */
  In = 'IN'
}

/** Input for specifying a metric in JiraCFO analytics queries. */
export type JiraCfoMetricInput = {
  /** Aggregation configuration for the metric. */
  aggregation?: InputMaybe<JiraCfoAggregationInput>;
  /** Optional alias for the metric in the response. */
  alias?: InputMaybe<Scalars['String']['input']>;
  /** Name of the metric to include, pass * for counting rows with COUNT aggregation. */
  name: Scalars['String']['input'];
  /** Whether to include this metric in summary calculations. */
  summarize?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Categories of recommendation groups. */
export enum JiraCfoRecommendationGroup {
  /** Limits and cleanup related recommendations */
  LimitsAndCleanup = 'LIMITS_AND_CLEANUP',
  /** None category */
  None = 'NONE',
  /** User setup related recommendations */
  UserSetup = 'USER_SETUP'
}

/** Status levels for recommendations. */
export enum JiraCfoRecommendationStatus {
  /** Critical recommendation status */
  Critical = 'CRITICAL',
  /** Info recommendation status */
  Info = 'INFO',
  /** Warning recommendation status */
  Warning = 'WARNING'
}

/** Time granularity options for aggregating JiraCFO analytics data. */
export enum JiraCfoTimeGranularity {
  /** Daily aggregation of data points. */
  Day = 'DAY',
  /** Monthly aggregation of data points. */
  Month = 'MONTH',
  /** Weekly aggregation of data points. */
  Week = 'WEEK'
}

/** Input type for cmdb field */
export type JiraCmdbFieldInput = {
  /** Option selected from the multi select options */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** List of cmdb objects on which the action will be performed */
  cmdbObjects: Array<JiraCmdbInput>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

/** Input type for cmdb object */
export type JiraCmdbInput = {
  cmdbObjectGlobalId: Scalars['ID']['input'];
};

export type JiraCalendarCrossProjectVersionsInput = {
  /**
   * The active window to filter the Versions to.
   * The window bounds are equivalent to filtering Versions where (startDate > start AND startDate < end)
   * OR (releasedate > start AND releasedate < end)
   * If no start or end is provided, the window is considered unbounded in that direction.
   */
  activeWithin?: InputMaybe<JiraDateTimeWindow>;
  /** Versions that have name match this search string will be returned. */
  searchString?: InputMaybe<Scalars['String']['input']>;
  /** The status of the Versions to filter to. */
  statuses?: InputMaybe<Array<InputMaybe<JiraVersionStatus>>>;
};

/**
 * The input to retrieve the calendar view.
 * Used for calendars that support saved views (currently software and business calendars)
 */
export type JiraCalendarInput = {
  /** The scope of the calendar view, used to determine what project, board, etc. to fetch data for. */
  viewInput?: InputMaybe<JiraViewQueryInput>;
};

export type JiraCalendarIssuesInput = {
  /** Additional JQL to adjust the search for */
  additionalFilterQuery?: InputMaybe<Scalars['String']['input']>;
};

export enum JiraCalendarMode {
  Day = 'DAY',
  Month = 'MONTH',
  Week = 'WEEK'
}

export enum JiraCalendarPermissionKey {
  CreateIssuePermission = 'CREATE_ISSUE_PERMISSION',
  ManageSprintsPermission = 'MANAGE_SPRINTS_PERMISSION',
  ScheduleIssuePermission = 'SCHEDULE_ISSUE_PERMISSION'
}

export type JiraCalendarSprintsInput = {
  /** Additional filtering on sprint states within the calendar date range. */
  sprintStates?: InputMaybe<Array<JiraSprintState>>;
};

export type JiraCalendarVersionsInput = {
  /**
   * Queries for additional software release versions from projects identified by the ARIs below.
   * This is used for subsequent software release version loading after a project is connected or disconnected on the calendar.
   * Note that this parameter cannot be used in conjunction with includeSharedReleases.
   */
  additionalProjectAris?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * Queries for additional software release versions based on project relationships from AGS.
   * Note that this parameter cannot be used in conjunction with additionalProjectAris.
   */
  includeSharedReleases?: InputMaybe<Scalars['Boolean']['input']>;
  /** Additional filtering on version statuses within the calendar date range. */
  versionStatuses?: InputMaybe<Array<JiraVersionStatus>>;
};

/**  View settings for Jira Calendar */
export type JiraCalendarViewConfigurationInput = {
  /** The date in which the fetched calendar view will be based. Default is the current date. */
  date?: InputMaybe<Scalars['DateTime']['input']>;
  /** The alias of the custom field that will be used as the end date of the query */
  endDateField?: InputMaybe<Scalars['String']['input']>;
  /** The view mode of the calendar, used to determine date ranges to search for issues, sprints, versions, etc. Default is MONTH. */
  mode?: InputMaybe<JiraCalendarMode>;
  /** The alias of the custom field that will be used as the start date of the query */
  startDateField?: InputMaybe<Scalars['String']['input']>;
  /**
   * The id to derive view configuration from this is most likely the location of the calendar.
   * When a plan ARI is passed in this determines which startDate & endDate fields are used by the calendar.
   */
  viewId?: InputMaybe<Scalars['ID']['input']>;
  /** The week start day of the calendar, used to determine the first day of the week in the calendar. Default is SUNDAY. */
  weekStart?: InputMaybe<JiraCalendarWeekStart>;
};

/**
 * Input for settings applied to the Jira calendar view.
 * Used for calendars that support saved views (currently software and business calendars)
 */
export type JiraCalendarViewSettings = {
  /** JQL of the filter applied to the Jira calendar view */
  filterJql?: InputMaybe<Scalars['String']['input']>;
};

export enum JiraCalendarWeekStart {
  Monday = 'MONDAY',
  Saturday = 'SATURDAY',
  Sunday = 'SUNDAY'
}

/**
 * #########################
 *  Mutation Inputs
 * #########################
 */
export type JiraCannedResponseCreateInput = {
  content: Scalars['String']['input'];
  isSignature?: InputMaybe<Scalars['Boolean']['input']>;
  projectAri: Scalars['ID']['input'];
  scope: JiraCannedResponseScope;
  title: Scalars['String']['input'];
};

/**
 * #########################
 *  Query Inputs
 * #########################
 */
export type JiraCannedResponseFilter = {
  /** The project under which canned response should be searched */
  projectAri: Scalars['ID']['input'];
  /** Query text to search for in title/name */
  query?: InputMaybe<Scalars['String']['input']>;
  /** The scopes that should be used to filter canned responses */
  scopes?: InputMaybe<Array<JiraCannedResponseScope>>;
  /** Whether to search only signature canned response */
  signature?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum JiraCannedResponseScope {
  Personal = 'PERSONAL',
  Project = 'PROJECT'
}

export type JiraCannedResponseSort = {
  name?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<JiraCannedResponseSortOrder>;
};

export enum JiraCannedResponseSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type JiraCannedResponseUpdateInput = {
  content: Scalars['String']['input'];
  /** ID represents a canned response ARI */
  id: Scalars['ID']['input'];
  isSignature?: InputMaybe<Scalars['Boolean']['input']>;
  scope: JiraCannedResponseScope;
  title: Scalars['String']['input'];
};

/** Enum representing capacity sub-route options. */
export enum JiraCapacitySubRouteEnum {
  People = 'PEOPLE',
  Work = 'WORK'
}

/** Input type representing cascading field inputs */
export type JiraCascadingSelectFieldInput = {
  /** Value of the child option selected for a cascading select field */
  childOptionValue?: InputMaybe<JiraSelectedOptionInput>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Value of the parent option selected for a cascading select field */
  parentOptionValue: JiraSelectedOptionInput;
};

export type JiraCascadingSelectFieldOperationInput = {
  /** Accept ARI(s): issue-field-option */
  childOption?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
  /** Accept ARI(s): issue-field-option */
  parentOption?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * Cascading options can either be a parent or a child - this enum captures this characteristic.
 *
 * E.g. If there is a parent cascading option named `P1`, it may or may not have
 * child cascading options named `C1` and `C2`.
 * - `P1` would be a `PARENT` enum
 * - `C1` and `C2` would be `CHILD` enums
 */
export enum JiraCascadingSelectOptionType {
  /** All options, regardless of whether they're a parent or child. */
  All = 'ALL',
  /** Child option only */
  Child = 'CHILD',
  /** Parent option only */
  Parent = 'PARENT'
}

/** An input filter used to specify the cascading options returned. */
export type JiraCascadingSelectOptionsFilter = {
  /** The type of cascading option to be returned. */
  optionType: JiraCascadingSelectOptionType;
  /** Used for retrieving CHILD cascading options by specifying the PARENT cascading option's id. */
  parentOptionId?: InputMaybe<Scalars['ID']['input']>;
  /** Used for retrieving CHILD cascading options by specifying the PARENT cascading option's name. */
  parentOptionName?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for defining the operation on the Checkboxes field of a Jira issue. */
export type JiraCheckboxesFieldOperationInput = {
  /**  Accepts ARI(s): issue-field-option  */
  ids: Array<Scalars['ID']['input']>;
  /**
   * The operation to perform on the Checkboxes field.
   * SET, ADD, REMOVE operations are supported.
   */
  operation: JiraMultiValueFieldOperations;
};

export type JiraClassificationLevelFilterInput = {
  /** Filter the available classification levels by JiraClassificationLevelStatus. */
  filterByStatus: Array<JiraClassificationLevelStatus>;
  /** Filter the available classification levels by JiraClassificationLevelType. */
  filterByType: Array<JiraClassificationLevelType>;
};

/** Enum to define the classification level source. */
export enum JiraClassificationLevelSource {
  Issue = 'ISSUE',
  Organization = 'ORGANIZATION',
  Project = 'PROJECT'
}

/** Enum to define the classification level status. */
export enum JiraClassificationLevelStatus {
  Archived = 'ARCHIVED',
  Draft = 'DRAFT',
  Published = 'PUBLISHED'
}

/** Enum to define the classification level type. */
export enum JiraClassificationLevelType {
  System = 'SYSTEM',
  User = 'USER'
}

/** Input to clear the card cover of an issue on the board view. */
export type JiraClearBoardIssueCardCoverInput = {
  /** The issue ID (ARI) being updated */
  issueId: Scalars['ID']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view where the issue card cover is being cleared */
  viewId: Scalars['ID']['input'];
};

/** Input type for date field. accepts null value to clear the date */
export type JiraClearableDateFieldInput = {
  date?: InputMaybe<JiraDateInput>;
  fieldId: Scalars['ID']['input'];
};

/** Input type for a clearable number field */
export type JiraClearableNumberFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  value?: InputMaybe<Scalars['Float']['input']>;
};

/** Input type for performing a clone operation for the issue */
export type JiraCloneIssueInput = {
  /** Input for assignee of cloned issue. If omitted, the original issue's assignee will be used. */
  assignee?: InputMaybe<JiraUserInfoInput>;
  /** Whether attachments are to be cloned. */
  includeAttachments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the cloned issue's child issues and the subtasks of those child issues are to be cloned. */
  includeChildrenWithSubtasks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether comments are also cloned. */
  includeComments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether issue links are cloned. */
  includeLinks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether subtasks or child issues are to be cloned. */
  includeSubtasksOrChildren?: InputMaybe<Scalars['Boolean']['input']>;
  /** ARI of the issue to be cloned */
  issueId: Scalars['ID']['input'];
  /** A map of custom field IDs, for example customfield_10044, indicating whether custom fields should cloned or not. Fields are cloned by default. */
  optionalFields?: InputMaybe<Array<JiraOptionalFieldInput>>;
  /** Input for reporter of cloned issue. If omitted, the original issue's reporter will be used. */
  reporter?: InputMaybe<JiraUserInfoInput>;
  /** The summary for the cloned issue. If omitted, the original issue's summary will be used. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Input to provide issue creation validation rules */
  validations?: InputMaybe<Array<JiraIssueCreateValidationRule>>;
};

/** The category of the CMDB attribute that can be created. */
export enum JiraCmdbAttributeType {
  /** Bitbucket repository attribute. */
  BitbucketRepo = 'BITBUCKET_REPO',
  /** Confluence attribute. */
  Confluence = 'CONFLUENCE',
  /** Default attributes, e.g. text, boolean, integer, date. */
  Default = 'DEFAULT',
  /** Group attribute. */
  Group = 'GROUP',
  /** Opsgenie team attribute. */
  OpsgenieTeam = 'OPSGENIE_TEAM',
  /** Project attribute. */
  Project = 'PROJECT',
  /** Reference object attribute. */
  ReferencedObject = 'REFERENCED_OBJECT',
  /** Status attribute. */
  Status = 'STATUS',
  /** User attribute. */
  User = 'USER',
  /** Version attribute. */
  Version = 'VERSION'
}

/** Input type for defining the operation on Cmdb field of a Jira issue. */
export type JiraCmdbFieldOperationInput = {
  /** Accept IDs: Cmdb objects */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The operations to perform on Cmdb field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
};

/** The options for sections which can be collapsed */
export enum JiraCollapsibleSection {
  Activity = 'ACTIVITY',
  Attachments = 'ATTACHMENTS',
  ChildWorkItem = 'CHILD_WORK_ITEM',
  Description = 'DESCRIPTION',
  LinkedWorkItem = 'LINKED_WORK_ITEM',
  UnifiedWorkSection = 'UNIFIED_WORK_SECTION'
}

/** Input type for a color field */
export type JiraColorFieldInput = {
  /** Represents a single color */
  color: JiraColorInput;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

export type JiraColorFieldOperationInput = {
  color: Scalars['String']['input'];
  operation: JiraSingleValueFieldOperations;
};

/** Input type representing a single colour */
export type JiraColorInput = {
  /** Name/Value of the color */
  name: Scalars['String']['input'];
};

/** The options for the Jira color scheme theme preference. */
export enum JiraColorSchemeThemeSetting {
  /** Theme matches the user browser settings */
  Automatic = 'AUTOMATIC',
  /** Dark mode theme */
  Dark = 'DARK',
  /** Light mode theme */
  Light = 'LIGHT'
}

/** The field for sorting comments. */
export enum JiraCommentSortField {
  /** sorts by the created date */
  Created = 'CREATED'
}

export type JiraCommentSortInput = {
  /** The field to sort on. */
  field: JiraCommentSortField;
  /** The sort direction. */
  order: SortDirection;
};

/** Represents the source of a Jira comment if it came from a third-party source. */
export enum JiraCommentThirdPartySource {
  Slack = 'SLACK'
}

export type JiraComponentFieldOperationInput = {
  /** Accept ARI(s): component */
  ids: Array<Scalars['ID']['input']>;
  operation: JiraMultiValueFieldOperations;
};

/** Input type for component field */
export type JiraComponentInput = {
  /** An identifier representing a component */
  componentId: Scalars['ID']['input'];
};

/**  Jira field types (not exhaustive list) */
export enum JiraConfigFieldType {
  /**  Date of First Response field */
  ChartingFirstResponseDate = 'CHARTING_FIRST_RESPONSE_DATE',
  /**  Time in Status field */
  ChartingTimeInStatus = 'CHARTING_TIME_IN_STATUS',
  /**  Team field */
  CustomAtlassianTeam = 'CUSTOM_ATLASSIAN_TEAM',
  /**  Allows multiple values to be selected using two select lists */
  CustomCascadingSelect = 'CUSTOM_CASCADING_SELECT',
  /**  Stores a date with a time component */
  CustomDatetime = 'CUSTOM_DATETIME',
  /**  Stores a date using a picker control */
  CustomDatePicker = 'CUSTOM_DATE_PICKER',
  /**  Stores and validates a numeric (floating point) input */
  CustomFloat = 'CUSTOM_FLOAT',
  /**  Focus areas field */
  CustomFocusAreas = 'CUSTOM_FOCUS_AREAS',
  /**  Goals field */
  CustomGoals = 'CUSTOM_GOALS',
  /**  Stores a user group using a picker control */
  CustomGroupPicker = 'CUSTOM_GROUP_PICKER',
  /**  A read-only field that stores the previous ID of the issue from the system that it was imported from */
  CustomImportId = 'CUSTOM_IMPORT_ID',
  /**  Category field */
  CustomJwmCategory = 'CUSTOM_JWM_CATEGORY',
  /**  Stores labels */
  CustomLabels = 'CUSTOM_LABELS',
  /**  Stores multiple values using checkboxes */
  CustomMultiCheckboxes = 'CUSTOM_MULTI_CHECKBOXES',
  /**  Stores multiple user groups using a picker control */
  CustomMultiGroupPicker = 'CUSTOM_MULTI_GROUP_PICKER',
  /**  Stores multiple values using a select list */
  CustomMultiSelect = 'CUSTOM_MULTI_SELECT',
  /**  Stores multiple users using a picker control */
  CustomMultiUserPicker = 'CUSTOM_MULTI_USER_PICKER',
  /**  Stores multiple versions from the versions available in a project using a picker control */
  CustomMultiVersion = 'CUSTOM_MULTI_VERSION',
  /**  People field */
  CustomPeople = 'CUSTOM_PEOPLE',
  /**  Stores a project from a list of projects that the user is permitted to view */
  CustomProject = 'CUSTOM_PROJECT',
  /**  Stores a value using radio buttons */
  CustomRadioButtons = 'CUSTOM_RADIO_BUTTONS',
  /**  Stores a read-only text value, which can only be populated via the API */
  CustomReadonlyField = 'CUSTOM_READONLY_FIELD',
  /**  Stores a value from a configurable list of options */
  CustomSelect = 'CUSTOM_SELECT',
  /**  Stores a long text string using a multiline text area */
  CustomTextarea = 'CUSTOM_TEXTAREA',
  /**  Stores a text string using a single-line text box */
  CustomTextField = 'CUSTOM_TEXT_FIELD',
  /**  Townsquare Project */
  CustomTownsquareProject = 'CUSTOM_TOWNSQUARE_PROJECT',
  /**  Stores a URL */
  CustomUrl = 'CUSTOM_URL',
  /**  Stores a user using a picker control */
  CustomUserPicker = 'CUSTOM_USER_PICKER',
  /**  Stores a version using a picker control */
  CustomVersion = 'CUSTOM_VERSION',
  /**  Design field */
  JdiDesign = 'JDI_DESIGN',
  /**  Dev Summary Custom Field */
  JdiDevSummary = 'JDI_DEV_SUMMARY',
  /**  Vulnerability field */
  JdiVulnerability = 'JDI_VULNERABILITY',
  /**  Bug Import Id field */
  JimBugImportId = 'JIM_BUG_IMPORT_ID',
  /**  Atlassian project field */
  JpdAtlassianProject = 'JPD_ATLASSIAN_PROJECT',
  /**  Atlassian project status field */
  JpdAtlassianProjectStatus = 'JPD_ATLASSIAN_PROJECT_STATUS',
  /**  Checkbox field */
  JpdBoolean = 'JPD_BOOLEAN',
  /**  Connection field */
  JpdConnection = 'JPD_CONNECTION',
  /**  Insights field */
  JpdCountInsights = 'JPD_COUNT_INSIGHTS',
  /**  Comments field */
  JpdCountIssueComments = 'JPD_COUNT_ISSUE_COMMENTS',
  /**  Linked issues field */
  JpdCountLinkedIssues = 'JPD_COUNT_LINKED_ISSUES',
  /**  Delivery progress field */
  JpdDeliveryProgress = 'JPD_DELIVERY_PROGRESS',
  /**  Delivery status field */
  JpdDeliveryStatus = 'JPD_DELIVERY_STATUS',
  /**  External reference field */
  JpdExternalReference = 'JPD_EXTERNAL_REFERENCE',
  /**  Custom formula field */
  JpdFormula = 'JPD_FORMULA',
  /**  Time interval field */
  JpdInterval = 'JPD_INTERVAL',
  /**  Custom Google Map Field. Note: this is a JConnect rather than a JPD field. */
  JpdLocation = 'JPD_LOCATION',
  /**  Rating field */
  JpdRating = 'JPD_RATING',
  /**  Reactions field */
  JpdReactions = 'JPD_REACTIONS',
  /**  Slider field */
  JpdSlider = 'JPD_SLIDER',
  /**  UUID Field. Note: this is a JConnect rather than a JPD field. */
  JpdUuid = 'JPD_UUID',
  /**  Votes field */
  JpdVotes = 'JPD_VOTES',
  /**  Parent Link field */
  JpoParent = 'JPO_PARENT',
  /**  Target end field */
  JpoTargetEnd = 'JPO_TARGET_END',
  /**  Target start field */
  JpoTargetStart = 'JPO_TARGET_START',
  /**  Locked forms field */
  ProformaFormsLocked = 'PROFORMA_FORMS_LOCKED',
  /**  Open forms field */
  ProformaFormsOpen = 'PROFORMA_FORMS_OPEN',
  /**  Submitted forms field */
  ProformaFormsSubmitted = 'PROFORMA_FORMS_SUBMITTED',
  /**  Total forms field */
  ProformaFormsTotal = 'PROFORMA_FORMS_TOTAL',
  /**  Servicedesk approvals field */
  ServicedeskApprovals = 'SERVICEDESK_APPROVALS',
  /**  Approvers list field */
  ServicedeskApproversList = 'SERVICEDESK_APPROVERS_LIST',
  /**  External asset platform field */
  ServicedeskAsset = 'SERVICEDESK_ASSET',
  /**  Assets objects field */
  ServicedeskCmdbField = 'SERVICEDESK_CMDB_FIELD',
  /**  Customer field */
  ServicedeskCustomer = 'SERVICEDESK_CUSTOMER',
  /**  Servicedesk customer organizations field */
  ServicedeskCustomerOrganizations = 'SERVICEDESK_CUSTOMER_ORGANIZATIONS',
  /**  Entitlement field */
  ServicedeskEntitlement = 'SERVICEDESK_ENTITLEMENT',
  /**  Major Incident Field */
  ServicedeskMajorIncidentEntity = 'SERVICEDESK_MAJOR_INCIDENT_ENTITY',
  /**  Organisation field */
  ServicedeskOrganization = 'SERVICEDESK_ORGANIZATION',
  /**  Servicedesk request feedback field */
  ServicedeskRequestFeedback = 'SERVICEDESK_REQUEST_FEEDBACK',
  /**  Servicedesk feedback date field */
  ServicedeskRequestFeedbackDate = 'SERVICEDESK_REQUEST_FEEDBACK_DATE',
  /**  Servicedesk request language field */
  ServicedeskRequestLanguage = 'SERVICEDESK_REQUEST_LANGUAGE',
  /**  Servicedesk request participants field */
  ServicedeskRequestParticipants = 'SERVICEDESK_REQUEST_PARTICIPANTS',
  /**  Responders Field */
  ServicedeskRespondersEntity = 'SERVICEDESK_RESPONDERS_ENTITY',
  /**  Sentiment field */
  ServicedeskSentiment = 'SERVICEDESK_SENTIMENT',
  /**  Service Field */
  ServicedeskServiceEntity = 'SERVICEDESK_SERVICE_ENTITY',
  /**  Servicedesk sla field */
  ServicedeskSlaField = 'SERVICEDESK_SLA_FIELD',
  /**  Servicedesk vp origin field */
  ServicedeskVpOrigin = 'SERVICEDESK_VP_ORIGIN',
  /**  Work category field */
  ServicedeskWorkCategory = 'SERVICEDESK_WORK_CATEGORY',
  /**  Software epic color field */
  SoftwareEpicColor = 'SOFTWARE_EPIC_COLOR',
  /**  Software epic issue color field */
  SoftwareEpicIssueColor = 'SOFTWARE_EPIC_ISSUE_COLOR',
  /**  Software epic label field */
  SoftwareEpicLabel = 'SOFTWARE_EPIC_LABEL',
  /**  Software epic lexo rank field */
  SoftwareEpicLexoRank = 'SOFTWARE_EPIC_LEXO_RANK',
  /**  Software epic link field */
  SoftwareEpicLink = 'SOFTWARE_EPIC_LINK',
  /**  Software epic sprint field */
  SoftwareEpicSprint = 'SOFTWARE_EPIC_SPRINT',
  /**  Software epic status field */
  SoftwareEpicStatus = 'SOFTWARE_EPIC_STATUS',
  /**  Story point estimate value field */
  SoftwareStoryPoints = 'SOFTWARE_STORY_POINTS',
  /**  Standard affected versions issue field */
  StandardAffectedVersions = 'STANDARD_AFFECTED_VERSIONS',
  /**  Standard aggregate progress issue field */
  StandardAggregateProgress = 'STANDARD_AGGREGATE_PROGRESS',
  /**  Standard aggregate time estimate issue field */
  StandardAggregateTimeEstimate = 'STANDARD_AGGREGATE_TIME_ESTIMATE',
  /**  Standard aggregate time original estimate issue field */
  StandardAggregateTimeOriginalEstimate = 'STANDARD_AGGREGATE_TIME_ORIGINAL_ESTIMATE',
  /**  Standard aggregate time spent issue field */
  StandardAggregateTimeSpent = 'STANDARD_AGGREGATE_TIME_SPENT',
  /**  Standard assignee issue field */
  StandardAssignee = 'STANDARD_ASSIGNEE',
  /**  Standard attachment issue field */
  StandardAttachment = 'STANDARD_ATTACHMENT',
  /**  Standard comment issue field */
  StandardComment = 'STANDARD_COMMENT',
  /**  Standard components issue field */
  StandardComponents = 'STANDARD_COMPONENTS',
  /**  Standard created issue field */
  StandardCreated = 'STANDARD_CREATED',
  /**  Standard creator issue field */
  StandardCreator = 'STANDARD_CREATOR',
  /**  Standard description issue field */
  StandardDescription = 'STANDARD_DESCRIPTION',
  /**  Standard due date issue field */
  StandardDueDate = 'STANDARD_DUE_DATE',
  /**  Standard environment issue field */
  StandardEnvironment = 'STANDARD_ENVIRONMENT',
  /**  Standard fix for versions issue field */
  StandardFixForVersions = 'STANDARD_FIX_FOR_VERSIONS',
  /**  Standard form token issue field */
  StandardFormToken = 'STANDARD_FORM_TOKEN',
  /**  Standard issue key issue field */
  StandardIssueKey = 'STANDARD_ISSUE_KEY',
  /**  Standard issue links issue field */
  StandardIssueLinks = 'STANDARD_ISSUE_LINKS',
  /**  Standard issue number issue field */
  StandardIssueNumber = 'STANDARD_ISSUE_NUMBER',
  /**  Standard restrict to field */
  StandardIssueRestriction = 'STANDARD_ISSUE_RESTRICTION',
  /**  Standard issue type issue field */
  StandardIssueType = 'STANDARD_ISSUE_TYPE',
  /**  Standard labels issue field */
  StandardLabels = 'STANDARD_LABELS',
  /**  Standard last viewed issue field */
  StandardLastViewed = 'STANDARD_LAST_VIEWED',
  /**  Standard parent issue field */
  StandardParent = 'STANDARD_PARENT',
  /**  Standard priority issue field */
  StandardPriority = 'STANDARD_PRIORITY',
  /**  Standard progress issue field */
  StandardProgress = 'STANDARD_PROGRESS',
  /**  Standard project issue field */
  StandardProject = 'STANDARD_PROJECT',
  /**  Standard project key issue field */
  StandardProjectKey = 'STANDARD_PROJECT_KEY',
  /**  Standard reporter issue field */
  StandardReporter = 'STANDARD_REPORTER',
  /**  Standard resolution issue field */
  StandardResolution = 'STANDARD_RESOLUTION',
  /**  Standard resolution date issue field */
  StandardResolutionDate = 'STANDARD_RESOLUTION_DATE',
  /**  Standard security issue field */
  StandardSecurity = 'STANDARD_SECURITY',
  /**  Standard status issue field */
  StandardStatus = 'STANDARD_STATUS',
  /**  Standard status category field */
  StandardStatusCategory = 'STANDARD_STATUS_CATEGORY',
  /**  Standard status category changed field */
  StandardStatusCategoryChangeDate = 'STANDARD_STATUS_CATEGORY_CHANGE_DATE',
  /**  Standard subtasks issue field */
  StandardSubtasks = 'STANDARD_SUBTASKS',
  /**  Standard summary issue field */
  StandardSummary = 'STANDARD_SUMMARY',
  /**  Standard thumbnail issue field */
  StandardThumbnail = 'STANDARD_THUMBNAIL',
  /**  Standard time tracking issue field */
  StandardTimetracking = 'STANDARD_TIMETRACKING',
  /**  Standard time estimate issue field */
  StandardTimeEstimate = 'STANDARD_TIME_ESTIMATE',
  /**  Standard original estimate issue field */
  StandardTimeOriginalEstimate = 'STANDARD_TIME_ORIGINAL_ESTIMATE',
  /**  Standard time spent issue field */
  StandardTimeSpent = 'STANDARD_TIME_SPENT',
  /**  Standard updated issue field */
  StandardUpdated = 'STANDARD_UPDATED',
  /**  Standard voters issue field */
  StandardVoters = 'STANDARD_VOTERS',
  /**  Standard votes issue field */
  StandardVotes = 'STANDARD_VOTES',
  /**  Standard watchers issue field */
  StandardWatchers = 'STANDARD_WATCHERS',
  /**  Standard watches issue field */
  StandardWatches = 'STANDARD_WATCHES',
  /**  Standard worklog issue field */
  StandardWorklog = 'STANDARD_WORKLOG',
  /**  Standard work ratio issue field */
  StandardWorkratio = 'STANDARD_WORKRATIO',
  /**  Domain of Assignee field */
  ToolkitAssigneeDomain = 'TOOLKIT_ASSIGNEE_DOMAIN',
  /**  Number of attachments field */
  ToolkitAttachments = 'TOOLKIT_ATTACHMENTS',
  /**  Number of comments field */
  ToolkitComments = 'TOOLKIT_COMMENTS',
  /**  Days since last comment field */
  ToolkitDaysLastCommented = 'TOOLKIT_DAYS_LAST_COMMENTED',
  /**  Last public comment date field */
  ToolkitLastCommentDate = 'TOOLKIT_LAST_COMMENT_DATE',
  /**  Username of last updater or commenter field */
  ToolkitLastUpdaterOrCommenter = 'TOOLKIT_LAST_UPDATER_OR_COMMENTER',
  /**  Last commented by a User Flag field */
  ToolkitLastUserCommented = 'TOOLKIT_LAST_USER_COMMENTED',
  /**  Message Custom Field (for edit) */
  ToolkitMessage = 'TOOLKIT_MESSAGE',
  /**  Participants of an issue field */
  ToolkitParticipants = 'TOOLKIT_PARTICIPANTS',
  /**  Domain of Reporter field */
  ToolkitReporterDomain = 'TOOLKIT_REPORTER_DOMAIN',
  /**  User Property Field */
  ToolkitUserProperty = 'TOOLKIT_USER_PROPERTY',
  /**  Message Custom Field (for view) */
  ToolkitViewMessage = 'TOOLKIT_VIEW_MESSAGE',
  /**  Used to represent a Field type that is currently not handled */
  Unsupported = 'UNSUPPORTED'
}

/**  Enum representing the configured status for a jira app/workspace  */
export enum JiraConfigStateConfigurationStatus {
  /** App is in configured state  */
  Configured = 'CONFIGURED',
  /** App is not in configured state  */
  NotConfigured = 'NOT_CONFIGURED',
  /** App is not installed  */
  NotInstalled = 'NOT_INSTALLED',
  /** Configured state not set  */
  NotSet = 'NOT_SET',
  /** App is in partially configured state */
  PartiallyConfigured = 'PARTIALLY_CONFIGURED',
  /** Provider action is in configured state  */
  ProviderActionConfigured = 'PROVIDER_ACTION_CONFIGURED',
  /** Provider action is not in configured state  */
  ProviderActionNotConfigured = 'PROVIDER_ACTION_NOT_CONFIGURED'
}

/**  Enum representing Provider Type of App for Config State Service  */
export enum JiraConfigStateProviderType {
  /** Represents a provider type of an app which providers build service  */
  Builds = 'BUILDS',
  /** Represents a provider type of an app which providers deployments service  */
  Deployments = 'DEPLOYMENTS',
  /** Represents a provider type of an app which providers designs service  */
  Designs = 'DESIGNS',
  /** Represents a provider type of an app which providers dev Info service  */
  DevelopmentInfo = 'DEVELOPMENT_INFO',
  /** Represents a provider type of an app which providers feature flag service  */
  FeatureFlags = 'FEATURE_FLAGS',
  /** Represents a provider type of an app which providers remote links service  */
  RemoteLinks = 'REMOTE_LINKS',
  /** Represents a provider type of an app which providers security service  */
  Security = 'SECURITY',
  /** Represents a provider type of an app which does not fit in above categories  */
  Unknown = 'UNKNOWN'
}

/** Each individual nav item that is configurable by the user. */
export type JiraConfigurableNavigationItemInput = {
  /** The visibility of the navigation item. */
  isVisible: Scalars['Boolean']['input'];
  /** The menuID for the navigation item. */
  menuId: Scalars['String']['input'];
};

/** The relationship type between the confluence link and the issue. */
export enum JiraConfluenceContentRelationshipType {
  Linked = 'LINKED',
  MentionedIn = 'MENTIONED_IN'
}

/** The error type when the confluence content is not available. */
export enum JiraConfluencePageContentErrorType {
  ApplinkMissing = 'APPLINK_MISSING',
  ApplinkReqAuth = 'APPLINK_REQ_AUTH',
  RemoteError = 'REMOTE_ERROR',
  RemoteLinkMissing = 'REMOTE_LINK_MISSING'
}

/**
 * Input type for a Confluence remote issue link.
 * Either the ARI of an existing page link, or href of a new page link to be created.
 */
export type JiraConfluenceRemoteIssueLinkInput = {
  /** The URL of the page link to be created */
  href?: InputMaybe<Scalars['String']['input']>;
  /** The Remote Link ARI - the ID of an existing page link */
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** Input type for defining the operation on Confluence remote issue links field of a Jira issue. */
export type JiraConfluenceRemoteIssueLinksFieldOperationInput = {
  /** Confluence remote issue link inputs accepted during the update operation. */
  links: Array<JiraConfluenceRemoteIssueLinkInput>;
  /**
   * The operations to perform on Confluence remote issue links field.
   * SET, ADD, REMOVE operations are supported.
   */
  operation: JiraMultiValueFieldOperations;
};

/** State of the modal for contacting the org admin to enable Atlassian Intelligence. */
export enum JiraContactOrgAdminToEnableAtlassianIntelligenceState {
  /** The modal is available to be shown. */
  Available = 'AVAILABLE',
  /** The modal is not available to be shown. */
  Unavailable = 'UNAVAILABLE'
}

/** Input to query the navigation of a container scoped to a project by its key. */
export type JiraContainerNavigationByProjectKeyQueryInput = {
  /** The identifier which indicates the cloud instance this data is to be fetched for, required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** Key of the project to retrieve the navigation for. */
  projectKey: Scalars['String']['input'];
};

/**
 * Input to retrieve the navigation details of a container. As per the `@oneOf` directive, Only one of the fields
 * `byScopeId` or `byProjectKey` must be provided.
 */
export type JiraContainerNavigationQueryInput = {
  /**
   * Input to retrieve the navigation for a project by key. Clients can use this when they don't have access to
   * the project ID or the default Board ID.
   */
  projectKeyQuery?: InputMaybe<JiraContainerNavigationByProjectKeyQueryInput>;
  /** ARI of the container scope to retrieve the navigation for. Supports project ARI and Board ARI. */
  scopeId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraCreateActivityConfigurationInput = {
  /** Field value mapping. It contains list of object which is like a map entry including a string key and array of string value */
  fieldValues?: InputMaybe<Array<InputMaybe<JiraActivityFieldValueKeyValuePairInput>>>;
  /** Id of the activity configuration */
  id: Scalars['ID']['input'];
  /** Name of the activity */
  issueTypeId?: InputMaybe<Scalars['ID']['input']>;
  /** Name of the activity */
  name: Scalars['String']['input'];
  /** Name of the activity */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** Name of the activity */
  requestTypeId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * Input for creating a navigation item of type `JiraNavigationItemTypeKey.APP`. The related app is identified by
 * the `appId` input field.
 */
export type JiraCreateAppNavigationItemInput = {
  /**
   * The app id for the app to add. Supported ARIs:
   * - [Forge app ARI](https://developer.atlassian.com/platform/atlassian-resource-identifier/resource-owners/registry/#ati%3Acloud%3Aecosystem%3Aapp)
   * - [Connect app ARI](https://developer.atlassian.com/platform/atlassian-resource-identifier/resource-owners/registry/#ati%3Acloud%3Aecosystem%3Aconnect-app)
   */
  appId: Scalars['ID']['input'];
  /** ARI of the scope to add the navigation item for. */
  scopeId: Scalars['ID']['input'];
};

/** The field name of the new approver list field and its associated project and issue type */
export type JiraCreateApproverListFieldInput = {
  fieldName: Scalars['String']['input'];
  issueTypeId?: InputMaybe<Scalars['Int']['input']>;
  projectId: Scalars['Int']['input'];
};

/** The input for creating an attachment background */
export type JiraCreateAttachmentBackgroundInput = {
  /** The entityId (ARI) of the entity to be updated */
  entityId: Scalars['ID']['input'];
  /** The Media API File ID of the background */
  mediaApiFileId: Scalars['String']['input'];
};

export type JiraCreateBoardFieldInput = {
  /** Issue types to be included in the new board */
  issueTypes?: InputMaybe<Array<JiraIssueTypeInput>>;
  /** Labels to be included in the new board */
  labels?: InputMaybe<Array<JiraLabelsInput>>;
  /** Projects to be included in the new board */
  projects: Array<JiraProjectInput>;
  /** Teams to be included in the new board */
  teams?: InputMaybe<Array<JiraAtlassianTeamInput>>;
};

export type JiraCreateBoardInput = {
  /** Source from which the board to be created - either projectIds or savedFilterId */
  createBoardSource: JiraCreateBoardSource;
  /** Location of the board */
  location: JiraBoardLocation;
  /** Name of board to create */
  name: Scalars['String']['input'];
  /** Preset of the board */
  preset: JiraBoardType;
};

export type JiraCreateBoardSource = {
  /** Fields with values that can be used to create a filter for the board. */
  fieldInput?: InputMaybe<JiraCreateBoardFieldInput>;
  /** Saved filter id that can be used to create the board. */
  savedFilterId?: InputMaybe<Scalars['Long']['input']>;
};

/** Input to create a new status in the project's workflow and map it to a new column in the board view. */
export type JiraCreateBoardViewStatusColumnInput = {
  /** Name of the new status column to create. */
  name: Scalars['String']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** The status category ID of the status to create in the project's workflow. */
  statusCategoryId: Scalars['ID']['input'];
  /** ARI of the board view where the status column is being created. */
  viewId: Scalars['ID']['input'];
};

/** Input to create board views for workflows. */
export type JiraCreateBoardViewsForWorkflowsInput = {
  /** ARI of an existing board view, to create new adjacent board views within the same project. Encoded as an ARI. */
  viewId: Scalars['ID']['input'];
  /** List of workflow IDs to create corresponding board views for. */
  workflowIds: Array<Scalars['ID']['input']>;
};

/** Input for creating a Jira Custom Background */
export type JiraCreateCustomBackgroundInput = {
  /** The alt text associated with the custom background */
  altText: Scalars['String']['input'];
  /**
   * The dominant color of the background image in HEX format, ie. "^#[A-Fa-f0-9]{6}$"
   * Currently optional for business projects.
   */
  dominantColor?: InputMaybe<Scalars['String']['input']>;
  /** The entityId (ARI) of the entity to be updated with the created background */
  entityId: Scalars['ID']['input'];
  /** The created mediaApiFileId of the background to create */
  mediaApiFileId: Scalars['String']['input'];
};

export type JiraCreateCustomFieldInput = {
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId: Scalars['ID']['input'];
  /** The description of the field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The field format configuration. */
  fieldFormatConfig?: InputMaybe<JiraFieldFormatConfigInput>;
  /** The name of the field. */
  name: Scalars['String']['input'];
  /** The field options. */
  options?: InputMaybe<Array<JiraCustomFieldOptionInput>>;
  /** Unique identifier of the project. */
  projectId: Scalars['String']['input'];
  /** The type of the field. */
  type: Scalars['String']['input'];
};

/** Input for creating a JiraCustomFilter. */
export type JiraCreateCustomFilterInput = {
  /** A string containing filter description */
  description?: InputMaybe<Scalars['String']['input']>;
  /**
   * The list of edit grants for the filter. Edit Grants represent different ways that users have been granted access to edit the filter.
   * Empty array represents private edit grant.
   */
  editGrants: Array<InputMaybe<JiraShareableEntityEditGrantInput>>;
  /** If present, column configuration will be copied from Filter represented by this filterId to the newly created filter */
  filterId?: InputMaybe<Scalars['String']['input']>;
  /** Determines whether the filter is currently starred by the user viewing the filter */
  isFavourite: Scalars['Boolean']['input'];
  /** JQL associated with the filter */
  jql: Scalars['String']['input'];
  /** A string representing the name of the filter */
  name: Scalars['String']['input'];
  /** A string representing namespace of the issue search view */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /**
   * The list of share grants for the filter. Share Grants represent different ways that users have been granted access to the filter.
   * Empty array represents private and null represents default share grant.
   */
  shareGrants: Array<InputMaybe<JiraShareableEntityShareGrantInput>>;
};

export type JiraCreateEmptyActivityConfigurationInput = {
  /** Id of the journey configuration */
  journeyId: Scalars['ID']['input'];
  /** The version number of the journey configuration. */
  journeyVersion: Scalars['Long']['input'];
  /** Name of the activity */
  name: Scalars['String']['input'];
};

export type JiraCreateFieldSchemeInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** Optional parameter used to copy items from an existing Field Scheme or (default) Field Configuration Scheme. */
  sourceOfItems?: InputMaybe<JiraFieldSchemeSourceInput>;
};

/** Input for creating a formatting rule. */
export type JiraCreateFormattingRuleInput = {
  /**
   * The id based cursor of a rule where the new rule should be created after.
   * If not specified, the new rule will be created on top of the rule list.
   */
  afterRuleId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** Content of this rule. */
  expression: JiraFormattingRuleExpressionInput;
  /** Formatting area of this rule (row or cell). */
  formattingArea: JiraFormattingArea;
  /** Color to be applied if condition matches. */
  formattingColor?: InputMaybe<JiraColorInput>;
  /** Id of the project to create a formatting rule for. Must provide either project key or id. */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** Key of the project to create a formatting rule for. Must provide either project key or id. */
  projectKey?: InputMaybe<Scalars['String']['input']>;
};

export type JiraCreateGlobalCustomFieldInput = {
  /** The description of the global custom field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The format configuration of the global custom field. */
  formatConfig?: InputMaybe<JiraFieldFormatConfigInput>;
  /** The name of the global custom field. */
  name: Scalars['String']['input'];
  /** The options of the global custom field, if any. */
  options?: InputMaybe<Array<JiraCreateGlobalCustomFieldOptionInput>>;
  /** The type of the global custom field. */
  type: JiraConfigFieldType;
};

export type JiraCreateGlobalCustomFieldOptionInput = {
  /** The child options of the option of the global custom field, if any. */
  childOptions?: InputMaybe<Array<JiraCreateGlobalCustomFieldOptionInput>>;
  /** The value of the option of the global custom field. */
  value: Scalars['String']['input'];
};

export type JiraCreateGlobalCustomFieldV2Input = {
  /** The description of the global custom field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The format configuration of the global custom field. */
  formatConfig?: InputMaybe<JiraFieldFormatConfigInput>;
  /** The name of the global custom field. */
  name: Scalars['String']['input'];
  /** The options of the global custom field, if any. */
  options?: InputMaybe<Array<JiraCreateGlobalCustomFieldOptionInput>>;
  /** The key of the type of the global custom field. */
  typeKey: Scalars['String']['input'];
};

/** Input for creating a new conditional formatting rule for the issue search view. */
export type JiraCreateIssueSearchFormattingRuleInput = {
  /**
   * The id based cursor of a rule where the new rule should be created after.
   * If not specified, the new rule will be created on top of the rule list.
   */
  afterRuleId?: InputMaybe<Scalars['String']['input']>;
  /** Content of this rule. */
  expression: JiraFormattingRuleExpressionInput;
  /** Formatting area of this rule (row or cell). */
  formattingArea: JiraFormattingArea;
  /** Color to be applied if condition matches. */
  formattingColor?: InputMaybe<JiraColorInput>;
  /** ARI of the issue search to create a formatting rule for. */
  viewId: Scalars['ID']['input'];
};

/** Input for jira_createIssueType mutation. */
export type JiraCreateIssueTypeInput = {
  /** ID for the avatar of the new issue type. */
  avatarId: Scalars['String']['input'];
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** Description of the new issue type. */
  description: Scalars['String']['input'];
  /**
   * The global hierarchy level of the IssueType.
   * E.g. -1 for the subtask level, 0 for the base level, 1 for the epic level.
   */
  hierarchyLevel: Scalars['Int']['input'];
  /** Name of the new issue type. */
  name: Scalars['String']['input'];
  /** ID of parent project.  The presence of a projectId will denote that this is for a TMP rather than a CMP. */
  projectId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraCreateJourneyConfigurationInput = {
  /** List of new activity configuration */
  createActivityConfigurations?: InputMaybe<Array<InputMaybe<JiraCreateActivityConfigurationInput>>>;
  /** Name of the journey */
  name: Scalars['String']['input'];
  /** Parent issue of the journey configuration */
  parentIssue: JiraJourneyParentIssueInput;
  /** The trigger of this journey */
  trigger: JiraJourneyTriggerInput;
};

export type JiraCreateJourneyItemInput = {
  /** Journey item configuration */
  configuration?: InputMaybe<JiraJourneyItemConfigurationInput>;
  /** The entity tag of the journey configuration */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** Id of the journey item which this item should be inserted after, null indicates insert at the front */
  insertAfterItemId?: InputMaybe<Scalars['ID']['input']>;
  /** Id of the journey configuration */
  journeyId: Scalars['ID']['input'];
  /** The version number of the journey configuration. */
  journeyVersion: Scalars['Long']['input'];
  /** The type of journey configuration */
  type?: InputMaybe<JiraJourneyConfigurationType>;
};

/** The input for creating the release notes in Confluence for the given version */
export type JiraCreateReleaseNoteConfluencePageInput = {
  /** The app link id that will correspond to the target confluence instance */
  appLinkId?: InputMaybe<Scalars['ID']['input']>;
  /** Exclude the issue key from the generated report */
  excludeIssueKey?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ARIs of issue fields(issue-field-meta ARI) to include when generating the release note
   *
   * Note: An empty array indicates no issue properties should be included in the release notes generation. Only summary will be included as the summary is included by default.
   */
  issueFieldIds: Array<Scalars['ID']['input']>;
  /**
   * The ARIs of issue types(issue-type ARI) to include when generating release notes
   *
   * Note: An empty array indicates all the issue types should be included in the release notes generation
   */
  issueTypeIds: Array<Scalars['ID']['input']>;
  /** The ARI of the confluence page under which the release note will be created */
  parentPageId?: InputMaybe<Scalars['ID']['input']>;
  /** The Confluence space ARI under which the release note will be created */
  spaceId: Scalars['ID']['input'];
  /** The ARI of the version to create a release note in Confluence */
  versionId: Scalars['ID']['input'];
};

export type JiraCreateShortcutInput = {
  /** ARI of the project the shortcut is being added to. */
  projectId: Scalars['ID']['input'];
  /** Data of shortcut being added */
  shortcutData: JiraShortcutDataInput;
  /** The type of the shortcut to be added. */
  type: JiraProjectShortcutType;
};

/** Input for creating a simple navigation item which doesn't require any additional data other than its `typeKey`. */
export type JiraCreateSimpleNavigationItemInput = {
  /** ARI of the scope to add the navigation item for. */
  scopeId: Scalars['ID']['input'];
  /** The key of the type of navigation item to add. */
  typeKey: JiraNavigationItemTypeKey;
};

/** The supported brightness of a custom background */
export enum JiraCustomBackgroundBrightness {
  Dark = 'DARK',
  Light = 'LIGHT'
}

export type JiraCustomFieldOptionInput = {
  /** The color of the field option. */
  color?: InputMaybe<JiraOptionColorInput>;
  /**
   * The identifier of the option set externally.
   * Set this field when creating a new parent option that has child (cascaded) options during create or edit Field operation.
   */
  externalUuid?: InputMaybe<Scalars['String']['input']>;
  /**
   * The identifier of the option that exists in the system.
   * Do not set this field when creating the option.
   */
  optionId?: InputMaybe<Scalars['Long']['input']>;
  /**
   * The external identifier of the parent of this option.
   * Set this only on child (cascaded) options when creating a new parent option during create or edit Field operation.
   */
  parentExternalUuid?: InputMaybe<Scalars['String']['input']>;
  /**
   * The identifier of the parent option that exists in the system.
   * Do not set this field if this option does not have a parent option or if the parent option has not been created yet.
   * Set this field only on child (cascaded) options during edit.
   */
  parentOptionId?: InputMaybe<Scalars['Long']['input']>;
  /** The value of the field option. */
  value: Scalars['String']['input'];
};

/** Used for grouping field types in UI */
export enum JiraCustomFieldTypeCategory {
  Advanced = 'ADVANCED',
  Standard = 'STANDARD'
}

/** The type of error returned from a custom search implementation */
export enum JiraCustomIssueSearchErrorType {
  /** A specific, internal error was generated by the custom search implementation */
  CustomImplementationError = 'CUSTOM_IMPLEMENTATION_ERROR',
  /** The requested custom search implementation is not enabled for this request */
  CustomSearchDisabled = 'CUSTOM_SEARCH_DISABLED',
  /** An ARI used as input to a custom search implementation was invalid */
  InvalidAri = 'INVALID_ARI',
  /** An ARI used as input to a custom search implementation is not supported by the implementation */
  UnsupportedAri = 'UNSUPPORTED_ARI'
}

export type JiraCustomerOrganizationsBulkFetchInput = {
  /** The UUIDs of the customer organizations to fetch. */
  customerOrganizationUUIDs: Array<Scalars['String']['input']>;
};

/** Input type for updating the Organization field of the Jira issue. */
export type JiraCustomerServiceUpdateOrganizationFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Organization field. */
  operation?: InputMaybe<JiraCustomerServiceUpdateOrganizationOperationInput>;
};

/** Input type for defining the operation on the Organization field of a Jira issue. */
export type JiraCustomerServiceUpdateOrganizationOperationInput = {
  /** Only SET operation is supported. */
  operation: JiraSingleValueFieldOperations;
  /** ARI of the selected organization. */
  organizationId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraCustomizeProjectLevelSidebarMenuItemInput = {
  /** The identifier of the cloud instance to update the sidebar menu settings for. */
  cloudId: Scalars['ID']['input'];
  /** The list of items to be hidden */
  hiddenMenuItems: Array<InputMaybe<JiraProjectLevelSidebarMenuItemInput>>;
  /** The identifier of the project ID to update the sidebar menu settings for. */
  projectId: Scalars['ID']['input'];
};

export type JiraDataClassificationFieldOperationInput = {
  /** The new classification level to set. */
  classificationLevel?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The operation to perform on the Data Classification field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
};

/** Input type for date field */
export type JiraDateFieldInput = {
  /** A date input on which the action will be performed */
  date: JiraDateInput;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

export type JiraDateFieldOperationInput = {
  date?: InputMaybe<Scalars['Date']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Input type for date */
export type JiraDateInput = {
  /** Formatted date string value in format DD/MMM/YY */
  formattedDate: Scalars['String']['input'];
};

/** Input type for date time field */
export type JiraDateTimeFieldInput = {
  dateTime: JiraDateTimeInput;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

export type JiraDateTimeFieldOperationInput = {
  datetime?: InputMaybe<Scalars['DateTime']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Input type for date time */
export type JiraDateTimeInput = {
  /** Formatted date time string value in format DD/MMM/YY hh:mm A */
  formattedDateTime: Scalars['String']['input'];
};

export type JiraDateTimeRange = {
  /** Specifies the start date (exclusive) for filtering attachments by upload date. */
  after?: InputMaybe<Scalars['DateTime']['input']>;
  /** Specifies the end date (exclusive) for filtering attachments by upload date. */
  before?: InputMaybe<Scalars['DateTime']['input']>;
};

export type JiraDateTimeWindow = {
  /** The end date time of the window. */
  end?: InputMaybe<Scalars['DateTime']['input']>;
  /** The start date time of the window. */
  start?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Input to decline creating board views for workflows. */
export type JiraDeclineBoardViewsForWorkflowsInput = {
  /** ARI of an existing board view, to decline creating new adjacent board views within the same project. Encoded as an ARI. */
  viewId: Scalars['ID']['input'];
};

/**
 * The input for searching an Unsplash Collection. Can only be used to retrieve photos from the "Unsplash Editorial".
 * Uses Unsplash's API definition for pagination https://unsplash.com/documentation#parameters-16
 */
export type JiraDefaultUnsplashImagesInput = {
  /**  CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The page number, defaults to 1 */
  pageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** The page size, defaults to 10 */
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  /** The requested width in pixels of the thumbnail image, default is 200px */
  width?: InputMaybe<Scalars['Int']['input']>;
};

export type JiraDeleteActivityConfigurationInput = {
  /** Id of the activity configuration */
  activityId: Scalars['ID']['input'];
  /** Id of the journey configuration */
  journeyId: Scalars['ID']['input'];
  /** The version number of the journey configuration. */
  journeyVersion: Scalars['Long']['input'];
};

/** Input to delete a status in the project's workflow and the column it is mapped to in the board view. */
export type JiraDeleteBoardViewStatusColumnInput = {
  /** ID of the status column to delete. */
  columnId: Scalars['ID']['input'];
  /** ID of the status to move the issues in the deleted status column to. */
  replacementStatusId: Scalars['ID']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view where the status column is being deleted. */
  viewId: Scalars['ID']['input'];
};

/** The input for deleting a comment. */
export type JiraDeleteCommentInput = {
  /** Accept ARI: comment */
  id: Scalars['ID']['input'];
  /** The Jira issue ARI. */
  issueId: Scalars['ID']['input'];
};

/** The input for deleting a custom background */
export type JiraDeleteCustomBackgroundInput = {
  /**  CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The customBackgroundId of the custom background to delete */
  customBackgroundId: Scalars['ID']['input'];
};

export type JiraDeleteCustomFieldInput = {
  /**
   * The cloudId indicates the cloud instance this mutation will be executed against.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId: Scalars['ID']['input'];
  fieldId: Scalars['String']['input'];
  projectId: Scalars['String']['input'];
};

export type JiraDeleteFieldSchemeInput = {
  schemeId: Scalars['ID']['input'];
};

export type JiraDeleteFormattingRuleInput = {
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The rule to delete. */
  ruleId: Scalars['ID']['input'];
};

/** Input for deleting an existing conditional formatting rule for the issue search view. */
export type JiraDeleteIssueSearchFormattingRuleInput = {
  /** Id of the rule to delete. */
  ruleId: Scalars['ID']['input'];
  /** ARI of the issue search to delete a formatting rule for. */
  viewId: Scalars['ID']['input'];
};

/** Input for jira_deleteIssueType mutation. */
export type JiraDeleteIssueTypeInput = {
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** ID of the issue type to delete. */
  issueTypeId: Scalars['ID']['input'];
  /** Optionally specify the project ID to disambiguate project-scoped issue types. */
  projectId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraDeleteJourneyItemInput = {
  /** The entity tag of the journey configuration */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** Id of the journey item to be deleted */
  itemId: Scalars['ID']['input'];
  /** Id of the journey configuration */
  journeyId: Scalars['ID']['input'];
  /** The version number of the journey configuration. */
  journeyVersion: Scalars['Long']['input'];
  /** The type of journey configuration */
  type?: InputMaybe<JiraJourneyConfigurationType>;
};

/** Input for deleting a navigation item. */
export type JiraDeleteNavigationItemInput = {
  /** Global identifier (ARI) for the navigation item to delete. */
  id: Scalars['ID']['input'];
};

/** This is an input argument for deleting project notification preferences. */
export type JiraDeleteProjectNotificationPreferencesInput = {
  /** The ARI of the project for which the notification preferences are to be deleted. */
  projectId: Scalars['ID']['input'];
};

export type JiraDeleteShortcutInput = {
  /** ARI of the project the shortcut is belongs to. */
  projectId: Scalars['ID']['input'];
  /** ARI of the shortcut */
  shortcutId: Scalars['ID']['input'];
};

/** The input to delete a version with no issues. */
export type JiraDeleteVersionWithNoIssuesInput = {
  /** The ID of the version to delete. */
  id: Scalars['ID']['input'];
};

export type JiraDeleteWorklogInput = {
  /** Accept ARI: worklog */
  id: Scalars['ID']['input'];
  /** Provide `null` to auto adjust remaining estimate. */
  remainingEstimate?: InputMaybe<JiraEstimateInput>;
};

/** The input contain details of a deployment app. */
export type JiraDeploymentAppInput = {
  /** Key name of the deployment app */
  appKey: Scalars['String']['input'];
};

/** The precondition state of the deployments JSW feature for a particular project and user. */
export enum JiraDeploymentsFeaturePrecondition {
  /** The deployments feature is available as the project has satisfied all precondition checks. */
  AllSatisfied = 'ALL_SATISFIED',
  /** The deployments feature is available and will show the empty-state page as no CI/CD provider is sending deployment data. */
  DeploymentsEmptyState = 'DEPLOYMENTS_EMPTY_STATE',
  /** The deployments feature is not available as the precondition checks have not been satisfied. */
  NotAvailable = 'NOT_AVAILABLE'
}

/** The possible config error type with a provider that feed devinfo details. */
export enum JiraDevInfoConfigErrorType {
  Incapable = 'INCAPABLE',
  NotConfigured = 'NOT_CONFIGURED',
  Unauthorized = 'UNAUTHORIZED',
  UnknownConfigError = 'UNKNOWN_CONFIG_ERROR'
}

/** The input type for a devOps association */
export type JiraDevOpsAssociationInput = {
  /** The association type */
  associationType: Scalars['String']['input'];
  /** List of associations */
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** The types of capabilities a devOps provider can support */
export enum JiraDevOpsCapability {
  Branch = 'BRANCH',
  Build = 'BUILD',
  Commit = 'COMMIT',
  Deployment = 'DEPLOYMENT',
  FeatureFlag = 'FEATURE_FLAG',
  PullRequest = 'PULL_REQUEST',
  Review = 'REVIEW'
}

/** The input type for devOps entity associations */
export type JiraDevOpsEntityAssociationsInput = {
  /** The associations to add to the entity ID */
  addAssociations?: InputMaybe<Array<JiraDevOpsAssociationInput>>;
  /** The entity ID to update the associations on */
  entityId: Scalars['ID']['input'];
  /** The associations to remove from the entity ID */
  removeAssociations?: InputMaybe<Array<JiraDevOpsAssociationInput>>;
};

export enum JiraDevOpsInContextConfigPromptLocation {
  DevelopmentPanel = 'DEVELOPMENT_PANEL',
  ReleasesPanel = 'RELEASES_PANEL',
  SecurityPanel = 'SECURITY_PANEL'
}

export enum JiraDevOpsIssuePanelBannerType {
  /** Banner that explains how to add issue keys in your commits, branches and PRs */
  IssueKeyOnboarding = 'ISSUE_KEY_ONBOARDING'
}

/** The possible States the DevOps Issue Panel can be in */
export enum JiraDevOpsIssuePanelState {
  /** Panel should show the available Dev Summary */
  DevSummary = 'DEV_SUMMARY',
  /** Panel should be hidden */
  Hidden = 'HIDDEN',
  /** Panel should show the "not connected" state to prompt user to integrate tools */
  NotConnected = 'NOT_CONNECTED'
}

export enum JiraDevOpsUpdateAssociationsEntityType {
  Vulnerability = 'VULNERABILITY'
}

/** The input type for updating devOps associations */
export type JiraDevOpsUpdateAssociationsInput = {
  /** List of entities with associations to add or remove */
  entityAssociations: Array<JiraDevOpsEntityAssociationsInput>;
  /** The type of the entities */
  entityType: JiraDevOpsUpdateAssociationsEntityType;
  /** The provider ID that the entities being associated belong to */
  providerId: Scalars['String']['input'];
};

export type JiraDisableJourneyConfigurationInput = {
  /** The entity tag of the journey configuration */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
  /** The version number of the entity. */
  version: Scalars['Long']['input'];
};

export type JiraDiscardUnpublishedChangesJourneyConfigurationInput = {
  /** The entity tag of the journey configuration */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
};

/** Input to revert the config of a board view to its globally published or default settings, discarding any user-specific settings. */
export type JiraDiscardUserBoardViewConfigInput = {
  /** ARI of the board view whose config is being reverted to its globally published or default settings. */
  viewId: Scalars['ID']['input'];
};

/** Input to revert the config of an issue search to its globally published or default settings, discarding user-specific settings. */
export type JiraDiscardUserIssueSearchConfigInput = {
  /** ARI of the issue search whose config is being reverted to its globally published or default settings. */
  viewId: Scalars['ID']['input'];
};

/** Input to revert the config of a timeline view to its globally published or default settings, discarding any user-specific settings. */
export type JiraDiscardUserTimelineViewConfigInput = {
  /** ARI of the timeline view whose config is being reverted to its globally published or default settings. */
  viewId: Scalars['ID']['input'];
};

/** Input to revert the config of a view to its globally published or default settings, discarding any user-specific settings. */
export type JiraDiscardUserViewConfigInput = {
  /** ARI of the view whose config is being reverted to its globally published or default settings. */
  viewId: Scalars['ID']['input'];
};

export type JiraDismissAiAgentSessionInput = {
  /** The agents identity account ID */
  agentIdentityAccountId: Scalars['String']['input'];
  /** Identifier for the cloud instance */
  cloudId: Scalars['ID']['input'];
  /** The conversation ID for the session */
  conversationId: Scalars['ID']['input'];
  /** ID of the issue the session relates to */
  issueId: Scalars['String']['input'];
  /** Sort key for ERS lookup */
  sortKey?: InputMaybe<Scalars['String']['input']>;
  /** The user who triggered to agents account ID */
  userAccountId?: InputMaybe<Scalars['String']['input']>;
};

/** The response payload to dismiss the banner that displays workspaces that are pending acceptance of access requests */
export type JiraDismissBitbucketPendingAccessRequestBannerInput = {
  /** if the banner should be dismissed. The default is true, if not given */
  isDismissed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The input type for devops panel banner dismissal */
export type JiraDismissDevOpsIssuePanelBannerInput = {
  /**
   * Only "issue-key-onboarding" is supported currently as this is the only banner
   * that can be displayed in the panel for now
   */
  bannerType: JiraDevOpsIssuePanelBannerType;
  /** ID of the issue this banner was dismissed on */
  issueId: Scalars['ID']['input'];
};

/** Input for dismissing a For You recommended action */
export type JiraDismissForYouRecommendedActionInput = {
  /** The category of the recommendation */
  category: JiraRecommendedActionCategoryType;
  /** The ARI of the entity to dismiss */
  entityAri: Scalars['ID']['input'];
};

/** The response payload to dismiss in-context configuration prompt that is per user setting */
export type JiraDismissInContextConfigPromptInput = {
  /** if the prompt should be dismissed. The default is true, if not given */
  isDismissed?: InputMaybe<Scalars['Boolean']['input']>;
  /** The location of the dismissed prompt. If array is empty, it won't do anything. */
  locations: Array<JiraDevOpsInContextConfigPromptLocation>;
};

/** The input for dismissing a suggestion group */
export type JiraDismissSuggestionGroupInput = {
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The reason for dismissing the suggestions */
  reason: Scalars['String']['input'];
  /** The IDs of the suggestions in the group to dismiss */
  suggestionIds: Array<Scalars['ID']['input']>;
};

/** The input for dismissing a single suggestion */
export type JiraDismissSuggestionInput = {
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The reason for dismissing the suggestion */
  reason: Scalars['String']['input'];
  /** The ID of the suggestion to dismiss */
  suggestionId: Scalars['ID']['input'];
};

/** Represents the input data required for Jira issue on a drag and drop mutation */
export type JiraDragAndDropBoardViewIssueInput = {
  /** @optional Destination cell ID to for the drop action and triggers the associated workflow as part of the drag and drop operation. Encoded as an ARI. */
  destinationCellId?: InputMaybe<Scalars['ID']['input']>;
  /** ID of the issue being actioned. Encoded as an ARI. */
  id: Scalars['ID']['input'];
  /** @optional Rank input to re-rank the issue as part of the drag and drop operation */
  rank?: InputMaybe<JiraIssueRankInput>;
  /** @optional Transition ID to transition an issue through its associated workflow as part of the drag and drop operation */
  transitionId?: InputMaybe<Scalars['Int']['input']>;
};

export type JiraDuplicateJourneyConfigurationInput = {
  /** Id of the existing journey configuration to be duplicated */
  id: Scalars['ID']['input'];
};

/** Input for OriginalEstimate field */
export type JiraDurationFieldInput = {
  /** Represents the time original estimate */
  originalEstimateField?: InputMaybe<Scalars['String']['input']>;
};

export type JiraEchoWhereInput = {
  /** If provided, the echo will return after this many milliseconds. */
  delayMs?: InputMaybe<Scalars['Int']['input']>;
  /** If provided and non-empty, the echo will return exactly this message. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** When true, the echo response will yield an error rather than a string value. */
  withDataError?: InputMaybe<Scalars['Boolean']['input']>;
  /** When true, the data fetcher will throw a RuntimeException. */
  withTopLevelError?: InputMaybe<Scalars['Boolean']['input']>;
};

export type JiraEditCustomFieldInput = {
  cloudId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  fieldFormatConfig?: InputMaybe<JiraFieldFormatConfigInput>;
  fieldId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  options?: InputMaybe<Array<JiraCustomFieldOptionInput>>;
  projectId: Scalars['String']['input'];
};

export type JiraEditFieldSchemeInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  schemeId: Scalars['ID']['input'];
};

/** Represents the possible email MIME types. */
export enum JiraEmailMimeType {
  Html = 'HTML',
  Text = 'TEXT'
}

/** Input type for Entitlement field */
export type JiraEntitlementFieldInput = {
  /** Represents entitlement field data */
  entitlement: JiraEntitlementInput;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

/** Input type representing a single entitlement */
export type JiraEntitlementInput = {
  /** An identifier for the entitlement */
  entitlementId: Scalars['ID']['input'];
};

/** Scope of values for the Entity (Ex: Field) */
export enum JiraEntityScope {
  Global = 'GLOBAL',
  Project = 'PROJECT'
}

/** Input type for epic link field */
export type JiraEpicLinkFieldInput = {
  /** Represents an epic link field */
  epicLink: JiraEpicLinkInput;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

/** Input type for epic link field */
export type JiraEpicLinkInput = {
  /** Issue key for epic */
  issueKey: Scalars['String']['input'];
};

export type JiraEstimateInput = {
  /** Does not currently support null. Use 0 to get a similar effect. */
  timeInSeconds: Scalars['Long']['input'];
};

/**
 * Input for Jira export issue details
 * Takes in issueId, along with options to include fields, comments, history and worklog
 */
export type JiraExportIssueDetailsInput = {
  /** Whether to include the issue comments in the export */
  includeComments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to include the issue fields in the export */
  includeFields?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to include the issue history in the export */
  includeHistory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to include the issue worklogs in the export */
  includeWorklogs?: InputMaybe<Scalars['Boolean']['input']>;
  /** ARI of the issue to be exported */
  issueId: Scalars['ID']['input'];
};

/**
 * Context where the extensions are supposed to be shown.
 *
 * Provide only the most specific entity. For example, there is no need to provide the project if an issue is given; the project will be inferred from the issue automatically.
 */
export type JiraExtensionRenderingContextInput = {
  issueKey?: InputMaybe<Scalars['String']['input']>;
  issueTypeId?: InputMaybe<Scalars['ID']['input']>;
  /** The JSM portal ID. */
  portalId?: InputMaybe<Scalars['ID']['input']>;
  projectKey?: InputMaybe<Scalars['String']['input']>;
  /** The JSM portal request type. Must be sent along `portalId` and without `projectKey` to have any effect. */
  requestTypeId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraFavouriteFilter = {
  /** Include archived projects in the result (applies to projects only, default to true) */
  includeArchivedProjects?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter the results by the keyword */
  keyword?: InputMaybe<Scalars['String']['input']>;
  /** Sorting the results. If not provided, the oldest favourited entity will be returned first. */
  sort?: InputMaybe<JiraFavouriteSortInput>;
  /** The Jira entity type to get. */
  type?: InputMaybe<JiraFavouriteType>;
  /** List of Jira entity types to get, if both type and types are provided, type will be ignored. */
  types?: InputMaybe<Array<JiraFavouriteType>>;
};

export type JiraFavouriteSortInput = {
  /**
   * The order to sort by.
   * ASC: oldest favourited entity will be returned first.
   * DESC: recent favourited entity will be returned first.
   */
  order: SortDirection;
};

/** Currently supported favouritable entities in Jira. */
export enum JiraFavouriteType {
  Board = 'BOARD',
  Dashboard = 'DASHBOARD',
  Filter = 'FILTER',
  Plan = 'PLAN',
  Project = 'PROJECT',
  Queue = 'QUEUE'
}

/** Represents an input to fieldAssociationWithIssueTypes query */
export type JiraFieldAssociationWithIssueTypesInput = {
  /** Search fields by list of field type groups. If empty, fields will not be filtered by field type group. */
  fieldTypeGroups?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search fields by field name. If null or empty, fields will not be filtered by field name. */
  filterContains?: InputMaybe<Scalars['String']['input']>;
  /** Search fields by list of issue types. If empty, fields will not be filtered by issue type. */
  issueTypeIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type JiraFieldAvailableWorkTypesInput = {
  nameFilter?: InputMaybe<Scalars['String']['input']>;
  schemeId?: InputMaybe<Scalars['ID']['input']>;
};

export enum JiraFieldCategoryType {
  /**  Represents the custom fields */
  Custom = 'CUSTOM',
  /**  Represents the system fields */
  System = 'SYSTEM'
}

export type JiraFieldConfigFilterInput = {
  /**
   * If includedFieldCategories is set to 'SYSTEM', this field is ignored.
   *
   * This field is merged with includedFieldCategories.
   * If both fields are provided, the result will include the matched system and custom field types of includedFieldCategories and all matched Connect and Forge custom field types.
   * If none of them are provided, the result will include all matched system and custom field types.
   */
  addConnectAndForgeFieldsToIncludedFieldTypes?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The field ID alias.
   * Applies to managed or commonly known custom fields in Jira, which allow lookup without requiring the custom field ID.
   * E.g. rank or startdate.
   * If specified, the result will only contain the fields that matches the provided aliasFieldIds
   */
  aliasFieldIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  The cloud id of the tenant. */
  cloudId: Scalars['ID']['input'];
  /**  If specified the result will be filtered by specific fieldIds */
  fieldIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  The field scope, if not provided it will use FieldScope.ALL */
  fieldScope?: InputMaybe<JiraFieldScopeType>;
  /**  Field Status, if not provided it will include only active fields. */
  fieldStatus?: InputMaybe<JiraFieldStatusType>;
  /**  Field Category if not provided it will include all field categories. */
  includedFieldCategories?: InputMaybe<Array<JiraFieldCategoryType>>;
  /**
   * If includedFieldCategories is set to 'CUSTOM', system field types in this field are ignored.
   * If includedFieldCategories is set to 'SYSTEM', custom field types in this field are ignored.
   *
   * This field is merged with addConnectAndForgeFieldsToIncludedFieldTypes.
   * If both fields are provided, the result will include the matched system and custom field types of this field and all matched Connect and Forge custom field types.
   * If none of them are provided, the result will include all matched system and custom field types.
   */
  includedFieldTypes?: InputMaybe<Array<JiraConfigFieldType>>;
  /**  Sort the result by the specified field */
  orderBy?: InputMaybe<JiraFieldConfigOrderBy>;
  /**  Sort the result in the specified order */
  orderDirection?: InputMaybe<JiraFieldConfigOrderDirection>;
  /**  If not specified all field configs in the system across projects will be returned */
  projectIdOrKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  The search string used to perform a contains search on the field name of the Field config */
  searchString?: InputMaybe<Scalars['String']['input']>;
};

export enum JiraFieldConfigOrderBy {
  /**  Available for only active fields */
  ContextCount = 'CONTEXT_COUNT',
  /**  Available for both trashed and active fields */
  Description = 'DESCRIPTION',
  /**  Available for both trashed and active fields */
  FieldType = 'FIELD_TYPE',
  /**  Available for both trashed and active fields */
  Id = 'ID',
  /**  Available for both trashed and active fields */
  IsGlobal = 'IS_GLOBAL',
  /**  Available for only active fields */
  LastUsed = 'LAST_USED',
  /**  Available for both trashed and active fields */
  Name = 'NAME',
  /**  Available for only trashed fields */
  PlannedDeleteDate = 'PLANNED_DELETE_DATE',
  /**  Available for only active fields */
  ProjectCount = 'PROJECT_COUNT',
  /**  Available for only active fields */
  ScreenCount = 'SCREEN_COUNT',
  /**  Available for only trashed fields */
  TrashedDate = 'TRASHED_DATE'
}

export enum JiraFieldConfigOrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

/** Available / Associated Field Config Schemes can optionally be filtered using nameOrDescriptionFilter */
export type JiraFieldConfigSchemesInput = {
  nameOrDescriptionFilter?: InputMaybe<Scalars['String']['input']>;
};

/** Input for filtering contextual data. */
export type JiraFieldContextualDataFilterInput = {
  /** A list of field IDs to filter by. */
  fieldIds: Array<Scalars['String']['input']>;
  /** A list of scopes to filter by. */
  scopes?: InputMaybe<Array<JiraFieldContextualDataScopeFilterInput>>;
};

/** Input for defining a scope to filter by. */
export type JiraFieldContextualDataScopeFilterInput = {
  /**
   * The ID of the issue type.
   * IMPORTANT: Issue Type level context is not supported at the moment and this field should be set to null.
   */
  issueTypeId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the project. */
  projectId?: InputMaybe<Scalars['ID']['input']>;
};

/** The input format configuration of the field. */
export type JiraFieldFormatConfigInput = {
  /** The input format configuration for a number field. */
  jiraNumberFieldFormatConfigInput?: InputMaybe<JiraNumberFieldFormatConfigInput>;
};

export type JiraFieldKeyValueInput = {
  key?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Represents argument input type for `fieldOptions` query to provide capability to filter field options by list of IDs */
export type JiraFieldOptionIdsFilterInput = {
  /** Filter operation to perform on the list of optionsIds provided in input. */
  operation: JiraFieldOptionIdsFilterOperation;
  /**
   * Filter the available field options with provided option ids by specifying a filter operation.
   * Upto maximum 100 Option Ids are can be provided in the input.
   * Accepts ARI(s): OptionID
   */
  optionIds: Array<Scalars['ID']['input']>;
};

/** Enum to define a filter operation on the optionIds in input JiraFieldOptionIdsFilterInput */
export enum JiraFieldOptionIdsFilterOperation {
  /**
   * Allow the optionIds provided in the JiraFieldOptionIdsFilterInput from available options
   * with intersection of result from searchBy query string.
   */
  Allow = 'ALLOW',
  /**
   * Exclude the optionIds provided in the JiraFieldOptionIdsFilterInput from available options
   * with intersection of result from searchBy query string.
   */
  Exclude = 'EXCLUDE'
}

export type JiraFieldSchemeAssociatedFieldsInput = {
  /** Search fields by list of field type groups. If empty, fields will not be filtered by field type group. */
  fieldTypeGroupsFilter?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search fields by field name or description. If null or empty, fields will not be filtered by field name or description. */
  nameOrDescriptionFilter?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier of the field scheme. */
  schemeId: Scalars['ID']['input'];
};

export type JiraFieldSchemeAvailableFieldsInput = {
  /** Search fields by field name or description. If null or empty, fields will not be filtered by field name or description. */
  nameOrDescriptionFilter?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier of the field scheme. */
  schemeId: Scalars['ID']['input'];
};

/** Only one of the following fields in this input must be provided. */
export type JiraFieldSchemeSourceInput = {
  /** Specify this field to copy items from an existing legacy Field Configuration Scheme. */
  sourceFieldConfigurationSchemeId?: InputMaybe<Scalars['ID']['input']>;
  /** Specify this field to copy items from an existing Field Scheme. */
  sourceFieldSchemeId?: InputMaybe<Scalars['ID']['input']>;
  /** Specify this field to copy items from the default legacy Field Configuration Scheme. */
  useDefaultFieldConfigScheme?: InputMaybe<Scalars['Boolean']['input']>;
};

export type JiraFieldSchemesInput = {
  nameOrDescriptionFilter?: InputMaybe<Scalars['String']['input']>;
};

export enum JiraFieldScopeType {
  /**  Represents all field scopes */
  All = 'ALL',
  /**  Represents global scoped fields */
  Global = 'GLOBAL',
  /**  Represents project scoped fields */
  Project = 'PROJECT'
}

export type JiraFieldSetPreferencesInput = {
  /** The field set id. */
  fieldSetId: Scalars['String']['input'];
  /** The width of the field set. */
  width?: InputMaybe<Scalars['Int']['input']>;
};

export type JiraFieldSetPreferencesMutationInput = {
  /** Input object which contains the fieldSets preferences */
  nodes?: InputMaybe<Array<JiraUpdateFieldSetPreferencesInput>>;
};

export type JiraFieldSetsMutationInput = {
  /** Input object which contains the new fieldSets */
  replaceFieldSetsInput?: InputMaybe<JiraReplaceIssueSearchViewFieldSetsInput>;
  /** Resets the fieldSets of a view to default fieldSets for given fieldset context, the logic depends on the context provided. */
  scopedResetToDefaultFieldSets?: InputMaybe<JiraScopedResetFieldsetsInput>;
};

export enum JiraFieldStatusType {
  /**  Represents the field that is active or unassociated */
  Active = 'ACTIVE',
  /**  Represents the field that is deleted */
  Trashed = 'TRASHED'
}

export type JiraFieldToFieldConfigSchemeAssociationsInput = {
  fieldId: Scalars['ID']['input'];
  schemeIdsToAdd: Array<InputMaybe<Scalars['ID']['input']>>;
  schemeIdsToRemove: Array<InputMaybe<Scalars['ID']['input']>>;
};

export type JiraFieldToFieldSchemeAssociationsInput = {
  fieldId: Scalars['ID']['input'];
  schemeIdsToAdd: Array<Scalars['ID']['input']>;
  schemeIdsToRemove: Array<Scalars['ID']['input']>;
};

/**
 * ##############
 * # Mutations ##
 * ##############
 */
export type JiraFieldWorkTypeAssociationsInput = {
  availableOnAllWorkTypes: Scalars['Boolean']['input'];
  workTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * This type represents input sent by the Advanced settings panel of Scheme Fields Management feature.
 * The work type associations and customisations have a single save button, and
 * hence are packaged into a single input object.
 */
export type JiraFieldWorkTypeCustomizationsInput = {
  descriptionCustomisations?: InputMaybe<Array<JiraFieldWorkTypeDescriptionCustomizationInput>>;
  fieldId: Scalars['ID']['input'];
  /**
   * Required customisations with support for 'required on all work types'.
   * Use this instead of requiredOnWorkTypeIds for new implementations.
   */
  requiredCustomizations?: InputMaybe<Array<JiraFieldWorkTypeRequiredOnCustomizationInput>>;
  schemeId: Scalars['ID']['input'];
  workTypeAssociations: JiraFieldWorkTypeAssociationsInput;
};

export type JiraFieldWorkTypeDescriptionCustomizationInput = {
  /**  null = remove customization (use field's description), non-null = set custom description */
  description?: InputMaybe<Scalars['String']['input']>;
  isDefault: Scalars['Boolean']['input'];
  workTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * Represents a required customization for a field on work types.
 *
 * Supported combinations:
 * - Option 1: workTypeIds: [], appliesToAllWorkTypes: true, isRequired: true
 *    Required on ALL work types
 * - Option 2: workTypeIds: [], appliesToAllWorkTypes: true, isRequired: false
 *    Not required on ALL work types
 * - Option 3: workTypeIds: [1,2,3], appliesToAllWorkTypes: false, isRequired: true
 *    Required on SPECIFIC work types
 * - Option 4: workTypeIds: [], appliesToAllWorkTypes: false, isRequired: *
 *    USER ERROR - Cannot have no work types without applying to all
 * - Option 5: workTypeIds: [1,2,3], appliesToAllWorkTypes: true, isRequired: *
 *    USER ERROR - Cannot specify specific work types AND apply to all (contradictory)
 */
export type JiraFieldWorkTypeRequiredOnCustomizationInput = {
  /** Whether this customization applies to all work types (default behavior). */
  appliesToAllWorkTypes: Scalars['Boolean']['input'];
  /** Whether the field is required. */
  isRequired: Scalars['Boolean']['input'];
  /** The IDs of specific work types this customization applies to. Empty if appliesToAllWorkTypes is true. */
  workTypeIds: Array<Scalars['ID']['input']>;
};

/** The options for filter search mode for user preference in List Filter switcher tab. */
export enum JiraFilterSearchMode {
  /** Advanced search mode in List Filter switcher tab */
  Advanced = 'ADVANCED',
  /** Basic search mode in List Filter switcher tab */
  Basic = 'BASIC',
  /** JQL search mode in List Filter switcher tab */
  Jql = 'JQL'
}

/** Operations that can be performed on flag field. */
export enum JiraFlagOperations {
  /** Adds flag to an issue. */
  Add = 'ADD',
  /** Removes flag from an issue. */
  Remove = 'REMOVE'
}

/** The environment type the extension can be installed into. See [Environments and versions](https://developer.atlassian.com/platform/forge/environments-and-versions/) for more details. */
export enum JiraForgeEnvironmentType {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING'
}

/** Input type for forge groups fields */
export type JiraForgeGroupsFieldInput = {
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List of groups associated with the field */
  selectedGroups: Array<JiraGroupInput>;
};

/** Input type for defining the operation on the ForgeMultipleGroupPicker field of a Jira issue. */
export type JiraForgeMultipleGroupPickerFieldOperationInput = {
  /**
   * Group Id(s) for field update.
   * Accepts ARI(s): group
   */
  ids?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Group names for field update. */
  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Operations supported: ADD, REMOVE and SET. */
  operation: JiraMultiValueFieldOperations;
};

export type JiraForgeObjectFieldOperationInput = {
  object?: InputMaybe<Scalars['String']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Represents an entity, that a panel can be pinned to. */
export type JiraForgePinnableEntity = {
  /** The unique id or key of the project. If not provided, the panel will be pinned only to the work item. */
  projectIdOrKey?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for defining the operation on the ForgeSingleGroupPicker field of a Jira issue. */
export type JiraForgeSingleGroupPickerFieldOperationInput = {
  /**
   * Group Id for field update.
   * Accepts ARI: group
   */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Group name for field update. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Operation supported: SET. */
  operation: JiraSingleValueFieldOperations;
};

/** Input for forge strings field */
export type JiraForgeStringsFieldInput = {
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /**
   * "
   * List of labels on which the action will be performed
   */
  labels: Array<JiraLabelsInput>;
};

/** The action to perform on the panel in Jira. */
export type JiraForgeUpdatePanelAction = {
  /** The type of action to be performed. */
  actionType: JiraForgeUpdatePanelActionType;
  /** The unique identifier or key of the project associated with the action. Required for certain actions like pinning or unpinning. */
  projectIdOrKey?: InputMaybe<Scalars['String']['input']>;
};

/** Types of actions that can be performed on a work item panel. */
export enum JiraForgeUpdatePanelActionType {
  /** Collapse the panel. */
  Collapse = 'COLLAPSE',
  /** Expand the panel. */
  Expand = 'EXPAND',
  /** Pin the panel to a specific project. */
  PinToProject = 'PIN_TO_PROJECT',
  /** Unpin the panel from a specific project. */
  UnpinFromProject = 'UNPIN_FROM_PROJECT'
}

/** Input required to update a work item panel in Jira. */
export type JiraForgeUpdatePanelInput = {
  /** The action to perform on the panel (e.g., pin to project, unpin, collapse, expand). */
  action: JiraForgeUpdatePanelAction;
  /** The unique identifier for the Jira Cloud tenant making the request, required for AGG routing. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The instance ID of the panel. Required for updates to existing panels.
   * Leave empty when creating a new panel.
   */
  instanceId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The unique ID of the Forge extension in the format: `ari:cloud:ecosystem::extension/{app-id}/{env-id}/static/{module-key}`.
   *
   * Example: `ari:cloud:ecosystem::extension/e62f20a2-4b61-4dbe-bfb9-9a88b5e3ac84/548c5df1-24aa-4f7c-bbbb-3038d947cb05/static/module-key`.
   */
  moduleId: Scalars['ID']['input'];
  /** The unique id or key of the work item. This is required to create a panel instance. */
  workItemIdOrKey: Scalars['String']['input'];
};

/** Input for forge users fields */
export type JiraForgeUsersFieldInput = {
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Input data for users being selected */
  users: Array<JiraUserInput>;
};

/** Context for which the panels are being fetched for. */
export type JiraForgeWorkItemPanelsContextInput = {
  /** Id or key of the work item. */
  workItemIdOrKey: Scalars['String']['input'];
};

export enum JiraForgeWorkItemPinnableEntityType {
  Project = 'PROJECT',
  WorkItem = 'WORK_ITEM'
}

export enum JiraFormattingArea {
  Cell = 'CELL',
  Row = 'ROW'
}

export enum JiraFormattingColor {
  /** @deprecated Use JiraColor instead */
  Blue = 'BLUE',
  /** @deprecated Use JiraColor instead */
  Green = 'GREEN',
  /** @deprecated Use JiraColor instead */
  Red = 'RED'
}

export type JiraFormattingMultipleValueOperandInput = {
  fieldId: Scalars['String']['input'];
  operator: JiraFormattingMultipleValueOperator;
  values: Array<Scalars['String']['input']>;
};

export enum JiraFormattingMultipleValueOperator {
  Contains = 'CONTAINS',
  DoesNotContain = 'DOES_NOT_CONTAIN',
  HasAnyOf = 'HAS_ANY_OF'
}

export type JiraFormattingNoValueOperandInput = {
  fieldId: Scalars['String']['input'];
  operator: JiraFormattingNoValueOperator;
};

export enum JiraFormattingNoValueOperator {
  IsEmpty = 'IS_EMPTY',
  IsNotEmpty = 'IS_NOT_EMPTY'
}

export type JiraFormattingRuleExpressionInput = {
  multipleValueOperand?: InputMaybe<JiraFormattingMultipleValueOperandInput>;
  noValueOperand?: InputMaybe<JiraFormattingNoValueOperandInput>;
  singleValueOperand?: InputMaybe<JiraFormattingSingleValueOperandInput>;
  twoValueOperand?: InputMaybe<JiraFormattingTwoValueOperandInput>;
};

export type JiraFormattingSingleValueOperandInput = {
  fieldId: Scalars['String']['input'];
  operator: JiraFormattingSingleValueOperator;
  value: Scalars['String']['input'];
};

export enum JiraFormattingSingleValueOperator {
  Contains = 'CONTAINS',
  DoesNotContain = 'DOES_NOT_CONTAIN',
  DoesNotEqual = 'DOES_NOT_EQUAL',
  Equals = 'EQUALS',
  GreaterThan = 'GREATER_THAN',
  GreaterThanOrEquals = 'GREATER_THAN_OR_EQUALS',
  Is = 'IS',
  IsAfter = 'IS_AFTER',
  IsBefore = 'IS_BEFORE',
  IsNot = 'IS_NOT',
  IsOnOrAfter = 'IS_ON_OR_AFTER',
  IsOnOrBefore = 'IS_ON_OR_BEFORE',
  LessThan = 'LESS_THAN',
  LessThanOrEquals = 'LESS_THAN_OR_EQUALS'
}

export type JiraFormattingTwoValueOperandInput = {
  fieldId: Scalars['String']['input'];
  first: Scalars['String']['input'];
  operator: JiraFormattingTwoValueOperator;
  second: Scalars['String']['input'];
};

export enum JiraFormattingTwoValueOperator {
  IsBetween = 'IS_BETWEEN',
  IsNotBetween = 'IS_NOT_BETWEEN'
}

export type JiraFormulaFieldExpressionConfigInput = {
  /** The formula expression. */
  expression?: InputMaybe<Scalars['String']['input']>;
};

export type JiraFormulaFieldFixContext = {
  /** The prompt entered by the user */
  existingFormula: Scalars['String']['input'];
  /** The field ID of the formula field if applicable */
  fieldId?: InputMaybe<Scalars['String']['input']>;
  /** The issueKey where the formula field is being created/edited if applicable */
  issueKey?: InputMaybe<Scalars['String']['input']>;
  /** Previous responses returned by the AI */
  previousResponses?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The project ID where the formula field is being created/edited if applicable */
  projectId?: InputMaybe<Scalars['String']['input']>;
};

export type JiraFormulaFieldSuggestionContext = {
  /** The field ID of the formula field if applicable */
  fieldId?: InputMaybe<Scalars['String']['input']>;
  /** The issueKey where the formula field is being created/edited if applicable */
  issueKey?: InputMaybe<Scalars['String']['input']>;
  /** The prompt entered by the user */
  naturalLanguagePrompt: Scalars['String']['input'];
  /** Previous responses returned by the AI */
  previousResponses?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The project ID where the formula field is being created/edited if applicable */
  projectId?: InputMaybe<Scalars['String']['input']>;
};

export enum JiraFormulaFieldType {
  Datetime = 'DATETIME',
  Number = 'NUMBER',
  Text = 'TEXT'
}

/** Input for generating an AI summary for a Jira issue. */
export type JiraGenerateIssueAiSummaryInput = {
  /** The Jira issue ARI (ID). */
  issueId: Scalars['ID']['input'];
};

export type JiraGetIssueResourceInput = {
  /**
   * The index based cursor to specify the beginning of the items.
   * If not specified it's assumed as the cursor for the item before the beginning.
   */
  after?: InputMaybe<Scalars['String']['input']>;
  /** The input for the Jira attachments with filters query. */
  filters?: InputMaybe<Array<InputMaybe<JiraIssueResourceFilters>>>;
  /** The number of items after the cursor to be returned in a forward page. */
  first: Scalars['Int']['input'];
  /** The direction in which the results are ordered. */
  orderDirection?: InputMaybe<JiraResourcesSortDirection>;
  /** The field by which the results are ordered. */
  orderField?: InputMaybe<JiraResourcesOrderField>;
  /**
   * Enhanced pagination input supporting both cursor and offset pagination.
   * If provided, takes precedence over first/after parameters.
   */
  pagination?: InputMaybe<JiraResourcePaginationInput>;
};

/** The global issue create modal view types. */
export enum JiraGlobalIssueCreateView {
  /** The global issue create full modal view. */
  FullModal = 'FULL_MODAL',
  /** The global issue create mini modal view. */
  MiniModal = 'MINI_MODAL'
}

export type JiraGlobalPermissionAddGroupGrantInput = {
  /** The group ari to be added. */
  groupAri: Scalars['ID']['input'];
  /** The unique key of the permission. */
  key: Scalars['String']['input'];
};

export type JiraGlobalPermissionDeleteGroupGrantInput = {
  /** The group ari to be deleted. */
  groupAri: Scalars['ID']['input'];
  /** The unique key of the permission. */
  key: Scalars['String']['input'];
};

export type JiraGlobalPermissionSetUserGroupsInput = {
  /** The list of group ARIs to set for this permission. This replaces all existing groups. */
  groupAris: Array<Scalars['ID']['input']>;
  /** The unique key of the permission. */
  key: Scalars['String']['input'];
};

/** Different Global permissions that the user can have */
export enum JiraGlobalPermissionType {
  /**
   * Create and administer projects, issue types, fields, workflows, and schemes for all projects.
   * Users with this permission can perform most administration tasks, except: managing users,
   * importing data, and editing system email settings.
   */
  Administer = 'ADMINISTER',
  /**
   * Grants access to the full custom onboarding functionality, including creating and editing
   * content, plus access to custom onboarding analytics.
   */
  ManageCustomOnboarding = 'MANAGE_CUSTOM_ONBOARDING',
  /** Users with this permission can see the names of all users and groups on your site. */
  UserPicker = 'USER_PICKER'
}

export enum JiraGoalStatus {
  Archived = 'ARCHIVED',
  AtRisk = 'AT_RISK',
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Done = 'DONE',
  OffTrack = 'OFF_TRACK',
  OnTrack = 'ON_TRACK',
  Paused = 'PAUSED',
  Pending = 'PENDING'
}

/**
 * The grant type key enum represents all the possible grant types available in Jira.
 * A grant type may take an optional parameter value.
 * For example: PROJECT_ROLE grant type takes project role id as parameter. And, PROJECT_LEAD grant type do not.
 *
 * The actual ARI formats are documented on the various concrete grant type values.
 */
export enum JiraGrantTypeKeyEnum {
  /**
   * The anonymous access represents the public access without logging in.
   * It takes no parameter.
   */
  AnonymousAccess = 'ANONYMOUS_ACCESS',
  /**
   * Any user who has the product access.
   * It takes no parameter.
   */
  AnyLoggedinUserApplicationRole = 'ANY_LOGGEDIN_USER_APPLICATION_ROLE',
  /**
   * A application role is used to grant a user/group access to the application group.
   * It takes application role as parameter.
   */
  ApplicationRole = 'APPLICATION_ROLE',
  /**
   * The issue assignee role.
   * It takes platform defined 'assignee' as parameter to represent the issue field value.
   */
  Assignee = 'ASSIGNEE',
  /**
   * A group is a collection of users who can be given access together.
   * It represents group in the organization's user base.
   * It takes group id as parameter.
   */
  Group = 'GROUP',
  /**
   * A multi group picker custom field.
   * It takes multi group picker custom field id as parameter.
   */
  MultiGroupPicker = 'MULTI_GROUP_PICKER',
  /**
   * A multi user picker custom field.
   * It takes multi user picker custom field id as parameter.
   */
  MultiUserPicker = 'MULTI_USER_PICKER',
  /**
   * The project lead role.
   * It takes no parameter.
   */
  ProjectLead = 'PROJECT_LEAD',
  /**
   * A role that user/group can play in a project.
   * It takes project role as parameter.
   */
  ProjectRole = 'PROJECT_ROLE',
  /**
   * The issue reporter role.
   * It takes platform defined 'reporter' as parameter to represent the issue field value.
   */
  Reporter = 'REPORTER',
  /**
   * The grant type defines what the customers can do from the portal view.
   * It takes no parameter.
   */
  ServiceProjectCustomerPortalAccess = 'SERVICE_PROJECT_CUSTOMER_PORTAL_ACCESS',
  /**
   * An individual user who can be given the access to work on one or more projects.
   * It takes user account id as parameter.
   */
  User = 'USER'
}

export type JiraGroupByDropdownFilter = {
  projectId?: InputMaybe<Scalars['String']['input']>;
  searchString?: InputMaybe<Scalars['String']['input']>;
};

/** Input for Groups values on fields */
export type JiraGroupInput = {
  /** Unique identifier for group field */
  groupName: Scalars['ID']['input'];
};

export enum JiraGroupManagedBy {
  Admins = 'ADMINS',
  External = 'EXTERNAL',
  Open = 'OPEN',
  TeamMembers = 'TEAM_MEMBERS'
}

export enum JiraGroupUsageType {
  TeamCollaboration = 'TEAM_COLLABORATION',
  UserbaseGroup = 'USERBASE_GROUP'
}

/** The types of Contexts supported by Groups field. */
export enum JiraGroupsContext {
  /** This corresponds to fields that accepts only "Group" entities as RHS value. */
  Group = 'GROUP',
  /** This corresponds to fields that accepts "User" entities as RHS value. */
  User = 'USER'
}

/** The different home page types a user can be directed to. */
export enum JiraHomePageType {
  /** The Dashboards home page */
  Dashboards = 'DASHBOARDS',
  /** The login redirect page for some anonymous users */
  LoginRedirect = 'LOGIN_REDIRECT',
  /** The Projects directory home page */
  ProjectsDirectory = 'PROJECTS_DIRECTORY',
  /** The Your Work home page */
  YourWork = 'YOUR_WORK'
}

export type JiraHydrateJqlInput = {
  /** ID of the filter used for hydration */
  filterId?: InputMaybe<Scalars['ID']['input']>;
  /** Identifies a view. The JQL persisted in this view's configuration will be retrieved and used for hydration. */
  jiraViewQueryInput?: InputMaybe<JiraViewQueryInput>;
  /** JQL query used for hydration */
  jql?: InputMaybe<Scalars['String']['input']>;
  /** Scope of the search, used to get the last used JQL query */
  lastUsedJqlForIssueNavigator?: InputMaybe<JiraJqlScopeInput>;
};

/** The JSM incident priority values */
export enum JiraIncidentPriority {
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5'
}

/** This is the input argument for initializing the project notification preferences. */
export type JiraInitializeProjectNotificationPreferencesInput = {
  /** The ARI of the project for which the notification preferences are to be initialized. */
  projectId: Scalars['ID']['input'];
};

/** Represents the input data required for Jira inline issue creation. */
export type JiraInlineIssueCreateInput = {
  /** Field to get board JQL */
  boardId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Field data to populate the created issues with.
   * Mandatory due to required fields such as Summary.
   */
  fields: JiraIssueFieldsInput;
  /** Issue type of issue to create, encoded as an ARI */
  issueTypeId: Scalars['ID']['input'];
  /** A list of JQLs of the issue is being created with */
  jqlContexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Field to specify the destination of the created issue */
  kanbanDestination?: InputMaybe<JiraKanbanDestination>;
  /** Project to create issue within, encoded as an ARI */
  projectId: Scalars['ID']['input'];
  /** Rank issue following creation */
  rank?: InputMaybe<JiraIssueCreateRankInput>;
};

/**
 * DEPRECATED: Banner experiment is no longer active
 *
 * The precondition state of the install-deployments banner for a particular project and user.
 */
export enum JiraInstallDeploymentsBannerPrecondition {
  /** The deployments banner is available but no CI/CD provider is sending deployment data. */
  DeploymentsEmptyState = 'DEPLOYMENTS_EMPTY_STATE',
  /** The deployments banner is available but the feature has not been enabled. */
  FeatureNotEnabled = 'FEATURE_NOT_ENABLED',
  /** The deployments banner is not available as the precondition checks have not been satisfied. */
  NotAvailable = 'NOT_AVAILABLE'
}

/** Option on where to fetch the summary from */
export enum JiraIssueAiSummaryType {
  /**
   * Generate a new AI summary
   * @deprecated Use jira.generateIssueAISummary mutation
   */
  OnDemand = 'ON_DEMAND',
  /** Return AI summary from ERS */
  PageLoad = 'PAGE_LOAD'
}

/** Types of Jira issue activity fields */
export enum JiraIssueActivityType {
  /** Issues that were created */
  Created = 'CREATED',
  /** Issues that were updated */
  Updated = 'UPDATED'
}

export type JiraIssueArchiveAsyncInput = {
  /** Accepts JQL string */
  jql: Scalars['String']['input'];
};

export type JiraIssueArchiveInput = {
  /** Accept ARI(s): issue */
  ids: Array<Scalars['ID']['input']>;
};

/**
 * Represents filters for attachments of an issue.
 * In Future can add multiple filter options like fileName, authorId, dateRange, etc.
 */
export type JiraIssueAttachmentFilterInput = {
  /** List of file types to be used as filters. Attachments matching these types will be included in the response. */
  mimeTypes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type JiraIssueBranchesInput = {
  /** Sets if the field should return only legacy SCM branches provided by Application Link or also the ones in TWG */
  filterLegacy?: InputMaybe<Scalars['Boolean']['input']>;
};

export type JiraIssueChangeInput = {
  /** The ID in numeric format (e.g. 10000) of the issue for which to retrieve the search view contexts. */
  issueId: Scalars['String']['input'];
};

export type JiraIssueCommitsInput = {
  /** Sets if the field should return only legacy SCM commits provided by Application Link or also the ones in TWG */
  filterLegacy?: InputMaybe<Scalars['Boolean']['input']>;
};

export type JiraIssueCreateFieldValidationRule = {
  /** User-specified custom error message */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  /** Field IDs on which the validation is to be applied for example summary, description, attachment etc. */
  fields: Array<Scalars['String']['input']>;
  /** Type of validation to be applied */
  type: JiraIssueCreateFieldValidationType;
};

export enum JiraIssueCreateFieldValidationType {
  Fieldrequiredvalidator = 'FIELDREQUIREDVALIDATOR'
}

/** Represents the input data required for Jira issue creation. */
export type JiraIssueCreateInput = {
  /** Field data to populate the created issue with. Mandatory due to required fields such as Summary. */
  fields: JiraIssueFieldsInput;
  /** Issue type of issue to create, encoded as an ARI */
  issueTypeId: Scalars['ID']['input'];
  /** Project to create issue within, encoded as an ARI */
  projectId: Scalars['ID']['input'];
  /** Rank Issue following creation */
  rank?: InputMaybe<JiraIssueCreateRankInput>;
  /** Transition ID to transition an issue through its associated workflow as part of the create issue. Overrides the status set in fields. */
  transitionId?: InputMaybe<Scalars['Int']['input']>;
};

/** @deprecated To be replaced with JiraIssueRankInput */
export type JiraIssueCreateRankInput = {
  /** ID of Issue after which the created issue should be ranked. Encoded as an ARI. Cannot be sent alongside before. */
  afterIssueId?: InputMaybe<Scalars['ID']['input']>;
  /** ID of Issue before which the created issue should be ranked. Encoded as an ARI. Cannot be sent alongside after. */
  beforeIssueId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraIssueCreateValidationRule = {
  /** Field-level validation rules */
  fieldValidations?: InputMaybe<Array<JiraIssueCreateFieldValidationRule>>;
};

/** Represents the input data required for Jira issue deletion. */
export type JiraIssueDeleteInput = {
  /**
   * Whether to delete subtasks of the issue being deleted.
   * Defaults to false.
   */
  deleteSubtasks?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID of the issue to delete. Encoded as an ARI. */
  id: Scalars['ID']['input'];
};

/** Possible states for a deployment environment */
export enum JiraIssueDeploymentEnvironmentState {
  /** The deployment was deployed successfully */
  Deployed = 'DEPLOYED',
  /** The deployment was not deployed successfully */
  NotDeployed = 'NOT_DEPLOYED'
}

export type JiraIssueExpandedGroup = {
  /** The field value used to group issues. */
  fieldValue?: InputMaybe<Scalars['String']['input']>;
  /**
   * The number of issues to fetch to determine the position of the current issue.
   * If not specified, it is up to the server to determine a default limit.
   */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** The JQL that's used to fetch issues for the group. */
  jql: Scalars['String']['input'];
};

export type JiraIssueExpandedGroups = {
  /** The ID of the field used to group issues in the current view. */
  groupedByFieldId: Scalars['String']['input'];
  groups?: InputMaybe<Array<JiraIssueExpandedGroup>>;
};

export type JiraIssueExpandedParent = {
  /**
   * The number of issues to fetch to determine the position of the current issue.
   * If not specified, it is up to the server to determine a default limit.
   */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** The id of the issue that's expanded. */
  parentIssueId: Scalars['String']['input'];
};

/** Input for the onIssueExported subscription. */
export type JiraIssueExportInput = {
  /** Unique ID for the Jira cloud instance. */
  cloudId: Scalars['ID']['input'];
  /** Whether to exclude work items with "done" status category */
  excludeDoneWorkItems?: InputMaybe<Scalars['Boolean']['input']>;
  /** Type of export, e.g., CSV_CURRENT_FIELDS or CSV_WITH_BOM_ALL_FIELDS. */
  exportType?: InputMaybe<JiraIssueExportType>;
  /** List of field set ids that can be used to influence which columns are shown in the csv */
  fieldSetIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ID of the Jira filter. Uses filter's JQL if 'modified' is false. */
  filterId?: InputMaybe<Scalars['String']['input']>;
  /** JQL query for exporting issues. Used if no filterId or 'modified' is true. */
  jql?: InputMaybe<Scalars['String']['input']>;
  /** Maximum number of issues to export. */
  maxResults?: InputMaybe<Scalars['Int']['input']>;
  /** If true, use 'jql' instead of the filter's JQL. */
  modified?: InputMaybe<Scalars['Boolean']['input']>;
  /** The scope in which the issue search was performed */
  scope?: InputMaybe<JiraIssueSearchScope>;
  /** Whether timeline aggregation is enabled in the current view. Used by CSV export to determine if aggregated columns should be included. */
  timelineAggregationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Types of exports available. */
export enum JiraIssueExportType {
  /** Export to CSV with all fields. */
  CsvAllFields = 'CSV_ALL_FIELDS',
  /** Export to CSV with current visible fields. */
  CsvCurrentFields = 'CSV_CURRENT_FIELDS',
  /** Export to CSV with user default fields (for saved filters). */
  CsvFilterDefaultFields = 'CSV_FILTER_DEFAULT_FIELDS',
  /** Export to CSV with BOM, all fields. */
  CsvWithBomAllFields = 'CSV_WITH_BOM_ALL_FIELDS',
  /** Export to CSV with BOM, current fields. */
  CsvWithBomCurrentFields = 'CSV_WITH_BOM_CURRENT_FIELDS',
  /** Export to CSV with BOM, user default fields (for saved filters). */
  CsvWithBomFilterDefaultFields = 'CSV_WITH_BOM_FILTER_DEFAULT_FIELDS'
}

/** Inputs for adding fields during an issue create or update */
export type JiraIssueFieldsInput = {
  /** Represents the input data for affected services field in jira */
  affectedServicesField?: InputMaybe<JiraAffectedServicesFieldInput>;
  /** Represents the input data for asset field */
  assetsField?: InputMaybe<JiraAssetFieldInput>;
  /** Represents the input data for team field in jira */
  atlassianTeamFields?: InputMaybe<Array<JiraAtlassianTeamFieldInput>>;
  /** Represents the input data for cascading select fields */
  cascadingSelectFields?: InputMaybe<Array<JiraCascadingSelectFieldInput>>;
  /** Represents the input data for clearable number fields */
  clearableNumberFields?: InputMaybe<Array<JiraClearableNumberFieldInput>>;
  /** Represents the input data for CMDB fields in jsm */
  cmdbFields?: InputMaybe<Array<JiraCmdbFieldInput>>;
  /** Represents the input data for color fields */
  colorFields?: InputMaybe<Array<JiraColorFieldInput>>;
  /** Represents the input data for date fields */
  datePickerFields?: InputMaybe<Array<JiraDateFieldInput>>;
  /** Represents the input data for date time fields */
  dateTimePickerFields?: InputMaybe<Array<JiraDateTimeFieldInput>>;
  /** Represents the input data for entitlement field in jsm */
  entitlementField?: InputMaybe<JiraEntitlementFieldInput>;
  /** Represents the input data for epic link field */
  epicLinkField?: InputMaybe<JiraEpicLinkFieldInput>;
  /** Represent the input data for the issue links field */
  issueLinks?: InputMaybe<JiraIssueLinksFieldInput>;
  /** Represents the input data for issue type field */
  issueType?: InputMaybe<JiraIssueTypeInput>;
  /** Represents the input data for forge groups fields */
  jiraForgeGroupsFields?: InputMaybe<Array<JiraForgeGroupsFieldInput>>;
  /** Represents the input data for Forge Strings fields */
  jiraForgeStringsFields?: InputMaybe<Array<JiraForgeStringsFieldInput>>;
  /** Represents the input data for Forge Users fields */
  jiraForgeUsersFields?: InputMaybe<Array<JiraForgeUsersFieldInput>>;
  /** Represents the input data for labels field */
  labelsFields?: InputMaybe<Array<JiraLabelsFieldInput>>;
  /** Represents the input data for multiple group picker fields */
  multipleGroupPickerFields?: InputMaybe<Array<JiraMultipleGroupPickerFieldInput>>;
  /** Represents the input data for multiple select clearable user picker fields */
  multipleSelectClearableUserPickerFields?: InputMaybe<Array<JiraMultipleSelectClearableUserPickerFieldInput>>;
  /** Represents the input data for multiple select fields */
  multipleSelectFields?: InputMaybe<Array<JiraMultipleSelectFieldInput>>;
  /** Represents the input data for multiple select user picker fields */
  multipleSelectUserPickerFields?: InputMaybe<Array<JiraMultipleSelectUserPickerFieldInput>>;
  /** Represents the input data for multiple version picker fields */
  multipleVersionPickerFields?: InputMaybe<Array<JiraMultipleVersionPickerFieldInput>>;
  /** Represents the input data for multiselect components field used in BulkOps */
  multiselectComponents?: InputMaybe<JiraMultiSelectComponentFieldInput>;
  /** Represents the input data for number fields */
  numberFields?: InputMaybe<Array<JiraNumberFieldInput>>;
  /** Represents the input data for customer organization field in jsm projects */
  organizationField?: InputMaybe<JiraOrganizationFieldInput>;
  /** Represents the input data for Original Estimate field */
  originalEstimateField?: InputMaybe<JiraDurationFieldInput>;
  /** Represents the parent issue */
  parentField?: InputMaybe<JiraParentFieldInput>;
  /** Represents the input data for people field in jira */
  peopleFields?: InputMaybe<Array<JiraPeopleFieldInput>>;
  /** Represents the input data for jira system priority field */
  priority?: InputMaybe<JiraPriorityInput>;
  /** Represents the input data for Project field */
  projectFields?: InputMaybe<Array<JiraProjectFieldInput>>;
  /** Represents the input data for jira system resolution field */
  resolution?: InputMaybe<JiraResolutionInput>;
  /** Represents the input data for responders field in jsm */
  respondersField?: InputMaybe<JiraServiceManagementRespondersFieldInput>;
  /** Represents the input data for rich text fields ex:- description, environment */
  richTextFields?: InputMaybe<Array<JiraRichTextFieldInput>>;
  /** Represents the input data for jira system securityLevel field */
  security?: InputMaybe<JiraSecurityLevelInput>;
  /** Represents the input data for single group picker fields */
  singleGroupPickerFields?: InputMaybe<Array<JiraSingleGroupPickerFieldInput>>;
  /** Represents the input data for text fields ex:- summary, epicName */
  singleLineTextFields?: InputMaybe<Array<JiraSingleLineTextFieldInput>>;
  /** Represents the input data for organization field in jcs */
  singleOrganizationField?: InputMaybe<JiraSingleOrganizationFieldInput>;
  /** Represents the input data for single select clearable user picker fields */
  singleSelectClearableUserPickerFields?: InputMaybe<Array<JiraUserFieldInput>>;
  /** Represents the input data for single select fields */
  singleSelectFields?: InputMaybe<Array<JiraSingleSelectFieldInput>>;
  /** Represents the input data for single select user picker fields */
  singleSelectUserPickerFields?: InputMaybe<Array<JiraSingleSelectUserPickerFieldInput>>;
  /** Represents the input data for single version picker fields */
  singleVersionPickerFields?: InputMaybe<Array<JiraSingleVersionPickerFieldInput>>;
  /** Represents the input data for sprint field */
  sprintsField?: InputMaybe<JiraSprintFieldInput>;
  /** Represents the input data for Status field */
  status?: InputMaybe<JiraStatusInput>;
  /** Represents the input data for team field in jira */
  teamFields?: InputMaybe<Array<JiraTeamFieldInput>>;
  /** Represents the input data for TimeTracking field */
  timeTrackingField?: InputMaybe<JiraTimeTrackingFieldInput>;
  /** Represents the input data for url fields */
  urlFields?: InputMaybe<Array<JiraUrlFieldInput>>;
};

export type JiraIssueHierarchyConfigInput = {
  /** A list of issue type IDs */
  issueTypeIds: Array<Scalars['ID']['input']>;
  /** Level number */
  level: Scalars['Int']['input'];
  /** Level title */
  title: Scalars['String']['input'];
};

export type JiraIssueHierarchyConfigurationMutationInput = {
  /** This indicates if the service needs to make a simulation run */
  dryRun: Scalars['Boolean']['input'];
  /** A list of hierarchy config input objects */
  issueHierarchyConfig: Array<JiraIssueHierarchyConfigInput>;
};

/** Represents the type of items that the default location rule applies to. */
export enum JiraIssueItemLayoutItemLocationRuleType {
  /** Date items. For example: date or time related fields. */
  Dates = 'DATES',
  /** Multiline text items. For example: a description field or custom multi-line test fields. */
  MultilineText = 'MULTILINE_TEXT',
  /** Any other item types not covered by previous item types. */
  Other = 'OTHER',
  /** People items. For example: user pickers, team pickers or group picker. */
  People = 'PEOPLE',
  /** Time tracking items. For example: estimate, original estimate or time tracking panels. */
  Timetracking = 'TIMETRACKING'
}

/** The system container types that are available for placing items. */
export enum JiraIssueItemSystemContainerType {
  /** The container type for the issue content. */
  Content = 'CONTENT',
  /** The container type for the issue context. */
  Context = 'CONTEXT',
  /** The container type for customer context fields in JCS. */
  CustomerContext = 'CUSTOMER_CONTEXT',
  /** The container type for the issue hidden items. */
  HiddenItems = 'HIDDEN_ITEMS',
  /** The container type for the issue primary context. */
  Primary = 'PRIMARY',
  /** The container type for the request in JSM projects. */
  Request = 'REQUEST',
  /** The container type for the request portal in JSM projects. */
  RequestPortal = 'REQUEST_PORTAL',
  /** The container type for the issue secondary context. */
  Secondary = 'SECONDARY'
}

/** Represents a collection of system container types to be fetched by passing in an issue id. */
export type JiraIssueItemSystemContainerTypeWithIdInput = {
  /** ARI of the issue. */
  issueId: Scalars['ID']['input'];
  /** Whether the default (first) tab should be returned or not (defaults to false). */
  supportDefaultTab?: InputMaybe<Scalars['Boolean']['input']>;
  /** The collection of system container types. */
  systemContainerTypes: Array<JiraIssueItemSystemContainerType>;
};

/** Represents a collection of system container types to be fetched by passing in an issue key and a cloud id. */
export type JiraIssueItemSystemContainerTypeWithKeyInput = {
  /** The cloudId associated with this Issue. */
  cloudId: Scalars['ID']['input'];
  /** The {projectKey}-{issueNumber} associated with this Issue. */
  issueKey: Scalars['String']['input'];
  /** Whether the default (first) tab should be returned or not (defaults to false). */
  supportDefaultTab?: InputMaybe<Scalars['Boolean']['input']>;
  /** The collection of system container types. */
  systemContainerTypes: Array<JiraIssueItemSystemContainerType>;
};

/** This class contains all the possible states an Issue can be in. */
export enum JiraIssueLifecycleState {
  /** An active issue is present and visible (Default state) */
  Active = 'ACTIVE',
  /**
   * An archived issue is present but hidden. It can be retrieved
   * back to active state.
   */
  Archived = 'ARCHIVED'
}

/** Represents the possible linking directions between issues. */
export enum JiraIssueLinkDirection {
  /** Going in both directions between issues. */
  Both = 'BOTH',
  /** Going from the other issue to this issue. */
  Inward = 'INWARD',
  /** Going from this issue to the other issue. */
  Outward = 'OUTWARD'
}

/** Input type for defining the operation on the IssueLink field of a Jira issue. */
export type JiraIssueLinkFieldOperationInputForIssueTransitions = {
  /** Accepts input for either inward or outward link */
  linkIssues?: InputMaybe<JiraLinkedIssuesInput>;
  /** Accepts ARI(s): issue-link-type */
  linkType: Scalars['ID']['input'];
  /** Single value ADD operation is supported. */
  operation: JiraAddValueFieldOperations;
};

export type JiraIssueLinkRelationshipTypeUpdateInput = {
  /**
   * Updated direction of the issue link.
   * The source and destination issue for the link will be updated based on the direction.
   * Can be null only if issueLinkTypeId is null.
   */
  direction?: InputMaybe<JiraIssueLinkDirection>;
  /**
   * Link ID to be updated
   * Accept ARI: issue-link (See: https://developer.atlassian.com/platform/atlassian-resource-identifier/resource-owners/registry/#ati%3Acloud%3Ajira%3Aissue-link)
   */
  issueLinkId: Scalars['ID']['input'];
  /**
   * ID for the new issue link type. Use null to remove the issue link.
   * Accept ARI: issue-link-type (See: https://developer.atlassian.com/platform/atlassian-resource-identifier/resource-owners/registry/#ati%3Acloud%3Ajira%3Aissue-link-type)
   */
  issueLinkTypeId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input for Issue Links field */
export type JiraIssueLinksFieldInput = {
  /** The direction of the link (e.g. "INWARD" or "OUTWARD") */
  direction?: InputMaybe<JiraIssueLinkDirection>;
  /** The ID of the link type (e.g. "10000", "10001", etc.) */
  linkTypeId?: InputMaybe<Scalars['String']['input']>;
  /** The type of link (e.g. "blocks", "relates to", etc.) */
  linkTypeName?: InputMaybe<Scalars['String']['input']>;
  /** List of issue keys to be linked */
  linkedIssueKeys?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Types of modules that can provide content for issues. */
export enum JiraIssueModuleType {
  /** A module that provides a content panel for displaying issue data. */
  IssueModule = 'ISSUE_MODULE',
  /** A module that provides a legacy web panel. */
  WebPanel = 'WEB_PANEL'
}

/** The options for issue navigator search layout. */
export enum JiraIssueNavigatorSearchLayout {
  /** Detailed or aka split-view of issues */
  Detail = 'DETAIL',
  /** List view of issues */
  List = 'LIST'
}

/** Input object for the jiraIssuePicker query. */
export type JiraIssuePickerInput = {
  /** The ID of an issue to exclude from search results. */
  currentIssueId: Scalars['ID']['input'];
  /** A JQL query defining a list of issues to search for the query term. */
  currentJQL?: InputMaybe<Scalars['String']['input']>;
  /** The ID of a project that suggested issues must belong to. */
  currentProjectId?: InputMaybe<Scalars['String']['input']>;
  /** A string to match against text fields in the issue such as title, description, or comments. */
  query?: InputMaybe<Scalars['String']['input']>;
  /** When currentIssueId is a subtask, whether to include the parent issue in the suggestions if it matches the query. */
  showSubTaskParent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicate whether to include subtasks in the suggestions list. */
  showSubTasks?: InputMaybe<Scalars['Boolean']['input']>;
};

export type JiraIssuePullRequestsInput = {
  /** Sets if the field should return only legacy SCM data provided by Application Link or also the ones in TWG. */
  filterLegacy?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents the input data required for Jira issue rank */
export type JiraIssueRankInput = {
  /** ID of Issue after which the issue should be ranked. Encoded as an ARI. */
  afterIssueId?: InputMaybe<Scalars['ID']['input']>;
  /** ID of Issue before which the issue should be ranked. Encoded as an ARI. */
  beforeIssueId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input for the JiraIssueRemoteIssueLink mutation. */
export type JiraIssueRemoteIssueLinkInput = {
  /** The name of the application. Used in conjunction with the (remote) object icon title to display a tooltip for the link's icon. The tooltip takes the format `[application name] icon title`. Blank items are excluded from the tooltip title. If both items are blank, the icon tooltip displays as `Web Link`. Grouping and sorting of links may place links without an application name last. */
  applicationName?: InputMaybe<Scalars['String']['input']>;
  /** The name-spaced type of the application, used by registered rendering apps. */
  applicationType?: InputMaybe<Scalars['String']['input']>;
  /**
   * An identifier for the remote item in the remote system. For example, the global ID for a remote item in Confluence would consist of the app ID and page ID, like this: `appId=456&pageId=123`.
   * Setting this field enables the remote issue link details to be updated or deleted using remote system and item details as the record identifier, rather than using the record's Jira ID.
   * The maximum length is 255 characters.
   */
  globalId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The title of the icon. This is used as follows:
   * - For a status icon it is used as a tooltip on the icon. If not set, the status icon doesn't display a tooltip in Jira.
   * - For the remote object icon it is used in conjunction with the application name to display a tooltip for the link's icon. The tooltip takes the format `[application name] icon title`. Blank items are excluded from the tooltip title. If both items are blank, the icon tooltip displays as `Web Link`.
   */
  iconTitle?: InputMaybe<Scalars['String']['input']>;
  /** The URL of an icon that displays at 16x16 pixel in Jira. */
  iconUrl?: InputMaybe<Scalars['String']['input']>;
  /** The Remote Link ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Description of the relationship between the issue and the linked item. If not set, the relationship description `links to` is used in Jira. */
  relationship?: InputMaybe<Scalars['String']['input']>;
  /** Whether the item is resolved. If set to `true`, the link to the issue is displayed in a strikethrough font, otherwise the link displays in normal font. */
  resolved?: InputMaybe<Scalars['Boolean']['input']>;
  /** The URL of the tooltip, used only for a status icon. If not set, the status icon in Jira is not clickable. */
  statusIconLink?: InputMaybe<Scalars['String']['input']>;
  /** The title of the status icon. Used as a tooltip on the icon. If not set, the status icon doesn't display a tooltip in Jira. */
  statusIconTitle?: InputMaybe<Scalars['String']['input']>;
  /** The URL of a status icon that displays at 16x16 pixel in Jira. */
  statusIconUrl?: InputMaybe<Scalars['String']['input']>;
  /** The summary details of the item. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** The title of the item. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the item. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the JiraIssueRemoteLinkMutation. */
export type JiraIssueRemoteLinkInput = {
  /** The Issue ARI. */
  issueId: Scalars['ID']['input'];
  /** ADD or SET or REMOVE operation to perform on the remote link. */
  operation: JiraIssueRemoteLinkOperations;
  /** The remote link to create or update. */
  remoteLink?: InputMaybe<JiraIssueRemoteIssueLinkInput>;
};

/** Operations that can be performed on issue remote link. */
export enum JiraIssueRemoteLinkOperations {
  /** Adds remote link to an issue. */
  Add = 'ADD',
  /** Removes remote link from an issue. */
  Remove = 'REMOVE',
  /** Overrides remote link of an issue. */
  Set = 'SET'
}

/**
 * Represents filters for resources of an issue.
 * In Future can add multiple filter options like name, author, dateRange, etc.
 */
export type JiraIssueResourceFilters = {
  /** The integration type and its filters */
  integration?: InputMaybe<JiraResourceIntegration>;
  /** List of file types to be used as filters. */
  types?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** The input used for an issue search to indicate the configuration for aggregation during issue search. */
export type JiraIssueSearchAggregationConfigInput = {
  /** A list of aggregation fields to be calculated as part of Jira issue search. */
  aggregationFields?: InputMaybe<Array<JiraIssueSearchFieldAggregationInput>>;
  /**
   * A nullable boolean indicating if aggregation can be enabled.
   * true -> Aggregation can be enabled (e.g. when filtering is not applied)
   * false -> Aggregation cannot be enabled (e.g. when filtering is applied or project exceeds the max number of issues to be aggregated)
   * null -> If any error has occured in fetching the preference. It shouldn't be possible to enable aggregation when an error happens.
   */
  canEnableAggregation?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Allowed aggregation types during issue search */
export enum JiraIssueSearchAggregationFunction {
  /** Aggregation based on hierarchy. */
  Rollup = 'ROLLUP'
}

/**
 * The input used in Issue Search to obtain all children for a given issue.
 * This is used when hierarchy is enabled in Issue Search and user expands children of an issue.
 */
export type JiraIssueSearchChildIssuesInput = {
  /** The list of project keys to filter the children by. If it's null or empty, no filter is applied. */
  filterByProjectKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * Filter used in the main search query. This is used to extract the ORDER BY clause and sort children accordingly.
   * Either this or jql should be provided.
   */
  filterId?: InputMaybe<Scalars['String']['input']>;
  /**
   * JQL used in the main search query. This is used to extract the ORDER BY clause and sort children accordingly.
   * Either this or filterId should be provided.
   */
  jql?: InputMaybe<Scalars['String']['input']>;
  /** A subscoping that affects where this view's last used data is stored and grouped by. If null, this view is in the global namespace. */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** The key of the parent issue for which children are to be fetched */
  parentIssueKey: Scalars['String']['input'];
  /** A unique identifier for this view within its namespace, or the global namespace if no namespace is defined. */
  viewId?: InputMaybe<Scalars['String']['input']>;
};

/** Container type for different definitions of custom input definitions. */
export type JiraIssueSearchCustomInput = {
  /** Input type used for Jira Software issue search. */
  jiraSoftwareInput?: InputMaybe<JiraSoftwareIssueSearchCustomInput>;
  jiraTimelineInput?: InputMaybe<JiraTimelineIssueSearchCustomInput>;
};

export type JiraIssueSearchFieldAggregationInput = {
  /** The calculation function of an aggregate value for a specific field. */
  aggregationFunction?: InputMaybe<JiraIssueSearchAggregationFunction>;
  /** The field id to be aggregated (including virtual field, i.e: timeline for dates aggregation). */
  fieldId?: InputMaybe<Scalars['String']['input']>;
  /** A nullable boolean indicating if aggregation for this field is enabled. */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Specifies which field config sets should be returned. */
export enum JiraIssueSearchFieldSetSelectedState {
  /** Both selected and non-selected field config sets. */
  All = 'ALL',
  /** Only the field config sets that have not been selected in the current view. */
  NonSelected = 'NON_SELECTED',
  /** Only the field config sets selected in the current view. */
  Selected = 'SELECTED'
}

export type JiraIssueSearchFieldSets = {
  /** Input object which contains the new fieldSets */
  replaceFieldSetsInput?: InputMaybe<JiraIssueSearchReplaceFieldSetsInput>;
};

/**
 * A filter for the JiraIssueSearchFieldSet connections.
 * By default, if no fieldSetSelectedState is specified, only SELECTED fields are returned.
 */
export type JiraIssueSearchFieldSetsFilter = {
  /** An enum specifying which field config sets should be returned based on the selected status. */
  fieldSetSelectedState?: InputMaybe<JiraIssueSearchFieldSetSelectedState>;
  /** Only the fieldSets that case-insensitively, contain this searchString in their displayName will be returned. */
  searchString?: InputMaybe<Scalars['String']['input']>;
};

/**
 * The necessary input to return the field sets connection when updating the view/column configuration
 * while paginating the issue search results.
 * There is an undocumented argument when paginating with Relay called UNSTABLE_extraVariables.
 * However, to leverage this we need to expose the field set connection as a field on JiraIssueEdge.
 * This makes it possible to provide all implicit view settings as explicit variables during pagination requests.
 * This will allow us to set all static variables to the top level issueSearch API,
 * without updating variables for any nested fields.
 */
export type JiraIssueSearchFieldSetsInput = {
  fieldSetIds?: InputMaybe<Array<Scalars['String']['input']>>;
  viewInput?: InputMaybe<JiraIssueSearchViewInput>;
};

/** The input expects the original jql from the search and the group by jql used for the operating group section to distinguish if filter applied */
export type JiraIssueSearchGroupByInput = {
  /** The merged original jql + the group by jql */
  groupByJql?: InputMaybe<Scalars['String']['input']>;
  /** The original jql, could be with or without the filter jql applied */
  jql?: InputMaybe<Scalars['String']['input']>;
};

/**
 * The input used for an issue search.
 * The issue search will either rely on the specified JQL, the specified filter's underlying JQL,
 * specified custom input, specific to a Jira family product, or child issues input
 */
export type JiraIssueSearchInput = {
  /** Used in issue search hierarchy for retrieving children for a given issue */
  childIssuesInput?: InputMaybe<JiraIssueSearchChildIssuesInput>;
  /** The custom input used for issue search. */
  customInput?: InputMaybe<JiraIssueSearchCustomInput>;
  /** The saved filter used for issue search. */
  filterId?: InputMaybe<Scalars['String']['input']>;
  /** Used when loading more issues within the group by section and expanding the non first group issues */
  groupByInput?: InputMaybe<JiraIssueSearchGroupByInput>;
  /** The JQL used for issue search. */
  jql?: InputMaybe<Scalars['String']['input']>;
  /** When this flag is true then the search is performed for last used Query within the provided scope */
  searchWithLastUsedJql?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum JiraIssueSearchOperationScope {
  NinGlobal = 'NIN_GLOBAL',
  NinGlobalSchemaRefactor = 'NIN_GLOBAL_SCHEMA_REFACTOR',
  NinGlobalShadowRequest = 'NIN_GLOBAL_SHADOW_REQUEST',
  NinProject = 'NIN_PROJECT',
  NinProjectSchemaRefactor = 'NIN_PROJECT_SCHEMA_REFACTOR',
  NinProjectShadowRequest = 'NIN_PROJECT_SHADOW_REQUEST',
  TimelineProject = 'TIMELINE_PROJECT'
}

/**
 * The options used for an issue search.
 * The issueKey determines the target page for search.
 * Do not provide pagination arguments alongside issueKey.
 */
export type JiraIssueSearchOptions = {
  issueKey?: InputMaybe<Scalars['String']['input']>;
};

export type JiraIssueSearchReplaceFieldSetsInput = {
  context?: InputMaybe<JiraIssueSearchViewFieldSetsContext>;
  nodes: Array<Scalars['String']['input']>;
};

/**
 * The input used for an issue search to identify the scope/context in which the search is being performed (e.g. project or global scope).
 * The plan is to evolve this to also include the namespace/experience for the search (e.g. ISSUE_NAVIGATOR or CHILD_ISSUE_PANEL).
 * For now this is going to be used only for monitoring purposes, allowing us to split the search queries between project and global scope.
 */
export type JiraIssueSearchScope = {
  /** The scope in which a search is being performed in the context of a particular experience (e.g. NIN_Project or NIN_Global). */
  operationScope?: InputMaybe<JiraIssueSearchOperationScope>;
  /** In case of a single-project search scope, this is the project key in context of which the search is performed */
  projectKey?: InputMaybe<Scalars['String']['input']>;
};

/** Input for settings applied to the Issue Search view. */
export type JiraIssueSearchSettings = {
  /** The fieldId of the field to group the issue search view by. Null when no grouping is explicitly applied */
  groupBy?: InputMaybe<Scalars['String']['input']>;
  /** Boolean indicating whether the completed issues should be hidden from the search result */
  hideDone?: InputMaybe<Scalars['Boolean']['input']>;
  /** Boolean indicating whether the issue hierarchy is enabled in the issue search view */
  hierarchyEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** JQL applied to the issue search view. */
  jql?: InputMaybe<Scalars['String']['input']>;
};

/**
 * The input used for an issue search when FE needs to tell the BE the specific view configuration to be used for an issue search query.
 * E.g. this can be used on pagination to make sure that the same view configuration calculated on initial load is used for the subsequent queries.
 * This would prevent scenarios where an user has two tabs open (one with hierarchy enabled and one with hierarchy disabled) and the BE needs to return
 * different results to respect the view configuration used on the initial load of each tab.
 */
export type JiraIssueSearchStaticViewInput = {
  /** A nullable JiraIssueSearchAggregationConfigInput containing aggregation configuration */
  aggregationConfig?: InputMaybe<JiraIssueSearchAggregationConfigInput>;
  /** A nullable boolean indicating if the Grouping is enabled */
  isGroupingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** A nullable boolean indicating if the Hide done work items is enabled */
  isHideDoneEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** A nullable boolean indicating if the Issue Hierarchy is enabled */
  isHierarchyEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * The view config data used for an issue search.
 * E.g. we can load different results depending on the hierarchy toggle value for a specific namespace/experience or view.
 * In NIN, if the hierarchy toggle is enabled, we will return only the top level issues or the issues with no parent satisfying the given JQL/filter.
 */
export type JiraIssueSearchViewConfigInput = {
  staticViewInput?: InputMaybe<JiraIssueSearchStaticViewInput>;
  viewInput?: InputMaybe<JiraIssueSearchViewInput>;
};

export type JiraIssueSearchViewContextInput = {
  /** When grouping is enabled, this input attribute lists the groups that are currently expanded in the view by the user. */
  expandedGroups?: InputMaybe<JiraIssueExpandedGroups>;
  /** When hierarchy is enabled, this input attribute lists the parent items that are currently expanded in the view by the user. */
  expandedParents?: InputMaybe<Array<JiraIssueExpandedParent>>;
  /** Total count of top level items loaded in the view by the user. This is the 'x' in the 'x of y' on the bottom of Issue Navigator. */
  topLevelItemsLoaded?: InputMaybe<Scalars['Int']['input']>;
};

/** Additional context when the field sets are being modified for a view with a filter applied. */
export type JiraIssueSearchViewFieldSetFilterContext = {
  /** The numerical ID of the filter applied to the view */
  filter?: InputMaybe<Scalars['ID']['input']>;
};

/** The context can be either project based or issue based, switch to use issue based when project id/issue type id are unknown */
export type JiraIssueSearchViewFieldSetsContext = {
  /** Context detailing the filter applied to the view */
  filterContext?: InputMaybe<JiraIssueSearchViewFieldSetFilterContext>;
  issueContext?: InputMaybe<JiraIssueSearchViewFieldSetsIssueContext>;
  projectContext?: InputMaybe<JiraIssueSearchViewFieldSetsProjectContext>;
};

export type JiraIssueSearchViewFieldSetsIssueContext = {
  issueKey?: InputMaybe<Scalars['String']['input']>;
};

export type JiraIssueSearchViewFieldSetsProjectContext = {
  issueType?: InputMaybe<Scalars['ID']['input']>;
  project?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * The view details used for an issue search.
 * We can use this input on initial load to avoid waterfall requests on the FE.
 * E.g. FE doesn't know if the hierarchy toggle is enabled or not, so it can pass the view details to the backend
 * to get the flag for the given experience.
 */
export type JiraIssueSearchViewInput = {
  /** The returned field set will belong to the context given, currently only applicable to CHILD_ISSUE_PANEL */
  context?: InputMaybe<JiraIssueSearchViewFieldSetsContext>;
  /** The tenant specific id of the filter that will be used to get the JiraIssueSearchView */
  filterId?: InputMaybe<Scalars['String']['input']>;
  /** A subscoping that affects where this view's last used data is stored and grouped by. If null, this view is in the global namespace. */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for this view within its namespace, or the global namespace if no namespace is defined. */
  viewId?: InputMaybe<Scalars['String']['input']>;
};

/** The options for issue search view layout. */
export enum JiraIssueSearchViewLayout {
  /** Detailed or aka split-view of issues */
  Detail = 'DETAIL',
  /** List view of issues */
  List = 'LIST'
}

/** Input to query a Jira project issue search view by its project key and item id. */
export type JiraIssueSearchViewProjectKeyAndItemIdQuery = {
  /** The cloud id of the tenant. Required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /**
   * Item ID of the view in the project. This is the identifier that follows the `/{projectKey}/` path segment in the URL.
   *
   * This value may consist of either one component (e.g., `list`) or two components (e.g., `list/123abc`). If two components are present,
   * both must be provided as the `itemId`, separated by a forward slash, as they appear in the URL.
   */
  itemId: Scalars['String']['input'];
  /** Key of the project which the issue search view is associated with. */
  projectKey: Scalars['String']['input'];
};

export type JiraIssueSearchViewQueryInput = {
  /** Input to retrieve a Jira project issue search view by its project key and item id. */
  projectKeyAndItemIdQuery?: InputMaybe<JiraIssueSearchViewProjectKeyAndItemIdQuery>;
  /** ARI of the issue search view to query. */
  viewAri?: InputMaybe<Scalars['ID']['input']>;
};

export enum JiraIssueTownsquareProjectLinkType {
  Explicit = 'EXPLICIT',
  Implicit = 'IMPLICIT',
  None = 'NONE'
}

/** Input type for Jira comment, which may be optional input to perform a transition for the issue */
export type JiraIssueTransitionCommentInput = {
  /** Accept ADF ( Atlassian Document Format) of paragraph */
  body: JiraAdfInput;
  /** Only ADD operation is supported for comment section in the context of Issue Transition Modernisation experience.. */
  operation: JiraAddValueFieldOperations;
  /** Type of comment to be added while transitioning, possible values are INTERNAL_NOTE, REPLY_TO_CUSTOMER */
  type?: InputMaybe<JiraIssueTransitionCommentType>;
  /** Jira issue transition comment visibility */
  visibility?: InputMaybe<JiraIssueTransitionCommentVisibilityInput>;
};

/** Possible Comment Types that can be made on the Transition screen. */
export enum JiraIssueTransitionCommentType {
  /** Comment has to be shared internally with the team */
  InternalNote = 'INTERNAL_NOTE',
  /** Comment has to be shared with the customer */
  ReplyToCustomer = 'REPLY_TO_CUSTOMER'
}

export type JiraIssueTransitionCommentVisibilityInput = {
  /**
   * Unique identifier for a group
   * Accepts ARI(s): group
   */
  groupId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Unique identifier for a project role
   * Accepts ARI(s): role
   */
  roleId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input type for field level inputs, which may be required to perform a transition for the issue */
export type JiraIssueTransitionFieldLevelInput = {
  /** An entry corresponding for input for JiraAffectedServicesField */
  JiraAffectedServicesField?: InputMaybe<Array<JiraUpdateAffectedServicesFieldInput>>;
  /** An entry corresponding for input for JiraAttachmentsField */
  JiraAttachmentsField?: InputMaybe<Array<JiraUpdateAttachmentFieldInput>>;
  /** An entry corresponding for input for JiraCmdbField */
  JiraCMDBField?: InputMaybe<Array<JiraUpdateCmdbFieldInput>>;
  /** An entry corresponding for input for JiraCascadingSelectField */
  JiraCascadingSelectField?: InputMaybe<Array<JiraUpdateCascadingSelectFieldInput>>;
  /** An entry corresponding for input for JiraCheckboxesField */
  JiraCheckboxesField?: InputMaybe<Array<JiraUpdateCheckboxesFieldInput>>;
  /** An entry corresponding for input for JiraColorField */
  JiraColorField?: InputMaybe<Array<JiraUpdateColorFieldInput>>;
  /** An entry corresponding for input for JirComponentsField */
  JiraComponentsField?: InputMaybe<Array<JiraUpdateComponentsFieldInput>>;
  /** An entry corresponding for input for JiraConnectMultipleSelectField */
  JiraConnectMultipleSelectField?: InputMaybe<Array<JiraUpdateMultipleSelectFieldInput>>;
  /** An entry corresponding for input for JiraConnectNumberField */
  JiraConnectNumberField?: InputMaybe<Array<JiraUpdateNumberFieldInput>>;
  /** An entry corresponding for input for JiraConnectRichTextField */
  JiraConnectRichTextField?: InputMaybe<Array<JiraUpdateRichTextFieldInput>>;
  /** An entry corresponding for input for JiraConnectSingleSelectField */
  JiraConnectSingleSelectField?: InputMaybe<Array<JiraUpdateSingleSelectFieldInput>>;
  /** An entry corresponding for input for JiraConnectTextField */
  JiraConnectTextField?: InputMaybe<Array<JiraUpdateSingleLineTextFieldInput>>;
  /** An entry corresponding for input for JiraDatePickerField */
  JiraDatePickerField?: InputMaybe<Array<JiraUpdateDateFieldInput>>;
  /** An entry corresponding for input for JiraDateTimePickerField */
  JiraDateTimePickerField?: InputMaybe<Array<JiraUpdateDateTimeFieldInput>>;
  /** An entry corresponding for input for JiraForgeDateField */
  JiraForgeDateField?: InputMaybe<Array<JiraUpdateDateFieldInput>>;
  /** An entry corresponding for input for JiraForgeDatetimeField */
  JiraForgeDatetimeField?: InputMaybe<Array<JiraUpdateDateTimeFieldInput>>;
  /** An entry corresponding for input for JiraForgeGroupField */
  JiraForgeGroupField?: InputMaybe<Array<JiraUpdateForgeSingleGroupPickerFieldInput>>;
  /** An entry corresponding for input for JiraForgeGroupsField */
  JiraForgeGroupsField?: InputMaybe<Array<JiraUpdateForgeMultipleGroupPickerFieldInput>>;
  /** An entry corresponding for input for JiraForgeNumberField */
  JiraForgeNumberField?: InputMaybe<Array<JiraUpdateNumberFieldInput>>;
  /** An entry corresponding for input for JiraForgeObjectField */
  JiraForgeObjectField?: InputMaybe<Array<JiraUpdateForgeObjectFieldInput>>;
  /** An entry corresponding for input for JiraForgeStringField */
  JiraForgeStringField?: InputMaybe<Array<JiraUpdateSingleLineTextFieldInput>>;
  /** An entry corresponding for input for JiraForgeStringsField */
  JiraForgeStringsField?: InputMaybe<Array<JiraUpdateLabelsFieldInput>>;
  /** An entry corresponding for input for JiraForgeUserField */
  JiraForgeUserField?: InputMaybe<Array<JiraUpdateSingleSelectUserPickerFieldInput>>;
  /** An entry corresponding for input for JiraForgeUsersField */
  JiraForgeUsersField?: InputMaybe<Array<JiraUpdateMultipleSelectUserPickerFieldInput>>;
  /** An entry corresponding for input for JiraIssueLinkField */
  JiraIssueLinkField?: InputMaybe<Array<JiraUpdateIssueLinkFieldInputForIssueTransitions>>;
  /** An entry corresponding for input for JiraIssueTypeField */
  JiraIssueTypeField?: InputMaybe<Array<JiraUpdateIssueTypeFieldInput>>;
  /** An entry corresponding for input for JiraLabelsField */
  JiraLabelsField?: InputMaybe<Array<JiraUpdateLabelsFieldInput>>;
  /** An entry corresponding for input for JiraMultipleGroupPickerField */
  JiraMultipleGroupPickerField?: InputMaybe<Array<JiraUpdateMultipleGroupPickerFieldInput>>;
  /** An entry corresponding for input for JiraMultipleSelectField */
  JiraMultipleSelectField?: InputMaybe<Array<JiraUpdateMultipleSelectFieldInput>>;
  /** An entry corresponding for input for JiraMultipleSelectUserPickerField */
  JiraMultipleSelectUserPickerField?: InputMaybe<Array<JiraUpdateMultipleSelectUserPickerFieldInput>>;
  /** An entry corresponding for input for JiraMultipleVersionPickerField */
  JiraMultipleVersionPickerField?: InputMaybe<Array<JiraUpdateMultipleVersionPickerFieldInput>>;
  /** An entry corresponding for input for JiraNumberField */
  JiraNumberField?: InputMaybe<Array<JiraUpdateNumberFieldInput>>;
  /** An entry corresponding for input for JiraParentIssueField */
  JiraParentIssueField?: InputMaybe<Array<JiraUpdateParentFieldInput>>;
  /** An entry corresponding for input for JiraPeopleField */
  JiraPeopleField?: InputMaybe<Array<JiraUpdatePeopleFieldInput>>;
  /** An entry corresponding for input for JiraPriorityField */
  JiraPriorityField?: InputMaybe<Array<JiraUpdatePriorityFieldInput>>;
  /** An entry corresponding for input for JiraProjectField */
  JiraProjectField?: InputMaybe<Array<JiraUpdateProjectFieldInput>>;
  /** An entry corresponding for input for JiraRadioSelectField */
  JiraRadioSelectField?: InputMaybe<Array<JiraUpdateRadioSelectFieldInput>>;
  /** An entry corresponding for input for JiraResolutionField */
  JiraResolutionField?: InputMaybe<Array<JiraUpdateResolutionFieldInput>>;
  /** An entry corresponding for input for JiraRichTextField */
  JiraRichTextField?: InputMaybe<Array<JiraUpdateRichTextFieldInput>>;
  /** An entry corresponding for input for JiraSecurityLevelField */
  JiraSecurityLevelField?: InputMaybe<Array<JiraUpdateSecurityLevelFieldInput>>;
  /** An entry corresponding for input for JiraServiceManagementOrganizationField */
  JiraServiceManagementOrganizationField?: InputMaybe<Array<JiraServiceManagementUpdateOrganizationFieldInput>>;
  /** An entry corresponding for input for JiraSingleGroupPickerField */
  JiraSingleGroupPickerField?: InputMaybe<Array<JiraUpdateSingleGroupPickerFieldInput>>;
  /** An entry corresponding for input for JiraSingleLineTextField */
  JiraSingleLineTextField?: InputMaybe<Array<JiraUpdateSingleLineTextFieldInput>>;
  /** An entry corresponding for input for JiraSingleSelectField */
  JiraSingleSelectField?: InputMaybe<Array<JiraUpdateSingleSelectFieldInput>>;
  /** An entry corresponding for input for JiraSingleSelectUserPickerField */
  JiraSingleSelectUserPickerField?: InputMaybe<Array<JiraUpdateSingleSelectUserPickerFieldInput>>;
  /** An entry corresponding for input for JiraSingleVersionPickerField */
  JiraSingleVersionPickerField?: InputMaybe<Array<JiraUpdateSingleVersionPickerFieldInput>>;
  /** An entry corresponding for input for JiraSprintField */
  JiraSprintField?: InputMaybe<Array<JiraUpdateSprintFieldInput>>;
  /** An entry corresponding for input for JiraTeamViewField */
  JiraTeamViewField?: InputMaybe<Array<JiraUpdateTeamFieldInput>>;
  /** An entry corresponding for input for JiraTimeTrackingField */
  JiraTimeTrackingField?: InputMaybe<Array<JiraUpdateTimeTrackingFieldInput>>;
  /** An entry corresponding for input for JiraURLField */
  JiraUrlField?: InputMaybe<Array<JiraUpdateUrlFieldInput>>;
  /** An entry corresponding for input for JiraWorkLogField */
  JiraWorkLogField?: InputMaybe<Array<JiraUpdateWorklogFieldInputForIssueTransitions>>;
};

/** Enum representing different types of messages to be shown on modal load screen */
export enum JiraIssueTransitionLayoutMessageType {
  /** An error message type is sent when there is any error while fetching the screen */
  Error = 'ERROR',
  /** An info message configured on the transition modal */
  Info = 'INFO',
  /** A send a success message during modal load */
  Success = 'SUCCESS',
  /** A warning message that might be configured on the BE or shown based on the screen configuration/field support etc. */
  Warn = 'WARN'
}

/** Input type for defining the operation on the IssueType field of a Jira issue. */
export type JiraIssueTypeFieldOperationInput = {
  /** Accepts : issue-type */
  id: Scalars['ID']['input'];
  /** Only SET operation is supported. */
  operation: JiraSingleValueFieldOperations;
};

/** Return only issue types that match this filter */
export type JiraIssueTypeFilterInput = {
  /** All issue types with a level max or lower will be returned. */
  maxHierarchyLevel?: InputMaybe<Scalars['Int']['input']>;
  /** All issue types with a level min or higher will be returned */
  minHierarchyLevel?: InputMaybe<Scalars['Int']['input']>;
  /**
   * Filter issue types to only those valid as children of this parent issue.
   * It will lookup the parent's hierarchy level and return types with level < parentLevel.
   * If provided along with maxHierarchyLevel or minHierarchyLevel, all filters are combined with AND logic
   * (only issue types satisfying all conditions will be returned).
   */
  parentIssueKey?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for issue type field */
export type JiraIssueTypeInput = {
  /** An identifier for the field */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** An identifier for a issue type value */
  issueTypeId: Scalars['ID']['input'];
};

export type JiraIssueUnarchiveInput = {
  /** Accept ARI(s): issue */
  ids: Array<Scalars['ID']['input']>;
};

/** The options for the activity feed sort order. */
export enum JiraIssueViewActivityFeedSortOrder {
  NewestFirst = 'NEWEST_FIRST',
  OldestFirst = 'OLDEST_FIRST'
}

/** The options for displaying activity layout. */
export enum JiraIssueViewActivityLayout {
  Horizontal = 'HORIZONTAL',
  Vertical = 'VERTICAL'
}

/** The options for the selected attachment view. */
export enum JiraIssueViewAttachmentPanelViewMode {
  GridView = 'GRID_VIEW',
  ListView = 'LIST_VIEW',
  StripView = 'STRIP_VIEW'
}

/** The options for displaying timestamps. */
export enum JiraIssueViewTimestampDisplayMode {
  Absolute = 'ABSOLUTE',
  Relative = 'RELATIVE'
}

/** Types of layouts in issue view */
export enum JiraIssueViewUserPreferenceLayoutType {
  Custom = 'CUSTOM',
  Discussion = 'DISCUSSION',
  Standard = 'STANDARD',
  Tab = 'TAB',
  Wide = 'WIDE'
}

export enum JiraIteration {
  Iteration_1 = 'ITERATION_1',
  Iteration_2 = 'ITERATION_2',
  IterationDynamic = 'ITERATION_DYNAMIC'
}

/** The options for jql builder search mode. */
export enum JiraJqlBuilderSearchMode {
  /** JQL text based builder. */
  Advanced = 'ADVANCED',
  /** User friendly JQL Builder. */
  Basic = 'BASIC'
}

export type JiraJqlContextFieldsFilter = {
  /**
   * Fields to be excluded from the result.
   * This is an optional parameter that will attempt to exactly match individual field names and filter them from the result.
   */
  excludeJqlTerms?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only the fields that support the provided JqlClauseType will be returned. */
  forClause?: InputMaybe<JiraJqlClauseType>;
  /** Only the jqlTerms requested will be returned. */
  jqlTerms?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only the fields that contain this searchString in their displayName will be returned. */
  searchString?: InputMaybe<Scalars['String']['input']>;
  /**
   * When true only the fields that are shown in JQL context are returned
   * When false only the fields that are not shown in JQL context are returned
   * When null or not specified, all fields are returned
   */
  shouldShowInContext?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum JiraJourneyActiveState {
  /** The journey is active */
  Active = 'ACTIVE',
  /** The journey is inactive */
  Inactive = 'INACTIVE',
  /** The active state is unavailable */
  None = 'NONE'
}

export enum JiraJourneyConfigurationType {
  /** The journey configuration is for a customizable journey */
  CustomizableJourney = 'CUSTOMIZABLE_JOURNEY',
  /** The journey configuration is for a journey type */
  JourneyType = 'JOURNEY_TYPE'
}

export type JiraJourneyCustomizationSettingsInput = {
  /** The ID of the agent that will handle customizing the journey at runtime. */
  agentId: Scalars['ID']['input'];
  /** Timeout in seconds. The amount of time the user has to customize the journey, before the original journey will continue to run. */
  timeout: Scalars['Int']['input'];
};

export enum JiraJourneyItemConditionComparator {
  /** The left contains the right value */
  Contains = 'CONTAINS',
  /** The left value is equal to the right value */
  Equals = 'EQUALS',
  /** The left value is greater than the right value */
  GreaterThan = 'GREATER_THAN',
  /** The left value is less than the right value */
  LessThan = 'LESS_THAN',
  /** The left does not contain the right value */
  NotContains = 'NOT_CONTAINS',
  /** The left value is not equal to the right value */
  NotEquals = 'NOT_EQUALS',
  /** The left value contains a substring that matches the regular expression in the right value */
  RegexContains = 'REGEX_CONTAINS',
  /** The left value matches the regular expression in the right value */
  RegexMatches = 'REGEX_MATCHES',
  /** The left value does not match the regular expression in the right value */
  RegexNotMatches = 'REGEX_NOT_MATCHES',
  /** The left value starts with the right value */
  StartsWith = 'STARTS_WITH'
}

export type JiraJourneyItemConditionInput = {
  /** The comparator to apply to the two values */
  comparator: JiraJourneyItemConditionComparator;
  /** The left value in the condition */
  left: Scalars['String']['input'];
  /** The right value in the condition */
  right: Scalars['String']['input'];
};

export type JiraJourneyItemConditionsInput = {
  /** The conditions for the item */
  conditions: Array<JiraJourneyItemConditionInput>;
};

export type JiraJourneyItemConfigurationInput = {
  statusDependencyConfiguration?: InputMaybe<JiraJourneyStatusDependencyConfigurationInput>;
  workItemConfiguration?: InputMaybe<JiraJourneyWorkItemConfigurationInput>;
};

export type JiraJourneyItemCustomizationSettingsInput = {
  workItemCustomizationSettings?: InputMaybe<JiraJourneyWorkItemCustomizationSettingsInput>;
};

export type JiraJourneyItemUpdateCustomizationSettingsInput = {
  /** The customization settings to be updated. If null, existing settings will be removed. */
  customizationSettings?: InputMaybe<JiraJourneyItemCustomizationSettingsInput>;
  /** The entity tag of the journey configuration */
  etag: Scalars['String']['input'];
  /** ID of the journey configuration */
  journeyId: Scalars['ID']['input'];
  /** ID of the journey item */
  journeyItemId: Scalars['ID']['input'];
  /** The version number of the journey configuration. */
  journeyVersion: Scalars['Long']['input'];
};

export enum JiraJourneyItemUpdatedChannel {
  JourneyFrontend = 'JOURNEY_FRONTEND',
  Rovo = 'ROVO'
}

export type JiraJourneyParentIssueInput = {
  /** The id of the project which the parent issue belongs to */
  projectId: Scalars['ID']['input'];
  /** The type of the parent issue, e.g. 'request' */
  type: JiraJourneyParentIssueType;
  /** The value of the parent issue, e.g. '10000' */
  value: Scalars['String']['input'];
};

export type JiraJourneyParentIssueTriggerConfigurationInput = {
  /** The type of the trigger. should be 'PARENT_ISSUE_CREATED' */
  type?: InputMaybe<JiraJourneyTriggerType>;
};

export enum JiraJourneyParentIssueType {
  /** Jira issue */
  Request = 'REQUEST'
}

export enum JiraJourneyRulesMigrationStatus {
  /** The journey failed to migrate to RuleDSL */
  Failure = 'FAILURE',
  /** The journey migration roll back failed */
  RollbackFailure = 'ROLLBACK_FAILURE',
  /** The journey migration was successfully rolled back */
  RollbackSuccess = 'ROLLBACK_SUCCESS',
  /** The journey was successfully migrated to RuleDSL */
  Success = 'SUCCESS',
  /** The journey had validation errors and was not migrated to RuleDSL */
  ValidationFailure = 'VALIDATION_FAILURE'
}

export enum JiraJourneyStatus {
  /** The journey is archived and can be restored */
  Archived = 'ARCHIVED',
  /**
   * The journey is disabled and can not be triggered
   * @deprecated Use ARCHIVED instead, DISABLED should not be used anymore
   */
  Disabled = 'DISABLED',
  /** The journey is in draft status and can not be triggered */
  Draft = 'DRAFT',
  /** The journey is enabled and can be triggered */
  Published = 'PUBLISHED',
  /** The journey has new version published, it is not active anymore */
  Superseded = 'SUPERSEDED'
}

export type JiraJourneyStatusDependencyConfigurationInput = {
  /** The list of statuses that work items should be in to satisfy this dependency */
  statuses?: InputMaybe<Array<JiraJourneyStatusDependencyConfigurationStatusInput>>;
  /** The list of dependent journey work item ids */
  workItemIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type JiraJourneyStatusDependencyConfigurationStatusInput = {
  /** ID of the status */
  id: Scalars['ID']['input'];
  /** Type of the status */
  type: JiraJourneyStatusDependencyType;
};

export enum JiraJourneyStatusDependencyType {
  Status = 'STATUS',
  StatusCategory = 'STATUS_CATEGORY'
}

export type JiraJourneyTriggerConfigurationInput = {
  parentIssueTriggerConfiguration?: InputMaybe<JiraJourneyParentIssueTriggerConfigurationInput>;
  workdayIntegrationTriggerConfiguration?: InputMaybe<JiraJourneyWorkdayIntegrationTriggerConfigurationInput>;
};

/** @deprecated(reason : "Replaced with JiraJourneyTriggerConfigurationInput to support @oneOf directive") */
export type JiraJourneyTriggerInput = {
  /** The type of the trigger, e.g. 'parentIssueCreated' */
  type: JiraJourneyTriggerType;
};

export enum JiraJourneyTriggerType {
  /** When a parent issue is created */
  ParentIssueCreated = 'PARENT_ISSUE_CREATED',
  /** When run customized journey is triggered */
  RunCustomizedJourneyTriggered = 'RUN_CUSTOMIZED_JOURNEY_TRIGGERED',
  /** When workday integration is triggered */
  WorkdayIntegrationTriggered = 'WORKDAY_INTEGRATION_TRIGGERED'
}

export type JiraJourneyWorkItemConfigurationInput = {
  /** Field value mapping. It contains list of object which is like a map entry including a string key and array of string value */
  fieldValues?: InputMaybe<Array<InputMaybe<JiraJourneyWorkItemFieldValueKeyValuePairInput>>>;
  /** Issue type of the work item */
  issueTypeId?: InputMaybe<Scalars['ID']['input']>;
  /** Name of the work item */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Project of the work item */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** Request type of the work item */
  requestTypeId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraJourneyWorkItemCustomizationSettingsInput = {
  /** Indicates if the work item is immutable during journey execution with type `JiraJourneyConfigurationType.CUSTOMIZABLE_JOURNEY` */
  isImmutable?: InputMaybe<Scalars['Boolean']['input']>;
};

export type JiraJourneyWorkItemFieldValueKeyValuePairInput = {
  key: Scalars['String']['input'];
  value: Array<InputMaybe<Scalars['String']['input']>>;
};

export type JiraJourneyWorkdayIntegrationTriggerConfigurationInput = {
  /** The automation rule id */
  ruleId?: InputMaybe<Scalars['ID']['input']>;
  /** The type of the trigger. should be 'WORKDAY_INTEGRATION_TRIGGERED' */
  type?: InputMaybe<JiraJourneyTriggerType>;
};

/**
 * The autocomplete types available for Jira fields in the context of the Jira Query Language.
 *
 * This enum also describes which fields have field-value support from this schema.
 */
export enum JiraJqlAutocompleteType {
  /** The Jira basic field JQL autocomplete type. */
  Basic = 'BASIC',
  /** The Jira cascadingOption field JQL autocomplete type. */
  Cascadingoption = 'CASCADINGOPTION',
  /** The Jira component field JQL autocomplete type. */
  Component = 'COMPONENT',
  /** The Jira group field JQL autocomplete type. */
  Group = 'GROUP',
  /** The Jira issue field JQL autocomplete type. */
  Issue = 'ISSUE',
  /** The Jira issue field type JQL autocomplete type. */
  Issuetype = 'ISSUETYPE',
  /** The Jira JWM Category field type JQL autocomplete type. */
  JwmCategory = 'JWM_CATEGORY',
  /** The Jira labels field type JQL autocomplete type. */
  Labels = 'LABELS',
  /** No autocomplete support. */
  None = 'NONE',
  /** The Jira option field type JQL autocomplete type. */
  Option = 'OPTION',
  /** The Jira Organization field JQL autocomplete type. */
  Organization = 'ORGANIZATION',
  /** The Jira priority field JQL autocomplete type. */
  Priority = 'PRIORITY',
  /** The Jira project field JQL autocomplete type. */
  Project = 'PROJECT',
  /** The Jira RequestType field JQL autocomplete type. */
  Requesttype = 'REQUESTTYPE',
  /** The Jira resolution field JQL autocomplete type. */
  Resolution = 'RESOLUTION',
  /** The Jira sprint field JQL autocomplete type. */
  Sprint = 'SPRINT',
  /** The Jira status field JQL autocomplete type. */
  Status = 'STATUS',
  /** The Jira status category field JQL autocomplete type. */
  Statuscategory = 'STATUSCATEGORY',
  /** The Jira TicketCategory field JQL autocomplete type. */
  TicketCategory = 'TICKET_CATEGORY',
  /** The Jira user field JQL autocomplete type. */
  User = 'USER',
  /** The Jira version field JQL autocomplete type. */
  Version = 'VERSION'
}

/** Represents what is needed to define the scope to a Jira backlog */
export type JiraJqlBacklogInput = {
  /** ID of the board */
  boardId: Scalars['Long']['input'];
};

/** Represents what is needed to define the scope to a Jira board */
export type JiraJqlBoardInput = {
  /** ID of the board */
  boardId: Scalars['Long']['input'];
  /** Swimlane strategy of the board */
  swimlaneStrategy?: InputMaybe<JiraBoardSwimlaneStrategy>;
};

/** The modes the JQL builder can be displayed and used in. */
export enum JiraJqlBuilderMode {
  /**
   * The basic mode, allows queries to be built and executed via the JQL basic editor.
   *
   * This mode allows users to easily construct JQL queries by interacting with the UI.
   */
  Basic = 'BASIC',
  /**
   * The JQL mode, allows queries to be built and executed via the JQL advanced editor.
   *
   * This mode allows users to manually type and construct complex JQL queries.
   */
  Jql = 'JQL'
}

/** The types of JQL clauses supported by Jira. */
export enum JiraJqlClauseType {
  /** This denotes both WHERE and ORDER_BY. */
  Any = 'ANY',
  /** This corresponds to fields used to sort Jira Issues. */
  OrderBy = 'ORDER_BY',
  /** This corresponds to jql fields used as filter criteria of Jira issues. */
  Where = 'WHERE'
}

export enum JiraJqlFunctionStatus {
  Finished = 'FINISHED',
  Processing = 'PROCESSING',
  Unknown = 'UNKNOWN'
}

/**
 * The types of JQL operators supported by Jira.
 *
 * An operator in JQL is one or more symbols or words,which compares the value of a field on its left with one or more values (or functions) on its right,
 * such that only true results are retrieved by the clause.
 *
 * For more information on JQL operators please visit: https://support.atlassian.com/jira-software-cloud/docs/advanced-search-reference-jql-operators.
 */
export enum JiraJqlOperator {
  /** The `CHANGED` operator is used to find issues that have a value that had changed for the specified field. */
  Changed = 'CHANGED',
  /** The `CHANGED` operator is used to find issues that have a value that had changed for the specified field. */
  Contains = 'CONTAINS',
  /** The `=` operator is used to search for issues where the value of the specified field exactly matches the specified value. */
  Equals = 'EQUALS',
  /** The `>` operator is used to search for issues where the value of the specified field is greater than the specified value. */
  GreaterThan = 'GREATER_THAN',
  /** The `>=` operator is used to search for issues where the value of the specified field is greater than or equal to the specified value. */
  GreaterThanOrEqual = 'GREATER_THAN_OR_EQUAL',
  /** The `IN` operator is used to search for issues where the value of the specified field is one of multiple specified values. */
  In = 'IN',
  /** The `IS` operator can only be used with EMPTY or NULL. That is, it is used to search for issues where the specified field has no value. */
  Is = 'IS',
  /** The `IS NOT` operator can only be used with EMPTY or NULL. That is, it is used to search for issues where the specified field has a value. */
  IsNot = 'IS_NOT',
  /** The `<` operator is used to search for issues where the value of the specified field is less than the specified value. */
  LessThan = 'LESS_THAN',
  /** The `<=` operator is used to search for issues where the value of the specified field is less than or equal to than the specified value. */
  LessThanOrEqual = 'LESS_THAN_OR_EQUAL',
  /** The `!~` operator is used to search for issues where the value of the specified field is not a "fuzzy" match for the specified value. */
  NotContains = 'NOT_CONTAINS',
  /** The `!=` operator is used to search for issues where the value of the specified field does not match the specified value. */
  NotEquals = 'NOT_EQUALS',
  /** The `NOT IN` operator is used to search for issues where the value of the specified field is not one of multiple specified values. */
  NotIn = 'NOT_IN',
  /** The `WAS` operator is used to find issues that currently have or previously had the specified value for the specified field. */
  Was = 'WAS',
  /** The `WAS IN` operator is used to find issues that currently have or previously had any of multiple specified values for the specified field. */
  WasIn = 'WAS_IN',
  /** The `WAS NOT` operator is used to find issues that have never had the specified value for the specified field. */
  WasNot = 'WAS_NOT',
  /** The `WAS NOT IN` operator is used to search for issues where the value of the specified field has never been one of multiple specified values. */
  WasNotIn = 'WAS_NOT_IN'
}

/** Represents what is needed to define the scope to a Jira plan */
export type JiraJqlPlanInput = {
  /** ID of the plan */
  planId: Scalars['Long']['input'];
  /** ID of the scenario */
  scenarioId?: InputMaybe<Scalars['Long']['input']>;
};

/** Represents what is needed to define the scope to a Jira project */
export type JiraJqlProjectInput = {
  /** Key of the project */
  projectKey?: InputMaybe<Scalars['String']['input']>;
};

/** Scope to provide specific logic for contexts that require additional inputs */
export type JiraJqlScopeInput = {
  /** When the scope is a Jira backlog */
  backlog?: InputMaybe<JiraJqlBacklogInput>;
  /** When the scope is a Jira board */
  board?: InputMaybe<JiraJqlBoardInput>;
  /** When the scope is Jira List (Issue Navigator) */
  list?: InputMaybe<JiraIssueSearchScope>;
  /** When the scope is a Jira plan */
  plan?: InputMaybe<JiraJqlPlanInput>;
  /** When the scope is a Jira project */
  project?: InputMaybe<JiraJqlProjectInput>;
};

export enum JiraJqlSyntaxError {
  BadFieldId = 'BAD_FIELD_ID',
  BadFunctionArgument = 'BAD_FUNCTION_ARGUMENT',
  BadOperator = 'BAD_OPERATOR',
  BadPropertyId = 'BAD_PROPERTY_ID',
  EmptyField = 'EMPTY_FIELD',
  EmptyFunction = 'EMPTY_FUNCTION',
  EmptyFunctionArgument = 'EMPTY_FUNCTION_ARGUMENT',
  IllegalCharacter = 'ILLEGAL_CHARACTER',
  IllegalEscape = 'ILLEGAL_ESCAPE',
  IllegalNumber = 'ILLEGAL_NUMBER',
  MissingFieldName = 'MISSING_FIELD_NAME',
  MissingLogicalOperator = 'MISSING_LOGICAL_OPERATOR',
  NoOperator = 'NO_OPERATOR',
  NoOrder = 'NO_ORDER',
  OperandUnsupported = 'OPERAND_UNSUPPORTED',
  PredicateUnsupported = 'PREDICATE_UNSUPPORTED',
  ReservedCharacter = 'RESERVED_CHARACTER',
  ReservedWord = 'RESERVED_WORD',
  UnexpectedText = 'UNEXPECTED_TEXT',
  UnfinishedString = 'UNFINISHED_STRING',
  Unknown = 'UNKNOWN'
}

/** The types of view contexts supported by JQL Fields. */
export enum JiraJqlViewContext {
  /** This corresponds to fields requested for Jira Product Discovery Roadmaps. */
  JpdRoadmaps = 'JPD_ROADMAPS',
  /** This corresponds to fields requested for Jira Service Management Queue Page. */
  JsmQueuePage = 'JSM_QUEUE_PAGE',
  /** This corresponds to fields requested for Jira Service Management Summary Page. */
  JsmSummaryPage = 'JSM_SUMMARY_PAGE',
  /** This corresponds to fields requested for Jira Software Plans. */
  JswPlans = 'JSW_PLANS',
  /** This corresponds to fields requested for Jira Software Summary Page. */
  JswSummaryPage = 'JSW_SUMMARY_PAGE',
  /** This corresponds to fields requested for Jira Work Management (JWM). */
  Jwm = 'JWM',
  /** This corresponds to the shadow request client. */
  ShadowRequest = 'SHADOW_REQUEST'
}

/** Represents the location where the created issue should be placed in the Backlog view */
export enum JiraKanbanDestination {
  /**  for kanban boards */
  Backlog = 'BACKLOG',
  Board = 'BOARD'
}

export type JiraLabelColorUpdateInput = {
  /** The color of the label */
  color?: InputMaybe<JiraOptionColorInput>;
  /** ARI for the issuefield */
  fieldId: Scalars['ID']['input'];
  /** Label name for the color update */
  label: Scalars['String']['input'];
};

/** These are supposed to be properties associated to a label. */
export type JiraLabelProperties = {
  /** Color selected by the user for the label. */
  color?: InputMaybe<JiraOptionColorInput>;
  name: Scalars['String']['input'];
};

/** Input type for labels field */
export type JiraLabelsFieldInput = {
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List of labels on which the action will be performed */
  labels?: InputMaybe<Array<JiraLabelsInput>>;
};

export type JiraLabelsFieldOperationInput = {
  /** A List of labels specifying its associated properties */
  labelProperties?: InputMaybe<Array<JiraLabelProperties>>;
  labels: Array<Scalars['String']['input']>;
  operation: JiraMultiValueFieldOperations;
};

/** Represents the data of a single Label */
export type JiraLabelsInput = {
  /** Name of the label selected */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for defining the operation on the Team field of a Jira issue. */
export type JiraLegacyTeamFieldOperationInput = {
  /**
   * The operation to perform on the Team field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
  /**  Accepts the team ID  */
  teamId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input to link/unlink an issue to/from a related work item. */
export type JiraLinkIssueToVersionRelatedWorkInput = {
  /**
   * The identifier for the Jira issue. To unlink an issue from the related work item, leave this field
   * as null.
   */
  issueId?: InputMaybe<Scalars['ID']['input']>;
  /** Client-generated ID for the related work item. */
  relatedWorkId?: InputMaybe<Scalars['ID']['input']>;
  /** The type of related work item being assigned. */
  relatedWorkType: JiraVersionRelatedWorkType;
  /** The identifier of the Jira version. */
  versionId: Scalars['ID']['input'];
};

export enum JiraLinkIssuesToIncidentIssueLinkTypeName {
  PostIncidentReviews = 'POST_INCIDENT_REVIEWS',
  Relates = 'RELATES'
}

export type JiraLinkIssuesToIncidentMutationInput = {
  /** The id of the JSM incident to have issues linked to it. */
  incidentId: Scalars['ID']['input'];
  /**
   * The ids of the issues to link to an incident. This can be a JSW issue as an
   * action item or a JSM issues as a post incident review.
   */
  issueIds: Array<Scalars['ID']['input']>;
  /**
   * The issue link type to create. If not provided, will fall back to the first
   * found one. The issue link created will use the outbound issue link name i.e.
   *
   * RELATES -> incident 'relates to' issue
   * POST_INCIDENT_REVIEWS -> incident 'reviewed by' issue
   */
  issueLinkTypeName: JiraLinkIssuesToIncidentIssueLinkTypeName;
};

export type JiraLinkedIssuesInput = {
  /** Accepts ARI(s): issue */
  inwardIssues?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Accepts ARI(s): issue */
  outwardIssues?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Legacy list setting at a project level */
export type JiraListSettingMigrationData = {
  /** A list of field ids in order */
  columns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Group by value which is a field id */
  groupBy?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether completed tasks should be hidden */
  hideDone?: InputMaybe<Scalars['Boolean']['input']>;
  /** The JQL from filter */
  jql?: InputMaybe<Scalars['String']['input']>;
  /** The project id that the migration is happening on */
  projectId: Scalars['Long']['input'];
};

/** Input to migrate the legacy list settings to saved view */
export type JiraListSettingMigrationInput = {
  /** cloud id of the tenant */
  cloudId: Scalars['ID']['input'];
  /** A list of legacy list settings per project */
  nodes?: InputMaybe<Array<JiraListSettingMigrationData>>;
};

export enum JiraLongRunningTaskStatus {
  /** Indicates the task has been successfully cancelled */
  Cancelled = 'CANCELLED',
  /** Indicates someone has requested the task to be cancelled */
  CancelRequested = 'CANCEL_REQUESTED',
  /** Indicates the task has been successfully completed */
  Complete = 'COMPLETE',
  /** Indicates the task has been unresponsive for some time and was marked to be dead */
  Dead = 'DEAD',
  /** Indicates the task has been created and waiting in the queue */
  Enqueued = 'ENQUEUED',
  /** Indicates the task has failed */
  Failed = 'FAILED',
  /** Indicates the task is currently running */
  Running = 'RUNNING'
}

export type JiraLookAndFeelImageInput = {
  /** ID of the image stored in media platform */
  mediaFileId?: InputMaybe<Scalars['ID']['input']>;
  /** External URL of the image (non-Atlassian URL) */
  url?: InputMaybe<Scalars['URL']['input']>;
};

/** Input for the jira_mergeIssues mutation */
export type JiraMergeIssuesInput = {
  /** Indicates whether attachments should be merged */
  mergeAttachments: Scalars['Boolean']['input'];
  /** Indicates whether comments should be merged */
  mergeComments: Scalars['Boolean']['input'];
  /** The ARI of the issue's description to retain */
  mergeDescriptionFrom: Scalars['ID']['input'];
  /** The ARI of the issue's fields to retain */
  mergeFieldsFrom: Scalars['ID']['input'];
  /** Indicates whether links should be merged */
  mergeLinks: Scalars['Boolean']['input'];
  /** Indicates whether subtasks should be merged */
  mergeSubtasks: Scalars['Boolean']['input'];
  /** The ARI of the issues to merge. These issues will be archived. */
  sourceIds: Array<Scalars['ID']['input']>;
  /** The ARI of the issue to merge into */
  targetId: Scalars['ID']['input'];
};

/** Input for the jira_mergeIssuesOperationProgress query */
export type JiraMergeIssuesOperationProgressInput = {
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The taskId to retrieve progress for */
  taskId: Scalars['ID']['input'];
};

/** # enums */
export enum JiraMergeSteps {
  MergeAttachments = 'MERGE_ATTACHMENTS',
  MergeComments = 'MERGE_COMMENTS',
  MergeDescription = 'MERGE_DESCRIPTION',
  MergeFields = 'MERGE_FIELDS',
  MergeLinks = 'MERGE_LINKS',
  MergeSubtasks = 'MERGE_SUBTASKS'
}

/**
 * The input to merge one version with another, which deletes the source version and moves
 * all issues from the source version to the target version.
 */
export type JiraMergeVersionInput = {
  /** The ID of the source version that is being merged. */
  id: Scalars['ID']['input'];
  /** The ID of the target version for the merge. */
  targetVersionId: Scalars['ID']['input'];
};

/** Describes the possible ends of a cell. */
export enum JiraMoveBoardViewIssueToCellEnd {
  /** Represents the bottom end of a cell. */
  Bottom = 'BOTTOM',
  /** Represents the top end of a cell. */
  Top = 'TOP'
}

/** Mutation input to move an issue to the end (top/bottom) of its cell. */
export type JiraMoveBoardViewIssueToCellEndInput = {
  /** ID of the cell the issue is expected to currently be in. */
  cellId: Scalars['ID']['input'];
  /** Which end of the cell (i.e. top or bottom) to move the issue to. */
  end: JiraMoveBoardViewIssueToCellEnd;
  /** ID of the issue being moved. Encoded as an ARI. */
  id: Scalars['ID']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
};

/** The input to reassign issues from an existing fix version to another fix version. */
export type JiraMoveIssuesToFixVersionInput = {
  /** The IDs of the issues to be reassigned to another fix version. */
  issueIds: Array<Scalars['ID']['input']>;
  /** The ID of the version to remove the issues from. */
  originalVersionId: Scalars['ID']['input'];
  /** The ID of the version to add the issues to. */
  targetVersionId: Scalars['ID']['input'];
};

/**
 * Input to update a version's sequence so that it is the latest version ordered
 * relative to other versions in the project.
 */
export type JiraMoveVersionToEndInput = {
  /** The identifier of the Jira version being updated. */
  id: Scalars['ID']['input'];
};

/**
 * Input to update a version's sequence so that it is the earliest version ordered
 * relative to other versions in the project.
 */
export type JiraMoveVersionToStartInput = {
  /** The identifier of the Jira version being updated. */
  id: Scalars['ID']['input'];
};

/** Input type for multi select component field */
export type JiraMultiSelectComponentFieldInput = {
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** List of component fields on which the action will be performed */
  components?: InputMaybe<Array<JiraComponentInput>>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
};

/** Operations that can be performed on multi value fields like labels, components, etc. */
export enum JiraMultiValueFieldOperations {
  /** Adds value to multi value field. */
  Add = 'ADD',
  /** Removes value from multi value field. */
  Remove = 'REMOVE',
  /** Overrides multi value field. */
  Set = 'SET'
}

/** Input type for multiple group picker field */
export type JiraMultipleGroupPickerFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List og groups associated with the field */
  groups: Array<JiraGroupInput>;
};

/** Input type for defining the operation on the MultipleGroupPicker field of a Jira issue. */
export type JiraMultipleGroupPickerFieldOperationInput = {
  /**
   * Group Id(s) for field update.
   * Accepts ARI(s): group
   */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Operations supported: ADD, REMOVE and SET. */
  operation: JiraMultiValueFieldOperations;
};

/** Input type for multiple select clearable user picker fields */
export type JiraMultipleSelectClearableUserPickerFieldInput = {
  fieldId: Scalars['ID']['input'];
  users?: InputMaybe<Array<JiraUserInput>>;
};

/** Input type for multi select field */
export type JiraMultipleSelectFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List of options on which the action will be performed */
  options: Array<JiraSelectedOptionInput>;
};

export type JiraMultipleSelectFieldOperationInput = {
  /**  Accepts ARI(s): issue-field-option  */
  ids: Array<Scalars['ID']['input']>;
  operation: JiraMultiValueFieldOperations;
};

/** Input type for multiple select user picker fields */
export type JiraMultipleSelectUserPickerFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Input data for users being selected */
  users: Array<JiraUserInput>;
};

/** Input type for defining the operation on MultipleSelectUserPicker field of a Jira issue. */
export type JiraMultipleSelectUserPickerFieldOperationInput = {
  /** Accepts ARI(s): user */
  ids: Array<Scalars['ID']['input']>;
  /** The operation to perform on the MultipleSelectUserPicker field. */
  operation: JiraMultiValueFieldOperations;
};

/** Input type for multiple select version picker fields */
export type JiraMultipleVersionPickerFieldInput = {
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List of versions on which the action will be performed */
  versions: Array<JiraVersionInput>;
};

/** Input type for defining the operation on Multiple Version Picker field of a Jira issue. */
export type JiraMultipleVersionPickerFieldOperationInput = {
  /** Accept ARI(s): version */
  ids: Array<Scalars['ID']['input']>;
  /**
   * The operations to perform on Multiple Version Picker field.
   * SET, ADD, REMOVE operations are supported.
   */
  operation: JiraMultiValueFieldOperations;
};

/** The input used for an natural language to JQL conversion */
export type JiraNaturalLanguageToJqlInput = {
  naturalLanguageInput: Scalars['String']['input'];
  searchContext?: InputMaybe<JiraSearchContextInput>;
};

/**
 * List of values identifying the known navigation item types. This list is shared between
 * business and software projects but only some are supported by one or the other.
 */
export enum JiraNavigationItemTypeKey {
  App = 'APP',
  Approvals = 'APPROVALS',
  /** @deprecated Replaced by APP as each app will have its own navigation item */
  Apps = 'APPS',
  ArchivedIssues = 'ARCHIVED_ISSUES',
  Attachments = 'ATTACHMENTS',
  Backlog = 'BACKLOG',
  Board = 'BOARD',
  Calendar = 'CALENDAR',
  Capacity = 'CAPACITY',
  Code = 'CODE',
  Components = 'COMPONENTS',
  /** @deprecated Replaced by INBOX which will be used as a more generic nav item */
  CustomerSupport = 'CUSTOMER_SUPPORT',
  Dependencies = 'DEPENDENCIES',
  Deployments = 'DEPLOYMENTS',
  Development = 'DEVELOPMENT',
  Forms = 'FORMS',
  /** @deprecated Get started item was an experiment which has been cleaned up */
  GetStarted = 'GET_STARTED',
  Goals = 'GOALS',
  Inbox = 'INBOX',
  Incidents = 'INCIDENTS',
  Issues = 'ISSUES',
  List = 'LIST',
  OnCall = 'ON_CALL',
  Pages = 'PAGES',
  PlanCalendar = 'PLAN_CALENDAR',
  PlanDependencies = 'PLAN_DEPENDENCIES',
  PlanProgram = 'PLAN_PROGRAM',
  PlanReleases = 'PLAN_RELEASES',
  PlanSummary = 'PLAN_SUMMARY',
  PlanTeams = 'PLAN_TEAMS',
  PlanTimeline = 'PLAN_TIMELINE',
  Program = 'PROGRAM',
  Queue = 'QUEUE',
  Releases = 'RELEASES',
  Reports = 'REPORTS',
  Requests = 'REQUESTS',
  Security = 'SECURITY',
  Shortcuts = 'SHORTCUTS',
  Staffing = 'STAFFING',
  Summary = 'SUMMARY',
  Teams = 'TEAMS',
  Timeline = 'TIMELINE'
}

/** Represents the possible notification categories for notification types. */
export enum JiraNotificationCategoryType {
  CommentChanges = 'COMMENT_CHANGES',
  IssueAssigned = 'ISSUE_ASSIGNED',
  IssueChanges = 'ISSUE_CHANGES',
  IssueMentioned = 'ISSUE_MENTIONED',
  IssueMiscellaneous = 'ISSUE_MISCELLANEOUS',
  IssueWorklogChanges = 'ISSUE_WORKLOG_CHANGES',
  Recurring = 'RECURRING',
  SpaceAccessRequest = 'SPACE_ACCESS_REQUEST',
  UserJoin = 'USER_JOIN'
}

/** Represents the possible types notification channels. */
export enum JiraNotificationChannelType {
  Email = 'EMAIL',
  InProduct = 'IN_PRODUCT',
  MobilePush = 'MOBILE_PUSH',
  Slack = 'SLACK'
}

/** Represents a notification preferences to be updated. */
export type JiraNotificationPreferenceInput = {
  /** The channel to enable/disable this preference for */
  channel?: InputMaybe<JiraNotificationChannelType>;
  /** Whether this channel should be enabled or disabled */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The notification type to be updated */
  type: JiraNotificationType;
};

/** Represents the possible types of notifications. */
export enum JiraNotificationType {
  CommentCreated = 'COMMENT_CREATED',
  CommentDeleted = 'COMMENT_DELETED',
  CommentEdited = 'COMMENT_EDITED',
  /** @deprecated Will be removed as part of experiment jira_mention_reminders_digest_new cleanup */
  CommentMentionReminder = 'COMMENT_MENTION_REMINDER',
  DailyDueDateNotification = 'DAILY_DUE_DATE_NOTIFICATION',
  IssueAssigned = 'ISSUE_ASSIGNED',
  IssueCreated = 'ISSUE_CREATED',
  IssueDeleted = 'ISSUE_DELETED',
  IssueMoved = 'ISSUE_MOVED',
  IssueUpdated = 'ISSUE_UPDATED',
  MentionsCombined = 'MENTIONS_COMBINED',
  MiscellaneousIssueEventCombined = 'MISCELLANEOUS_ISSUE_EVENT_COMBINED',
  ProjectRecapNotification = 'PROJECT_RECAP_NOTIFICATION',
  SpaceAccessRequestNotification = 'SPACE_ACCESS_REQUEST_NOTIFICATION',
  WorklogCombined = 'WORKLOG_COMBINED'
}

export type JiraNumberFieldFormatConfigInput = {
  /**
   * The number of decimals allowed or enforced on display.
   * Possible values are null, 1, 2, 3, or 4.
   */
  formatDecimals?: InputMaybe<Scalars['Int']['input']>;
  /** The format style of the number field. */
  formatStyle: JiraNumberFieldFormatStyle;
  /** The ISO currency code or unit configured for the number field. */
  formatUnit?: InputMaybe<Scalars['String']['input']>;
};

/** Represents the formatting style configuration for formatting a number field on the UI */
export enum JiraNumberFieldFormatStyle {
  /** Currency style. see Intl.NumberFormat style='currency' */
  Currency = 'CURRENCY',
  /** Decimal means default number formatting without any Unit or Currency style */
  Decimal = 'DECIMAL',
  /** Percent formatting. see Intl.NumberFormat style='percent' */
  Percent = 'PERCENT',
  /** Units like Kilogram, Gigabyte. see Intl.NumberFormat style='unit' */
  Unit = 'UNIT'
}

/** Input type for a number field */
export type JiraNumberFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  value: Scalars['Float']['input'];
};

export type JiraNumberFieldOperationInput = {
  number?: InputMaybe<Scalars['Float']['input']>;
  operation: JiraSingleValueFieldOperations;
};

export type JiraOAuthAppsAppInput = {
  /** Module for reading/writing builds data using these credentials */
  buildsModule?: InputMaybe<JiraOAuthAppsBuildsModuleInput>;
  /** Module for reading/writing deployments data using these credentials */
  deploymentsModule?: InputMaybe<JiraOAuthAppsDeploymentsModuleInput>;
  /** Module for reading/writing development information data using these credentials */
  devInfoModule?: InputMaybe<JiraOAuthAppsDevInfoModuleInput>;
  /** Module for reading/writing feature flags data using these credentials */
  featureFlagsModule?: InputMaybe<JiraOAuthAppsFeatureFlagsModuleInput>;
  /** Home URL from which this app should be accessible */
  homeUrl: Scalars['String']['input'];
  /** Logo of this app which will be shown on the screen */
  logoUrl: Scalars['String']['input'];
  /** Name of this app */
  name: Scalars['String']['input'];
  /** Module for reading/writing remoteLinks information data using these credentials */
  remoteLinksModule?: InputMaybe<JiraOAuthAppsRemoteLinksModuleInput>;
};

export type JiraOAuthAppsAppUpdateInput = {
  /** Module for reading/writing builds data using these credentials */
  buildsModule?: InputMaybe<JiraOAuthAppsBuildsModuleInput>;
  /** Module for reading/writing deployments data using these credentials */
  deploymentsModule?: InputMaybe<JiraOAuthAppsDeploymentsModuleInput>;
  /** Module for reading/writing development information data using these credentials */
  devInfoModule?: InputMaybe<JiraOAuthAppsDevInfoModuleInput>;
  /** Module for reading/writing feature flags data using these credentials */
  featureFlagsModule?: InputMaybe<JiraOAuthAppsFeatureFlagsModuleInput>;
  /** Module for reading/writing remoteLinks information data using these credentials */
  remoteLinksModule?: InputMaybe<JiraOAuthAppsRemoteLinksModuleInput>;
};

export type JiraOAuthAppsBuildsModuleInput = {
  /** True if this app can read/write builds data */
  isEnabled: Scalars['Boolean']['input'];
};

export type JiraOAuthAppsCreateAppInput = {
  /** The app that should be created */
  app: JiraOAuthAppsAppInput;
  /** An id for this mutation */
  clientMutationId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraOAuthAppsDeleteAppInput = {
  /** The id of the app which will be deleted */
  clientId: Scalars['ID']['input'];
  /** An id for this mutation */
  clientMutationId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraOAuthAppsDeploymentsModuleActionsInput = {
  /** A UrlTemplate which the app can inject a list deployments button on the issue view */
  listDeployments?: InputMaybe<JiraOAuthAppsUrlTemplateInput>;
};

export type JiraOAuthAppsDeploymentsModuleInput = {
  /** Actions that this app can invoke on deployments data */
  actions?: InputMaybe<JiraOAuthAppsDeploymentsModuleActionsInput>;
  /** True if this app can read/write deployments data */
  isEnabled: Scalars['Boolean']['input'];
};

export type JiraOAuthAppsDevInfoModuleActionsInput = {
  /** A UrlTemplate which the app can inject a create branch button on the issue view */
  createBranch?: InputMaybe<JiraOAuthAppsUrlTemplateInput>;
};

export type JiraOAuthAppsDevInfoModuleInput = {
  /** Actions that this app can invoke on development information data */
  actions?: InputMaybe<JiraOAuthAppsDevInfoModuleActionsInput>;
  /** True if this app can read/write development information data */
  isEnabled: Scalars['Boolean']['input'];
};

export type JiraOAuthAppsFeatureFlagsModuleActionsInput = {
  /** A UrlTemplate which the app can inject a create feature flag button on the issue view */
  createFlag?: InputMaybe<JiraOAuthAppsUrlTemplateInput>;
  /** A UrlTemplate which the app can inject a link feature flag button on the issue view */
  linkFlag?: InputMaybe<JiraOAuthAppsUrlTemplateInput>;
  /** A UrlTemplate which the app can inject a list feature flags button on the issue view */
  listFlag?: InputMaybe<JiraOAuthAppsUrlTemplateInput>;
};

export type JiraOAuthAppsFeatureFlagsModuleInput = {
  /** Actions that this app can invoke on feature flags data */
  actions?: InputMaybe<JiraOAuthAppsFeatureFlagsModuleActionsInput>;
  /** True if this app can read/write feature flags data */
  isEnabled: Scalars['Boolean']['input'];
};

export type JiraOAuthAppsInstallAppInput = {
  /** The id of the app which will be installed */
  appId: Scalars['ID']['input'];
  /** An id for this mutation */
  clientMutationId?: InputMaybe<Scalars['ID']['input']>;
};

export enum JiraOAuthAppsInstallationStatus {
  Complete = 'COMPLETE',
  Failed = 'FAILED',
  /** One of the possible installation statuses: PENDING, RUNNING, COMPLETE, FAILED */
  Pending = 'PENDING',
  Running = 'RUNNING'
}

export type JiraOAuthAppsRemoteLinksModuleActionInput = {
  id: Scalars['String']['input'];
  label: JiraOAuthAppsRemoteLinksModuleActionLabelInput;
  urlTemplate: Scalars['String']['input'];
};

export type JiraOAuthAppsRemoteLinksModuleActionLabelInput = {
  value: Scalars['String']['input'];
};

export type JiraOAuthAppsRemoteLinksModuleInput = {
  /** Actions that this app can invoke on remoteLinks information data */
  actions?: InputMaybe<Array<JiraOAuthAppsRemoteLinksModuleActionInput>>;
  /** True if this app can read/write remoteLinks information data */
  isEnabled: Scalars['Boolean']['input'];
};

export type JiraOAuthAppsUpdateAppInput = {
  /** The state the app should be after updating it */
  app: JiraOAuthAppsAppUpdateInput;
  /** The id of the app which will be changed */
  clientId: Scalars['ID']['input'];
  /** An id for this mutation */
  clientMutationId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraOAuthAppsUrlTemplateInput = {
  urlTemplate: Scalars['String']['input'];
};

/** Input type for creating or updating an onboarding configuration. */
export type JiraOnboardingConfigInput = {
  /**
   * Indicates if the onboarding modal can be dismissed before the final step.
   * If false, users must complete the entire onboarding flow.
   */
  canDismiss?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specific landing destination URL after onboarding flow completion. */
  destination?: InputMaybe<Scalars['URL']['input']>;
  /** Indicates if the onboarding config is disabled. */
  isDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Logo configuration for the onboarding flow, displayed across all steps. */
  logo?: InputMaybe<JiraOnboardingMediaInput>;
  /**
   * Array of modal configurations for different locales.
   * Each modal contains locale-specific content and steps.
   */
  modals: Array<JiraOnboardingModalInput>;
  /** Custom onboarding name that identifies this configuration. */
  name: Scalars['String']['input'];
  /** Field used for matching onboarding config against user profile (e.g., team type). */
  targetType: JiraOnboardingTargetType;
  /** Values for matching onboarding config against user profile (e.g., specific team names). */
  targetValues: Array<Scalars['String']['input']>;
};

/** Input type for action links in onboarding steps. */
export type JiraOnboardingLinkInput = {
  /** Link target behavior (e.g., "_blank", "_self"). */
  target?: InputMaybe<Scalars['String']['input']>;
  /** Display text for the link. */
  text?: InputMaybe<Scalars['String']['input']>;
  /** Full URL that the link points to. */
  url: Scalars['URL']['input'];
};

/** Input type for media content (images, videos) used in onboarding. */
export type JiraOnboardingMediaInput = {
  /** Alternative text for accessibility purposes. */
  altText?: InputMaybe<Scalars['String']['input']>;
  /**
   * A media file ARI in the format `ari:cloud:media::file/{fileId}`.
   * For more details, see [ARI Registry](https://developer.atlassian.com/platform/atlassian-resource-identifier/resource-owners/registry/#ati%3Acloud%3Amedia%3Afile)
   */
  fileId?: InputMaybe<Scalars['ID']['input']>;
  /** Type of media content. Useful for client-side rendering decisions. */
  mediaType: JiraOnboardingMediaType;
  /** Full URL to the media content. */
  url?: InputMaybe<Scalars['URL']['input']>;
};

/** Enum defining the supported media types for onboarding content. */
export enum JiraOnboardingMediaType {
  /** Static image media type for logos, backgrounds, and visual content. */
  Image = 'IMAGE',
  /** Video media type for embedded video content in onboarding steps. */
  Video = 'VIDEO'
}

/** Input type for modal configuration within an onboarding flow. */
export type JiraOnboardingModalInput = {
  /**
   * Locale of this modal (e.g., "default", "en-US", "de-DE").
   * Matches the locale field for a user shown at /gateway/api/me.
   */
  locale?: InputMaybe<Scalars['String']['input']>;
  /** Array of onboarding steps for this modal. */
  steps: Array<JiraOnboardingStepInput>;
};

/** Input type for individual onboarding steps. */
export type JiraOnboardingStepInput = {
  /** Background media for the step. */
  background?: InputMaybe<JiraOnboardingMediaInput>;
  /** Rich text or markdown description for the step. */
  description: Scalars['String']['input'];
  /** Array of action links for the step. */
  links?: InputMaybe<Array<InputMaybe<JiraOnboardingLinkInput>>>;
  /** Media content embedded in the step. */
  media?: InputMaybe<JiraOnboardingMediaInput>;
  /** Step title displayed to the user. */
  title: Scalars['String']['input'];
};

/** Enum defining the types of targets that can be used for matching onboarding configurations against user profiles. */
export enum JiraOnboardingTargetType {
  /** Target type for matching against team types in user profiles. */
  TeamType = 'TEAM_TYPE'
}

/** Limited colors available for field options from the UI. */
export enum JiraOptionColorInput {
  Blue = 'BLUE',
  BlueDarker = 'BLUE_DARKER',
  BlueDarkest = 'BLUE_DARKEST',
  BlueLighter = 'BLUE_LIGHTER',
  BlueLightest = 'BLUE_LIGHTEST',
  Green = 'GREEN',
  GreenDarker = 'GREEN_DARKER',
  GreenDarkest = 'GREEN_DARKEST',
  GreenLighter = 'GREEN_LIGHTER',
  GreenLightest = 'GREEN_LIGHTEST',
  Grey = 'GREY',
  GreyDarker = 'GREY_DARKER',
  GreyDarkest = 'GREY_DARKEST',
  GreyLighter = 'GREY_LIGHTER',
  GreyLightest = 'GREY_LIGHTEST',
  Lime = 'LIME',
  LimeDarker = 'LIME_DARKER',
  LimeDarkest = 'LIME_DARKEST',
  LimeLighter = 'LIME_LIGHTER',
  LimeLightest = 'LIME_LIGHTEST',
  Magenta = 'MAGENTA',
  MagentaDarker = 'MAGENTA_DARKER',
  MagentaDarkest = 'MAGENTA_DARKEST',
  MagentaLighter = 'MAGENTA_LIGHTER',
  MagentaLightest = 'MAGENTA_LIGHTEST',
  Orange = 'ORANGE',
  OrangeDarker = 'ORANGE_DARKER',
  OrangeDarkest = 'ORANGE_DARKEST',
  OrangeLighter = 'ORANGE_LIGHTER',
  OrangeLightest = 'ORANGE_LIGHTEST',
  Purple = 'PURPLE',
  PurpleDarker = 'PURPLE_DARKER',
  PurpleDarkest = 'PURPLE_DARKEST',
  PurpleLighter = 'PURPLE_LIGHTER',
  PurpleLightest = 'PURPLE_LIGHTEST',
  Red = 'RED',
  RedDarker = 'RED_DARKER',
  RedDarkest = 'RED_DARKEST',
  RedLighter = 'RED_LIGHTER',
  RedLightest = 'RED_LIGHTEST',
  Teal = 'TEAL',
  TealDarker = 'TEAL_DARKER',
  TealDarkest = 'TEAL_DARKEST',
  TealLighter = 'TEAL_LIGHTER',
  TealLightest = 'TEAL_LIGHTEST',
  Yellow = 'YELLOW',
  YellowDarker = 'YELLOW_DARKER',
  YellowDarkest = 'YELLOW_DARKEST',
  YellowLighter = 'YELLOW_LIGHTER',
  YellowLightest = 'YELLOW_LIGHTEST'
}

/** Input type for optional custom field and whether it should be cloned or not */
export type JiraOptionalFieldInput = {
  /** Custom field ID, for example customfield_10044 */
  fieldId: Scalars['String']['input'];
  /** Boolean indicating whether custom fields should cloned or not. Fields are cloned by default. */
  shouldClone: Scalars['Boolean']['input'];
};

/** The input type for opting out of the Not Connected state in the DevOpsPanel */
export type JiraOptoutDevOpsIssuePanelNotConnectedInput = {
  /** Cloud ID of the tenant this change is applied to */
  cloudId: Scalars['ID']['input'];
};

export type JiraOrderDirection = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraOrderFormattingRuleInput = {
  /** Move the current rule after this given rule. If not provided, move the current rule to top of the rule list. */
  afterRuleId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The rule to reorder. */
  ruleId: Scalars['ID']['input'];
};

/** Input for the order issue search formatting rule mutation. */
export type JiraOrderIssueSearchFormattingRuleInput = {
  /** Move the current rule after this given rule. If not provided, move the current rule to top of the rule list. */
  afterRuleId?: InputMaybe<Scalars['ID']['input']>;
  /** The rule to reorder. */
  ruleId: Scalars['ID']['input'];
  /** ARI of the issue search to order formatting rules for. */
  viewId: Scalars['ID']['input'];
};

export enum JiraOrganizationApprovalLocation {
  /** When the approval is done during the organization installation process */
  DuringInstallationFlow = 'DURING_INSTALLATION_FLOW',
  /** When the approval is done during the provisioning the tenant */
  DuringProvisioning = 'DURING_PROVISIONING',
  /** When the approval is done via DVCS page in Jira */
  OnAdminScreen = 'ON_ADMIN_SCREEN',
  /** When the approval is done during the provisioning the tenant. This should be specific to Bitbucket only. */
  RemindBitbucketApprovalBanner = 'REMIND_BITBUCKET_APPROVAL_BANNER',
  /** When the approval is done in unknown UI */
  Unknown = 'UNKNOWN'
}

/** Input type for an organization field */
export type JiraOrganizationFieldInput = {
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List of organizations */
  organizations: Array<JiraOrganizationsInput>;
};

/** Input type for an organization value */
export type JiraOrganizationsInput = {
  /** An identifier for the organization */
  organizationId: Scalars['ID']['input'];
};

/** Input type for updating the Original Time Estimate field of a Jira issue. */
export type JiraOriginalTimeEstimateFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The new value to be placed in the Original Time Estimate field */
  originalEstimate: JiraEstimateInput;
};

/** Possible changeboarding statuses. */
export enum JiraOverviewPlanMigrationChangeboardingStatus {
  /** Indicate that the user has completed the changeboarding flow. */
  Completed = 'COMPLETED',
  /** @deprecated Not used, replaced by COMPLETED status */
  Triggered = 'TRIGGERED'
}

/** Pagination styles supported by the system */
export enum JiraPaginationStyle {
  /** Cursor-based pagination (existing behavior) */
  Cursor = 'CURSOR',
  /** Offset-based pagination for numerical page navigation */
  Offset = 'OFFSET'
}

/** Input type for the parent field of an issue */
export type JiraParentFieldInput = {
  /** An identifier for the issue */
  issueId: Scalars['ID']['input'];
};

/** Input type for defining the operation on the Parent field of a Jira issue. */
export type JiraParentFieldOperationInput = {
  /** Accept ARI(s): issue */
  id?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The operation to perform on the Parent field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
};

/** Input type for people field */
export type JiraPeopleFieldInput = {
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Input data for users being selected */
  users: Array<JiraUserInput>;
};

/** Input type for defining the operation on People field of a Jira issue. */
export type JiraPeopleFieldOperationInput = {
  /** Accepts ARI(s): user */
  ids: Array<Scalars['ID']['input']>;
  /** The operation to perform on the People field. */
  operation: JiraMultiValueFieldOperations;
};

/**
 * Input type contains either the group or the projectRole associated with a comment/worklog, but not both.
 * If both are null, then the permission level is unspecified and the comment/worklog is public.
 */
export type JiraPermissionLevelInput = {
  /** The Jira Group to associate with the comment/worklog. */
  group?: InputMaybe<JiraGroupInput>;
  /** The Jira ProjectRole to associate with the comment/worklog. */
  role?: InputMaybe<JiraRoleInput>;
};

/** The JiraPermissionMessageTypeEnum represents category of the message section. */
export enum JiraPermissionMessageTypeEnum {
  /** Represents a basic message. */
  Information = 'INFORMATION',
  /** Represents a warning message. */
  Warning = 'WARNING'
}

/** The input type to add new permission grants to the given permission scheme. */
export type JiraPermissionSchemeAddGrantInput = {
  /** The list of one or more grants to be added. */
  grants: Array<JiraPermissionSchemeGrantInput>;
  /** The permission scheme ID in ARI format. */
  schemeId: Scalars['ID']['input'];
};

/** Specifies permission scheme grant for the combination of permission key, grant type key, and grant type value ARI. */
export type JiraPermissionSchemeGrantInput = {
  /** The grant type key such as USER. */
  grantType: JiraGrantTypeKeyEnum;
  /**
   * The optional grant value in ARI format. Some grantType like PROJECT_LEAD, REPORTER etc. have no grantValue. Any grantValue passed will be silently ignored.
   * For example: project role ID ari is of the format - ari:cloud:jira:a2520569-493f-45bc-807b-54b02bc724d1:role/project-role/activation/bd0c43a9-a23a-4302-8ffa-ca04bde7c747/projectrole/b434089d-7f6d-476b-884b-7811661f91d2
   */
  grantValue?: InputMaybe<Scalars['ID']['input']>;
  /** the project permission key. */
  permissionKey: Scalars['String']['input'];
};

/** The input type to remove permission grants from the given permission scheme. */
export type JiraPermissionSchemeRemoveGrantInput = {
  /** The list of permission grant ids. */
  grantIds: Array<Scalars['Long']['input']>;
  /** The permission scheme ID in ARI format. */
  schemeId: Scalars['ID']['input'];
};

/** The JiraPermissionTagEnum represents additional tags for the permission key. */
export enum JiraPermissionTagEnum {
  /** Represents a permission that is about to be deprecated. */
  Deprecated = 'DEPRECATED',
  /** Represents a permission that is only available to enterprise customers. */
  Enterprise = 'ENTERPRISE',
  /** Represents a permission that is newly added. */
  New = 'NEW'
}

/** The different permission types that a user can perform on a global level */
export enum JiraPermissionType {
  /** user with this permission can browse at least one project */
  BrowseProjects = 'BROWSE_PROJECTS',
  /** user with this permission can modify collections of issues at once */
  BulkChange = 'BULK_CHANGE'
}

export type JiraPlanFeatureMutationInput = {
  /** Feature toggle value */
  enabled: Scalars['Boolean']['input'];
  /** Plan ARI ID */
  planId: Scalars['ID']['input'];
};

export type JiraPlanMultiScenarioFeatureMutationInput = {
  /** Feature toggle value */
  enabled: Scalars['Boolean']['input'];
  /** Plan ARI ID */
  planId: Scalars['ID']['input'];
  /** The scenario ID to keep */
  scenarioId: Scalars['ID']['input'];
};

export type JiraPlanReleaseFeatureMutationInput = {
  /** Feature toggle value */
  enabled: Scalars['Boolean']['input'];
  /** Indicates if user has consented to the deletion of unsaved release changes */
  hasConsentToDeleteUnsavedChanges?: InputMaybe<Scalars['Boolean']['input']>;
  /** Plan ARI ID */
  planId: Scalars['ID']['input'];
};

/** The status of a Jira Plan */
export enum JiraPlanStatus {
  Active = 'ACTIVE',
  Archived = 'ARCHIVED',
  Trashed = 'TRASHED'
}

/** Execution log filters */
export type JiraPlaybookExecutionFilter = {
  /** contextId is the same as issueId */
  contextId?: InputMaybe<Scalars['String']['input']>;
  endTime?: InputMaybe<Scalars['DateTime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  startTime?: InputMaybe<Scalars['DateTime']['input']>;
  status?: InputMaybe<Array<JiraPlaybookStepRunStatus>>;
};

/** Search by name, state filter for Jira Playbook */
export type JiraPlaybookFilter = {
  name?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<JiraPlaybookStateField>;
};

/**  --------------------------------------------------------------------------------------------- */
export type JiraPlaybookIssueFilterInput = {
  type?: InputMaybe<JiraPlaybookIssueFilterType>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum JiraPlaybookIssueFilterType {
  Groups = 'GROUPS',
  IssueTypes = 'ISSUE_TYPES',
  RequestTypes = 'REQUEST_TYPES'
}

export type JiraPlaybookLabelFilter = {
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for additional properties for a Jira-playbook */
export type JiraPlaybookLabelPropertyInput = {
  color?: InputMaybe<Scalars['String']['input']>;
  editable?: InputMaybe<Scalars['Boolean']['input']>;
};

export type JiraPlaybookListFilter = {
  labels?: InputMaybe<Array<Scalars['ID']['input']>>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Scopes */
export enum JiraPlaybookScopeType {
  Global = 'GLOBAL',
  Issue = 'ISSUE',
  Project = 'PROJECT',
  Team = 'TEAM'
}

/** Status of playbook */
export enum JiraPlaybookStateField {
  Disabled = 'DISABLED',
  Draft = 'DRAFT',
  Enabled = 'ENABLED'
}

export enum JiraPlaybookStepRunStatus {
  Aborted = 'ABORTED',
  ConfigChange = 'CONFIG_CHANGE',
  Failed = 'FAILED',
  Failure = 'FAILURE',
  InProgress = 'IN_PROGRESS',
  Loop = 'LOOP',
  NoActionsPerformed = 'NO_ACTIONS_PERFORMED',
  QueuedForRetry = 'QUEUED_FOR_RETRY',
  SomeErrors = 'SOME_ERRORS',
  Success = 'SUCCESS',
  SuccessUndone = 'SUCCESS_UNDONE',
  Throttled = 'THROTTLED',
  Waiting = 'WAITING'
}

/**  --------------------------------------------------------------------------------------------- */
export enum JiraPlaybookStepType {
  AutomationRule = 'AUTOMATION_RULE',
  InstructionalRule = 'INSTRUCTIONAL_RULE',
  Task = 'TASK'
}

/** The request filters for usage tab */
export type JiraPlaybookStepUsageFilter = {
  /** Filter for executions before this date-time */
  endTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** Filter by playbook name (exact match) */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Filter for executions after this date-time */
  startTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** Filter by playbook state (enum) */
  state?: InputMaybe<JiraPlaybookStateField>;
  /** Filter by step run status (enum) */
  stepStatus?: InputMaybe<Array<JiraPlaybookStepRunStatus>>;
  /** Filter by step type (enum) */
  stepType?: InputMaybe<JiraPlaybookStepType>;
};

/** JiraPlaybookTemplateFilter: Search by name */
export type JiraPlaybookTemplateFilter = {
  name?: InputMaybe<Scalars['String']['input']>;
};

export enum JiraPlaybooksSortBy {
  Name = 'NAME'
}

/**  --------------------------------------------------------------------------------------------- */
export type JiraPlaybooksSortInput = {
  /** The field to apply sorting on */
  by: JiraPlaybooksSortBy;
  /** The direction of sorting */
  order?: SortDirection;
};

export type JiraPriorityFieldOperationInput = {
  /** Accepts ARI(s): priority */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Input type for priority field */
export type JiraPriorityInput = {
  /** An identifier for a priority value */
  priorityId: Scalars['ID']['input'];
};

/** Representation of each Jira product offering. */
export enum JiraProductEnum {
  JiraProductDiscovery = 'JIRA_PRODUCT_DISCOVERY',
  JiraServiceManagement = 'JIRA_SERVICE_MANAGEMENT',
  JiraSoftware = 'JIRA_SOFTWARE',
  JiraWorkManagement = 'JIRA_WORK_MANAGEMENT'
}

/** The type of access level for the project. */
export enum JiraProjectAccessLevelType {
  Free = 'FREE',
  Limited = 'LIMITED',
  Open = 'OPEN',
  Private = 'PRIVATE'
}

/** The different action types that a user can perform on a project */
export enum JiraProjectActionType {
  /** Assign issues within the project. */
  AssignIssues = 'ASSIGN_ISSUES',
  /** Create issues within the project and fill out their fields upon creation. */
  CreateIssues = 'CREATE_ISSUES',
  /** Delete issues within the project. */
  DeleteIssues = 'DELETE_ISSUES',
  /** Edit issues within the project. */
  EditIssues = 'EDIT_ISSUES',
  /** Edit project configuration such as edit access, manage people and permissions, configure issue types and their fields, and enable project features. */
  EditProjectConfig = 'EDIT_PROJECT_CONFIG',
  /** Link issues within the project. */
  LinkIssues = 'LINK_ISSUES',
  /** Manage versions within the project. */
  ManageVersions = 'MANAGE_VERSIONS',
  /** Schedule issues within the project. */
  ScheduleIssues = 'SCHEDULE_ISSUES',
  /** Transition issues within the project. */
  TransitionIssues = 'TRANSITION_ISSUES',
  /** View issues within the project. */
  ViewIssues = 'VIEW_ISSUES',
  /** View some set of project configurations such as edit workflows, edit issue layout, or project details. If EditProjectConfig is true this should be too. */
  ViewProjectConfig = 'VIEW_PROJECT_CONFIG'
}

export type JiraProjectApproveAccessRequestInput = {
  /** AccountId of the user that needs granting the role. */
  actorAccountId: Scalars['ID']['input'];
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The ARI of the project to approve the access request for. */
  projectId: Scalars['ID']['input'];
  /** The ID of the roles to assign to the user when approving the access request. */
  projectRoleIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The ID of the access request to approve. */
  requestId: Scalars['ID']['input'];
};

export type JiraProjectAssociatedFieldsInput = {
  /**  if not specified the result will include all Field types matched */
  includedFieldTypes?: InputMaybe<Array<JiraConfigFieldType>>;
};

/** Represents an input to available fields query */
export type JiraProjectAvailableFieldsInput = {
  /** Search fields by list of field type groups. If empty, fields will not be filtered by field type group. */
  fieldTypeGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Search fields by field name. If null or empty, fields will not be filtered by field name. */
  filterContains?: InputMaybe<Scalars['String']['input']>;
};

export type JiraProjectCategoryFilterInput = {
  /** Filter the project categories list with these category ids */
  categoryIds?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Recommendation action for a project cleanup. */
export enum JiraProjectCleanupRecommendationAction {
  /** This project can be archived. */
  Archive = 'ARCHIVE',
  /** This project can be trashed. */
  Trash = 'TRASH'
}

/** A period of time since the project was found stale. */
export enum JiraProjectCleanupRecommendationStaleSince {
  OneYear = 'ONE_YEAR',
  SixMonths = 'SIX_MONTHS',
  TwoYears = 'TWO_YEARS'
}

export enum JiraProjectCleanupTaskStatusType {
  Complete = 'COMPLETE',
  Error = 'ERROR',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  TerminalError = 'TERMINAL_ERROR'
}

/**
 * String formats for DateTime in JiraProject, the format is in the value of the jira.date.time.picker.java.format property
 * Please refer to the "Change date and time formats" section of the "Configure the look and feel of Jira applications" page
 * https://support.atlassian.com/jira-cloud-administration/docs/configure-the-look-and-feel-of-jira-applications/
 */
export enum JiraProjectDateTimeFormat {
  /** dd/MMM/yy h:mm a    E.g. 23/May/07 3:55 AM */
  CompleteDatetimeFormat = 'COMPLETE_DATETIME_FORMAT',
  /** EEEE h:mm a     E.g. Wednesday 3:55 AM */
  DayFormat = 'DAY_FORMAT',
  /** dd/MMM/yy   E.g. 23/May/07 */
  DayMonthYearFormat = 'DAY_MONTH_YEAR_FORMAT',
  /** E.g. 2 days ago */
  Relative = 'RELATIVE',
  /** h:mm a  E.g. 3:55 AM */
  TimeFormat = 'TIME_FORMAT'
}

/** The input for deleting a custom background */
export type JiraProjectDeleteCustomBackgroundInput = {
  /** The customBackgroundId of the custom background to be deleted */
  customBackgroundId: Scalars['ID']['input'];
  /** The entityId (ARI) of the entity for which the custom background will be deleted */
  entityId: Scalars['ID']['input'];
};

export type JiraProjectDenyAccessRequestInput = {
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The ARI of the project to approve the access request for. */
  projectId: Scalars['ID']['input'];
  /** The ID of the access request to approve. */
  requestId: Scalars['ID']['input'];
};

/** Input type for a project field */
export type JiraProjectFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Represents a project field data */
  project: JiraProjectInput;
};

export type JiraProjectFieldOperationInput = {
  /** Accept ARI(s): project */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
};

export type JiraProjectFilterInput = {
  /**  Filter the results using a literal string. Projects witha matching key or name are returned (case insensitive). */
  keyword?: InputMaybe<Scalars['String']['input']>;
  /** Filter the results based on whether the user has configured notification preferences for it. */
  notificationConfigurationState?: InputMaybe<JiraProjectNotificationConfigurationState>;
  /** the project category that can be used to filter list of projects */
  projectCategoryId?: InputMaybe<Scalars['ID']['input']>;
  /** the sort criteria that is used while filtering the projects */
  sortBy?: InputMaybe<JiraProjectSortInput>;
  /** the project types that can be used to filter list of projects */
  types?: InputMaybe<Array<JiraProjectType>>;
};

/** Input type for a project */
export type JiraProjectInput = {
  /** An identifier for the field */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the project */
  projectId: Scalars['ID']['input'];
};

export type JiraProjectKeysInput = {
  /** Cloud ID of the Jira instance containing the project keys. Required for routing. */
  cloudId: Scalars['ID']['input'];
  /** Project keys to fetch data for. */
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Input type for specifying a sidebar menu item in mutation operations. */
export type JiraProjectLevelSidebarMenuItemInput = {
  /** Unique identifier for the sidebar menu item being customized. */
  itemId: Scalars['ID']['input'];
};

/** The options for the project list sidebar state. */
export enum JiraProjectListRightPanelState {
  /** The project list sidebar is closed. */
  Closed = 'CLOSED',
  /** The project list sidebar is open. */
  Open = 'OPEN'
}

/** Whether or not the user has configured notification preferences for the project. */
export enum JiraProjectNotificationConfigurationState {
  /** The user has configured notification preferences for this project */
  Configured = 'CONFIGURED',
  /** The user has not configured notification preferences for this project. Computed defaults will be returned. */
  Default = 'DEFAULT'
}

/** Options to filter based on project properties */
export type JiraProjectOptions = {
  /** The type of projects we need to filter */
  projectType?: InputMaybe<JiraProjectType>;
};

/**
 * The category of the project permission.
 * It represents the logical grouping of the project permissions.
 */
export enum JiraProjectPermissionCategoryEnum {
  /** Represents one or more permissions to manage issue attacments such as create and delete. */
  Attachments = 'ATTACHMENTS',
  /** Represents one or more permissions to manage issue comments such as add, delete and edit. */
  Comments = 'COMMENTS',
  /** Represents one or more permissions applicable at issue level to manage operations such as create, delete, edit, and transition. */
  Issues = 'ISSUES',
  /** Represents one or more permissions representing default category if not any other existing category. */
  Other = 'OTHER',
  /** Represents one or more permissions applicable at project level such as project administration, view project information, and manage sprints. */
  Projects = 'PROJECTS',
  /** Represents one or more permissions to manage worklogs, time tracking for billing purpose in some cases. */
  TimeTracking = 'TIME_TRACKING',
  /** Represents one or more permissions to manage watchers and voters of an issue. */
  VotersAndWatchers = 'VOTERS_AND_WATCHERS'
}

/**
 * The context in which projects are being queried
 * Project Results differ on the context they are being queried for
 * ex:- passing in CREATE_ISSUE as context will return the list of projects
 * for which user has CREATE_ISSUE permission
 */
export enum JiraProjectPermissionContext {
  CreateIssue = 'CREATE_ISSUE',
  ViewIssue = 'VIEW_ISSUE'
}

/** The different permissions that the user can have for a project */
export enum JiraProjectPermissionType {
  /** Ability to comment on issues. */
  AddComments = 'ADD_COMMENTS',
  /** Ability to administer a project in Jira. */
  AdministerProjects = 'ADMINISTER_PROJECTS',
  /** Ability to archive issues within a project. */
  ArchiveIssues = 'ARCHIVE_ISSUES',
  /** Users with this permission may be assigned to issues. */
  AssignableUser = 'ASSIGNABLE_USER',
  /** Ability to assign issues to other people. */
  AssignIssues = 'ASSIGN_ISSUES',
  /** Ability to browse projects and the issues within them. */
  BrowseProjects = 'BROWSE_PROJECTS',
  /** Ability to close issues. Often useful where your developers resolve issues, and a QA department closes them. */
  CloseIssues = 'CLOSE_ISSUES',
  /** Users with this permission may create attachments. */
  CreateAttachments = 'CREATE_ATTACHMENTS',
  /** Ability to create issues. */
  CreateIssues = 'CREATE_ISSUES',
  /** Users with this permission may delete all attachments. */
  DeleteAllAttachments = 'DELETE_ALL_ATTACHMENTS',
  /** Ability to delete all comments made on issues. */
  DeleteAllComments = 'DELETE_ALL_COMMENTS',
  /** Ability to delete all worklogs made on issues. */
  DeleteAllWorklogs = 'DELETE_ALL_WORKLOGS',
  /** Ability to delete issues. */
  DeleteIssues = 'DELETE_ISSUES',
  /** Users with this permission may delete own attachments. */
  DeleteOwnAttachments = 'DELETE_OWN_ATTACHMENTS',
  /** Ability to delete own comments made on issues. */
  DeleteOwnComments = 'DELETE_OWN_COMMENTS',
  /** Ability to delete own worklogs made on issues. */
  DeleteOwnWorklogs = 'DELETE_OWN_WORKLOGS',
  /** Ability to edit all comments made on issues. */
  EditAllComments = 'EDIT_ALL_COMMENTS',
  /** Ability to edit all worklogs made on issues. */
  EditAllWorklogs = 'EDIT_ALL_WORKLOGS',
  /** Ability to edit issues. */
  EditIssues = 'EDIT_ISSUES',
  /** Ability to manage issue layout, and add, remove, and search for fields in Jira. */
  EditIssueLayout = 'EDIT_ISSUE_LAYOUT',
  /** Ability to edit own comments made on issues. */
  EditOwnComments = 'EDIT_OWN_COMMENTS',
  /** Ability to edit own worklogs made on issues. */
  EditOwnWorklogs = 'EDIT_OWN_WORKLOGS',
  /** Ability to edit a workflow. */
  EditWorkflow = 'EDIT_WORKFLOW',
  /** Ability to link issues together and create linked issues. Only useful if issue linking is turned on. */
  LinkIssues = 'LINK_ISSUES',
  /** Ability to manage the watchers of an issue. */
  ManageWatchers = 'MANAGE_WATCHERS',
  /** Ability to modify the reporter when creating or editing an issue. */
  ModifyReporter = 'MODIFY_REPORTER',
  /** Ability to move issues between projects or between workflows of the same project (if applicable). Note the user can only move issues to a project they have the create permission for. */
  MoveIssues = 'MOVE_ISSUES',
  /** Ability to resolve and reopen issues. This includes the ability to set a fix version. */
  ResolveIssues = 'RESOLVE_ISSUES',
  /** Ability to view or edit an issue's due date. */
  ScheduleIssues = 'SCHEDULE_ISSUES',
  /** Ability to use service desk agent features. */
  ServicedeskAgent = 'SERVICEDESK_AGENT',
  /** Ability to set the level of security on an issue so that only people in that security level can see the issue. */
  SetIssueSecurity = 'SET_ISSUE_SECURITY',
  /** Ability to transition issues. */
  TransitionIssues = 'TRANSITION_ISSUES',
  /** Ability to unarchive issues within a project. */
  UnarchiveIssues = 'UNARCHIVE_ISSUES',
  /** Allows users in a software project to view development-related information on the issue, such as commits, reviews and build information. */
  ViewDevTools = 'VIEW_DEV_TOOLS',
  /** Users with this permission may view a read-only version of a workflow. */
  ViewReadonlyWorkflow = 'VIEW_READONLY_WORKFLOW',
  /** Ability to view the voters and watchers of an issue. */
  ViewVotersAndWatchers = 'VIEW_VOTERS_AND_WATCHERS',
  /** Ability to log work done against an issue. Only useful if Time Tracking is turned on. */
  WorkOnIssues = 'WORK_ON_ISSUES'
}

/** Types of project recommendations based on different activity sources */
export enum JiraProjectRecommendationType {
  /** The project recommendation was via inviter activity */
  InviterActivity = 'INVITER_ACTIVITY',
  /** The project recommendation was via top projects in the tenant */
  TenantActivity = 'TENANT_ACTIVITY'
}

/** Recommendation action for a project role actor. */
export enum JiraProjectRoleActorRecommendationAction {
  /** This project role actor can be trashed. */
  Trash = 'TRASH'
}

/** User status for a project role actor. */
export enum JiraProjectRoleActorUserStatus {
  /** The user associated with this project role actor is deleted. */
  Deleted = 'DELETED',
  /** The user associated with this project role actor is not active. */
  Inactive = 'INACTIVE'
}

/** The supported different shortcut types */
export enum JiraProjectShortcutType {
  /** A shortcut which links to a repository */
  Repository = 'REPOSITORY',
  /** The basic shortcut link */
  ShortcutLink = 'SHORTCUT_LINK',
  /** When an unexpected shortcut type is encountered which is not yet supported */
  Unknown = 'UNKNOWN'
}

export enum JiraProjectSortField {
  /** sorts by category */
  Category = 'CATEGORY',
  /** sorts by favourite value of the project */
  Favourite = 'FAVOURITE',
  /** sorts by project key */
  Key = 'KEY',
  /** sorts by the time of the last updated issue in the project */
  LastIssueUpdatedTime = 'LAST_ISSUE_UPDATED_TIME',
  /** sorts by lead */
  Lead = 'LEAD',
  /** sorts by project name */
  Name = 'NAME',
  /** sorts by recommendation */
  Recommendation = 'RECOMMENDATION'
}

export type JiraProjectSortInput = {
  order?: InputMaybe<SortDirection>;
  sortBy?: InputMaybe<JiraProjectSortField>;
};

/** Jira Project statuses. */
export enum JiraProjectStatus {
  /** An active project. */
  Active = 'ACTIVE',
  /** An archived project. */
  Archived = 'ARCHIVED',
  /** A deleted project. */
  Deleted = 'DELETED'
}

/** Jira Project Styles. */
export enum JiraProjectStyle {
  /** A company-managed project. */
  CompanyManagedProject = 'COMPANY_MANAGED_PROJECT',
  /** A team-managed project. */
  TeamManagedProject = 'TEAM_MANAGED_PROJECT'
}

/** Jira Project types. */
export enum JiraProjectType {
  /** A business project. */
  Business = 'BUSINESS',
  /** A customer service project. */
  CustomerService = 'CUSTOMER_SERVICE',
  /** A product discovery project. */
  ProductDiscovery = 'PRODUCT_DISCOVERY',
  /** A service desk project. */
  ServiceDesk = 'SERVICE_DESK',
  /** A software project. */
  Software = 'SOFTWARE'
}

/** Input for updating a project's avatar. */
export type JiraProjectUpdateAvatarInput = {
  /** The new project avatarId. */
  avatarId: Scalars['ID']['input'];
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The id or key of the project to update the name for. */
  projectIdOrKey: Scalars['String']['input'];
};

/** Input for updating a project's name. */
export type JiraProjectUpdateNameInput = {
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The new project name. */
  name: Scalars['String']['input'];
  /** The id or key of the project to update the name for. */
  projectIdOrKey: Scalars['String']['input'];
};

/** Whether or not the user wants linked, unlinked or all the projects. */
export enum JiraProjectsHelpCenterMappingStatus {
  All = 'ALL',
  Linked = 'LINKED',
  Unlinked = 'UNLINKED'
}

export type JiraProjectsMappedToHelpCenterFilterInput = {
  /** help center ARI that can be used to filter the projects mapped to Help Center */
  helpCenterARI?: InputMaybe<Scalars['ID']['input']>;
  /** the help center id that can be used to filter the projects mapped to Help Center */
  helpCenterId: Scalars['ID']['input'];
  /** Filter the results based on whether the user wants linked, unlinked or all the projects. */
  helpCenterMappingStatus?: InputMaybe<JiraProjectsHelpCenterMappingStatus>;
};

/** Input to publish the customized config of a board view for all users. */
export type JiraPublishBoardViewConfigInput = {
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view whose config is being published for all users. */
  viewId: Scalars['ID']['input'];
};

/** Input to publish the customized config of an issue search for all users. */
export type JiraPublishIssueSearchConfigInput = {
  /** Input for settings applied to Issue Search views. */
  settings?: InputMaybe<JiraIssueSearchSettings>;
  /** ARI of the issue search whose config is being published for all users. */
  viewId: Scalars['ID']['input'];
};

export type JiraPublishJourneyConfigurationInput = {
  /** The entity tag of the journey configuration */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
  /** The type of journey configuration */
  type?: InputMaybe<JiraJourneyConfigurationType>;
  /** The version number of the entity. */
  version: Scalars['Long']['input'];
};

/** Input to publish the customized config of a timeline view for all users. */
export type JiraPublishTimelineViewConfigInput = {
  /** Input for settings applied to the timeline view. */
  settings?: InputMaybe<JiraTimelineViewSettings>;
  /** ARI of the timeline view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Possible states for Pull Requests */
export enum JiraPullRequestState {
  /** Pull Request is Declined */
  Declined = 'DECLINED',
  /** Pull Request is Draft */
  Draft = 'DRAFT',
  /** Pull Request is Merged */
  Merged = 'MERGED',
  /** Pull Request is Open */
  Open = 'OPEN'
}

export type JiraRadioSelectFieldOperationInput = {
  /** Accept ARI(s): issue-field-option */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Represents a direction in the ranking of two issues. */
export enum JiraRankMutationEdge {
  Bottom = 'BOTTOM',
  Top = 'TOP'
}

/** Input for ranking issues against one another using a rank field. */
export type JiraRankMutationInput = {
  /** The edge the issues will be ranked in (TOP/BOTTOM) */
  edge: JiraRankMutationEdge;
  /** The list of issue ARIs to be ranked. */
  issues: Array<Scalars['ID']['input']>;
  /** The issue ARI of the target issue which the `issues` will be positioned against. */
  relativeToIssue: Scalars['ID']['input'];
};

/** Input for ranking a navigation item. Only pass one of beforeItemId or afterItemId. */
export type JiraRankNavigationItemInput = {
  /** Global identifier (ARI) of the navigation item that the navigation item being ranked will be placed after. */
  afterItemId?: InputMaybe<Scalars['ID']['input']>;
  /** Global identifier (ARI) of the navigation item that the navigation item being ranked will be placed before. */
  beforeItemId?: InputMaybe<Scalars['ID']['input']>;
  /** Global identifier (ARI) of the navigation item to rank. */
  id: Scalars['ID']['input'];
  /** ARI of the scope to rank the navigation items. */
  scopeId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input type for the recentItems' filter. */
export type JiraRecentItemsFilter = {
  /** Include archived projects in the result (applies to projects only, default to true) */
  includeArchivedProjects?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter the results by the keyword */
  keyword?: InputMaybe<Scalars['String']['input']>;
  /** List of Jira entity types to get, */
  types?: InputMaybe<Array<JiraSearchableEntityType>>;
};

/** Category of recommendation */
export enum JiraRecommendationCategory {
  /** Recommendation to delete a custom field */
  CustomField = 'CUSTOM_FIELD',
  /** Recommendation to archive issues */
  IssueArchival = 'ISSUE_ARCHIVAL',
  /** Recommendation to clean (archive or trash) the project */
  ProjectCleanup = 'PROJECT_CLEANUP',
  /** Recommendation to delete a project role actor */
  ProjectRoleActor = 'PROJECT_ROLE_ACTOR'
}

/** Enum representing distinct recommendation categories. An individual entity such as a JiraIssue can appear in one or more categories. */
export enum JiraRecommendedActionCategoryType {
  /** Action to reply / react to new comments on issues assigned to the current user. */
  CommentAssigned = 'COMMENT_ASSIGNED',
  /** Action to reply / react to comments that the current user has been recently mentioned in. */
  CommentMention = 'COMMENT_MENTION',
  /** Action to reply / react to new comments in threads started by the current user. */
  CommentReply = 'COMMENT_REPLY',
  /** Action to approve issues that have pending approvals on the current user. */
  IssueApproval = 'ISSUE_APPROVAL',
  /** Action to review issues that have overdue or impending due dates. */
  IssueDueSoon = 'ISSUE_DUE_SOON',
  NotSet = 'NOT_SET',
  /** Action to join a Project based on the projects the inviter, or inviters team mates are active in. */
  ProjectInviterContext = 'PROJECT_INVITER_CONTEXT',
  /** Action to join a Project based on tenant-wide popularity. */
  ProjectPopularity = 'PROJECT_POPULARITY',
  /** Action to review pull requests that are open, where the current user is a reviewer, and has not already reviewed. */
  PrReview = 'PR_REVIEW',
  /** Action to create a new team based on the current user collaborating with other users, who are not already in a team together. */
  TeamCollaboratorsCreate = 'TEAM_COLLABORATORS_CREATE',
  /** Action to join a team based on the current user collaborating with other users who are part of that team. */
  TeamCollaboratorsJoin = 'TEAM_COLLABORATORS_JOIN',
  /** Action to join a team based on the teams the inviter that invited the current user is part of. */
  TeamInviterContext = 'TEAM_INVITER_CONTEXT',
  /** Action to join a Team based on popularity of that team within the tenant. Popularity is simply defined as teams with the most members. */
  TeamPopularity = 'TEAM_POPULARITY'
}

/** Represents sort fields for JiraRedaction */
export enum JiraRedactionSortField {
  /** Sort by redaction created time */
  Created = 'CREATED',
  /** Sort by field name */
  Field = 'FIELD',
  /** Sort by redaction reason */
  Reason = 'REASON',
  /** Sort by redacted by user */
  RedactedBy = 'REDACTED_BY',
  /** Sort by redaction updated time */
  Updated = 'UPDATED'
}

export type JiraRedactionSortInput = {
  field: JiraRedactionSortField;
  order?: SortDirection;
};

/** Enum describing the possible states to represent issue keys when generating release notes */
export enum JiraReleaseNotesIssueKeyConfig {
  /** Include issue keys in the generated release notes as hyperlinks to their respective issue view */
  Linked = 'LINKED',
  /** Exclude issue keys from the generated release notes */
  None = 'NONE',
  /** Include issue keys in the generated release notes as plain text */
  Unlinked = 'UNLINKED'
}

export type JiraReleasesDeploymentFilter = {
  /** Only deployments in these environment types will be returned. */
  environmentCategories?: InputMaybe<Array<DevOpsEnvironmentCategory>>;
  /** Only deployments in these environments will be returned. */
  environmentDisplayNames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only deployments associated with these issues will be returned. */
  issueIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Only deployments associated with these services will be returned. */
  serviceIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Only deployments in this time window will be returned. */
  timeWindow: JiraReleasesTimeWindowInput;
};

export type JiraReleasesEpicFilter = {
  /** Only epics in this project will be returned. */
  projectId: Scalars['ID']['input'];
  /** Determines whether epics that haven't been released should be included in the results. */
  releaseStatusFilter?: InputMaybe<JiraReleasesEpicReleaseStatusFilter>;
  /** Only epics matching this text filter will be returned. */
  text?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Used for specifying whether or not epics that haven't been released should be included
 * in the results.
 *
 * For an epic to be considered as released, at least one of the issues or subtasks within
 * it must have been released.
 */
export enum JiraReleasesEpicReleaseStatusFilter {
  /** Only epics that have been released (to any environment) will be included in the results. */
  Released = 'RELEASED',
  /**
   * Epics that have been released will be returned first, followed by epics that haven't
   * yet been released.
   */
  ReleasedAndUnreleased = 'RELEASED_AND_UNRELEASED'
}

export type JiraReleasesIssueFilter = {
  /** Only issues assigned to these users will be returned. */
  assignees?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Only issues that have been released in these environment *types* will be returned. */
  environmentCategories?: InputMaybe<Array<InputMaybe<DevOpsEnvironmentCategory>>>;
  /** Only issues that have been released in these environments will be returned. */
  environmentDisplayNames?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * Only issues in these epics will be returned.
   *
   * Note:
   * * If a null ID is included in the list, issues not in epics will be included in the results.
   * * If a subtask's parent issue is in one of the epics, the subtask will also be returned.
   */
  epicIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Only issues with the supplied fixVersions will be returned. */
  fixVersions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Only issues of these types will be returned. */
  issueTypes?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Only issues in this project will be returned. */
  projectId: Scalars['ID']['input'];
  /** Determines whether issues that haven't been released should be included in the results. */
  releaseStatusFilter?: JiraReleasesIssueReleaseStatusFilter;
  /** Only issues matching this text filter will be returned (will match against all issue fields). */
  text?: InputMaybe<Scalars['String']['input']>;
  /**
   * Only issues that have been released within this time window will be returned.
   *
   * Note: Issues that have not been released within the time window will still be returned
   * if the `includeIssuesWithoutReleases` argument is `true`.
   */
  timeWindow: JiraReleasesTimeWindowInput;
};

/**
 * Used for specifying whether or not issues that haven't been released should be included
 * in the results.
 */
export enum JiraReleasesIssueReleaseStatusFilter {
  /** Only issues that have been released (to any environment) will be included in the results. */
  Released = 'RELEASED',
  /**
   * Issues that have been released will be returned first, followed by issues that haven't
   * yet been released.
   */
  ReleasedAndUnreleased = 'RELEASED_AND_UNRELEASED',
  /** Only issues that have *not* been released (to any environment) will be included in the results. */
  Unreleased = 'UNRELEASED'
}

export type JiraReleasesTimeWindowInput = {
  after: Scalars['DateTime']['input'];
  before: Scalars['DateTime']['input'];
};

/** Input type for updating the Remaining Time Estimate field of a Jira issue. */
export type JiraRemainingTimeEstimateFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The new value to be placed in the Remaining Time Estimate field */
  remainingEstimate: JiraEstimateInput;
};

export enum JiraRemoteLinkedIssueErrorType {
  ApplinkMissing = 'APPLINK_MISSING',
  ApplinkReqAuth = 'APPLINK_REQ_AUTH'
}

/** The input for deleting an active background */
export type JiraRemoveActiveBackgroundInput = {
  /** The entityId (ARI) of the entity to remove the active background for */
  entityId: Scalars['ID']['input'];
};

export type JiraRemoveCustomFieldInput = {
  /**
   * The cloudId indicates the cloud instance this mutation will be executed against.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId: Scalars['ID']['input'];
  fieldId: Scalars['String']['input'];
  projectId: Scalars['String']['input'];
};

export type JiraRemoveCustomFieldTranslationInput = {
  /** The ID of the custom field. */
  fieldId: Scalars['String']['input'];
  /**
   * The language for the custom field translation.
   * Example: en-US, fr-FR, de-DE, etc. (ISO 639-1 and ISO 3166-1 format)
   */
  language: Scalars['String']['input'];
};

export type JiraRemoveFieldsFromFieldSchemeInput = {
  fieldIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  schemeId: Scalars['ID']['input'];
};

/** The input to remove isses from all versions */
export type JiraRemoveIssuesFromAllFixVersionsInput = {
  /** The IDs of the issues to be removed from all versions. */
  issueIds: Array<Scalars['ID']['input']>;
};

/** The input to remove issues from a fix version. */
export type JiraRemoveIssuesFromFixVersionInput = {
  /** The IDs of the issues to be removed from a fix version. */
  issueIds: Array<Scalars['ID']['input']>;
  /** The ID of the version to remove the issues from. */
  versionId: Scalars['ID']['input'];
};

/** The input type to remove bitbucket workspace(organization in Jira term) connection */
export type JiraRemoveJiraBitbucketWorkspaceConnectionInput = {
  /** The workspace id(organization in Jira term) to remove the connection */
  workspaceId: Scalars['ID']['input'];
};

export type JiraRemovePostIncidentReviewLinkMutationInput = {
  /**
   * The ID of the incident the PIR link will be removed from. Initially only Jira Service Management
   * incidents are supported, but eventually 3rd party / Data Depot incidents will follow.
   */
  incidentId: Scalars['ID']['input'];
  /** The ID of the PIR link that will be removed from the incident. */
  postIncidentReviewLinkId: Scalars['ID']['input'];
};

/** Input to delete a related work item and unlink it from a version. */
export type JiraRemoveRelatedWorkFromVersionInput = {
  /**
   * Client-generated ID for the related work item.
   *
   * To delete native release notes, leave this as null and pass `removeNativeReleaseNotes` instead.
   */
  relatedWorkId?: InputMaybe<Scalars['ID']['input']>;
  /** If true the "native release notes" related work item will be deleted. */
  removeNativeReleaseNotes?: InputMaybe<Scalars['Boolean']['input']>;
  /** The identifier of the Jira version. */
  versionId: Scalars['ID']['input'];
};

export type JiraRemoveTimelineIssueLinkInput = {
  /** Accepts ARI(s): issue-link */
  id: Scalars['ID']['input'];
};

/** Input to rename a status in the project's workflow and the name of the column it is mapped to in the board view. */
export type JiraRenameBoardViewStatusColumnInput = {
  /** ID of the status column to rename. */
  columnId: Scalars['ID']['input'];
  /** New name of the status column. */
  name: Scalars['String']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view where the status column is being renamed. */
  viewId: Scalars['ID']['input'];
};

/** Input for renaming a navigation item. */
export type JiraRenameNavigationItemInput = {
  /** Global identifier (ARI) for the navigation item to rename. */
  id: Scalars['ID']['input'];
  /** The new label for the navigation item. */
  label: Scalars['String']['input'];
  /** ARI of the scope to rename the navigation item. */
  scopeId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input to reorder a column on the board view. */
export type JiraReorderBoardViewColumnInput = {
  /** Id of the column to be reordered. */
  columnId: Scalars['ID']['input'];
  /** Position of the column relative to the relative column. */
  position: JiraReorderBoardViewColumnPosition;
  /** Id of the column to position the column relative to. */
  relativeColumnId: Scalars['ID']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view to reorder a column for. */
  viewId: Scalars['ID']['input'];
};

/** Position relative to the relative column. */
export enum JiraReorderBoardViewColumnPosition {
  After = 'AFTER',
  Before = 'BEFORE'
}

export type JiraReorderSidebarMenuItemInput = {
  /** The identifier of the cloud instance to update the sidebar menu settings for. */
  cloudId: Scalars['ID']['input'];
  /** The item to be reordered */
  menuItem: JiraSidebarMenuItemInput;
  /** Required if the mode is BEFORE or AFTER. The item being reordered will be placed before or after this item. */
  relativeMenuItem?: InputMaybe<JiraSidebarMenuItemInput>;
  /** The desired reordering operation to perform */
  reorderMode: JiraSidebarMenuItemReorderOperation;
};

export type JiraReplaceIssueSearchViewFieldSetsInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  context?: InputMaybe<JiraIssueSearchViewFieldSetsContext>;
  /**  Denotes whether `before` and/or `after` nodes will be replaced inclusively. If not specified, defaults to false. */
  inclusive?: InputMaybe<Scalars['Boolean']['input']>;
  nodes: Array<Scalars['String']['input']>;
};

export type JiraResetFaviconInput = {
  cloudId: Scalars['ID']['input'];
};

export type JiraResetLogoInput = {
  cloudId: Scalars['ID']['input'];
};

/** Input type for defining the operation on the Resolution field of a Jira issue. */
export type JiraResolutionFieldOperationInput = {
  /**  Accepts ARI(s): resolution  */
  id?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The operation to perform on the Resolution field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
};

/** Input type for resolution field */
export type JiraResolutionInput = {
  /** An identifier for the resolution field */
  resolutionId: Scalars['ID']['input'];
};

export enum JiraResourceIntegration {
  Attachment = 'ATTACHMENT',
  Confluence = 'CONFLUENCE',
  Gdrive = 'GDRIVE',
  Loom = 'LOOM',
  Whiteboard = 'WHITEBOARD'
}

/** Input for flexible pagination supporting both cursor-based and offset-based navigation */
export type JiraResourcePaginationInput = {
  /** Current page number for context (1-based). Used for offset pagination. */
  currentPageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Whether this is the last page. Used for context in offset pagination. */
  isLast?: InputMaybe<Scalars['Boolean']['input']>;
  /** The page cursor returned for the current page. Used for cursor pagination. */
  pageCursor?: InputMaybe<Scalars['String']['input']>;
  /** The page number you want the results for (1-based). Used for offset pagination. */
  pageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Count of resources you need to display on the page */
  pageSize: Scalars['Int']['input'];
  /** The pagination style to use */
  style: JiraPaginationStyle;
  /** Total number of resources. Used for context in offset pagination. */
  totalCount?: InputMaybe<Scalars['Long']['input']>;
  /** Total number of linked resources (non-attachments). Used for context in offset pagination. */
  totalLinks?: InputMaybe<Scalars['Long']['input']>;
};

/** Represents a fixed set of attachments' parents */
export enum JiraResourceParentName {
  Comment = 'COMMENT',
  Customfield = 'CUSTOMFIELD',
  Description = 'DESCRIPTION',
  Environment = 'ENVIRONMENT',
  Form = 'FORM',
  Issue = 'ISSUE',
  Worklog = 'WORKLOG'
}

/** Recommendation action for a custom field. */
export enum JiraResourceUsageCustomFieldRecommendationAction {
  /** This custom field can be trashed. */
  Trash = 'TRASH'
}

/** Status of the recommendation. */
export enum JiraResourceUsageRecommendationStatus {
  /** The recommendation has been archived */
  Archived = 'ARCHIVED',
  /** The recommendation has been executed */
  Executed = 'EXECUTED',
  /** The recommendation has been created, user hasn't been notified about it or acted on it */
  New = 'NEW',
  /** The recommendation is not relevant anymore */
  Obsolete = 'OBSOLETE',
  /** The recommendation has been trashed */
  Trashed = 'TRASHED'
}

export enum JiraResourcesOrderField {
  Created = 'CREATED',
  Filename = 'FILENAME',
  Filesize = 'FILESIZE',
  Mimetype = 'MIMETYPE'
}

export enum JiraResourcesSortDirection {
  /** Sort in ascending order */
  Asc = 'ASC',
  /** Sort in descending order */
  Desc = 'DESC'
}

export type JiraResourcesTotalCountInput = {
  integration?: InputMaybe<Array<InputMaybe<JiraResourceIntegration>>>;
};

export type JiraRestoreCustomFieldsInput = {
  /** Ids of the custom fields, e.g. "customfield_10000". */
  fieldIds: Array<Scalars['String']['input']>;
};

export type JiraRestoreGlobalCustomFieldsInput = {
  /** Ids of the global custom fields, e.g. "customfield_10000". */
  fieldIds: Array<Scalars['String']['input']>;
};

export type JiraRestoreJourneyConfigurationInput = {
  /** The entity tag of the journey configuration */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
};

/** Possible states for Reviews */
export enum JiraReviewState {
  /** Review is in Require Approval state */
  Approval = 'APPROVAL',
  /** Review has been closed */
  Closed = 'CLOSED',
  /** Review is in Dead state */
  Dead = 'DEAD',
  /** Review is in Draft state */
  Draft = 'DRAFT',
  /** Review has been rejected */
  Rejected = 'REJECTED',
  /** Review is in Review state */
  Review = 'REVIEW',
  /** Review is in Summarize state */
  Summarize = 'SUMMARIZE',
  /** Review state is unknown */
  Unknown = 'UNKNOWN'
}

/** Input type for rich text fields. Supports both text area and wiki text fields */
export type JiraRichTextFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Rich text input on which the action will be performed */
  richText: JiraRichTextInput;
};

export type JiraRichTextFieldOperationInput = {
  /** Accept ADF ( Atlassian Document Format) of paragraph */
  document: JiraAdfInput;
  operation: JiraSingleValueFieldOperations;
};

/** Input type for rich text field */
export type JiraRichTextInput = {
  /** ADF based input for rich text field */
  adfValue?: InputMaybe<Scalars['JSON']['input']>;
  /** Plain text input */
  wikiText?: InputMaybe<Scalars['String']['input']>;
};

export type JiraRoleInput = {
  /** The Jira ProjectRole id to associate with the comment/worklog. */
  roleId?: InputMaybe<Scalars['ID']['input']>;
};

/** Types of scenarios that can be an issue. */
export enum JiraScenarioType {
  Added = 'ADDED',
  Deleted = 'DELETED',
  Deletedfromjira = 'DELETEDFROMJIRA',
  Updated = 'UPDATED'
}

export type JiraScheduleTimelineItemInput = {
  /** Virtual Field, has no defined fieldId */
  aggregatedEndDate?: InputMaybe<JiraDateInput>;
  /** Virtual Field, has no defined fieldId */
  aggregatedStartDate?: InputMaybe<JiraDateInput>;
  endDate?: InputMaybe<JiraClearableDateFieldInput>;
  /** ARI of the issue being updated */
  issueId: Scalars['ID']['input'];
  operation: JiraScheduleTimelineItemOperation;
  startDate?: InputMaybe<JiraClearableDateFieldInput>;
};

export enum JiraScheduleTimelineItemOperation {
  /**  Drags the dates, will alter dates of child issues  */
  Drag = 'DRAG',
  /** Set 'sets the dates' */
  Set = 'SET'
}

export type JiraScopedResetFieldsetsInput = {
  context?: InputMaybe<JiraIssueSearchViewFieldSetsContext>;
  doReset?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The input used to specify the search scope for the natural language to JQL conversion */
export type JiraSearchContextInput = {
  projectKey?: InputMaybe<Scalars['String']['input']>;
};

/** The entity types of searchable items. */
export enum JiraSearchableEntityType {
  /** A searchable board item. */
  Board = 'BOARD',
  /** A searchable dashboard item. */
  Dashboard = 'DASHBOARD',
  /** A searchable filter item. */
  Filter = 'FILTER',
  /** An searchable issue item. */
  Issue = 'ISSUE',
  /** A searchable plan item. */
  Plan = 'PLAN',
  /** A searchable project item. */
  Project = 'PROJECT',
  /** A searchable queue item. */
  Queue = 'QUEUE'
}

/** Input type for defining the operation on the Security Level field of a Jira issue. */
export type JiraSecurityLevelFieldOperationInput = {
  /** Accepts ARI(s): SecurityLevel ARI */
  id?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The operation to perform on the Security Level field.
   * Only SET operation is supported.
   */
  operation: JiraSingleValueFieldOperations;
};

/** Input type for security level field */
export type JiraSecurityLevelInput = {
  /** An identifier for the security level */
  securityLevelId: Scalars['ID']['input'];
};

/** Input type for selected option */
export type JiraSelectedOptionInput = {
  /** An identifier for the field */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** An identifier for the option */
  optionId?: InputMaybe<Scalars['ID']['input']>;
};

/** Represents the possible decisions that can be made by an approver. */
export enum JiraServiceManagementApprovalDecisionResponseType {
  /** Indicates that the decision is approved by the approver. */
  Approved = 'approved',
  /** Indicates that the decision is declined by the approver. */
  Declined = 'declined',
  /** Indicates that the decision is pending by the approver. */
  Pending = 'pending'
}

/** Represent whether approval can be achieved or not. */
export enum JiraServiceManagementApprovalState {
  /** Indicates that approval can not be completed due to lack of approvers. */
  InsufficientApprovers = 'INSUFFICIENT_APPROVERS',
  /** Indicates that approval has sufficient user to complete. */
  Ok = 'OK'
}

export type JiraServiceManagementBulkCreateRequestTypeFromTemplateInput = {
  /** Collection of create request type input configuration */
  createRequestTypeFromTemplateInputItems: Array<JiraServiceManagementCreateRequestTypeFromTemplateInput>;
  /** Project ARI where request types will be created */
  projectId: Scalars['ID']['input'];
};

/** The visibility property of a comment within a JSM project type. */
export enum JiraServiceManagementCommentVisibility {
  /** This comment will only appear in JIRA's issue view. Also called private. */
  Internal = 'INTERNAL',
  /** This comment will appear in the portal, visible to all customers. Also called public. */
  VisibleToHelpseeker = 'VISIBLE_TO_HELPSEEKER'
}

/** Represent the input data for create workflow and associate it to the issue type. */
export type JiraServiceManagementCreateAndAssociateWorkflowFromTemplateInput = {
  /** The avatar id for the issue type icon. */
  avatarId?: InputMaybe<Scalars['ID']['input']>;
  /** The name of the created new issue type. */
  issueTypeName?: InputMaybe<Scalars['String']['input']>;
  /** The project ARI workflow is created in. */
  projectId: Scalars['ID']['input'];
  /** Template id to be used to create workflow. */
  templateId: Scalars['String']['input'];
  /** The name of create new workflow, which should be a unique name. */
  workflowName?: InputMaybe<Scalars['String']['input']>;
};

/**
 * #########################
 *  Input types
 * #########################
 */
export type JiraServiceManagementCreateRequestTypeCategoryInput = {
  /** Name of the Request Type Category. */
  name: Scalars['String']['input'];
  /** Owner of the Request Type Category. */
  owner?: InputMaybe<Scalars['String']['input']>;
  /** Project id of the Request Type Category. */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** Request types to be associated with the Request Type Category. */
  requestTypes?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Restriction of the Request Type Category. */
  restriction?: InputMaybe<JiraServiceManagementRequestTypeCategoryRestriction>;
  /** Status of the Request Type Category. */
  status?: InputMaybe<JiraServiceManagementRequestTypeCategoryStatus>;
};

export type JiraServiceManagementCreateRequestTypeFromTemplateInput = {
  /**
   * Id of the creation request/attempt, to track which requests were created and which were not, to retry only failed ones
   * Format: UUID
   */
  clientMutationId: Scalars['String']['input'];
  /** Description of the new request type */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name of the new request type (that's going to be created) */
  name: Scalars['String']['input'];
  /** Portal instructions of the new request type */
  portalInstructions?: InputMaybe<Scalars['String']['input']>;
  /** Practice (work category) which will be associated with the new request type */
  practice?: InputMaybe<JiraServiceManagementPractice>;
  /** Request form content of the new request type */
  requestForm: JiraServiceManagementCreateRequestTypeFromTemplateRequestFormInput;
  /** Request type groups which will be associated with the new request type */
  requestTypeGroup?: InputMaybe<JiraServiceManagementCreateRequestTypeFromTemplateRequestTypeGroupInput>;
  /** Icon of the new request type */
  requestTypeIconInternalId?: InputMaybe<Scalars['String']['input']>;
  /** Workflow which will be associated with the new request type */
  workflow?: InputMaybe<JiraServiceManagementCreateRequestTypeFromTemplateWorkflowInput>;
};

/** Input for FORM_TEMPLATE_REFERENCE or REQUEST_TYPE_TEMPLATE_REFERENCE JiraServiceManagementCreateRequestTypeFromTemplateRequestFormInputType. */
export type JiraServiceManagementCreateRequestTypeFromTemplateReferenceInput = {
  /** Reference of the request type template id, not ARI format */
  formTemplateInternalId: Scalars['String']['input'];
};

export type JiraServiceManagementCreateRequestTypeFromTemplateRequestFormInput = {
  /** Request form input type. */
  inputType: JiraServiceManagementCreateRequestTypeFromTemplateRequestFormInputType;
  /** Input for CreateRequestTypeFromTemplateRequestFormInputType.FORM_TEMPLATE_REFERENCE . */
  templateFormReferenceInput: JiraServiceManagementCreateRequestTypeFromTemplateReferenceInput;
};

/** This enum represents different input variation for the "request form" part of the new request type to be created. */
export enum JiraServiceManagementCreateRequestTypeFromTemplateRequestFormInputType {
  /** This means the reference of the proforma form template will be sent as input. */
  FormTemplateReference = 'FORM_TEMPLATE_REFERENCE',
  /** This means the reference of the jira request type template will be sent as input. */
  RequestTypeTemplateReference = 'REQUEST_TYPE_TEMPLATE_REFERENCE'
}

export type JiraServiceManagementCreateRequestTypeFromTemplateRequestTypeGroupInput = {
  /** Collection of request type group reference */
  requestTypeGroupInternalIds: Array<Scalars['String']['input']>;
};

/** This enum represent different action variation for workflow. */
export enum JiraServiceManagementCreateRequestTypeFromTemplateWorkflowAction {
  /** This mean workflow will be shared with going to created request type. */
  Share = 'SHARE'
}

export type JiraServiceManagementCreateRequestTypeFromTemplateWorkflowInput = {
  /** Action to perform with input workflow. */
  action: JiraServiceManagementCreateRequestTypeFromTemplateWorkflowAction;
  /** Workflow input type. */
  inputType: JiraServiceManagementCreateRequestTypeFromTemplateWorkflowInputType;
  /** Input for CreateRequestTypeFromTemplateWorkflowInputType.REFERENCE_THROUGH_ISSUE_TYPE . */
  workflowIssueTypeReferenceInput: JiraServiceManagementCreateRequestTypeFromTemplateWorkflowIssueTypeReferenceInput;
};

/** This enum represent different input variation for workflow which will be associated with the new request type to be created. */
export enum JiraServiceManagementCreateRequestTypeFromTemplateWorkflowInputType {
  /** This mean use workflow that associated with given issue type */
  ReferenceThroughIssueType = 'REFERENCE_THROUGH_ISSUE_TYPE'
}

/** Input for CreateRequestTypeFromTemplateWorkflowInputType.REFERENCE_THROUGH_ISSUE_TYPE . */
export type JiraServiceManagementCreateRequestTypeFromTemplateWorkflowIssueTypeReferenceInput = {
  /** Issue type ARI */
  workflowIssueTypeId: Scalars['ID']['input'];
};

export enum JiraServiceManagementIssueViewDefaultCommentBehavior {
  /** Default comment behavior is to only show the comment to the team */
  InternalNote = 'INTERNAL_NOTE',
  /** Default comment behavior is to show the comment to the customer */
  ReplyToCustomer = 'REPLY_TO_CUSTOMER'
}

/** An enum representing possible values for Major Incident JSM field. */
export enum JiraServiceManagementMajorIncident {
  MajorIncident = 'MAJOR_INCIDENT'
}

/**
 * Input type for defining the operation on Jira Service Management Organization field of a Jira issue.
 * Renamed to JsmOrganizationFieldOperationInput to compatible with jira/gira prefix validation
 */
export type JiraServiceManagementOrganizationFieldOperationInput = {
  /**  Accepts ARI(s): organization  */
  ids: Array<Scalars['ID']['input']>;
  /**
   * The operations to perform on Jira Service Management Organization field.
   * SET, ADD, REMOVE operations are supported.
   */
  operation: JiraMultiValueFieldOperations;
};

/** ITSM project practice categorization. */
export enum JiraServiceManagementPractice {
  /** Empower the IT operations teams with richer contextual information around changes from software development tools so they can make better decisions and minimize risk. */
  ChangeManagement = 'CHANGE_MANAGEMENT',
  /** Provide customer support teams with the tools they need to escalate requests to software development teams. */
  DeveloperEscalation = 'DEVELOPER_ESCALATION',
  /** Bring the development and IT operations teams together to rapidly respond to, resolve, and continuously learn from incidents. */
  IncidentManagement = 'INCIDENT_MANAGEMENT',
  /** Bring people and teams together to discuss the details of an incident: why it happened, what impact it had, what actions were taken to resolve it, and how the team can prevent it from happening again. */
  PostIncidentReview = 'POST_INCIDENT_REVIEW',
  /** Group incidents to problems, fast-track root cause analysis, and record workarounds to minimize the impact of incidents. */
  ProblemManagement = 'PROBLEM_MANAGEMENT',
  /** Manage work across teams with one platform so the employees and customers quickly get the help they need. */
  ServiceRequest = 'SERVICE_REQUEST'
}

/**
 * Renderer Preview Type
 * Represents the type of editing experience to load for a multi-line text field.
 */
export enum JiraServiceManagementRendererType {
  AtlassianWikiRendererType = 'ATLASSIAN_WIKI_RENDERER_TYPE',
  JiraTextRendererType = 'JIRA_TEXT_RENDERER_TYPE'
}

export enum JiraServiceManagementRequestTypeCategoryRestriction {
  Open = 'OPEN',
  Restricted = 'RESTRICTED'
}

export enum JiraServiceManagementRequestTypeCategoryStatus {
  Active = 'ACTIVE',
  Draft = 'DRAFT',
  Inactive = 'INACTIVE'
}

/** Input type for a single service management responder */
export type JiraServiceManagementResponderFieldInput = {
  /** An identifier for the responder */
  responderId: Scalars['ID']['input'];
};

/** Input type for the service management responders field */
export type JiraServiceManagementRespondersFieldInput = {
  /** Option selected from the multi select operation */
  bulkEditMultiSelectFieldOption?: InputMaybe<JiraBulkEditMultiSelectFieldOptions>;
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List of responders */
  responders: Array<JiraServiceManagementResponderFieldInput>;
};

/** Input type for updating the Entitlement field of the Jira issue. */
export type JiraServiceManagementUpdateEntitlementFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Entitlement field. */
  operation?: InputMaybe<JiraServiceManagementUpdateEntitlementOperationInput>;
};

/** Input type for defining the operation on the Entitlement field of a Jira issue. */
export type JiraServiceManagementUpdateEntitlementOperationInput = {
  /** UUID value of the selected entitlement. */
  entitlementId?: InputMaybe<Scalars['ID']['input']>;
  /** Only SET operation is supported. */
  operation: JiraSingleValueFieldOperations;
};

/**
 * Input type for updating the Jira Service Management Organization field of a Jira issue.
 * Renamed to JsmUpdateOrganizationFieldInput to compatible with jira/gira prefix validation
 */
export type JiraServiceManagementUpdateOrganizationFieldInput = {
  /**  Accepts ARI(s): issuefieldvalue  */
  id: Scalars['ID']['input'];
  /** The operations to perform on Jira Service Management Organization field. */
  operations: Array<JiraServiceManagementOrganizationFieldOperationInput>;
};

export type JiraServiceManagementUpdateRequestTypeCategoryInput = {
  /** Id of the Request Type Category. */
  id: Scalars['ID']['input'];
  /** Name of the Request Type Category. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Owner of the Request Type Category. */
  owner?: InputMaybe<Scalars['String']['input']>;
  /** Restriction of the Request Type Category. */
  restriction?: InputMaybe<JiraServiceManagementRequestTypeCategoryRestriction>;
  /** Status of the Request Type Category. */
  status?: InputMaybe<JiraServiceManagementRequestTypeCategoryStatus>;
};

/** Input type for updating the Sentiment field of the Jira issue. */
export type JiraServiceManagementUpdateSentimentFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Sentiment field. */
  operation?: InputMaybe<JiraServiceManagementUpdateSentimentOperationInput>;
};

/** Input type for defining the operation on the Sentiment field of a Jira issue. */
export type JiraServiceManagementUpdateSentimentOperationInput = {
  /** Only SET operation is supported. */
  operation: JiraSingleValueFieldOperations;
  /** ID value of the selected sentiment. */
  sentimentId?: InputMaybe<Scalars['String']['input']>;
};

/** The key of the property you want to update, and the new value you want to set it to */
export type JiraSetApplicationPropertyInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** Input to set the card density of a backlog view. */
export type JiraSetBacklogViewCardDensityInput = {
  /** The card density value. */
  cardDensity: JiraBacklogCardDensity;
  /** ARI of the view to set the card density for. */
  viewId: Scalars['ID']['input'];
};

/** Input to set the card field of a backlog view. */
export type JiraSetBacklogViewCardFieldsInput = {
  /** The list of card field values to set the card fields to. */
  cardFields: Array<JiraBacklogViewCardFieldInput>;
  /** ARI of the view to set the card fields for. */
  viewId: Scalars['ID']['input'];
};

/** Input to set the assignee filters field of a backlog view. */
export type JiraSetBacklogViewStringFiltersInput = {
  /** The list of string values to set the filters to. */
  values: Array<Scalars['String']['input']>;
  /** ARI of the view to set the filters for. */
  viewId: Scalars['ID']['input'];
};

/** Input to set text setting for a backlog view. */
export type JiraSetBacklogViewTextInput = {
  /** The text value. */
  text: Scalars['String']['input'];
  /** ARI of the view to set the view setting text for. */
  viewId: Scalars['ID']['input'];
};

/** Input to set the card cover of an issue on the board view. */
export type JiraSetBoardIssueCardCoverInput = {
  /** The type of background to update to */
  coverType: JiraBackgroundType;
  /**
   * The gradient/color if the background is a gradient/color type,
   * the customBackgroundId if the background is a custom (user uploaded) type, or
   * the image filePath if the background is from Unsplash
   */
  coverValue: Scalars['String']['input'];
  /** The issue ID (ARI) being updated */
  issueId: Scalars['ID']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view where the issue card cover is being set */
  viewId: Scalars['ID']['input'];
};

/** Input to select or deselect a card field within the board view. */
export type JiraSetBoardViewCardFieldSelectedInput = {
  /** FieldId of the card field within the board view to select or deselect. */
  fieldId: Scalars['String']['input'];
  /** Whether the board view card field is selected. */
  selected: Scalars['Boolean']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input to enable or disable a card option within a board view. */
export type JiraSetBoardViewCardOptionStateInput = {
  /** Whether the board view card option is enabled or not. */
  enabled: Scalars['Boolean']['input'];
  /** ID of the card option to enable or disable within a board view. */
  id: Scalars['ID']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view to set the card option state for. */
  viewId: Scalars['ID']['input'];
};

/** Input to collapse or expand a column within the board view. */
export type JiraSetBoardViewColumnStateInput = {
  /** Whether the board view column is collapsed. */
  collapsed: Scalars['Boolean']['input'];
  /** Id of the column within the board view to collapse or expand. */
  columnId: Scalars['ID']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input to set the order of columns on the board view. */
export type JiraSetBoardViewColumnsOrderInput = {
  /**
   * Ordered list of column IDs. Column IDs is the value returned by `JiraBoardViewColumn.id`.
   * Up to a max of 100 IDs will be accepted. Beyond that, the list will be truncated.
   */
  columnIds: Array<Scalars['ID']['input']>;
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view to set the columns order for. */
  viewId: Scalars['ID']['input'];
};

/** Input to set the number of days after which completed issues are removed from the board view. */
export type JiraSetBoardViewCompletedIssueSearchCutOffInput = {
  /**
   * The number of days after which completed issues are to be removed from the board view.
   * A null value indicates that completed issues are not removed from the board view.
   */
  completedIssueSearchCutOffInDays?: InputMaybe<Scalars['Int']['input']>;
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view to set the completed issue search cut off for. */
  viewId: Scalars['ID']['input'];
};

/** Input to set the filter of a board view. */
export type JiraSetBoardViewFilterInput = {
  /** The JQL query to filter work items on the view by. */
  jql: Scalars['String']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the view to set the filter for. */
  viewId: Scalars['ID']['input'];
};

/** Input to set the group by field of a board view. */
export type JiraSetBoardViewGroupByInput = {
  /** The field id to group work items on the view by. */
  fieldId?: InputMaybe<Scalars['String']['input']>;
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the view to set the group by field for. */
  viewId: Scalars['ID']['input'];
};

/** Input describing a new status to create and map to a column. */
export type JiraSetBoardViewStatusColumnMappingCreateStatusInput = {
  /** Name of the new status to create. */
  name: Scalars['String']['input'];
  /**
   * An arbitrary string to be used in JiraBoardViewStatusColumnMapping.statusIds to refer to the newly created status.
   * UUID is recommended.
   */
  reference: Scalars['ID']['input'];
  /** The status category ID of the status to create in the project's workflow. */
  statusCategoryId: Scalars['ID']['input'];
};

/** Input describing a status to delete while mapping columns. */
export type JiraSetBoardViewStatusColumnMappingDeleteStatusInput = {
  /** ID of the status to move the issues in the deleted status to. */
  replacementStatusId: Scalars['ID']['input'];
  /** ID of the status to delete. */
  statusId: Scalars['ID']['input'];
};

/** Input to set the status column mapping on the board view. */
export type JiraSetBoardViewStatusColumnMappingInput = {
  /**
   * Ordered list of all status column mappings to set, including existing, new and updated columns.
   * Up to a max of 100 columns will be accepted. Beyond that, the list will be truncated.
   */
  columns: Array<JiraBoardViewStatusColumnMapping>;
  /**
   * List of statuses to be created. Each must be referenced in a column as well.
   * Requires JiraBoardView.canManageStatuses permission.
   */
  createStatuses?: InputMaybe<Array<JiraSetBoardViewStatusColumnMappingCreateStatusInput>>;
  /**
   * List of statuses to be deleted. Each must not be referenced in any column.
   * Requires JiraBoardView.canManageStatuses permission.
   */
  deleteStatuses?: InputMaybe<Array<JiraSetBoardViewStatusColumnMappingDeleteStatusInput>>;
  /**
   * List of statuses to be renamed.
   * Requires JiraBoardView.canManageStatuses permission.
   */
  renameStatuses?: InputMaybe<Array<JiraSetBoardViewStatusColumnMappingRenameStatusInput>>;
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view where the status column mapping is being set. */
  viewId: Scalars['ID']['input'];
};

/** Input describing a status to rename while mapping columns. */
export type JiraSetBoardViewStatusColumnMappingRenameStatusInput = {
  /** New name of the status. */
  name: Scalars['String']['input'];
  /** ID of the status to rename. */
  statusId: Scalars['ID']['input'];
};

/** Input to set the selected workflow for the board view. */
export type JiraSetBoardViewWorkflowSelectedInput = {
  /** The selected workflow id. */
  selectedWorkflowId: Scalars['ID']['input'];
  /** Input for settings applied to the board view. */
  settings?: InputMaybe<JiraBoardViewSettings>;
  /** ARI of the board view to set the selected workflow for. */
  viewId: Scalars['ID']['input'];
};

/** Input for setting the most recent capacity sub-route view. */
export type JiraSetCapacityMostRecentSubRouteInput = {
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId: Scalars['ID']['input'];
  /**
   * The scope container ARI (project or board).
   * Example: "ari:cloud:jira:instance::project/10000"
   */
  scopeId: Scalars['ID']['input'];
  /** The capacity sub-route to set. */
  subRoute: JiraCapacitySubRouteEnum;
};

export type JiraSetCustomFieldTranslationInput = {
  /** The ID of the custom field. */
  fieldId: Scalars['String']['input'];
  /**
   * The language for the custom field translation.
   * Example: en-US, fr-FR, de-DE, etc. (ISO 639-1 and ISO 3166-1 format)
   */
  language: Scalars['String']['input'];
  /** The translated description of the custom field. */
  translatedDescription?: InputMaybe<Scalars['String']['input']>;
  /** The translated name of the custom field. */
  translatedName?: InputMaybe<Scalars['String']['input']>;
};

/** Input for setting a navigation item as default. */
export type JiraSetDefaultNavigationItemInput = {
  /** Global identifier (ARI) for the navigation item to set as default. */
  id: Scalars['ID']['input'];
  /** ARI of the scope to set the navigation item as default. */
  scopeId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraSetFaviconInput = {
  cloudId: Scalars['ID']['input'];
  /** Input for the specific image to set as favicon */
  faviconImageInput: JiraLookAndFeelImageInput;
};

export type JiraSetFieldAssociationWithIssueTypesInput = {
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId: Scalars['ID']['input'];
  /** Unique identifier of the field. */
  fieldId: Scalars['ID']['input'];
  /** List of issue type ids to be removed from the field */
  issueTypeIdsToRemove: Array<Scalars['ID']['input']>;
  /** List of issue type ids to be associated with the field */
  issueTypeIdsToUpsert: Array<Scalars['ID']['input']>;
  /** Unique identifier of the project. */
  projectId: Scalars['ID']['input'];
};

/** Input to set the field sets preferences for the issue search view config. */
export type JiraSetFieldSetsPreferencesInput = {
  /** Field set preferences */
  fieldSetsPreferences?: InputMaybe<Array<JiraFieldSetPreferencesInput>>;
  /** ARI of the issue search view to manipulate. */
  viewId: Scalars['ID']['input'];
};

export type JiraSetFormulaFieldExpressionConfigInput = {
  cloudId: Scalars['ID']['input'];
  /** The desired formula expression configuration. */
  expressionConfig?: InputMaybe<JiraFormulaFieldExpressionConfigInput>;
  /** The field ID of the formula field. */
  fieldId: Scalars['String']['input'];
  /**
   * The project ID if the expression configuration is being set for a particular project context.
   * Use null for the global context.
   */
  projectId?: InputMaybe<Scalars['String']['input']>;
};

/** The isFavourite of the entityId of type entityType you want to update, and the new value you want to set it to */
export type JiraSetIsFavouriteInput = {
  /**
   * ARI of the entity the ordered before the position the selectedEntity is being moved to. beforeEntity can be null when
   * there is no before entity (i.e. favourite is ordered at the end of the list) or the favourite is being removed.
   */
  beforeEntityId?: InputMaybe<Scalars['ID']['input']>;
  /** ARI of the Atlassian entity to be modified */
  entityId: Scalars['ID']['input'];
  /** The new value to set */
  isFavourite: Scalars['Boolean']['input'];
};

/** Input to modify the aggregation settings of the issue search view config. */
export type JiraSetIssueSearchAggregationConfigInput = {
  /** A nullable list of aggregation fields (JiraIssueSearchFieldAggregationInput) to configure aggregation during issue search. */
  aggregationFields?: InputMaybe<Array<JiraIssueSearchFieldAggregationInput>>;
  /** ARI of the issue search view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input to modify the field sets setting of the issue search view config. */
export type JiraSetIssueSearchFieldSetsInput = {
  /** The field sets input. */
  fieldSetsInput?: InputMaybe<JiraIssueSearchFieldSets>;
  /** ARI of the issue search view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input to modify the group by field setting of the issue search view config. */
export type JiraSetIssueSearchGroupByInput = {
  /** The field id to set for the group by field in the issue search view. A nullable value will reset the config. */
  fieldId?: InputMaybe<Scalars['String']['input']>;
  /** ARI of the issue search view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input to modify the 'hide done items' setting of the issue search view config. */
export type JiraSetIssueSearchHideDoneItemsInput = {
  /** Whether work items in the 'done' status category should be hidden from display in the Issue Table component. */
  hideDoneItems: Scalars['Boolean']['input'];
  /** ARI of the issue search view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input for the set issue search hide warnings mutation. */
export type JiraSetIssueSearchHideWarningsInput = {
  /** A boolean indicating whether or not to hide warnings on the timeline. */
  hideWarnings: Scalars['Boolean']['input'];
  /** ARI of the issue search view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input to modify the search hierarchy setting of the issue search view config. */
export type JiraSetIssueSearchHierarchyEnabledInput = {
  /** The boolean value to indicate whether hierarchy is enabled in the issue search view. */
  hierarchyEnabled: Scalars['Boolean']['input'];
  /** ARI of the issue search view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input to modify the JQL of the issue search view config. */
export type JiraSetIssueSearchJqlInput = {
  /** The JQL to set for the issue search view. */
  jql: Scalars['String']['input'];
  /** ARI of the issue search view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input to modify the view layout setting of the issue search view config. */
export type JiraSetIssueSearchViewLayoutInput = {
  /** ARI of the issue search view to manipulate. */
  viewId: Scalars['ID']['input'];
  /** The layout to set for the issue search view. */
  viewLayout: JiraIssueSearchViewLayout;
};

export type JiraSetLogoInput = {
  cloudId: Scalars['ID']['input'];
  /** Input for the specific image to set as logo */
  logoImageInput: JiraLookAndFeelImageInput;
};

export type JiraSetProjectAccessRequestAllowedPropertyInput = {
  /** Whether to allow project access requests on this project or not. */
  allowAccessRequests: Scalars['Boolean']['input'];
  /** CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The ARI of the project to set the access request setting for. */
  projectId: Scalars['ID']['input'];
};

/** The input type for settings deployment apps property of a JSW project. */
export type JiraSetProjectSelectedDeploymentAppsPropertyInput = {
  /** Deployment apps to set */
  deploymentApps?: InputMaybe<Array<JiraDeploymentAppInput>>;
  /** ARI of the project to set the property on */
  projectId: Scalars['ID']['input'];
};

/** Input to set highlighted releases for a timeline view. */
export type JiraSetTimelineHighlightedReleasesInput = {
  /** A list of version IDs to highlight on the timeline view. */
  highlightedReleases: Array<Scalars['ID']['input']>;
  /** ARI of the issue search view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input to modify the hide warnings of the timeline view config. */
export type JiraSetTimelineViewHideWarningsInput = {
  /** A boolean indicating whether or not to hide warnings on the timeline. */
  hideWarnings: Scalars['Boolean']['input'];
  /** ARI of the timeline view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input to modify the range mode settings of the timeline view. */
export type JiraSetTimelineViewRangeModeInput = {
  /** Range mode (JiraTimelineViewRangeMode) to display the timeline view */
  rangeMode: JiraTimelineViewRangeMode;
  /** ARI of the timeline view to manipulate. */
  viewId: Scalars['ID']['input'];
};

/** Input to set the filter for a Jira View. */
export type JiraSetViewFilterInput = {
  /** The JQL query to filter work items on the view by. */
  jql: Scalars['String']['input'];
  /** ARI of the view to set the filter for. */
  viewId: Scalars['ID']['input'];
};

/** Input to set the group by field for a Jira View. */
export type JiraSetViewGroupByInput = {
  /** The field id to group work items on the view by. */
  fieldId: Scalars['String']['input'];
  /** ARI of the view to set the group by field for. */
  viewId: Scalars['ID']['input'];
};

/** Input to set a view setting field of a backlog view. */
export type JiraSetViewSettingToggleInput = {
  /** The value of the view setting field. */
  toggleValue: Scalars['Boolean']['input'];
  /** ARI of the view to set the view setting field for. */
  viewId: Scalars['ID']['input'];
};

/**
 * Input for when the shareable entity is intended to be shared with all users on a Jira instance
 * and anonymous users.
 */
export type JiraShareableEntityAnonymousAccessGrantInput = {
  /** JiraShareableEntityGrant ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * Input for when the shareable entity is intended to be shared with all users on a Jira instance
 * and NOT anonymous users.
 */
export type JiraShareableEntityAnyLoggedInUserGrantInput = {
  /** JiraShareableEntityGrant ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** Input type for JiraShareableEntityEditGrants. */
export type JiraShareableEntityEditGrantInput = {
  /** User group that will be granted permission. */
  group?: InputMaybe<JiraShareableEntityGroupGrantInput>;
  /** Members of the specifid project will be granted permission. */
  project?: InputMaybe<JiraShareableEntityProjectGrantInput>;
  /** Users with the specified role in the project will be granted permission. */
  projectRole?: InputMaybe<JiraShareableEntityProjectRoleGrantInput>;
  /** User that will be granted permission. */
  user?: InputMaybe<JiraShareableEntityUserGrantInput>;
};

/** The grant types to share or edit ShareableEntities. */
export enum JiraShareableEntityGrant {
  /** The anonymous access represents the public access without logging in. */
  AnonymousAccess = 'ANONYMOUS_ACCESS',
  /** Any user who has the product access. */
  AnyLoggedinUserApplicationRole = 'ANY_LOGGEDIN_USER_APPLICATION_ROLE',
  /**
   * A group is a collection of users who can be given access together.
   * It represents group in the organization's user base.
   */
  Group = 'GROUP',
  /** A project or a role that user can play in a project. */
  Project = 'PROJECT',
  /** A project or a role that user can play in a project. */
  ProjectRole = 'PROJECT_ROLE',
  /**
   * Indicates that the user does not have access to the project
   * the members of which have been granted permission.
   */
  ProjectUnknown = 'PROJECT_UNKNOWN',
  /** An individual user who can be given the access to work on one or more projects. */
  User = 'USER'
}

/** Input for the group that will be granted permission. */
export type JiraShareableEntityGroupGrantInput = {
  /** ID of the user group */
  groupId: Scalars['ID']['input'];
  /** JiraShareableEntityGrant ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** Input for the project ID, members of which will be granted permission. */
export type JiraShareableEntityProjectGrantInput = {
  /** JiraShareableEntityGrant ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** ARI of the project in the format `ari:cloud:jira:{siteId}:project/{projectId}`. */
  projectId: Scalars['ID']['input'];
};

/**
 * Input for the id of the role.
 * Users with the specified role will be granted permission.
 */
export type JiraShareableEntityProjectRoleGrantInput = {
  /** JiraShareableEntityGrant ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** ARI of the project in the format `ari:cloud:jira:{siteId}:project/{projectId}`. */
  projectId: Scalars['ID']['input'];
  /** Tenant local roleId. */
  projectRoleId: Scalars['Int']['input'];
};

/** Input type for JiraShareableEntityShareGrants. */
export type JiraShareableEntityShareGrantInput = {
  /** All users with access to the instance and anonymous users will be granted permission. */
  anonymousAccess?: InputMaybe<JiraShareableEntityAnonymousAccessGrantInput>;
  /** All users with access to the instance will be granted permission. */
  anyLoggedInUser?: InputMaybe<JiraShareableEntityAnyLoggedInUserGrantInput>;
  /** User group that will be granted permission. */
  group?: InputMaybe<JiraShareableEntityGroupGrantInput>;
  /** Members of the specified project will be granted permission. */
  project?: InputMaybe<JiraShareableEntityProjectGrantInput>;
  /** Users with the specified role in the project will be granted permission. */
  projectRole?: InputMaybe<JiraShareableEntityProjectRoleGrantInput>;
  /** User that will be granted permission. */
  user?: InputMaybe<JiraShareableEntityUserGrantInput>;
};

/** Input for user that will be granted permission. */
export type JiraShareableEntityUserGrantInput = {
  /** JiraShareableEntityGrant ARI. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** ARI of the user in the form of ARI: ari:cloud:identity::user/{userId}. */
  userId: Scalars['ID']['input'];
};

export type JiraShortcutDataInput = {
  /** The name identifying this shortcut. */
  name: Scalars['String']['input'];
  /** The url link of this shortcut. */
  url: Scalars['String']['input'];
};

/** The content to display in the sidebar menu. */
export enum JiraSidebarMenuDisplayMode {
  MostRecentOnly = 'MOST_RECENT_ONLY',
  Starred = 'STARRED',
  StarredAndRecent = 'STARRED_AND_RECENT'
}

export type JiraSidebarMenuItemInput = {
  /** ID for the menu item. For example, for projects, this would be the project ID. */
  itemId: Scalars['ID']['input'];
};

/** The available reordering operations */
export enum JiraSidebarMenuItemReorderOperation {
  After = 'AFTER',
  Before = 'BEFORE',
  MoveDown = 'MOVE_DOWN',
  MoveToBottom = 'MOVE_TO_BOTTOM',
  MoveToTop = 'MOVE_TO_TOP',
  MoveUp = 'MOVE_UP'
}

/** Input type for single group picker field */
export type JiraSingleGroupPickerFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Group value for the field */
  group: JiraGroupInput;
};

/** Input type for defining the operation on the SingleGroupPicker field of a Jira issue. */
export type JiraSingleGroupPickerFieldOperationInput = {
  /**
   * Group Id for field update.
   * Accepts ARI: group
   */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Operation supported: SET. */
  operation: JiraSingleValueFieldOperations;
};

/** Input for single line text fields like summary */
export type JiraSingleLineTextFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Single line text input on which the action will be performed */
  text?: InputMaybe<Scalars['String']['input']>;
};

export type JiraSingleLineTextFieldOperationInput = {
  operation: JiraSingleValueFieldOperations;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for a single organization field */
export type JiraSingleOrganizationFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Organization */
  organization: JiraOrganizationsInput;
};

/** Input type for single select field */
export type JiraSingleSelectFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Option on which the action will be performed */
  option: JiraSelectedOptionInput;
};

export type JiraSingleSelectOperationInput = {
  /** Accepts ARI(s): issue-field-option */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Input type for single select user picker fields */
export type JiraSingleSelectUserPickerFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Input data for user being selected */
  user: JiraUserInput;
};

export type JiraSingleSelectUserPickerFieldOperationInput = {
  /** Accepts ARI(s): user */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Operations that can be performed on single value fields like date, date time, etc. */
export enum JiraSingleValueFieldOperations {
  /** Overrides single value field. */
  Set = 'SET'
}

/** Input type for single select version picker fields */
export type JiraSingleVersionPickerFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Version field on which the action will be performed */
  version: JiraVersionInput;
};

/** Input type for defining the operation on the SingleVersionPicker field of a Jira issue. */
export type JiraSingleVersionPickerFieldOperationInput = {
  /** Accepts ARI(s): version */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Operation supported: SET. */
  operation: JiraSingleValueFieldOperations;
};

/** Custom input definition for Jira Software issue search. */
export type JiraSoftwareIssueSearchCustomInput = {
  /** Additional JQL clause that can be added to the search (e.g. 'AND <additionalJql>') */
  additionalJql?: InputMaybe<Scalars['String']['input']>;
  /** Additional context for issue search, optionally constraining the returned issues */
  context?: InputMaybe<JiraSoftwareIssueSearchCustomInputContext>;
  /**
   * The Jira entity ARI of the object to constrain search to.
   * Currently only supports board ARI.
   */
  jiraEntityId: Scalars['ID']['input'];
};

/**
 * Additional context for Jira Software custom issue search, optionally constraining the search
 * by adding additional clauses to the search query.
 */
export enum JiraSoftwareIssueSearchCustomInputContext {
  /** Search is constrained to issues visible on backlogs */
  Backlog = 'BACKLOG',
  /** Search is constrained to issues visible on boards */
  Board = 'BOARD',
  /** No additional visibility constraints are applied to the search */
  None = 'NONE'
}

/** Input type for sprint field */
export type JiraSprintFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** List of sprints on which the action will be performed */
  sprints: Array<JiraSprintInput>;
};

export type JiraSprintFieldOperationInput = {
  /** Accepts ARI(s): sprint */
  id?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Accepts operation type and sprintId.
   * The sprintId is optional, in case of a missing sprintId the sprint field will be cleared.
   */
  operation: JiraSingleValueFieldOperations;
};

export type JiraSprintFilterInput = {
  /**
   * The active window to filter the Sprints to.
   * The window bounds are equivalent to filtering Sprints where (startDate > start AND startDate < end)
   * OR if sprint is completed (completionDate > start AND completionDate < end),
   * otherwise if sprint isn't completed (endDate > start AND < endDate < end).
   * If no start or end is provided, the window is considered unbounded in that direction.
   */
  activeWithin?: InputMaybe<JiraDateTimeWindow>;
  /**
   * The Board ids to filter Sprints to.
   * A Sprint is considered to be in a Board if it is associated with that board directly
   * or if it is associated with an Issue that is part of the Board's saved filter.
   */
  boardIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The Project ids to filter Sprints to.
   * A Sprint is considered to be in a Project if it is associated with a board that is associated with the Project
   * or if it is associated with an Issue that is associated with the Project.
   */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The raw Project keys to filter Sprints to.
   * A Sprint is considered to be in a Project if it is associated with a board that is associated with the Project
   * or if it is associated with an Issue that is associated with the Project.
   */
  projectKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The state of the Sprints to filter to. */
  states?: InputMaybe<Array<JiraSprintState>>;
};

/** Input type for sprints */
export type JiraSprintInput = {
  /** An identifier for the sprint */
  sprintId: Scalars['ID']['input'];
};

/** Represents the state of the sprint. */
export enum JiraSprintState {
  /** The sprint is in progress. */
  Active = 'ACTIVE',
  /** The sprint has been completed. */
  Closed = 'CLOSED',
  /** The sprint hasn't been started yet. */
  Future = 'FUTURE'
}

export type JiraSprintUpdateInput = {
  /** End date of the sprint */
  endDate?: InputMaybe<Scalars['String']['input']>;
  /** Goal of the sprint */
  goal?: InputMaybe<Scalars['String']['input']>;
  /** Name of the sprint */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Sprint ARI https://developer.atlassian.com/platform/atlassian-resource-identifier/resource-owners/registry/#ati%3Acloud%3Ajira%3Asprint */
  sprintId: Scalars['ID']['input'];
  /** Start date of the sprint */
  startDate?: InputMaybe<Scalars['String']['input']>;
};

/** Color of the status category. */
export enum JiraStatusCategoryColor {
  /** #4a6785 */
  BlueGray = 'BLUE_GRAY',
  /** #815b3a */
  Brown = 'BROWN',
  /** #14892c */
  Green = 'GREEN',
  /** #707070 */
  MediumGray = 'MEDIUM_GRAY',
  /** #d04437 */
  WarmRed = 'WARM_RED',
  /** #f6c342 */
  Yellow = 'YELLOW'
}

/** Input type for status field */
export type JiraStatusInput = {
  /** An identifier for the field */
  statusId: Scalars['ID']['input'];
};

export type JiraStoryPointEstimateFieldOperationInput = {
  operation: JiraSingleValueFieldOperations;
  /** Only positive storypoint and null are allowed */
  storyPoint?: InputMaybe<Scalars['Float']['input']>;
};

/** This is an input argument client will have to give in order to perform bulk edit submit */
export type JiraSubmitBulkOperationInput = {
  /** Payload provided to perform the bulk operation */
  bulkOperationInput: JiraBulkOperationInput;
  /** Represents the type of bulk operation */
  bulkOperationType: JiraBulkOperationType;
};

/** The type representing the status of the suggest child issues feature */
export enum JiraSuggestedChildIssueStatusType {
  /** The feature has completed its work and the stream is finished */
  Complete = 'COMPLETE',
  /** The service is refining suggested issues based on the user's additional context prompt */
  RefiningSuggestedIssues = 'REFINING_SUGGESTED_ISSUES',
  /** The service is reformatting the suggested issues to the standard format for their issue type */
  ReformattingIssues = 'REFORMATTING_ISSUES',
  /**
   * The service is removing issues that are semantically similar to existing child issues or issues provided in
   * excludeSimilarIssues argument
   */
  RemovingDuplicateIssues = 'REMOVING_DUPLICATE_ISSUES',
  /** The service is retrieving context for the source issue from the DB */
  RetrievingSourceContext = 'RETRIEVING_SOURCE_CONTEXT',
  /** The service is generating suggestions for child issues based on the source issue context */
  SuggestingInitialIssues = 'SUGGESTING_INITIAL_ISSUES'
}

/** Represents the different types of errors that will be returned by the suggest child issues feature */
export enum JiraSuggestedIssueErrorType {
  /** There are communication problems with downstream services used by the feature. */
  CommunicationsError = 'COMMUNICATIONS_ERROR',
  /** The source issue did not contain enough information to suggest any quality child issues */
  NotEnoughInformation = 'NOT_ENOUGH_INFORMATION',
  /**
   * All quality child issues have already been suggested by the issues.  Generally this indicates that all viable child
   * issues have already been added to the issue
   */
  NoFurtherSuggestions = 'NO_FURTHER_SUGGESTIONS',
  /** A general catch all for other types of errors encountered while suggesting child issues. */
  Unclassified = 'UNCLASSIFIED',
  /** The feature has deemed the content in the source issue to be unethical and will not suggest child issues. */
  UnethicalContent = 'UNETHICAL_CONTENT'
}

export enum JiraSuggestedIssueFieldValueError {
  /** We don't support issue which has required field yet */
  HaveRequiredField = 'HAVE_REQUIRED_FIELD',
  /** We don't support issue which is sub-task */
  IsSubTask = 'IS_SUB_TASK',
  /** The LLM responded that it does not have enough information to suggest any issues */
  NotEnoughInformation = 'NOT_ENOUGH_INFORMATION',
  /**
   * The LLM response that it has no further suggestions, generally this indicates that all viable child issues
   * have already been added to the issue
   */
  NoFurtherSuggestions = 'NO_FURTHER_SUGGESTIONS',
  /** We don't support suggestion if feature is not enabled (ie not opt-in to ai, etc) */
  SuggestionIsNotEnabled = 'SUGGESTION_IS_NOT_ENABLED',
  /**
   * A general catch all for other types of errors. This will not be generated by the LLM, but used for invalid LLM
   * responses
   */
  Unclassified = 'UNCLASSIFIED'
}

/**
 * Represents an issue supplied to the suggest child issues feature to prevent semantically similar issues from being
 * suggested
 */
export type JiraSuggestedIssueInput = {
  /** The description of the issue */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The summary of the issue */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** The currently supported actions for suggestions */
export enum JiraSuggestionActionType {
  MergeIssues = 'MERGE_ISSUES'
}

/** The possible statuses of a suggestion */
export enum JiraSuggestionStatus {
  Dismissed = 'DISMISSED',
  Done = 'DONE',
  Pending = 'PENDING'
}

/** The currently supported suggestions types */
export enum JiraSuggestionType {
  DuplicateIssues = 'DUPLICATE_ISSUES'
}

/** The input for retrieving suggestions by context */
export type JiraSuggestionsByContextInput = {
  /**
   * NOTE: Field not supported yet
   *
   * The index based cursor to specify the beginning of the items.
   * If not specified it's assumed as the cursor for the item before the beginning.
   */
  after?: InputMaybe<Scalars['String']['input']>;
  /**
   * NOTE: Field not supported yet
   *
   * The number of items after the cursor to be returned in a forward page.
   * If not specified, it is up to the server to determine a page size.
   */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** The entityId (ARI) of the entity to fetch suggestions for. ProjectARI and Board ARI supported as of now. */
  id: Scalars['ID']['input'];
  /** The status of suggestions to fetch */
  status?: InputMaybe<Array<JiraSuggestionStatus>>;
  /** The types of suggestions to fetch */
  types: Array<JiraSuggestionType>;
};

/** List of values identifying the different synthetic field types. */
export enum JiraSyntheticFieldCardOptionType {
  CardCover = 'CARD_COVER',
  Pages = 'PAGES'
}

/** Input type for team field */
export type JiraTeamFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Represents a team field */
  team: JiraTeamInput;
};

export type JiraTeamFieldOperationInput = {
  /** Accept ARI(s): team */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraSingleValueFieldOperations;
};

/** Input type for team data */
export type JiraTeamInput = {
  /** An identifier for the team */
  teamId: Scalars['ID']['input'];
};

/** Enum representing the allowed teams for the Teams field filter. */
export enum JiraTeamsFieldAllowedTeams {
  /** All teams are allowed. */
  All = 'ALL',
  /** Only teams approved for the project are allowed. */
  OnlyVerified = 'ONLY_VERIFIED'
}

/** Configuration for the Teams field filter. */
export type JiraTeamsFieldFilterConfigInput = {
  /** Determines which teams are allowed by the filter. */
  allowedTeams: JiraTeamsFieldAllowedTeams;
};

/** Different time formats supported for entering & displaying time tracking related data. */
export enum JiraTimeFormat {
  /** E.g. 2d 4.5h */
  Days = 'DAYS',
  /** E.g. 52.5h */
  Hours = 'HOURS',
  /** E.g. 2 days, 4 hours, 30 minutes */
  Pretty = 'PRETTY'
}

/** Input for TimeTracking field */
export type JiraTimeTrackingFieldInput = {
  /** Represents the original time tracking estimate */
  originalEstimate?: InputMaybe<Scalars['String']['input']>;
  /** Represents the remaining time tracking estimate */
  timeRemaining?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Different time units supported for entering & displaying time tracking related data.
 * Get the currently configured default duration to use when parsing duration string for time tracking.
 */
export enum JiraTimeUnit {
  /** When the current duration is in days. */
  Day = 'DAY',
  /** When the current duration is in hours. */
  Hour = 'HOUR',
  /** When the current duration is in minutes. */
  Minute = 'MINUTE',
  /** When the current duration is in weeks. */
  Week = 'WEEK'
}

export type JiraTimelineIssueSearchCustomInput = {
  /** JQL search query if any additional filters(e.g. assignee, epic, issuetype etc.) are applied on top of the base JQL */
  additionalJql?: InputMaybe<Scalars['String']['input']>;
  /** The board ID to fetch the base JQL for the board */
  boardId: Scalars['ID']['input'];
  /** The custom filters ids. BE will fetch the JQL for each custom filter and combine them with the base JQL of the board */
  customFilterIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The quick filters ids. BE will fetch the JQL for each quick filter and combine them with the base JQL of the board */
  quickFilterIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * The input used for Timeline when FE needs to tell the BE the specific view configuration to be used for a Timeline query.
 * This would prevent scenarios where in user has two tabs open (one with warnings enabled and one with warnings disabled) and the BE needs to return
 * different results to respect the view configuration used on the initial load of each tab.
 */
export type JiraTimelineStaticViewInput = {
  /** A nullable boolean indicating if the Hide warnings setting is enabled */
  hideWarnings?: InputMaybe<Scalars['Boolean']['input']>;
  /** Range mode (JiraTimelineViewRangeMode) to display the timeline view */
  rangeMode?: InputMaybe<JiraTimelineViewRangeMode>;
};

/** The options for timeline view range mode. */
export enum JiraTimelineViewRangeMode {
  /** Display timeline grouped by months. */
  Months = 'MONTHS',
  /** Display timeline grouped by quarters. */
  Quarters = 'QUARTERS',
  /** Display timeline grouped by weeks. */
  Weeks = 'WEEKS'
}

/** Input for settings applied to the timeline view. */
export type JiraTimelineViewSettings = {
  /** Boolean indicating whether the completed issues should be hidden from the search result */
  hideDone?: InputMaybe<Scalars['Boolean']['input']>;
  /** JQL applied to the timeline view. */
  jql?: InputMaybe<Scalars['String']['input']>;
  /** Range mode (JiraTimelineViewRangeMode) to display the timeline view */
  rangeMode?: InputMaybe<JiraTimelineViewRangeMode>;
};

/** Input for tracking a recent issue. */
export type JiraTrackRecentIssueInput = {
  /** The Cloud ID of the Jira site for routing. */
  cloudId: Scalars['ID']['input'];
  /** The key of the issue to track as recently accessed. */
  issueKey: Scalars['String']['input'];
};

/** Input for tracking a recent project. */
export type JiraTrackRecentProjectInput = {
  /** The Cloud ID of the Jira site for routing. */
  cloudId: Scalars['ID']['input'];
  /** The key of the project to track as recently accessed. */
  projectKey: Scalars['String']['input'];
};

/** Input type for transition screen when fields have to be edited */
export type JiraTransitionScreenInput = {
  /** Info of the fields which are edited on transition screen */
  editedFieldsInput: JiraIssueFieldsInput;
  /** Set of fields edited on the transition screen. */
  selectedActions?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Enum representing different sort options for transitions. */
export enum JiraTransitionSortOption {
  OpsBar = 'OPS_BAR',
  OpsBarThenStatusCategory = 'OPS_BAR_THEN_STATUS_CATEGORY'
}

export type JiraTrashCustomFieldsInput = {
  /** Ids of the custom fields, e.g. "customfield_10000". */
  fieldIds: Array<Scalars['String']['input']>;
};

export type JiraTrashGlobalCustomFieldsInput = {
  /** Ids of the global custom fields, e.g. "customfield_10000". */
  fieldIds: Array<Scalars['String']['input']>;
};

export type JiraUiModificationsContextInput = {
  issueKey?: InputMaybe<Scalars['String']['input']>;
  issueTypeId?: InputMaybe<Scalars['ID']['input']>;
  portalId?: InputMaybe<Scalars['ID']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  requestTypeId?: InputMaybe<Scalars['ID']['input']>;
  viewType: JiraUiModificationsViewType;
};

export enum JiraUiModificationsViewType {
  Gic = 'GIC',
  GicAgentView = 'GICAgentView',
  IssueTransition = 'IssueTransition',
  IssueTransitionAgentView = 'IssueTransitionAgentView',
  IssueView = 'IssueView',
  IssueViewAgentView = 'IssueViewAgentView',
  JsmRequestCreate = 'JSMRequestCreate'
}

export type JiraUnlinkIssuesFromIncidentMutationInput = {
  /** The id of the JSM incident to have issues linked to it. */
  incidentId: Scalars['ID']['input'];
  /**
   * The ids of the issues to unlink from an incident. This can be a JSW issue as an
   * action item or a JSM issues as a post incident review.
   */
  issueIds: Array<Scalars['ID']['input']>;
};

/** Input for attributing Unsplash images */
export type JiraUnsplashAttributionInput = {
  /**  CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /**
   * The list of unsplash image filepaths to attribute. Returned by the sourceId field of JiraCustomBackground.
   * A maximum of 50 images can be attributed at once.
   */
  filePaths: Array<Scalars['ID']['input']>;
};

/**
 * The input for searching Unsplash images. Uses Unsplash's API definition for pagination
 * https://unsplash.com/documentation#parameters-16
 */
export type JiraUnsplashSearchInput = {
  /**  CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The page number, defaults to 1 */
  pageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** The page size, defaults to 10 */
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  /** The search query */
  query: Scalars['String']['input'];
  /** The requested width in pixels of the thumbnail image, default is 200px */
  width?: InputMaybe<Scalars['Int']['input']>;
};

export type JiraUpdateActivityConfigurationInput = {
  /** Id of the activity configuration */
  activityId: Scalars['ID']['input'];
  /** Field value mapping. It contains list of object which is like a map entry including a string key and array of string value */
  fieldValues?: InputMaybe<Array<InputMaybe<JiraActivityFieldValueKeyValuePairInput>>>;
  /** Name of the activity */
  issueTypeId?: InputMaybe<Scalars['ID']['input']>;
  /** Id of the journey configuration */
  journeyId: Scalars['ID']['input'];
  /** The version number of the journey configuration. */
  journeyVersion: Scalars['Long']['input'];
  /** Name of the activity */
  name: Scalars['String']['input'];
  /** Name of the activity */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** Name of the activity */
  requestTypeId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input type for updating the Affected Services(Service Entity) field of a Jira issue. */
export type JiraUpdateAffectedServicesFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on Affected Services field. */
  operation: JiraAffectedServicesFieldOperationInput;
};

/** Input for updating an agent's assignability status. */
export type JiraUpdateAgentAssignmentInput = {
  /** The agent to update. Must provide either agentId or agentAccountId. */
  agentInput: JiraAgentAssignableInput;
  /** Whether the agent can be assignable to issues */
  isAssignable: Scalars['Boolean']['input'];
};

/**
 * Input type for updating the Attachment field of a Jira issue.
 * Note: This schema is intended for GraphQL submit API only. It might not work with other Inline mutations
 */
export type JiraUpdateAttachmentFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on the Attachment field. */
  operation: JiraAttachmentFieldOperationInput;
};

/** The input for updating a Jira Background */
export type JiraUpdateBackgroundInput = {
  /** The type of background to update to */
  backgroundType: JiraBackgroundType;
  /**
   * The gradient/color if the background is a gradient/color type,
   * the customBackgroundId if the background is a custom (user uploaded) type, or
   * the image filePath if the background is from Unsplash
   */
  backgroundValue: Scalars['String']['input'];
  /**
   * The dominant color of the background image in HEX format, ie. "^#[A-Fa-f0-9]{6}$"
   * Currently optional for business projects.
   */
  dominantColor?: InputMaybe<Scalars['String']['input']>;
  /** The entityId (ARI) of the entity to be updated */
  entityId: Scalars['ID']['input'];
};

/**
 * The input used for updating calendar view configuration
 * Used for calendars that support saved views (currently software and business calendars)
 */
export type JiraUpdateCalendarViewConfigInput = {
  /** Settings overrides to be updated */
  overrides?: InputMaybe<JiraCalendarViewSettings>;
  /** ARI of the calendar view whose config is being updated */
  viewId: Scalars['ID']['input'];
};

export type JiraUpdateCascadingSelectFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraCascadingSelectFieldOperationInput;
};

/** Input type for updating the Checkboxes field of a Jira issue. */
export type JiraUpdateCheckboxesFieldInput = {
  /**  Accepts ARI(s): issuefieldvalue  */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Checkboxes field. */
  operations: Array<JiraCheckboxesFieldOperationInput>;
};

/** Input type for updating the Cmdb field of a Jira issue. */
export type JiraUpdateCmdbFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on Cmdb field. */
  operation: JiraCmdbFieldOperationInput;
};

export type JiraUpdateColorFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraColorFieldOperationInput;
};

export type JiraUpdateCommentInput = {
  /** Accept ADF (Atlassian Document Format) of comment content */
  content: JiraAdfInput;
  /** Timestamp at which the event corresponding to the comment occurred. */
  eventOccurredAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Accept ARI: comment */
  id: Scalars['ID']['input'];
  /** The Jira issue ARI. */
  issueId: Scalars['ID']['input'];
  /** Indicates whether the comment is hidden from Incident activity timeline or not. */
  jsdIncidentActivityViewHidden?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Either the group or the project role to associate with this comment, but not both.
   * Null means the permission level is unspecified, i.e. the comment is public.
   */
  permissionLevel?: InputMaybe<JiraPermissionLevelInput>;
};

export type JiraUpdateComponentsFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operations: Array<JiraComponentFieldOperationInput>;
};

/** Input type for defining the operation on Confluence remote issue links field of a Jira issue. */
export type JiraUpdateConfluenceRemoteIssueLinksFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /**
   * The operations to perform on Confluence Remote Issue Links
   * ADD, REMOVE, SET operations are supported.
   */
  operations: Array<JiraConfluenceRemoteIssueLinksFieldOperationInput>;
};

/** The input for updating a custom background */
export type JiraUpdateCustomBackgroundInput = {
  /** The new alt text */
  altText: Scalars['String']['input'];
  /**  CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** The customBackgroundId of the custom background to update */
  customBackgroundId: Scalars['ID']['input'];
};

export type JiraUpdateCustomFieldInput = {
  /**
   * The description of the custom field.
   * If this field is absent or null, the description will be removed from the custom field.
   */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom field. */
  fieldId: Scalars['String']['input'];
  /** The format configuration of the custom field. */
  formatConfig?: InputMaybe<JiraFieldFormatConfigInput>;
  /** The name of the custom field. */
  name: Scalars['String']['input'];
  /**
   * The key of the searcher of the custom field.
   * If this field is absent, null, "" or "-1", the searcher will be removed from the custom field.
   */
  searcherKey?: InputMaybe<Scalars['String']['input']>;
};

/** Input for updating a JiraCustomFilter. */
export type JiraUpdateCustomFilterDetailsInput = {
  /** A string containing filter description */
  description?: InputMaybe<Scalars['String']['input']>;
  /**
   * The list of edit grants for the filter. Edit Grants represent different ways that users have been granted access to edit the filter.
   * Empty array represents private edit grant.
   */
  editGrants: Array<InputMaybe<JiraShareableEntityEditGrantInput>>;
  /** ARI of the filter */
  id: Scalars['ID']['input'];
  /** A string representing the name of the filter */
  name: Scalars['String']['input'];
  /**
   * The list of share grants for the filter. Share Grants represent different ways that users have been granted access to the filter.
   * Empty array represents private share grant.
   */
  shareGrants: Array<InputMaybe<JiraShareableEntityShareGrantInput>>;
};

/** Input for updating the JQL of a JiraCustomFilter. */
export type JiraUpdateCustomFilterJqlInput = {
  /** An ARI-format value that encodes the filterId. */
  id: Scalars['ID']['input'];
  /** JQL associated with the filter */
  jql: Scalars['String']['input'];
};

export type JiraUpdateDataClassificationFieldInput = {
  /** Accepts ARI: issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Data Classification field. */
  operation: JiraDataClassificationFieldOperationInput;
};

export type JiraUpdateDateFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraDateFieldOperationInput;
};

export type JiraUpdateDateTimeFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraDateTimeFieldOperationInput;
};

/** Defines the scope for contextual data. */
export type JiraUpdateFieldContextualDataScopeInput = {
  /** The ID of the field. */
  fieldId: Scalars['String']['input'];
  /**
   * The ID of the issue type. If null, the context applies to all issue types within the project.
   * IMPORTANT: Issue Type level context is not supported at the moment and this field should be set to null.
   */
  issueTypeId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the project. If null, the context is global. */
  projectId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraUpdateFieldSetPreferencesInput = {
  fieldSetId: Scalars['String']['input'];
  /** Indicates whether the user has chosen to freeze this column, keep it fixed on horizontal scroll */
  isFrozen?: InputMaybe<Scalars['Boolean']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** Input type for comment added for Jira issue flag update. */
export type JiraUpdateFlagCommentInput = {
  /** Content of the comment inputted in ADF format */
  content?: InputMaybe<JiraAdfInput>;
  /** The comment property string to be parsed */
  property?: InputMaybe<Scalars['String']['input']>;
  /** Role or group level visibility */
  visibility?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for updating Jira issue flag. */
export type JiraUpdateFlagFieldInput = {
  /** Optional comment for flag update */
  comment?: InputMaybe<JiraUpdateFlagCommentInput>;
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /**
   * The operations to perform on Jira Issue Flags
   * ADD, REMOVE operations are supported.
   */
  operation: JiraUpdateFlagFieldOperationInput;
};

/** Input type for Jira issue flag update operation type: ADD, REMOVE */
export type JiraUpdateFlagFieldOperationInput = {
  /**
   * The operations to perform on Jira Issue Flags
   * ADD, REMOVE operations are supported.
   */
  operation: JiraFlagOperations;
};

/** Input type for updating the ForgeMultipleGroupPicker field of a Jira issue. */
export type JiraUpdateForgeMultipleGroupPickerFieldInput = {
  /** Accepts ARI: issuefieldvalue. */
  id: Scalars['ID']['input'];
  /** The operation to be performed on ForgeMultipleGroupPicker field. */
  operations: Array<JiraForgeMultipleGroupPickerFieldOperationInput>;
};

export type JiraUpdateForgeObjectFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraForgeObjectFieldOperationInput;
};

/** Input type for updating the ForgeSingleGroupPicker field of a Jira issue. */
export type JiraUpdateForgeSingleGroupPickerFieldInput = {
  /** Accepts ARI: issuefieldvalue. */
  id: Scalars['ID']['input'];
  /** The operation to be performed on ForgeSingleGroupPicker field. */
  operation: JiraForgeSingleGroupPickerFieldOperationInput;
};

/** Input for update a formatting rule. */
export type JiraUpdateFormattingRuleInput = {
  /**
   * The identifier that indicates that cloud instance this search to be executed for.
   * This value is used by AGG to route requests and ignored in Jira.
   */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** Content of this rule. */
  expression?: InputMaybe<JiraFormattingRuleExpressionInput>;
  /** Format type of this rule. */
  formatType?: InputMaybe<JiraFormattingArea>;
  /** Color to be applied if condition matches. */
  formattingColor?: InputMaybe<JiraColorInput>;
  /** The rule to update. */
  ruleId: Scalars['ID']['input'];
};

export type JiraUpdateGlobalCustomFieldInput = {
  /**
   * The description of the global custom field.
   * If this field is absent or null, the description will be removed from the global custom field.
   */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the global custom field. */
  fieldId: Scalars['String']['input'];
  /** The format configuration of the global custom field. */
  formatConfig?: InputMaybe<JiraFieldFormatConfigInput>;
  /** The name of the global custom field. */
  name: Scalars['String']['input'];
  /**
   * The key of the searcher of the global custom field.
   * If this field is absent, null, "" or "-1", the searcher will be removed from the global custom field.
   */
  searcherKey?: InputMaybe<Scalars['String']['input']>;
};

/** This is an input argument for updating the global notification preferences. */
export type JiraUpdateGlobalNotificationPreferencesInput = {
  /** A list of notification preferences to update. */
  preferences: Array<JiraNotificationPreferenceInput>;
};

/**
 * Input type for updating the IssueLink field of a Jira issue.
 * Note: This schema is intended for GraphQL submit API only. It might not work with other Inline mutations
 */
export type JiraUpdateIssueLinkFieldInputForIssueTransitions = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on the IssueLink field. */
  operation: JiraIssueLinkFieldOperationInputForIssueTransitions;
};

export type JiraUpdateIssueLinkRelationshipTypeFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /**
   * The operations to perform on Confluence Remote Issue Links
   * ADD, REMOVE, SET operations are supported.
   */
  operation: JiraUpdateIssueLinkRelationshipTypeFieldOperationInput;
};

export type JiraUpdateIssueLinkRelationshipTypeFieldOperationInput = {
  operation: JiraSingleValueFieldOperations;
  update: JiraIssueLinkRelationshipTypeUpdateInput;
};

/** Input for updating an existing conditional formatting rule for the issue search view. */
export type JiraUpdateIssueSearchFormattingRuleInput = {
  /** Content of this rule. */
  expression?: InputMaybe<JiraFormattingRuleExpressionInput>;
  /** Formatting area of this rule (row or cell). */
  formattingArea?: InputMaybe<JiraFormattingArea>;
  /** Color to be applied if condition matches. */
  formattingColor?: InputMaybe<JiraColorInput>;
  /** Id of the rule to update. */
  ruleId: Scalars['ID']['input'];
  /** ARI of the issue search to update a formatting rule for. */
  viewId: Scalars['ID']['input'];
};

/** Input type for performing a transition for the issue */
export type JiraUpdateIssueTransitionInput = {
  /** Jira Comment for Issue Transition */
  comment?: InputMaybe<JiraIssueTransitionCommentInput>;
  /** This contains list of all field level inputs, that may be required for mutation */
  fieldInputs?: InputMaybe<JiraIssueTransitionFieldLevelInput>;
  /**
   * Unique identifier for the issue
   * Accepts ARI(s): issue
   */
  issueId: Scalars['ID']['input'];
  /** Identifier for the transition to be performed */
  transitionId: Scalars['Int']['input'];
};

/** Input type for updating the IssueType field of a Jira issue. */
export type JiraUpdateIssueTypeFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the IssueType field. */
  operation: JiraIssueTypeFieldOperationInput;
};

/** Input for jira_updateIssueType mutation. */
export type JiraUpdateIssueTypeInput = {
  /** ID for the avatar of the issue type. */
  avatarId?: InputMaybe<Scalars['String']['input']>;
  /**  CloudID is required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** Description of the issue type. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issueType. */
  issueTypeId: Scalars['String']['input'];
  /** Name of the issue type. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** ID of parent project.  The presence of a projectId will denote that this is for a TMP rather than a CMP. */
  projectId?: InputMaybe<Scalars['ID']['input']>;
};

export type JiraUpdateJourneyActivityConfigurationInput = {
  /** List of new activity configuration */
  createActivityConfigurations?: InputMaybe<Array<InputMaybe<JiraCreateActivityConfigurationInput>>>;
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
  /** The version number of the entity. */
  version: Scalars['Long']['input'];
};

export type JiraUpdateJourneyConfigurationInput = {
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
  /** Name of the journey configuration */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Parent issue of the journey configuration */
  parentIssue?: InputMaybe<JiraJourneyParentIssueInput>;
  /** The trigger of this journey */
  trigger?: InputMaybe<JiraJourneyTriggerInput>;
  /** The version number of the entity. */
  version: Scalars['Long']['input'];
};

export type JiraUpdateJourneyCustomizationSettingsInput = {
  /** The customization settings to be updated. If null, existing settings will be removed. */
  customizationSettings?: InputMaybe<JiraJourneyCustomizationSettingsInput>;
  /** The entity tag of the journey configuration */
  etag: Scalars['String']['input'];
  /** ID of the journey configuration */
  journeyId: Scalars['ID']['input'];
  /** The version number of the journey configuration. */
  journeyVersion: Scalars['Long']['input'];
};

export type JiraUpdateJourneyItemInput = {
  /** Journey item configuration to be updated */
  configuration: JiraJourneyItemConfigurationInput;
  /** The entity tag of the journey configuration */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** Id of the journey item to be updated */
  itemId: Scalars['ID']['input'];
  /** Id of the journey configuration */
  journeyId: Scalars['ID']['input'];
  /** The version number of the journey configuration. */
  journeyVersion: Scalars['Long']['input'];
  /** The type of journey configuration */
  type?: InputMaybe<JiraJourneyConfigurationType>;
};

export type JiraUpdateJourneyNameInput = {
  /** The entity tag of the journey configuration */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
  /** The name of this journey */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The version number of the entity. */
  version: Scalars['Long']['input'];
};

export type JiraUpdateJourneyParentIssueConfigurationInput = {
  /** The entity tag of the journey configuration */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
  /** The parent issue of this journey */
  parentIssue?: InputMaybe<JiraJourneyParentIssueInput>;
  /** The version number of the entity. */
  version: Scalars['Long']['input'];
};

export type JiraUpdateJourneyParentTriggerConditionsInput = {
  /** Conditions to add or remove from the Journey Parent Trigger */
  conditions: JiraJourneyItemConditionsInput;
  /** The entity tag of the journey configuration */
  etag: Scalars['String']['input'];
  /** ID of the journey configuration */
  journeyId: Scalars['ID']['input'];
  /** The version number of the journey configuration. */
  journeyVersion: Scalars['Long']['input'];
};

export type JiraUpdateJourneyTriggerConfigurationInput = {
  /** The entity tag of the journey configuration */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** Id of the journey configuration */
  id: Scalars['ID']['input'];
  /** The trigger configuration of this journey */
  triggerConfiguration?: InputMaybe<JiraJourneyTriggerConfigurationInput>;
  /** The version number of the entity. */
  version: Scalars['Long']['input'];
};

export type JiraUpdateJourneyWorkItemAssociatedAutomationRuleInput = {
  /** Automation Rule UUID to be added to/removed from the Journey Work Item */
  associatedRuleId: Scalars['ID']['input'];
  /** The entity tag of the journey configuration */
  etag?: InputMaybe<Scalars['String']['input']>;
  /** ID of the journey configuration */
  journeyId: Scalars['ID']['input'];
  /** ID of the journey work item */
  journeyItemId: Scalars['ID']['input'];
  /** The version number of the journey configuration. */
  journeyVersion: Scalars['Long']['input'];
};

export type JiraUpdateJourneyWorkItemConditionsInput = {
  /** Conditions to add or remove from the Journey Work Item */
  conditions: JiraJourneyItemConditionsInput;
  /** The entity tag of the journey configuration */
  etag: Scalars['String']['input'];
  /** ID of the journey configuration */
  journeyId: Scalars['ID']['input'];
  /** ID of the journey work item */
  journeyItemId: Scalars['ID']['input'];
  /** The version number of the journey configuration. */
  journeyVersion: Scalars['Long']['input'];
};

export type JiraUpdateLabelsFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operations: Array<JiraLabelsFieldOperationInput>;
};

/** Input type for updating the Team field of a Jira issue. */
export type JiraUpdateLegacyTeamFieldInput = {
  /**  Accepts ARI(s): issuefieldvalue  */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Team field. */
  operation: JiraLegacyTeamFieldOperationInput;
};

/** Input type for updating the MultipleGroupPicker field of a Jira issue. */
export type JiraUpdateMultipleGroupPickerFieldInput = {
  /** Accepts ARI: issuefieldvalue. */
  id: Scalars['ID']['input'];
  /** The operation to be performed on MultipleGroupPicker field. */
  operations: Array<JiraMultipleGroupPickerFieldOperationInput>;
};

export type JiraUpdateMultipleSelectFieldInput = {
  /**  Accepts ARI(s): issuefieldvalue  */
  id: Scalars['ID']['input'];
  operations: Array<JiraMultipleSelectFieldOperationInput>;
};

/** Input type for updating the MultipleSelectUserPicker field of a Jira issue. */
export type JiraUpdateMultipleSelectUserPickerFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on MultipleSelectUserPicker field. */
  operations: Array<JiraMultipleSelectUserPickerFieldOperationInput>;
};

/** Input type for updating the Multiple Version Picker field of a Jira issue. */
export type JiraUpdateMultipleVersionPickerFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on Multiple Version Picker field. */
  operations: Array<JiraMultipleVersionPickerFieldOperationInput>;
};

/** This is an input argument for updating the notification options */
export type JiraUpdateNotificationOptionsInput = {
  /** Indicates the idle time for emails awaiting changes per issue, multiple emails within this time are consolidated and sent together in a single batched email */
  batchWindow?: InputMaybe<JiraBatchWindowPreference>;
  /** Indicates the local time to receive email notifications if user has chosen once-per-day email batching */
  dailyBatchLocalTime?: InputMaybe<Scalars['String']['input']>;
  /** The updated email MIME type preference that we wish to persist. */
  emailMimeType?: InputMaybe<JiraEmailMimeType>;
  /** Whether or not email notifications are enabled for this user. */
  isEmailNotificationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not to notify user for there own actions. */
  notifyOwnChangesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not notify when user is assignee on issue. */
  notifyWhenRoleAssigneeEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not notify when user is reporter on issue. */
  notifyWhenRoleReporterEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type JiraUpdateNumberFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraNumberFieldOperationInput;
};

/**
 * Mutation input used to update the changeboarding status of the current user in the context of the overview-plan
 * migration.
 */
export type JiraUpdateOverviewPlanMigrationChangeboardingInput = {
  /** Status of the changeboarding to be updated. */
  changeboardingStatus: JiraOverviewPlanMigrationChangeboardingStatus;
  /** ID of the tenant this mutation input is for. Only used for AGG tenant routing, ignored otherwise. */
  cloudId: Scalars['ID']['input'];
};

/** Input type for updating the Parent field of a Jira issue. */
export type JiraUpdateParentFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Parent field. */
  operation: JiraParentFieldOperationInput;
};

/** Input type for updating the People field of a Jira issue. */
export type JiraUpdatePeopleFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on People field. */
  operations: Array<JiraPeopleFieldOperationInput>;
};

export type JiraUpdatePriorityFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraPriorityFieldOperationInput;
};

export type JiraUpdateProjectFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraProjectFieldOperationInput;
};

/** This is the input argument for updating project notification preferences. */
export type JiraUpdateProjectNotificationPreferencesInput = {
  /** A list of notification preferences to update. */
  preferences: Array<JiraNotificationPreferenceInput>;
  /** The ARI of the project for which the notification preferences are to be updated. */
  projectId: Scalars['ID']['input'];
};

export type JiraUpdateRadioSelectFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraRadioSelectFieldOperationInput;
};

/** The input for updating the release notes configuration options for a version */
export type JiraUpdateReleaseNotesConfigurationInput = {
  /** The ARI of the version to update the release notes configuration for */
  id: Scalars['ID']['input'];
  /** The ARIs of issue fields(issue-field-meta ARI) to include when generating release notes */
  issueFieldIds: Array<Scalars['ID']['input']>;
  /** The issue key config to include when generating release notes */
  issueKeyConfig: JiraReleaseNotesIssueKeyConfig;
  /** The ARIs of issue types(issue-type ARI) to include when generating release notes */
  issueTypeIds: Array<Scalars['ID']['input']>;
};

/** Input type for updating the Resolution field of a Jira issue. */
export type JiraUpdateResolutionFieldInput = {
  /**  Accepts ARI(s): issuefieldvalue  */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Resolution field. */
  operation: JiraResolutionFieldOperationInput;
};

export type JiraUpdateRichTextFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraRichTextFieldOperationInput;
};

/** Input type for updating the Security Level field of a Jira issue. */
export type JiraUpdateSecurityLevelFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to perform on the Security Level field. */
  operation: JiraSecurityLevelFieldOperationInput;
};

export type JiraUpdateShortcutInput = {
  /** ARI of the project the shortcut is belongs to. */
  projectId: Scalars['ID']['input'];
  /** Data of shortcut being updated */
  shortcutData: JiraShortcutDataInput;
  /** ARI of the shortcut */
  shortcutId: Scalars['ID']['input'];
};

export type JiraUpdateSidebarMenuDisplaySettingInput = {
  /** The identifier of the cloud instance to update the sidebar menu settings for. */
  cloudId: Scalars['ID']['input'];
  /** The current URL where the request is made. */
  currentURL?: InputMaybe<Scalars['URL']['input']>;
  /** The content to display in the sidebar menu. */
  displayMode?: InputMaybe<JiraSidebarMenuDisplayMode>;
  /** The upper limit of favourite items to display. */
  favouriteLimit?: InputMaybe<Scalars['Int']['input']>;
  /** The desired order of favourite items. */
  favouriteOrder?: InputMaybe<Array<InputMaybe<JiraSidebarMenuItemInput>>>;
  /** The upper limit of recent items to display. */
  recentLimit?: InputMaybe<Scalars['Int']['input']>;
};

/** Input type for updating the SingleGroupPicker field of a Jira issue. */
export type JiraUpdateSingleGroupPickerFieldInput = {
  /** Accepts ARI: issuefieldvalue. */
  id: Scalars['ID']['input'];
  /** The operation to be performed on SingleGroupPicker field. */
  operation: JiraSingleGroupPickerFieldOperationInput;
};

export type JiraUpdateSingleLineTextFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraSingleLineTextFieldOperationInput;
};

export type JiraUpdateSingleSelectFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraSingleSelectOperationInput;
};

export type JiraUpdateSingleSelectUserPickerFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraSingleSelectUserPickerFieldOperationInput;
};

/** Input type for updating the SingleVersionPicker field of a Jira issue. */
export type JiraUpdateSingleVersionPickerFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operation to be performed on SingleVersionPicker field. */
  operation: JiraSingleVersionPickerFieldOperationInput;
};

export type JiraUpdateSprintFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraSprintFieldOperationInput;
};

export type JiraUpdateStatusFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** Accepts Transition actionId as input */
  statusTransitionId: Scalars['Int']['input'];
};

export type JiraUpdateStoryPointEstimateFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraStoryPointEstimateFieldOperationInput;
};

export type JiraUpdateTeamFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraTeamFieldOperationInput;
};

export type JiraUpdateTimeTrackingFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /**
   * Provide `null` to keep originalEstimate unchanged.
   *
   * Note: Setting originalEstimate when both originalEstimate & remainingEstimate are null, will also set
   * remainingEstimate to the value provided for originalEstimate.
   */
  originalEstimate?: InputMaybe<JiraEstimateInput>;
  /** Provide `null` to keep remainingEstimate unchanged. */
  remainingEstimate?: InputMaybe<JiraEstimateInput>;
};

export type JiraUpdateUrlFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraUrlFieldOperationInput;
};

export type JiraUpdateUserNavigationConfigurationInput = {
  /** The identifier that indicates that cloud instance this data is to be fetched for */
  cloudID: Scalars['ID']['input'];
  /**
   * A list of all the navigation items that the user has configured for this navigation section.
   * The order of the items in this list is the order in which they will be stored in the database.
   */
  navItems: Array<JiraConfigurableNavigationItemInput>;
  /** The uniques key describing the particular navigation section. */
  navKey: Scalars['String']['input'];
};

/** Input to update whether a version is archived or not. */
export type JiraUpdateVersionArchivedStatusInput = {
  /** The identifier for the Jira version. */
  id: Scalars['ID']['input'];
  /** Boolean that indicates if the version is archived. */
  isArchived: Scalars['Boolean']['input'];
};

/** Input to update the version description. */
export type JiraUpdateVersionDescriptionInput = {
  /** Version description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The identifier of the Jira version. */
  id: Scalars['ID']['input'];
};

/** Input shape to update(set/unset) Driver of a Jira Version */
export type JiraUpdateVersionDriverInput = {
  /** Atlassian Account ID (AAID) of the driver of the version. */
  driver?: InputMaybe<Scalars['ID']['input']>;
  /** Version ARI */
  id: Scalars['ID']['input'];
};

/** Input to update the version name. */
export type JiraUpdateVersionNameInput = {
  /** The identifier of the Jira version. */
  id: Scalars['ID']['input'];
  /** Version name. */
  name: Scalars['String']['input'];
};

/**
 * Input to update the version's sequence, which affects the version's
 * position and display order relative to other versions in the project.
 */
export type JiraUpdateVersionPositionInput = {
  /** The ID of the version preceding the version being updated. */
  afterVersionId: Scalars['ID']['input'];
  /** The identifier of the Jira version being updated. */
  id: Scalars['ID']['input'];
};

/**
 * Input to update/edit a related work item's title/URL/category.
 *
 * Only applicable for "generic link" work items.
 */
export type JiraUpdateVersionRelatedWorkGenericLinkInput = {
  /** The new related work item category. */
  category: Scalars['String']['input'];
  /** The identifier for the related work item. */
  relatedWorkId: Scalars['ID']['input'];
  /** The new related work title (can be null only if a `url` was given). */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The new URL for the related work item (pass `null` to make the item a placeholder). */
  url?: InputMaybe<Scalars['URL']['input']>;
  /** The identifier for the Jira version the work item lives in. */
  versionId: Scalars['ID']['input'];
};

/** Input to update the version release date. */
export type JiraUpdateVersionReleaseDateInput = {
  /** The identifier of the Jira version. */
  id: Scalars['ID']['input'];
  /** The date at which the version was released to customers. Must occur after startDate. */
  releaseDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Input to update whether a version is released or not. */
export type JiraUpdateVersionReleasedStatusInput = {
  /** The identifier for the Jira version. */
  id: Scalars['ID']['input'];
  /** Boolean that indicates if the version is released. */
  isReleased: Scalars['Boolean']['input'];
};

/** Input to update the rich text section's title for a given version */
export type JiraUpdateVersionRichTextSectionContentInput = {
  /** The rich text section's content in ADF */
  content?: InputMaybe<Scalars['JSON']['input']>;
  /** The identifier of the Jira version. */
  id: Scalars['ID']['input'];
};

/** Input to update the rich text section's title for a given version */
export type JiraUpdateVersionRichTextSectionTitleInput = {
  /** The identifier of the Jira version. */
  id: Scalars['ID']['input'];
  /** The rich text section's title. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Input to update the version start date. */
export type JiraUpdateVersionStartDateInput = {
  /** The identifier of the Jira version. */
  id: Scalars['ID']['input'];
  /** The date at which work on the version began. */
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** The input to update the version details page warning report. */
export type JiraUpdateVersionWarningConfigInput = {
  /** The ARI of the Jira project. */
  jiraProjectId: Scalars['ID']['input'];
  /** The version configuration options to be updated. */
  updatedVersionWarningConfig: JiraVersionUpdatedWarningConfigInput;
};

export type JiraUpdateViewConfigInput = {
  /** The field id for the end date field */
  endDateFieldId?: InputMaybe<Scalars['String']['input']>;
  /**
   * viewId is the unique identifier for the view: ari:cloud:jira:{siteId}:view/activation/{activationId}/{scopeType}/{scopeId}
   * https://developer.atlassian.com/platform/atlassian-resource-identifier/resource-owners/registry/#ati%3Acloud%3Ajira%3Aview
   */
  id: Scalars['ID']['input'];
  /** The field id for the start date field */
  startDateFieldId?: InputMaybe<Scalars['String']['input']>;
};

export type JiraUpdateVotesFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraVotesFieldOperationInput;
};

export type JiraUpdateWatchesFieldInput = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  operation: JiraWatchesFieldOperationInput;
};

/**
 * Input type for updating the Worklog field of a Jira issue.
 * Note: This schema is intended for GraphQL submit API only. It will not work with other Inline mutations
 */
export type JiraUpdateWorklogFieldInputForIssueTransitions = {
  /** Accepts ARI(s): issuefieldvalue */
  id: Scalars['ID']['input'];
  /** The operations to perform on the Worklog field. */
  operation: JiraWorklogFieldOperationInputForIssueTransitions;
};

export type JiraUpdateWorklogInput = {
  /**
   * Accept ARI: worklog
   * If `null`, adds a new worklog, else updates the worklog referenced by the provided Id.
   */
  id?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Accept ARI: issue
   * Cannot be `null` when adding a new worklog.
   */
  issue?: InputMaybe<Scalars['ID']['input']>;
  /** Provide `null` to auto adjust remainingEstimate. */
  remainingEstimate?: InputMaybe<JiraEstimateInput>;
  /**
   * Cannot be `null` when adding a new worklog.
   * When updating a worklog, provide `null` to keep time spent unchanged.
   */
  startedTime?: InputMaybe<Scalars['DateTime']['input']>;
  /**
   * Cannot be `null` when adding a new worklog.
   * When updating a worklog, provide `null` to keep time spent unchanged.
   */
  timeSpent?: InputMaybe<JiraEstimateInput>;
  workDescription?: InputMaybe<JiraAdfInput>;
};

/** Input type for url field */
export type JiraUrlFieldInput = {
  /** An identifier for the field */
  fieldId: Scalars['ID']['input'];
  /** Represents a url on which the action will be performed */
  url: Scalars['String']['input'];
};

export type JiraUrlFieldOperationInput = {
  operation: JiraSingleValueFieldOperations;
  uri?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for user field input */
export type JiraUserFieldInput = {
  fieldId: Scalars['ID']['input'];
  user?: InputMaybe<JiraUserInput>;
};

/** Input type for user information */
export type JiraUserInfoInput = {
  /** ARI of the user. */
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** Input type for user field */
export type JiraUserInput = {
  /** ARI representing the user */
  accountId: Scalars['ID']['input'];
};

export type JiraVersionAddApproverInput = {
  /** Atlassian Account ID (AAID) of approver. */
  approverAccountId: Scalars['ID']['input'];
  /** Version ARI */
  versionId: Scalars['ID']['input'];
};

/** The status of an Approver task in the version */
export enum JiraVersionApproverStatus {
  /** Indicates the task has been approved */
  Approved = 'APPROVED',
  /** Indicates the task has been declined */
  Declined = 'DECLINED',
  /** Indicates the task is yet to be approved or rejected */
  Pending = 'PENDING'
}

/** GraphQL input shape for creating new version */
export type JiraVersionCreateMutationInput = {
  /** Description of the version */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Atlassian Account ID (AAID) of the user who is the driver for the version */
  driver?: InputMaybe<Scalars['ID']['input']>;
  /** Name of the version. */
  name: Scalars['String']['input'];
  /** Project ID of the version */
  projectId: Scalars['ID']['input'];
  /** Release Date of the version */
  releaseDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Start Date of the version */
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** The section UI in version details page that are collapsed */
export enum JiraVersionDetailsCollapsedUi {
  Description = 'DESCRIPTION',
  Issues = 'ISSUES',
  IssueAssociatedDesigns = 'ISSUE_ASSOCIATED_DESIGNS',
  ProgressCard = 'PROGRESS_CARD',
  RelatedWork = 'RELATED_WORK',
  RichTextSection = 'RICH_TEXT_SECTION',
  RightSidebar = 'RIGHT_SIDEBAR'
}

export type JiraVersionDetailsCollapsedUisInput = {
  collapsedUis: Array<JiraVersionDetailsCollapsedUi>;
  versionId: Scalars['ID']['input'];
};

export type JiraVersionFilterInput = {
  /**
   * The active window to filter the Versions to.
   * The window bounds are equivalent to filtering Versions where (startDate > start AND startDate < end)
   * OR (releasedate > start AND releasedate < end)
   * If no start or end is provided, the window is considered unbounded in that direction.
   */
  activeWithin?: InputMaybe<JiraDateTimeWindow>;
  /** The Project ids to filter Versions to. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The raw Project keys to filter Versions to. */
  projectKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Versions that have name match this search string will be returned. */
  searchString?: InputMaybe<Scalars['String']['input']>;
  /** The statuses of the Versions to filter to. */
  statuses?: InputMaybe<Array<InputMaybe<JiraVersionStatus>>>;
};

/** Input for Versions values on fields */
export type JiraVersionInput = {
  /** Unique identifier for version field */
  versionId?: InputMaybe<Scalars['ID']['input']>;
};

/** The table column enum of version details page. */
export enum JiraVersionIssueTableColumn {
  /** build status column */
  BuildStatus = 'BUILD_STATUS',
  /** deployment status column (either from Bamboo or other providers) */
  DeploymentStatus = 'DEPLOYMENT_STATUS',
  /** development status column */
  DevelopmentStatus = 'DEVELOPMENT_STATUS',
  /** feature flag status column */
  FeatureFlagStatus = 'FEATURE_FLAG_STATUS',
  /** Issue assignee column */
  IssueAssignee = 'ISSUE_ASSIGNEE',
  /** Priority column */
  IssuePriority = 'ISSUE_PRIORITY',
  /** Issue status column */
  IssueStatus = 'ISSUE_STATUS',
  /** More action meat ball menu column */
  MoreAction = 'MORE_ACTION',
  /** Warnings column */
  Warnings = 'WARNINGS'
}

export type JiraVersionIssueTableColumnHiddenStateInput = {
  /** The columns to hide */
  hiddenColumns: Array<JiraVersionIssueTableColumn>;
  /** Version ARI */
  versionId: Scalars['ID']['input'];
};

/** The filter for a version's issues */
export enum JiraVersionIssuesFilter {
  All = 'ALL',
  Done = 'DONE',
  FailingBuild = 'FAILING_BUILD',
  InProgress = 'IN_PROGRESS',
  OpenPullRequest = 'OPEN_PULL_REQUEST',
  OpenReview = 'OPEN_REVIEW',
  Todo = 'TODO',
  UnreviewedCode = 'UNREVIEWED_CODE'
}

export type JiraVersionIssuesFiltersInput = {
  /** Assignee field account ARIs to filter by. Null means, don't apply assignee filter. Null inside array means unassigned issues. */
  assigneeAccountIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Epic ARIs to filter by */
  epicIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Search string to filter by. This will search issue title, description, id and key. */
  searchStr?: InputMaybe<Scalars['String']['input']>;
  /** Status categories to filter by */
  statusCategories?: InputMaybe<Array<JiraVersionIssuesStatusCategories>>;
  /** Warning categories to filter by */
  warningCategories?: InputMaybe<Array<JiraVersionWarningCategories>>;
};

/** Fields that can be used to sort issues returned on the version. */
export enum JiraVersionIssuesSortField {
  /** Sort by assignee */
  Assignee = 'ASSIGNEE',
  /** Sort by date issue was created */
  Created = 'CREATED',
  /** Sort by issue key */
  Key = 'KEY',
  /** Sort by priority */
  Priority = 'PRIORITY',
  /** Sort by status */
  Status = 'STATUS',
  /** Sort by type */
  Type = 'TYPE'
}

/** The sort criteria used for a version's issues */
export type JiraVersionIssuesSortInput = {
  order?: InputMaybe<SortDirection>;
  sortByField?: InputMaybe<JiraVersionIssuesSortField>;
};

export enum JiraVersionIssuesStatusCategories {
  /** Issue status done category */
  Done = 'DONE',
  /** Issue status in-progress category */
  InProgress = 'IN_PROGRESS',
  /** Issue status todo category */
  Todo = 'TODO'
}

/** Enumeration of the kinds of Jira version related work items. */
export enum JiraVersionRelatedWorkType {
  /** A related work item that links to the version's release notes in a Confluence page. */
  ConfluenceReleaseNotes = 'CONFLUENCE_RELEASE_NOTES',
  /** The most general kind of related work item - an arbitrary link/URL. */
  GenericLink = 'GENERIC_LINK',
  /**
   * A related work item that represents the "native" release notes for the version. These release notes are
   * generated dynamically, and there is at most one per version.
   */
  NativeReleaseNotes = 'NATIVE_RELEASE_NOTES'
}

/** The input for fetching a preview of the release notes */
export type JiraVersionReleaseNotesConfigurationInput = {
  /** The ids of issue fields to include when generating release notes */
  issueFieldIds: Array<Scalars['ID']['input']>;
  /** The issue key config to include when generating release notes */
  issueKeyConfig: JiraReleaseNotesIssueKeyConfig;
  /** The ids of issue types to include when generating release notes */
  issueTypeIds: Array<Scalars['ID']['input']>;
};

/** Types of Release Notes that are available */
export enum JiraVersionReleaseNotesType {
  /** Represents a Release Note generated in Confluence */
  ConfluenceReleaseNote = 'CONFLUENCE_RELEASE_NOTE',
  /** Represents the standard html/markdown Release Note Type */
  NativeReleaseNote = 'NATIVE_RELEASE_NOTE'
}

/** The argument for sorting project versions. */
export enum JiraVersionSortField {
  Description = 'DESCRIPTION',
  Name = 'NAME',
  ReleaseDate = 'RELEASE_DATE',
  Sequence = 'SEQUENCE',
  StartDate = 'START_DATE'
}

export type JiraVersionSortInput = {
  order: SortDirection;
  sortByField: JiraVersionSortField;
};

/** The status of a version field. */
export enum JiraVersionStatus {
  /** Indicates the version is archived, no further changes can be made to this version unless it is un-archived */
  Archived = 'ARCHIVED',
  /** Indicates the version is available to public */
  Released = 'RELEASED',
  /** Indicates the version is not launched yet */
  Unreleased = 'UNRELEASED'
}

export type JiraVersionUpdateApproverDeclineReasonInput = {
  /** Approver ARI to update decline reason */
  approverId: Scalars['ID']['input'];
  /** The new decline reason. Null means no reason saved, that is identical to empty string */
  reason?: InputMaybe<Scalars['String']['input']>;
};

/** The input to update approval description */
export type JiraVersionUpdateApproverDescriptionInput = {
  /** Approver ARI. */
  approverId: Scalars['ID']['input'];
  /** The description of the task to be approved. Null means empty description. */
  description?: InputMaybe<Scalars['String']['input']>;
};

/** The input to update approval status */
export type JiraVersionUpdateApproverStatusInput = {
  /** Approver ARI. */
  approverId: Scalars['ID']['input'];
  /** Project key */
  projectKey?: InputMaybe<Scalars['String']['input']>;
  /** The status of the task */
  status?: InputMaybe<JiraVersionApproverStatus>;
};

/** GraphQL input shape for updating an entire(all fields) version object */
export type JiraVersionUpdateMutationInput = {
  /** Description of the version */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Atlassian Account ID (AAID) of the user who is the driver for the version */
  driver?: InputMaybe<Scalars['ID']['input']>;
  /** JiraVersion ARI. */
  id: Scalars['ID']['input'];
  /** Name of the version. */
  name: Scalars['String']['input'];
  /** Release Date of the version */
  releaseDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Start Date of the version */
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/**
 * The warning configuration to be updated for version details page warning report.
 * Applicable values will have their value updated. Null values will default to true.
 */
export type JiraVersionUpdatedWarningConfigInput = {
  /** The warnings for issues that has failing build and in done issue status category. */
  isFailingBuildEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The warnings for issues that has open pull request and in done issue status category. */
  isOpenPullRequestEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The warnings for issues that has open review(FishEye/Crucible integration) and in done issue status category. */
  isOpenReviewEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The warnings for issues that has unreviewed code and in done issue status category. */
  isUnreviewedCodeEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum JiraVersionWarningCategories {
  /** Category to list issues with failing build in the version */
  FailingBuild = 'FAILING_BUILD',
  /** Category to list issues with pull request still open in the version */
  OpenPullRequest = 'OPEN_PULL_REQUEST',
  /** Category to list issues with review(FishEye/Crucible specific entity) still open in the version */
  OpenReview = 'OPEN_REVIEW',
  /** Category to list issues with some code linked that is not reviewed in the version */
  UnreviewedCode = 'UNREVIEWED_CODE'
}

/** The warning config for version details page to generate warning report. Depending on tenant settings and providers installed, some warning config could be in NOT_APPLICABLE state. */
export enum JiraVersionWarningConfigState {
  Disabled = 'DISABLED',
  Enabled = 'ENABLED',
  NotApplicable = 'NOT_APPLICABLE'
}

/** Input to query a Jira view by its board ID scope and item ID */
export type JiraViewBoardIdAndItemQuery = {
  /** ID of a Jira board. */
  boardId: Scalars['Long']['input'];
  /** The identifier which indicates the cloud instance this data is to be fetched for, required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** Item ID for the Jira View, in the format `itemType/itemId`, or just `itemType` for the original view. */
  itemId: Scalars['String']['input'];
};

/** Input to retrieve a Jira view. */
export type JiraViewInput = {
  /** Input to retrieve a specific Jira view. */
  jiraViewQueryInput: JiraViewQueryInput;
};

/** Input to query a Jira view by its project key scope and item ID */
export type JiraViewProjectKeyAndItemQuery = {
  /** The identifier which indicates the cloud instance this data is to be fetched for, required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** Item ID for the Jira View, in the format `itemType/itemId`, or just `itemType` for the original view. */
  itemId: Scalars['String']['input'];
  /** Key of a Jira project. */
  projectKey: Scalars['String']['input'];
};

/**
 * Input to retrieve a specific Jira view. As per the oneOf directive, the view can either be fetched by its Jira View
 * ARI, or by a particular scope and item combination.
 */
export type JiraViewQueryInput = {
  /** Input to retrieve a Jira view by its board ID and item ID. */
  boardIdAndItemQuery?: InputMaybe<JiraViewBoardIdAndItemQuery>;
  /** Input to retrieve a Jira view by its project key and item ID. */
  projectKeyAndItemQuery?: InputMaybe<JiraViewProjectKeyAndItemQuery>;
  /** Input to retrieve a Jira view by its subcontainer ID and item ID. */
  subcontainerIdAndItemQuery?: InputMaybe<JiraViewSubcontainerIdAndItemQuery>;
  /** Jira View ARI. */
  viewId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input for the view that can be shared across multiple products, i.e., Jira Calendar */
export type JiraViewScopeInput = {
  /** Combination of ARIs to fetch data from different entities. Supported ARIs now are project and board. */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Project keys provided as a way to fetch data relating to projects. */
  projectKeys?: InputMaybe<JiraProjectKeysInput>;
};

/** Input to query a Jira view by its subcontainer ID and item ID */
export type JiraViewSubcontainerIdAndItemQuery = {
  /** The identifier which indicates the cloud instance this data is to be fetched for, required for AGG routing. */
  cloudId: Scalars['ID']['input'];
  /** Item ID for the Jira View, in the format `itemType/itemId`, or just `itemType` for the original view. */
  itemId: Scalars['String']['input'];
  /** Id of a Jira subcontainer (eg subspace) */
  subcontainerId: Scalars['String']['input'];
};

/** The reason why an extension shouldn't be visible in the given context. */
export enum JiraVisibilityControlMechanism {
  /** A Jira admin blocked the app from accessing the data in the given context using [App Access Rules](https://support.atlassian.com/security-and-access-policies/docs/block-app-access/). */
  AppAccessRules = 'AppAccessRules',
  /** The extension specified [Display Conditions](https://developer.atlassian.com/platform/forge/manifest-reference/display-conditions/) that evaluated to `false`. The app doesn't want the extension to be visible in the given context. */
  DisplayConditions = 'DisplayConditions',
  /**
   * The user can't see the extension in the given context because they are either anonymous or not fully licensed to use the product.
   * Some extension types can override these rules using the `unlicensedAccess` property.
   */
  UnlicensedAccess = 'UnlicensedAccess'
}

export type JiraVotesFieldOperationInput = {
  operation: JiraVotesOperations;
};

/** Operations that can be performed on vote field. */
export enum JiraVotesOperations {
  /** Adds voter to an issue. */
  Add = 'ADD',
  /** Removes voter from an issue. */
  Remove = 'REMOVE'
}

export type JiraWatchesFieldOperationInput = {
  /**
   * Accepts ARI(s): user
   * The user is optional, in case of missing user the logged in user will be added/removed as a watcher.
   */
  id?: InputMaybe<Scalars['ID']['input']>;
  operation: JiraWatchesOperations;
};

/** Operations that can be performed on watches field. */
export enum JiraWatchesOperations {
  /** Adds watcher to an issue. */
  Add = 'ADD',
  /** Removes watcher from an issue. */
  Remove = 'REMOVE'
}

export type JiraWorkManagementAssociateFieldInput = {
  /** The ID of the field to associate. */
  fieldId: Scalars['String']['input'];
  /** Optional list of issue type IDs to associate the fields to. */
  issueTypeIds?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  /** The Jira Project ID. */
  projectId: Scalars['Long']['input'];
};

/** The supported background types */
export enum JiraWorkManagementBackgroundType {
  Attachment = 'ATTACHMENT',
  Color = 'COLOR',
  Custom = 'CUSTOM',
  Gradient = 'GRADIENT'
}

/** Represents the input data required for JWM board settings . */
export type JiraWorkManagementBoardSettingsInput = {
  /**
   * Number of days to use as the cutoff for completed issues search.
   * Must be between 1 and 90 days.
   */
  completedIssueSearchCutOffInDays: Scalars['Int']['input'];
  /** Project to create issue within, encoded as an ARI */
  projectId: Scalars['ID']['input'];
};

/** Input for creating a Jira Work Management Custom Background */
export type JiraWorkManagementCreateCustomBackgroundInput = {
  /** The alt text associated with the custom background */
  altText: Scalars['String']['input'];
  /** The entityId (ARI) of the entity to be updated with the created background */
  entityId: Scalars['ID']['input'];
  /** The created mediaApiFileId of the background to create */
  mediaApiFileId: Scalars['String']['input'];
};

export type JiraWorkManagementCreateFilterInput = {
  /** ARI that encodes the ID of the project or project overview the filter was created on */
  contextId: Scalars['ID']['input'];
  /** JQL of filter to store */
  jql: Scalars['String']['input'];
  /** Name of filter to create */
  name: Scalars['String']['input'];
};

/** Represents the input data required for JWM issue creation. */
export type JiraWorkManagementCreateIssueInput = {
  /** Field data to populate the created issue with. Mandatory due to required fields such as Summary. */
  fields: JiraIssueFieldsInput;
  /** Issue type of issue to create in numeric format. E.g. 10000 */
  issueTypeId: Scalars['ID']['input'];
  /** Project to create issue within, encoded as an ARI */
  projectId: Scalars['ID']['input'];
  /** Rank Issue following creation */
  rank?: InputMaybe<JiraWorkManagementRankInput>;
  /** Transition Issue following creation in numeric format. E.g. 10000 */
  transitionId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input for creating a Jira Work Management Overview. */
export type JiraWorkManagementCreateOverviewInput = {
  /** Name of the Jira Work Management Overview. */
  name: Scalars['String']['input'];
  /** Project IDs (ARIs) to include in the created Jira Work Management Overview. */
  projectIds: Array<Scalars['ID']['input']>;
  /** Theme to set for the created Jira Work Management Overview. */
  theme?: InputMaybe<Scalars['String']['input']>;
};

/** Input for creating a saved view. */
export type JiraWorkManagementCreateSavedViewInput = {
  /** The label for the saved view, for display purposes. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** ARI of the project to create a saved view for. */
  projectId: Scalars['ID']['input'];
  /** The key of the type of the saved view. */
  typeKey: Scalars['String']['input'];
};

/** Represents the input data required for Jwm Delete Attachment mutation. */
export type JiraWorkManagementDeleteAttachmentInput = {
  /** The ARI of the attachment to be deleted */
  id: Scalars['ID']['input'];
};

/** The input for deleting a custom background */
export type JiraWorkManagementDeleteCustomBackgroundInput = {
  /** The identifier which indicates the cloud instance this data is to be fetched for */
  cloudId: Scalars['ID']['input'];
  /** The customBackgroundId of the custom background to delete */
  customBackgroundId: Scalars['ID']['input'];
};

/** Input for deleting a Jira Work Management Overview. */
export type JiraWorkManagementDeleteOverviewInput = {
  /** Global identifier (ARI) of the Jira Work Management Overview to delete. */
  id: Scalars['ID']['input'];
};

export type JiraWorkManagementFilterSearchInput = {
  /** An ARI of the context to search for filters by */
  contextId: Scalars['ID']['input'];
  /** Search for only favorite filters */
  favoritesOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Search by filter name. The string is broken into white-space delimited words and each word is
   * used as a OR'ed partial match for the filter name.  If this is null, the filters returned will not be filtered by name
   */
  keyword?: InputMaybe<Scalars['String']['input']>;
};

/** Represents the input data to rank an issue upon creation. */
export type JiraWorkManagementRankInput = {
  /**
   * ID of Issue after which the created issue should be ranked. Encoded as an ARI. Cannot be sent alongside before.
   * Accepts ARI(s): issue
   */
  after?: InputMaybe<Scalars['ID']['input']>;
  /**
   * ID of Issue before which the created issue should be ranked. Encoded as an ARI. Cannot be sent alongside after.
   * Accepts ARI(s): issue
   */
  before?: InputMaybe<Scalars['ID']['input']>;
};

/** The input for deleting an active background */
export type JiraWorkManagementRemoveActiveBackgroundInput = {
  /** The entityId (ARI) of the entity to remove the active background for */
  entityId: Scalars['ID']['input'];
};

/** The input for updating a Jira Work Management Background */
export type JiraWorkManagementUpdateBackgroundInput = {
  /** The type of background to update to */
  backgroundType: JiraWorkManagementBackgroundType;
  /**
   * The gradient/color if the background is a gradient/color type or
   * a customBackgroundId if the background is a custom (user uploaded) type
   */
  backgroundValue: Scalars['String']['input'];
  /** The entityId (ARI) of the entity to be updated */
  entityId: Scalars['ID']['input'];
};

/** The input for updating a custom background */
export type JiraWorkManagementUpdateCustomBackgroundInput = {
  /** The new alt text */
  altText: Scalars['String']['input'];
  /** The identifier which indicates the cloud instance this data is to be fetched for */
  cloudId: Scalars['ID']['input'];
  /** The customBackgroundId of the custom background to update */
  customBackgroundId: Scalars['ID']['input'];
};

export type JiraWorkManagementUpdateFilterInput = {
  /** An ARI-format value that encodes the filterId. */
  id: Scalars['ID']['input'];
  /** New filter name */
  name: Scalars['String']['input'];
};

/** Input for updating a Jira Work Management Overview. */
export type JiraWorkManagementUpdateOverviewInput = {
  /** Global identifier (ARI) of the Jira Work Management Overview to update. */
  id: Scalars['ID']['input'];
  /** New name of the Jira Work Management Overview. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** New project IDs to replace the existing project IDs for the Jira Work Management Overview. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** New theme to set for the Jira Work Management Overview. */
  theme?: InputMaybe<Scalars['String']['input']>;
};

export enum JiraWorkManagementUserLicenseSeatEdition {
  Free = 'FREE',
  Premium = 'PREMIUM',
  Standard = 'STANDARD'
}

/** Accepted Worklog adjustments */
export enum JiraWorklogAdjustmentEstimateOperation {
  /** To adjust estimate automatically whatever time spent mentioned. */
  Auto = 'AUTO',
  /** To leave time tracking without auto adjusting based on time spent */
  Leave = 'LEAVE',
  /** To reduce the time remaining manually. */
  Manual = 'MANUAL',
  /** To specifiy new time remaining. */
  New = 'NEW'
}

/** Input type for defining the operation on the Worklog field of a Jira issue. */
export type JiraWorklogFieldOperationInputForIssueTransitions = {
  /** provide a way to adjust the Estimate */
  adjustEstimateInput: JiraAdjustmentEstimate;
  /** Only ADD operation is supported for worklog field in purview of Issue Transition Modernisation flow. */
  operation: JiraAddValueFieldOperations;
  /** If user didn't provide this field or if it is `null` then startedTime will be logged as current time. */
  startedTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** If user didn't provide this field or if it is `null` then work will be logged with 0 minites. */
  timeSpentInMinutes?: InputMaybe<Scalars['Long']['input']>;
};

export type JiraWorklogSortInput = {
  /** The sort direction. */
  order: SortDirection;
};

/** Supported connection types */
export enum JsmChannelsConnectionType {
  Identitynow = 'IDENTITYNOW',
  Okta = 'OKTA'
}

/** Input for establishing outbound connection */
export type JsmChannelsEstablishConnectionInput = {
  clientId: Scalars['String']['input'];
  clientSecret?: InputMaybe<Scalars['String']['input']>;
  connectionType: JsmChannelsConnectionType;
  displayName: Scalars['String']['input'];
  exchangeUrl?: InputMaybe<Scalars['String']['input']>;
  hostUrl: Scalars['String']['input'];
  profileRetrieverUrl?: InputMaybe<Scalars['String']['input']>;
  refreshToken?: InputMaybe<Scalars['String']['input']>;
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum JsmChannelsExperience {
  EmployeeOnboardingAgent = 'EMPLOYEE_ONBOARDING_AGENT',
  EmployeeServiceAgent = 'EMPLOYEE_SERVICE_AGENT'
}

export type JsmChannelsExperienceConfigurationInput = {
  /** Filter configuration for the experience. */
  filter?: InputMaybe<JsmChannelsFilterConfigurationInput>;
  /** A boolean flag which defines if an underlying experience is active or not. */
  isEnabled: Scalars['Boolean']['input'];
};

export type JsmChannelsFilterConfigurationInput = {
  requestTypes?: InputMaybe<Array<JsmChannelsRequestTypesInput>>;
};

export enum JsmChannelsOrchestratorConversationActionType {
  AiAnswered = 'AI_ANSWERED',
  Matched = 'MATCHED',
  Unhandled = 'UNHANDLED'
}

export enum JsmChannelsOrchestratorConversationChannel {
  HelpCenter = 'HELP_CENTER',
  JsmPortal = 'JSM_PORTAL',
  JsmWidget = 'JSM_WIDGET',
  MsTeams = 'MS_TEAMS',
  Slack = 'SLACK'
}

export enum JsmChannelsOrchestratorConversationCsatOptionType {
  CsatOption_1 = 'CSAT_OPTION_1',
  CsatOption_2 = 'CSAT_OPTION_2',
  CsatOption_3 = 'CSAT_OPTION_3',
  CsatOption_4 = 'CSAT_OPTION_4',
  CsatOption_5 = 'CSAT_OPTION_5'
}

export enum JsmChannelsOrchestratorConversationState {
  Closed = 'CLOSED',
  Escalated = 'ESCALATED',
  Open = 'OPEN',
  Resolved = 'RESOLVED'
}

export type JsmChannelsOrchestratorConversationsFilter = {
  /** Filter by action type(s) */
  actions?: InputMaybe<Array<JsmChannelsOrchestratorConversationActionType>>;
  /** Filter by channel */
  channels?: InputMaybe<Array<JsmChannelsOrchestratorConversationChannel>>;
  /** Filter by csat score(s) */
  csatOptions?: InputMaybe<Array<JsmChannelsOrchestratorConversationCsatOptionType>>;
  /** The end date of a period to filter conversations */
  endDate: Scalars['DateTime']['input'];
  /** The start date of a period to filter conversations */
  startDate: Scalars['DateTime']['input'];
  /** Filter by state(s) */
  states?: InputMaybe<Array<JsmChannelsOrchestratorConversationState>>;
};

export enum JsmChannelsPlanNodeType {
  Condition = 'CONDITION',
  Step = 'STEP'
}

/** Input for querying a project and filters on request types */
export type JsmChannelsProjectQueryFilter = {
  /** The project Id */
  projectId: Scalars['String']['input'];
  /** Optional filter criteria. If omitted, returns all configured request types */
  requestTypeIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Agent status types */
export enum JsmChannelsRequestTypeAgentStatus {
  Assistive = 'ASSISTIVE',
  Autonomous = 'AUTONOMOUS',
  Disabled = 'DISABLED',
  Smart = 'SMART',
  Supervised = 'SUPERVISED'
}

export enum JsmChannelsRequestTypeExecutionMode {
  Assistive = 'ASSISTIVE',
  Autonomous = 'AUTONOMOUS',
  Disabled = 'DISABLED',
  Smart = 'SMART',
  Supervised = 'SUPERVISED'
}

export type JsmChannelsRequestTypesInput = {
  id: Scalars['String']['input'];
  mode: JsmChannelsRequestTypeExecutionMode;
};

/** Supported resolution plan actions */
export enum JsmChannelsResolutionPlanAction {
  Approve = 'APPROVE',
  Pause = 'PAUSE',
  Reject = 'REJECT',
  Resume = 'RESUME'
}

/** Resolution plan status enum */
export enum JsmChannelsResolutionPlanStatus {
  Approved = 'APPROVED',
  Paused = 'PAUSED',
  Pending = 'PENDING',
  Rejected = 'REJECTED'
}

/** Resolution plan step status enum */
export enum JsmChannelsResolutionPlanStepStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  Waiting = 'WAITING'
}

/** Input for updating the task agent configuration */
export type JsmChannelsTaskAgentConfigurationInput = {
  /** agent-specific configuration as a JSON map */
  configuration?: InputMaybe<Scalars['JSON']['input']>;
  /** Status of the task agent */
  status: JsmChannelsTaskAgentStatus;
};

/** Task agent related types */
export enum JsmChannelsTaskAgentStatus {
  Disabled = 'DISABLED',
  Enabled = 'ENABLED'
}

export enum JsmChatChannelExperienceId {
  Helpcenter = 'HELPCENTER',
  Widget = 'WIDGET'
}

export enum JsmChatChannelType {
  Agent = 'AGENT',
  Request = 'REQUEST'
}

export enum JsmChatConnectedApps {
  Slack = 'SLACK',
  Teams = 'TEAMS'
}

export enum JsmChatConversationAnalyticsEvent {
  UserClearedChat = 'USER_CLEARED_CHAT',
  UserMarkedAsNotResolved = 'USER_MARKED_AS_NOT_RESOLVED',
  UserMarkedAsResolved = 'USER_MARKED_AS_RESOLVED',
  UserSharedCsat = 'USER_SHARED_CSAT',
  VaRespondedWithKnowledgeAnswer = 'VA_RESPONDED_WITH_KNOWLEDGE_ANSWER',
  VaRespondedWithNonKnowledgeAnswer = 'VA_RESPONDED_WITH_NON_KNOWLEDGE_ANSWER'
}

export type JsmChatConversationAnalyticsMetadataInput = {
  channelType?: InputMaybe<JsmChatConversationChannelType>;
  csatScore?: InputMaybe<Scalars['Int']['input']>;
  helpCenterId?: InputMaybe<Scalars['String']['input']>;
  projectId?: InputMaybe<Scalars['String']['input']>;
};

export enum JsmChatConversationChannelType {
  Email = 'EMAIL',
  HelpCenter = 'HELP_CENTER',
  Portal = 'PORTAL',
  Slack = 'SLACK',
  Widget = 'WIDGET'
}

export type JsmChatCreateChannelInput = {
  channelName: Scalars['String']['input'];
  channelType: JsmChatChannelType;
  isVirtualAgentChannel?: InputMaybe<Scalars['Boolean']['input']>;
  isVirtualAgentTestChannel?: InputMaybe<Scalars['Boolean']['input']>;
  requestTypeIds: Array<Scalars['String']['input']>;
};

export type JsmChatCreateCommentInput = {
  message: Scalars['JSON']['input'];
  messageSource: JsmChatMessageSource;
  messageType: JsmChatMessageType;
};

export type JsmChatCreateConversationAnalyticsInput = {
  conversationAnalyticsEvent: JsmChatConversationAnalyticsEvent;
  conversationAnalyticsMetadata?: InputMaybe<JsmChatConversationAnalyticsMetadataInput>;
  conversationId: Scalars['String']['input'];
  messageId?: InputMaybe<Scalars['String']['input']>;
};

export type JsmChatCreateConversationInput = {
  channelExperienceId: JsmChatChannelExperienceId;
  conversationContextAri: Scalars['ID']['input'];
  isTestChannel?: InputMaybe<Scalars['Boolean']['input']>;
  mode?: InputMaybe<JsmChatMode>;
};

export enum JsmChatCreateWebConversationMessageContentType {
  Adf = 'ADF'
}

export type JsmChatCreateWebConversationMessageInput = {
  /** The text content of the message */
  message: Scalars['String']['input'];
};

export enum JsmChatCreateWebConversationUserRole {
  Acknowledgment = 'Acknowledgment',
  Init = 'Init',
  JsmAgent = 'JSM_Agent',
  Participant = 'Participant',
  Reporter = 'Reporter',
  VirtualAgent = 'VirtualAgent'
}

export type JsmChatDisconnectJiraProjectInput = {
  activationId: Scalars['ID']['input'];
  projectId: Scalars['ID']['input'];
  siteId: Scalars['ID']['input'];
  teamId: Scalars['ID']['input'];
};

export type JsmChatDisconnectMsTeamsJiraProjectInput = {
  tenantId: Scalars['String']['input'];
};

export type JsmChatInitializeAndSendMessageInput = {
  channelExperienceId: JsmChatWebChannelExperienceId;
  conversationContextAri: Scalars['ID']['input'];
  isTestChannel?: InputMaybe<Scalars['Boolean']['input']>;
  message: Scalars['String']['input'];
  subscriptionId: Scalars['String']['input'];
};

export type JsmChatInitializeConfigRequest = {
  activationId: Scalars['ID']['input'];
  projectId: Scalars['ID']['input'];
  siteId: Scalars['ID']['input'];
};

export enum JsmChatMessageSource {
  Email = 'EMAIL'
}

export enum JsmChatMessageType {
  Adf = 'ADF'
}

export enum JsmChatMode {
  Preview = 'PREVIEW'
}

export type JsmChatMsTeamsUpdatedProjectSettings = {
  jsmApproversEnabled: Scalars['Boolean']['input'];
};

export type JsmChatPaginationConfig = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset: Scalars['Int']['input'];
};

export type JsmChatUpdateChannelSettingsInput = {
  isDeflectionChannel?: InputMaybe<Scalars['Boolean']['input']>;
  isVirtualAgentChannel?: InputMaybe<Scalars['Boolean']['input']>;
  requestTypeIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type JsmChatUpdateMsTeamsChannelSettingsInput = {
  requestTypeIds: Array<Scalars['String']['input']>;
};

export type JsmChatUpdateMsTeamsProjectSettingsInput = {
  settings?: InputMaybe<JsmChatMsTeamsUpdatedProjectSettings>;
};

export type JsmChatUpdateProjectSettingsInput = {
  activationId: Scalars['String']['input'];
  projectId: Scalars['String']['input'];
  settings?: InputMaybe<JsmChatUpdatedProjectSettings>;
  siteId: Scalars['String']['input'];
};

export type JsmChatUpdatedProjectSettings = {
  agentAssignedMessageDisabled: Scalars['Boolean']['input'];
  agentIssueClosedMessageDisabled: Scalars['Boolean']['input'];
  agentThreadMessageDisabled: Scalars['Boolean']['input'];
  areRequesterThreadRepliesPrivate: Scalars['Boolean']['input'];
  hideQueueDuringTicketCreation: Scalars['Boolean']['input'];
  jsmApproversEnabled: Scalars['Boolean']['input'];
  requesterIssueClosedMessageDisabled: Scalars['Boolean']['input'];
  requesterThreadMessageDisabled: Scalars['Boolean']['input'];
};

export type JsmChatWebAddConversationInteractionInput = {
  interactionType: JsmChatWebInteractionType;
  jiraFieldId?: InputMaybe<Scalars['String']['input']>;
  selectedValue: Scalars['String']['input'];
};

export enum JsmChatWebChannelExperienceId {
  Helpcenter = 'HELPCENTER'
}

export enum JsmChatWebConversationActions {
  CloseConversation = 'CLOSE_CONVERSATION',
  DisableInput = 'DISABLE_INPUT',
  GreetingMessage = 'GREETING_MESSAGE',
  RedirectToSearch = 'REDIRECT_TO_SEARCH'
}

export enum JsmChatWebConversationMessageContentType {
  Adf = 'ADF'
}

export enum JsmChatWebConversationUserRole {
  JsmAgent = 'JSM_Agent',
  Participant = 'Participant',
  Reporter = 'Reporter',
  VirtualAgent = 'VirtualAgent'
}

export enum JsmChatWebInteractionType {
  Buttons = 'BUTTONS',
  Dropdown = 'DROPDOWN',
  JiraField = 'JIRA_FIELD'
}

export type JsmConversationClaimConversationInput = {
  cloudId: Scalars['ID']['input'];
  conversationId: Scalars['ID']['input'];
};

export type JsmConversationCloseConversationInput = {
  channelId: Scalars['ID']['input'];
  cloudId: Scalars['ID']['input'];
};

export enum JsmConversationMessageSource {
  Agent = 'AGENT',
  Helpseeker = 'HELPSEEKER',
  System = 'SYSTEM'
}

export type JsmConversationSettingsInput = {
  projectAri?: InputMaybe<Scalars['String']['input']>;
  slaList?: InputMaybe<Array<JsmConversationSlaInput>>;
  teamId?: InputMaybe<Scalars['String']['input']>;
};

export type JsmConversationSlaInput = {
  slaDuration: Scalars['String']['input'];
  slaType: JsmConversationSlaType;
};

export enum JsmConversationSlaType {
  TimeToClaimConversation = 'TIME_TO_CLAIM_CONVERSATION',
  TimeToReplyAfterHsMessage = 'TIME_TO_REPLY_AFTER_HS_MESSAGE'
}

export enum JsmConversationStatus {
  /** Conversation breached because of SLA expiry */
  Breached = 'BREACHED',
  /** Chat is resolved and marked as closed */
  Closed = 'CLOSED',
  /** Conversation is currently assigned to an agent */
  InProgress = 'IN_PROGRESS',
  /** Conversation was not picked up by any agent */
  Missed = 'MISSED',
  /**
   * Same as UNASSIGNED, going to be removed in future
   * @deprecated use UNASSIGNED instead
   */
  Requested = 'REQUESTED',
  /** Conversation timed out due to inactivity */
  Timeout = 'TIMEOUT',
  /** Conversation is currently in unassigned state waiting to be picked up */
  Unassigned = 'UNASSIGNED'
}

export enum KitsuneComparisonOperator {
  Contains = 'CONTAINS',
  DoesNotContain = 'DOES_NOT_CONTAIN',
  Is = 'IS',
  IsBetween = 'IS_BETWEEN',
  IsEmpty = 'IS_EMPTY',
  IsFalse = 'IS_FALSE',
  IsGreaterThan = 'IS_GREATER_THAN',
  IsGreaterThanOrEqualTo = 'IS_GREATER_THAN_OR_EQUAL_TO',
  IsLowerThan = 'IS_LOWER_THAN',
  IsLowerThanOrEqualTo = 'IS_LOWER_THAN_OR_EQUAL_TO',
  IsNot = 'IS_NOT',
  IsNotEmpty = 'IS_NOT_EMPTY',
  IsTrue = 'IS_TRUE'
}

export enum KitsuneFieldType {
  Content = 'CONTENT',
  CreationDate = 'CREATION_DATE',
  Creator = 'CREATOR',
  Custom = 'CUSTOM',
  Customer = 'CUSTOMER',
  Reporter = 'REPORTER',
  SourceCategory = 'SOURCE_CATEGORY'
}

export type KitsuneFilterInput = {
  comparisonOperator: KitsuneComparisonOperator;
  fieldId: Scalars['ID']['input'];
  logicalOperator: KitsuneLogicalOperator;
  values: KitsuneFilterValueInput;
};

export type KitsuneFilterValueInput = {
  sourceCategoryId?: InputMaybe<Array<Scalars['ID']['input']>>;
  valueDate?: InputMaybe<Array<Scalars['Date']['input']>>;
  valueId?: InputMaybe<Array<Scalars['ID']['input']>>;
  valueNumber?: InputMaybe<Array<Scalars['Float']['input']>>;
  valueText?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum KitsuneLogicalOperator {
  And = 'AND',
  Or = 'OR'
}

export type KitsunePaginationInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export enum KitsuneSourceCategoryType {
  FeedbackApp = 'FEEDBACK_APP',
  Loom = 'LOOM'
}

export type KitsuneSourceInput = {
  sourceWeb?: InputMaybe<KitsuneSourceInputWeb>;
};

export type KitsuneSourceInputWeb = {
  url: Scalars['String']['input'];
};

export type KitsuneViewConfigInput = {
  filters: Array<KitsuneFilterInput>;
  logicalOperator: KitsuneLogicalOperator;
};

export enum KitsuneViewConfigStatus {
  Draft = 'DRAFT',
  Published = 'PUBLISHED',
  Saved = 'SAVED'
}

export enum KitsuneViewType {
  Dashboard = 'DASHBOARD',
  List = 'LIST',
  Table = 'TABLE'
}

export type KnowledgeBaseAgentArticleSearchInput = {
  /** cloud ID of the tenant */
  cloudId: Scalars['ID']['input'];
  /** cursor for the page */
  cursor?: InputMaybe<Scalars['String']['input']>;
  /** how many results to return */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** project ID to scope the search */
  projectIdentifier: Scalars['String']['input'];
  /** Filter for search */
  searchFilters?: InputMaybe<KnowledgeBaseSearchFiltersInput>;
  /** search query term */
  searchQuery?: InputMaybe<Scalars['String']['input']>;
  shouldFetchCategories?: InputMaybe<Scalars['Boolean']['input']>;
  /** field / key based on which the search results are sorted */
  sortByKey?: InputMaybe<KnowledgeBaseArticleSearchSortByKey>;
  /** ASC or DESC */
  sortOrder?: InputMaybe<KnowledgeBaseArticleSearchSortOrder>;
};

export type KnowledgeBaseArticleSearchInput = {
  /** containers to search articles from. For eg. Confluence space, gdrive folder, etc. */
  articleContainers?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** cloud ID of the tenant */
  cloudId: Scalars['ID']['input'];
  /** cursor for pagination */
  cursor?: InputMaybe<Scalars['String']['input']>;
  /** how many results to return. Default and Maximum value is 25 */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** project ID to scope the search */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** search query term */
  searchQuery?: InputMaybe<Scalars['String']['input']>;
  /** field / key based on which the search results are sorted */
  sortByKey?: InputMaybe<KnowledgeBaseArticleSearchSortByKey>;
  /** ASC or DESC */
  sortOrder?: InputMaybe<KnowledgeBaseArticleSearchSortOrder>;
  /** when set, only sources with this visibility will be considered in article search results */
  sourceVisibility?: InputMaybe<Scalars['String']['input']>;
};

export enum KnowledgeBaseArticleSearchSortByKey {
  LastModified = 'LAST_MODIFIED',
  Title = 'TITLE'
}

export enum KnowledgeBaseArticleSearchSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type KnowledgeBasePermissionUpdateRequest = {
  sourceARI?: InputMaybe<Scalars['ID']['input']>;
  sourceVisibility?: InputMaybe<Scalars['String']['input']>;
  viewPermission?: InputMaybe<Scalars['String']['input']>;
};

export type KnowledgeBaseSearchFiltersInput = {
  /** Filter the confluence sites and third parties */
  sourceContainers?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter the type of KB source visibility */
  sourceVisibility?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter the spaces(Confluence) and folders(3P) */
  sources?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type KnowledgeBaseSourceInput = {
  metadata?: InputMaybe<KnowledgeBaseSourceMetadataInput>;
  sourceARI?: InputMaybe<Scalars['ID']['input']>;
  sourceContainerARI?: InputMaybe<Scalars['ID']['input']>;
  visibility?: InputMaybe<Scalars['String']['input']>;
};

export type KnowledgeBaseSourceMetadataInput = {
  applicationIdentifier?: InputMaybe<Scalars['String']['input']>;
};

export enum KnowledgeBaseSpacePermissionType {
  /**  Permission for anonymous users (view only)  */
  AnonymousUsers = 'ANONYMOUS_USERS',
  /**  Permission for Confluence licensed users  */
  ConfluenceLicensedUsers = 'CONFLUENCE_LICENSED_USERS',
  /**  Permission for Confluence unlicensed users  */
  ConfluenceUnlicensedUsers = 'CONFLUENCE_UNLICENSED_USERS'
}

export type KnowledgeBaseSpacePermissionUpdateViewInput = {
  /**  The space ARI  */
  spaceAri: Scalars['ID']['input'];
  /**  The new view permission  */
  viewPermission?: InputMaybe<KnowledgeBaseSpacePermissionType>;
};

export type KnowledgeBaseSuggestionFilters = {
  query?: InputMaybe<Scalars['String']['input']>;
  sourceSystemCloudId?: InputMaybe<Scalars['ID']['input']>;
  sourceType?: InputMaybe<Scalars['String']['input']>;
  sourceVisibility?: InputMaybe<Scalars['String']['input']>;
};

export type KnowledgeBaseUnlinkSourceInput = {
  linkedSourceId?: InputMaybe<Scalars['ID']['input']>;
  sourceARI?: InputMaybe<Scalars['ID']['input']>;
  visibility?: InputMaybe<Scalars['String']['input']>;
};

export type KnowledgeDiscoveryApproveAdminhubBookmarkSuggestionInput = {
  bookmarkAdminhubId: Scalars['ID']['input'];
  cloudId: Scalars['ID']['input'];
  orgId: Scalars['String']['input'];
};

export enum KnowledgeDiscoveryBookmarkState {
  Active = 'ACTIVE',
  Suggested = 'SUGGESTED'
}

export type KnowledgeDiscoveryCreateAdminhubBookmarkInput = {
  cloudId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  keyPhrases?: InputMaybe<Array<Scalars['String']['input']>>;
  orgId: Scalars['String']['input'];
  title: Scalars['String']['input'];
  url: Scalars['String']['input'];
};

export type KnowledgeDiscoveryCreateAdminhubBookmarksInput = {
  bookmarks?: InputMaybe<Array<KnowledgeDiscoveryCreateAdminhubBookmarkInput>>;
  cloudId: Scalars['ID']['input'];
  orgId: Scalars['String']['input'];
};

export type KnowledgeDiscoveryCreateDefinitionInput = {
  definition: Scalars['String']['input'];
  entityIdInScope: Scalars['String']['input'];
  keyPhrase: Scalars['String']['input'];
  referenceContentId?: InputMaybe<Scalars['String']['input']>;
  referenceUrl?: InputMaybe<Scalars['String']['input']>;
  scope: KnowledgeDiscoveryDefinitionScope;
  workspaceId: Scalars['String']['input'];
};

export enum KnowledgeDiscoveryDefinitionScope {
  Blogpost = 'BLOGPOST',
  Goal = 'GOAL',
  Organization = 'ORGANIZATION',
  Page = 'PAGE',
  Project = 'PROJECT',
  Space = 'SPACE'
}

export type KnowledgeDiscoveryDefinitionScopeIdConfluence = {
  contentId?: InputMaybe<Scalars['String']['input']>;
  spaceId?: InputMaybe<Scalars['String']['input']>;
};

export type KnowledgeDiscoveryDefinitionScopeIdJira = {
  projectId?: InputMaybe<Scalars['String']['input']>;
};

export type KnowledgeDiscoveryDeleteBookmarkInput = {
  bookmarkAdminhubId: Scalars['ID']['input'];
  keyPhrases?: InputMaybe<Array<Scalars['String']['input']>>;
  url: Scalars['String']['input'];
};

export type KnowledgeDiscoveryDeleteBookmarksInput = {
  cloudId: Scalars['ID']['input'];
  deleteRequests?: InputMaybe<Array<KnowledgeDiscoveryDeleteBookmarkInput>>;
  orgId: Scalars['ID']['input'];
};

export enum KnowledgeDiscoveryDetectionType {
  Bookmark = 'BOOKMARK',
  ContentNav = 'CONTENT_NAV',
  EntityRecognition = 'ENTITY_RECOGNITION',
  Heuristic = 'HEURISTIC',
  Llm = 'LLM',
  None = 'NONE',
  Slm = 'SLM'
}

export type KnowledgeDiscoveryDismissAdminhubBookmarkSuggestionInput = {
  bookmarkAdminhubId: Scalars['ID']['input'];
  cloudId: Scalars['ID']['input'];
  orgId: Scalars['String']['input'];
};

export enum KnowledgeDiscoveryEntityType {
  ConfluenceBlogpost = 'CONFLUENCE_BLOGPOST',
  ConfluenceDocument = 'CONFLUENCE_DOCUMENT',
  ConfluencePage = 'CONFLUENCE_PAGE',
  ConfluenceSpace = 'CONFLUENCE_SPACE',
  JiraProject = 'JIRA_PROJECT',
  KeyPhrase = 'KEY_PHRASE',
  Topic = 'TOPIC',
  User = 'USER'
}

export enum KnowledgeDiscoveryJiraIntentDetectionModel {
  FpsHeuristic = 'FPS_HEURISTIC',
  GninHeuristic = 'GNIN_HEURISTIC'
}

export enum KnowledgeDiscoveryJiraSearchClassificationType {
  Fps = 'FPS',
  Gnin = 'GNIN'
}

/**  Start Jira intent detection types */
export enum KnowledgeDiscoveryJiraSearchExperience {
  QuickFind = 'QUICK_FIND'
}

export enum KnowledgeDiscoveryKeyPhraseCategory {
  Acronym = 'ACRONYM',
  Auto = 'AUTO',
  Other = 'OTHER',
  Project = 'PROJECT',
  Team = 'TEAM'
}

export type KnowledgeDiscoveryKeyPhraseInputText = {
  format: KnowledgeDiscoveryKeyPhraseInputTextFormat;
  text: Scalars['String']['input'];
};

export enum KnowledgeDiscoveryKeyPhraseInputTextFormat {
  Adf = 'ADF',
  Plain = 'PLAIN'
}

export type KnowledgeDiscoveryMarkZeroQueryInteractedInput = {
  cloudId: Scalars['String']['input'];
  product?: InputMaybe<KnowledgeDiscoveryProduct>;
  query: Scalars['String']['input'];
};

export type KnowledgeDiscoveryMetadata = {
  numberOfRecentDocuments?: InputMaybe<Scalars['Int']['input']>;
};

export enum KnowledgeDiscoveryProduct {
  Confluence = 'CONFLUENCE',
  Google = 'GOOGLE',
  Jira = 'JIRA',
  Sharepoint = 'SHAREPOINT',
  Slack = 'SLACK'
}

export enum KnowledgeDiscoveryQueryClassification {
  Bookmark = 'BOOKMARK',
  JiraNaturalLanguageQuery = 'JIRA_NATURAL_LANGUAGE_QUERY',
  JobTitle = 'JOB_TITLE',
  KeywordOrAcronym = 'KEYWORD_OR_ACRONYM',
  NaturalLanguageQuery = 'NATURAL_LANGUAGE_QUERY',
  Navigational = 'NAVIGATIONAL',
  NavContent = 'NAV_CONTENT',
  None = 'NONE',
  OrgChart = 'ORG_CHART',
  Person = 'PERSON',
  Team = 'TEAM',
  Topic = 'TOPIC'
}

export enum KnowledgeDiscoveryQuerySubType {
  Command = 'COMMAND',
  Confluence = 'CONFLUENCE',
  Evaluate = 'EVALUATE',
  Jira = 'JIRA',
  JobTitle = 'JOB_TITLE',
  Llm = 'LLM',
  Question = 'QUESTION'
}

export enum KnowledgeDiscoveryQuerySuggestionType {
  AssignedItems = 'ASSIGNED_ITEMS',
  TicketAssignee = 'TICKET_ASSIGNEE',
  TicketDueDate = 'TICKET_DUE_DATE',
  TicketStatus = 'TICKET_STATUS'
}

export type KnowledgeDiscoveryRelatedEntityAction = {
  action?: InputMaybe<KnowledgeDiscoveryRelatedEntityActionType>;
  relatedEntityId: Scalars['ID']['input'];
};

export enum KnowledgeDiscoveryRelatedEntityActionType {
  Delete = 'DELETE',
  Persist = 'PERSIST'
}

export type KnowledgeDiscoveryRelatedEntityRequest = {
  count: Scalars['Int']['input'];
  entityType: KnowledgeDiscoveryEntityType;
};

export type KnowledgeDiscoveryRelatedEntityRequests = {
  requests?: InputMaybe<Array<KnowledgeDiscoveryRelatedEntityRequest>>;
};

export type KnowledgeDiscoveryScopeInput = {
  entityIdInScope: Scalars['String']['input'];
  scope: KnowledgeDiscoveryDefinitionScope;
};

export enum KnowledgeDiscoverySearchQueryClassification {
  JiraNaturalLanguageQuery = 'JIRA_NATURAL_LANGUAGE_QUERY',
  KeywordOrAcronym = 'KEYWORD_OR_ACRONYM',
  NaturalLanguageQuery = 'NATURAL_LANGUAGE_QUERY',
  Navigational = 'NAVIGATIONAL',
  None = 'NONE',
  OrgChart = 'ORG_CHART',
  Person = 'PERSON',
  Team = 'TEAM',
  Topic = 'TOPIC'
}

export enum KnowledgeDiscoverySearchQueryClassificationSubtype {
  Command = 'COMMAND',
  Confluence = 'CONFLUENCE',
  Evaluate = 'EVALUATE',
  Jira = 'JIRA',
  JobTitle = 'JOB_TITLE',
  Llm = 'LLM',
  Question = 'QUESTION'
}

export enum KnowledgeDiscoveryTopicType {
  Area = 'AREA',
  Company = 'COMPANY',
  Event = 'EVENT',
  Process = 'PROCESS',
  Program = 'PROGRAM',
  Team = 'TEAM'
}

export type KnowledgeDiscoveryUpdateAdminhubBookmarkInput = {
  bookmarkAdminhubId: Scalars['ID']['input'];
  cloudId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  keyPhrases?: InputMaybe<Array<Scalars['String']['input']>>;
  orgId: Scalars['String']['input'];
  title: Scalars['String']['input'];
  url: Scalars['String']['input'];
};

export type KnowledgeDiscoveryUpdateRelatedEntitiesInput = {
  actions?: InputMaybe<Array<InputMaybe<KnowledgeDiscoveryRelatedEntityAction>>>;
  cloudId?: InputMaybe<Scalars['String']['input']>;
  entity: Scalars['ID']['input'];
  entityType: KnowledgeDiscoveryEntityType;
  relatedEntityType: KnowledgeDiscoveryEntityType;
  workspaceId?: InputMaybe<Scalars['String']['input']>;
};

export type KnowledgeDiscoveryUpdateUserKeyPhraseInteractionInput = {
  isDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  keyPhrase: Scalars['String']['input'];
  workspaceId: Scalars['String']['input'];
};

export enum KnowledgeDiscoveryZeroQueryDateRange {
  Past_7Days = 'PAST_7_DAYS',
  Past_30Days = 'PAST_30_DAYS',
  Today = 'TODAY',
  Yesterday = 'YESTERDAY'
}

export enum KnowledgeDiscoveryZeroQueryType {
  CollaboratorProfile = 'COLLABORATOR_PROFILE',
  ConfluencePagesCreated = 'CONFLUENCE_PAGES_CREATED',
  ConfluencePagesCreated_7Days = 'CONFLUENCE_PAGES_CREATED_7_DAYS',
  ConfluencePagesCreated_30Days = 'CONFLUENCE_PAGES_CREATED_30_DAYS',
  ConfluencePagesCreatedCollaborator = 'CONFLUENCE_PAGES_CREATED_COLLABORATOR',
  ConfluencePagesCreatedCollaborator_7Days = 'CONFLUENCE_PAGES_CREATED_COLLABORATOR_7_DAYS',
  ConfluencePagesCreatedCollaborator_30Days = 'CONFLUENCE_PAGES_CREATED_COLLABORATOR_30_DAYS',
  JiraAssignedCollaboratorInProject = 'JIRA_ASSIGNED_COLLABORATOR_IN_PROJECT',
  JiraMyWorkItems = 'JIRA_MY_WORK_ITEMS',
  JiraNlq = 'JIRA_NLQ',
  JiraNlqCollaborator = 'JIRA_NLQ_COLLABORATOR',
  JiraTicketsAssigned = 'JIRA_TICKETS_ASSIGNED',
  JiraTicketsAssignedCollaborator = 'JIRA_TICKETS_ASSIGNED_COLLABORATOR',
  JiraTicketsCreated = 'JIRA_TICKETS_CREATED',
  JiraTicketsCreatedCollaborator = 'JIRA_TICKETS_CREATED_COLLABORATOR',
  RelatedQuestion = 'RELATED_QUESTION',
  ThirdPartyGoogleCollaboratorDocs = 'THIRD_PARTY_GOOGLE_COLLABORATOR_DOCS',
  ThirdPartyGoogleMyDocs = 'THIRD_PARTY_GOOGLE_MY_DOCS',
  ThirdPartySharepointCollaboratorDocs = 'THIRD_PARTY_SHAREPOINT_COLLABORATOR_DOCS',
  ThirdPartySharepointMyDocs = 'THIRD_PARTY_SHAREPOINT_MY_DOCS',
  ThirdPartySlackCollaboratorMessages = 'THIRD_PARTY_SLACK_COLLABORATOR_MESSAGES',
  ThirdPartySlackMyMessages = 'THIRD_PARTY_SLACK_MY_MESSAGES',
  WhoIs = 'WHO_IS'
}

export enum KnowledgeGraphContentType {
  Blogpost = 'BLOGPOST',
  Page = 'PAGE'
}

export enum KnowledgeGraphObjectType {
  SnippetV1 = 'snippet_v1',
  SnippetV2 = 'snippet_v2',
  SnippetV2_180 = 'snippet_v2_180'
}

export type LabelInput = {
  name: Scalars['String']['input'];
  prefix: Scalars['String']['input'];
};

export type LabelSort = {
  direction: GraphQlLabelSortDirection;
  sortField: GraphQlLabelSortField;
};

export enum LicenseOverrideState {
  Active = 'ACTIVE',
  Advanced = 'ADVANCED',
  Inactive = 'INACTIVE',
  Standard = 'STANDARD',
  Trial = 'TRIAL'
}

export enum LicenseStatus {
  Active = 'ACTIVE',
  Suspended = 'SUSPENDED',
  Unlicensed = 'UNLICENSED'
}

/** enum of licenseState and edition */
export enum LicenseValue {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  Trial = 'TRIAL'
}

/**
 * See https://developer.atlassian.com/platform/graphql-gateway/schemas/lifecycle-support/#lifecycle-stages for more
 * information on how to use these stages and what they mean in detail.
 * | Lifecycle            | Visible in Prod | Needs `@optIn` directive |                     Allow third parties                       |
 * |----------------------|:---------------:|:------------------------:|:-------------------------------------------------------------:|
 * | STAGING              |       No        |            No            | By default no. Can enable via `allowThirdParties` directive   |
 * | EXPERIMENTAL         |       Yes       |           Yes            | By default no. Can enable via `allowThirdParties` directive   |
 * | BETA                 |       Yes       |           Yes            |                       Always                                  |
 * | PRODUCTION (default) |       Yes       |            No            |                       Always                                  |
 */
export enum LifecycleStage {
  Beta = 'BETA',
  Experimental = 'EXPERIMENTAL',
  Production = 'PRODUCTION',
  Staging = 'STAGING'
}

export type LikeContentInput = {
  contentId: Scalars['ID']['input'];
};

/**  LiveChatUserMessage Input */
export type LiveChatSendUserMessageInput = {
  chatAri: Scalars['ID']['input'];
  content: Scalars['String']['input'];
};

export type LocalStorageBooleanPairInput = {
  key: Scalars['String']['input'];
  value?: InputMaybe<Scalars['Boolean']['input']>;
};

export type LocalStorageInput = {
  booleanValues?: InputMaybe<Array<InputMaybe<LocalStorageBooleanPairInput>>>;
  stringValues?: InputMaybe<Array<InputMaybe<LocalStorageStringPairInput>>>;
};

export type LocalStorageStringPairInput = {
  key: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

/** The input for choosing invocations of interest. */
export type LogQueryInput = {
  /**
   * Limits the search to a particular version of the app.
   * Optional: if empty will search all versions of the app
   */
  appVersion?: InputMaybe<Scalars['String']['input']>;
  /**
   * Limits the search to a list of versions of the app.
   * Optional: if empty will search all versions of the app
   */
  appVersions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Filters logs by container name. Use `containers` field instead. */
  container?: InputMaybe<Scalars['String']['input']>;
  /**
   * Filters logs by container name.
   * Optional: if empty then look for all the logs
   */
  containers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Filters logs by products.
   * Optional: if empty then look for all the logs
   */
  contexts?: InputMaybe<Array<InputMaybe<Context>>>;
  /**
   * Limits the search to a particular date range.
   *
   * Note: Logs may have a TTL on them so older logs may not be available
   * despite search parameters.
   */
  dates?: InputMaybe<DateSearchInput>;
  /**
   * Filters logs by edition.
   * Optional: if empty will search all editions types.
   */
  editions?: InputMaybe<Array<InputMaybe<EditionValue>>>;
  /**
   * Limits the search to a particular function in the app.
   * Optional: if empty will search all functions.
   */
  functionKey?: InputMaybe<Scalars['String']['input']>;
  /**
   * Limits the search to a particular functionKeys of the app.
   * Optional: if empty will search all functionKeys of the app
   */
  functionKeys?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Specify which installations you want to search.
   * Optional: if empty will search all installations user has access to.
   */
  installationContexts?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filters logs by container instance. Use `instances` field instead. */
  instance?: InputMaybe<Scalars['String']['input']>;
  /**
   * Filters logs by container instance.
   * Optional: if empty then look for all the logs
   */
  instances?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Filters logs by a specific invocation ID.
   * Optional: if empty will search all invocation IDs.
   */
  invocationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Filters logs by license state.
   * Optional: if empty will search all licenseState types.
   */
  licenseStates?: InputMaybe<Array<InputMaybe<LicenseValue>>>;
  /**
   * Limits the search to a particular log level type of message.
   * Optional: if empty will search all log levels
   */
  lvl?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Filters logs by module type.
   * Optional: if empty will search all module types.
   */
  moduleType?: InputMaybe<Scalars['String']['input']>;
  /**
   * Searches all logs matching the search input from user.
   * Optional: if empty will search all logs
   */
  msg?: InputMaybe<Scalars['String']['input']>;
  /**
   * Filters logs by runtime (node runtime, containers, etc)
   * Optional: if empty will search all runtimes.
   */
  runtime?: InputMaybe<Scalars['String']['input']>;
  /** Filters logs by container service. Use `services` field instead. */
  service?: InputMaybe<Scalars['String']['input']>;
  /**
   * Filters logs by container service.
   * Optional: if empty then look for all the logs
   */
  services?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Filters logs by a specific trace ID.
   * Optional: if empty will search all trace IDs.
   */
  traceId?: InputMaybe<Scalars['String']['input']>;
};

export enum LoomMeetingSource {
  GoogleCalendar = 'GOOGLE_CALENDAR',
  MicrosoftOutlook = 'MICROSOFT_OUTLOOK',
  Zoom = 'ZOOM'
}

export enum LoomPhraseRangeType {
  Punct = 'punct',
  Text = 'text'
}

export enum LoomSpacePrivacyType {
  Private = 'private',
  Workspace = 'workspace'
}

/**  Reflects TranscriptLanguage type in projects/libraries/shared-utilities/src/types/transcription.ts */
export enum LoomTranscriptLanguage {
  Af = 'af',
  Am = 'am',
  As = 'as',
  Ba = 'ba',
  Be = 'be',
  Bg = 'bg',
  Bn = 'bn',
  Bo = 'bo',
  Br = 'br',
  Bs = 'bs',
  Ca = 'ca',
  Cs = 'cs',
  Cy = 'cy',
  Da = 'da',
  De = 'de',
  El = 'el',
  En = 'en',
  Es = 'es',
  Et = 'et',
  Eu = 'eu',
  Fi = 'fi',
  Fo = 'fo',
  Fr = 'fr',
  Gl = 'gl',
  Gu = 'gu',
  Ha = 'ha',
  Haw = 'haw',
  Hi = 'hi',
  Hr = 'hr',
  Ht = 'ht',
  Hu = 'hu',
  Hy = 'hy',
  Id = 'id',
  Is = 'is',
  It = 'it',
  Ja = 'ja',
  Jw = 'jw',
  Ka = 'ka',
  Kk = 'kk',
  Km = 'km',
  Kn = 'kn',
  Ko = 'ko',
  La = 'la',
  Lb = 'lb',
  Ln = 'ln',
  Lo = 'lo',
  Lt = 'lt',
  Lv = 'lv',
  Mg = 'mg',
  Mi = 'mi',
  Mk = 'mk',
  Ml = 'ml',
  Mn = 'mn',
  Mr = 'mr',
  Ms = 'ms',
  Mt = 'mt',
  My = 'my',
  Ne = 'ne',
  Nl = 'nl',
  Nn = 'nn',
  No = 'no',
  Oc = 'oc',
  Pa = 'pa',
  Pl = 'pl',
  Ps = 'ps',
  Pt = 'pt',
  Ro = 'ro',
  Ru = 'ru',
  Sa = 'sa',
  Sd = 'sd',
  Si = 'si',
  Sk = 'sk',
  Sl = 'sl',
  Sn = 'sn',
  So = 'so',
  Sq = 'sq',
  Sr = 'sr',
  Su = 'su',
  Sv = 'sv',
  Sw = 'sw',
  Ta = 'ta',
  Te = 'te',
  Tg = 'tg',
  Th = 'th',
  Tk = 'tk',
  Tl = 'tl',
  Tr = 'tr',
  Tt = 'tt',
  Uk = 'uk',
  Unknown = 'unknown',
  Uz = 'uz',
  Vi = 'vi',
  Yi = 'yi',
  Yo = 'yo',
  Zh = 'zh'
}

export enum LoomUserStatus {
  Linked = 'LINKED',
  LinkedEnterprise = 'LINKED_ENTERPRISE',
  Mastered = 'MASTERED',
  NotFound = 'NOT_FOUND'
}

export type LpCertSort = {
  sortDirection?: InputMaybe<SortDirection>;
  sortField?: InputMaybe<LpCertSortField>;
};

export enum LpCertSortField {
  ActiveDate = 'ACTIVE_DATE',
  ExpireDate = 'EXPIRE_DATE',
  Id = 'ID',
  ImageUrl = 'IMAGE_URL',
  Name = 'NAME',
  NameAbbr = 'NAME_ABBR',
  PublicUrl = 'PUBLIC_URL',
  Status = 'STATUS',
  Type = 'TYPE'
}

export enum LpCertStatus {
  Active = 'ACTIVE',
  Expired = 'EXPIRED'
}

export enum LpCertType {
  Badge = 'BADGE',
  Certification = 'CERTIFICATION',
  Standing = 'STANDING'
}

export type LpCourseSort = {
  sortDirection?: InputMaybe<SortDirection>;
  sortField?: InputMaybe<LpCourseSortField>;
};

export enum LpCourseSortField {
  CompletedDate = 'COMPLETED_DATE',
  CourseId = 'COURSE_ID',
  Id = 'ID',
  Status = 'STATUS',
  Title = 'TITLE',
  Url = 'URL'
}

export enum LpCourseStatus {
  Completed = 'COMPLETED',
  InProgress = 'IN_PROGRESS'
}

export enum MacroRendererMode {
  Editor = 'EDITOR',
  Pdf = 'PDF',
  Renderer = 'RENDERER'
}

export type Mark = {
  attrs?: InputMaybe<MarkAttribute>;
  type: Scalars['String']['input'];
};

export type MarkAttribute = {
  annotationType: Scalars['String']['input'];
  id: Scalars['String']['input'];
};

export type MarkCommentsAsReadInput = {
  commentIds: Array<Scalars['ID']['input']>;
};

/** Payment model for integrating an app with an Atlassian product. */
export enum MarketplaceAppPaymentModel {
  Free = 'FREE',
  PaidViaAtlassian = 'PAID_VIA_ATLASSIAN',
  PaidViaPartner = 'PAID_VIA_PARTNER'
}

export type MarketplaceAppVersionFilter = {
  /** Unique id of Cloud App's version */
  cloudAppVersionId?: InputMaybe<Scalars['ID']['input']>;
  /** Compliance boundaries available for a version */
  cloudComplianceBoundary?: InputMaybe<Array<InputMaybe<ComplianceBoundary>>>;
  /** Excludes hidden versions as per Marketplace */
  excludeHiddenIn?: InputMaybe<MarketplaceLocation>;
  /** Options of Atlassian product instance hosting types for which app versions are available. */
  productHostingOptions?: InputMaybe<Array<AtlassianProductHostingType>>;
  /** Visibility of the version. */
  visibility?: InputMaybe<MarketplaceAppVersionVisibility>;
};

/** Visibility of the Marketplace app's version */
export enum MarketplaceAppVersionVisibility {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

/** Filters to apply when querying for my apps. */
export type MarketplaceAppsFilter = {
  /** The apps' status in the Cloud Fortified program */
  cloudFortifiedStatus?: InputMaybe<Array<MarketplaceProgramStatus>>;
  /** Includes private apps or versions if you are authorized to see them */
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  /** Options of Atlassian product instance hosting types for which app versions are available. */
  productHostingOptions?: InputMaybe<Array<AtlassianProductHostingType>>;
};

/** Billing cycle for which pricing plan applies */
export enum MarketplaceBillingCycle {
  Annual = 'ANNUAL',
  Monthly = 'MONTHLY'
}

export enum MarketplaceCloudFortifiedStatus {
  Applied = 'APPLIED',
  Approved = 'APPROVED',
  NotAParticipant = 'NOT_A_PARTICIPANT',
  Rejected = 'REJECTED'
}

export enum MarketplaceConsoleAsvlLegacyVersionApprovalStatus {
  Approved = 'APPROVED',
  Archived = 'ARCHIVED',
  Deleted = 'DELETED',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED',
  Uninitiated = 'UNINITIATED'
}

export enum MarketplaceConsoleAsvlLegacyVersionStatus {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

/**  --------------------------------------------------------------------------------------------- */
export type MarketplaceConsoleAppInput = {
  appKey: Scalars['ID']['input'];
  appName: Scalars['String']['input'];
  cloudComplianceBoundaries?: InputMaybe<Array<MarketplaceConsoleCloudComplianceBoundary>>;
  developerId?: InputMaybe<Scalars['ID']['input']>;
  marketingLabels?: InputMaybe<Array<Scalars['String']['input']>>;
  onDemandPaymentModel?: InputMaybe<MarketplaceConsolePaymentModel>;
  vendorId?: InputMaybe<Scalars['Int']['input']>;
  vendorLinks?: InputMaybe<MarketplaceConsoleAppVendorLinksInput>;
  version: MarketplaceConsoleAppVersionCreateRequestInput;
};

export type MarketplaceConsoleAppSoftwareVersionCompatibilityInput = {
  hosting: MarketplaceConsoleHosting;
  maxBuildNumber?: InputMaybe<Scalars['String']['input']>;
  minBuildNumber?: InputMaybe<Scalars['String']['input']>;
  parentSoftwareId: Scalars['ID']['input'];
};

export type MarketplaceConsoleAppSoftwareVersionFrameworkDetailsInput = {
  attributes: MarketplaceConsoleFrameworkAttributesInput;
  frameworkId: Scalars['ID']['input'];
};

/**
 * Unified input type for creating app software versions.
 * Handles both private and public version creation for cloud.
 */
export type MarketplaceConsoleAppSoftwareVersionInput = {
  bonTermsSupported?: InputMaybe<Scalars['Boolean']['input']>;
  /** Core Version Creation Fields */
  buildNumber?: InputMaybe<Scalars['String']['input']>;
  communityEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  compatibilities: Array<MarketplaceConsoleAppSoftwareVersionCompatibilityInput>;
  deploymentInstructions?: InputMaybe<Array<MarketplaceConsoleDeploymentInstructionInput>>;
  documentationUrl?: InputMaybe<Scalars['String']['input']>;
  editionDetails?: InputMaybe<MarketplaceConsoleEditionDetailsInput>;
  eulaUrl?: InputMaybe<Scalars['String']['input']>;
  frameworkDetails: MarketplaceConsoleAppSoftwareVersionFrameworkDetailsInput;
  heroImageUrl?: InputMaybe<Scalars['String']['input']>;
  highlights?: InputMaybe<Array<MarketplaceConsoleListingHighLightInput>>;
  isBeta?: InputMaybe<Scalars['Boolean']['input']>;
  isSupported?: InputMaybe<Scalars['Boolean']['input']>;
  learnMoreUrl?: InputMaybe<Scalars['String']['input']>;
  licenseType?: InputMaybe<MarketplaceConsoleAppSoftwareVersionLicenseTypeId>;
  moreDetails?: InputMaybe<Scalars['String']['input']>;
  /** Listing/Product Fields (used for public versions) */
  name?: InputMaybe<Scalars['String']['input']>;
  partnerSpecificTerms?: InputMaybe<Scalars['String']['input']>;
  paymentModel?: InputMaybe<MarketplaceConsolePaymentModel>;
  productId?: InputMaybe<Scalars['String']['input']>;
  purchaseUrl?: InputMaybe<Scalars['String']['input']>;
  releaseNotes?: InputMaybe<Scalars['String']['input']>;
  releaseSummary?: InputMaybe<Scalars['String']['input']>;
  screenshots?: InputMaybe<Array<MarketplaceConsoleListingScreenshotInput>>;
  sourceCodeLicenseUrl?: InputMaybe<Scalars['String']['input']>;
  status: MarketplaceConsoleVersionType;
  versionNumber?: InputMaybe<Scalars['String']['input']>;
  youtubeId?: InputMaybe<Scalars['String']['input']>;
};

export enum MarketplaceConsoleAppSoftwareVersionLicenseTypeId {
  Asl = 'ASL',
  AtlassianClosedSource = 'ATLASSIAN_CLOSED_SOURCE',
  Bsd = 'BSD',
  Commercial = 'COMMERCIAL',
  CommercialFree = 'COMMERCIAL_FREE',
  Epl = 'EPL',
  Gpl = 'GPL',
  Lgpl = 'LGPL'
}

export enum MarketplaceConsoleAppSoftwareVersionState {
  Active = 'ACTIVE',
  Approved = 'APPROVED',
  Archived = 'ARCHIVED',
  AutoApproved = 'AUTO_APPROVED',
  Draft = 'DRAFT',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED'
}

export type MarketplaceConsoleAppVendorLinksInput = {
  appStatusPage?: InputMaybe<Scalars['String']['input']>;
  forums?: InputMaybe<Scalars['String']['input']>;
  issueTracker?: InputMaybe<Scalars['String']['input']>;
  privacy?: InputMaybe<Scalars['String']['input']>;
  supportTicketSystem?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleAppVersionCreateRequestInput = {
  assets?: InputMaybe<MarketplaceConsoleCreateVersionAssetsInput>;
  buildNumber?: InputMaybe<Scalars['String']['input']>;
  compatibilities: Array<MarketplaceConsoleAppSoftwareVersionCompatibilityInput>;
  dcBuildNumber?: InputMaybe<Scalars['String']['input']>;
  editionDetails?: InputMaybe<MarketplaceConsoleEditionDetailsInput>;
  frameworkDetails: MarketplaceConsoleAppSoftwareVersionFrameworkDetailsInput;
  paymentModel?: InputMaybe<MarketplaceConsolePaymentModel>;
  versionNumber?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleAppVersionDeleteRequestInput = {
  appKey?: InputMaybe<Scalars['ID']['input']>;
  appSoftwareId?: InputMaybe<Scalars['ID']['input']>;
  buildNumber: Scalars['ID']['input'];
};

export type MarketplaceConsoleArchiveAppRequest = {
  appKey: Scalars['ID']['input'];
};

export enum MarketplaceConsoleBankAccountType {
  Cacc = 'CACC',
  Moma = 'MOMA',
  Other = 'OTHER',
  Svgs = 'SVGS'
}

export type MarketplaceConsoleBankDetailsInput = {
  accountName: Scalars['String']['input'];
  accountNumber: Scalars['String']['input'];
  bankAccountType?: InputMaybe<MarketplaceConsoleBankAccountType>;
  bankAddress?: InputMaybe<Scalars['String']['input']>;
  bankCity: Scalars['String']['input'];
  bankCountryCode: Scalars['String']['input'];
  bankName: Scalars['String']['input'];
  bankPostCode?: InputMaybe<Scalars['String']['input']>;
  bankState?: InputMaybe<Scalars['String']['input']>;
  intermediaryBankId?: InputMaybe<Scalars['String']['input']>;
  intermediaryBankName?: InputMaybe<Scalars['String']['input']>;
  localBankId?: InputMaybe<Scalars['String']['input']>;
  routingNumber?: InputMaybe<Scalars['String']['input']>;
  specialHandlingNotes?: InputMaybe<Scalars['String']['input']>;
  swiftCode?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleBillingAddressInput = {
  city: Scalars['String']['input'];
  country: Scalars['String']['input'];
  line1: Scalars['String']['input'];
  line2?: InputMaybe<Scalars['String']['input']>;
  postcode: Scalars['String']['input'];
  state: Scalars['String']['input'];
};

export type MarketplaceConsoleBillingContactInput = {
  emailId: Scalars['String']['input'];
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  phoneNumber: Scalars['String']['input'];
};

export type MarketplaceConsoleCanMakeServerVersionPublicInput = {
  dcAppSoftwareId?: InputMaybe<Scalars['ID']['input']>;
  serverAppSoftwareId: Scalars['ID']['input'];
  userKey?: InputMaybe<Scalars['ID']['input']>;
  versionNumber: Scalars['ID']['input'];
};

export enum MarketplaceConsoleCloudComplianceBoundary {
  Commercial = 'COMMERCIAL',
  FedrampModerate = 'FEDRAMP_MODERATE',
  IsolatedCloud = 'ISOLATED_CLOUD'
}

export type MarketplaceConsoleConnectFrameworkAttributesInput = {
  href: Scalars['String']['input'];
};

export type MarketplaceConsoleCreateMakerInput = {
  developerSpaceListing: MarketplaceConsoleDevSpaceListingInput;
  makerName: Scalars['String']['input'];
};

export type MarketplaceConsoleCreateVersionAssetsInput = {
  highlights?: InputMaybe<Array<MarketplaceConsoleHighlightAssetInput>>;
  screenshots?: InputMaybe<Array<MarketplaceConsoleImageAssetInput>>;
};

/**  --------------------------------------------------------------------------------------------- */
export type MarketplaceConsoleDefaultEditionEnrolledInput = {
  appKey?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleDeleteAppRequest = {
  appKey: Scalars['ID']['input'];
};

export type MarketplaceConsoleDeploymentInstructionInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  screenshotImageUrl?: InputMaybe<Scalars['String']['input']>;
};

/**  eslint-disable-next-line @graphql-eslint/strict-id-in-types -- id is not required */
export type MarketplaceConsoleDevSpaceContactInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  homePageUrl?: InputMaybe<Scalars['String']['input']>;
  otherContactDetails?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  postCode?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleDevSpaceListingInput = {
  contactDetails: MarketplaceConsoleDevSpaceContactInput;
  description?: InputMaybe<Scalars['String']['input']>;
  logoImage?: InputMaybe<MarketplaceConsoleMakerLogoImageInput>;
  supportDetails?: InputMaybe<MarketplaceConsoleDevSpaceSupportDetailsInput>;
  trustCenterUrl?: InputMaybe<Scalars['String']['input']>;
};

export enum MarketplaceConsoleDevSpaceProgram {
  AtlassianParter = 'ATLASSIAN_PARTER',
  FreeLicense = 'FREE_LICENSE',
  MarketplacePartner = 'MARKETPLACE_PARTNER',
  SolutionPartner = 'SOLUTION_PARTNER'
}

export type MarketplaceConsoleDevSpaceSupportAvailabilityInput = {
  availableFrom?: InputMaybe<Scalars['String']['input']>;
  availableTo?: InputMaybe<Scalars['String']['input']>;
  days?: InputMaybe<Array<Scalars['String']['input']>>;
  holidays?: InputMaybe<Array<MarketplaceConsoleDevSpaceSupportContactHolidayInput>>;
  timezone: Scalars['String']['input'];
};

export type MarketplaceConsoleDevSpaceSupportContactHolidayInput = {
  date: Scalars['String']['input'];
  repeatAnnually: Scalars['Boolean']['input'];
  title: Scalars['String']['input'];
};

export type MarketplaceConsoleDevSpaceSupportDetailsInput = {
  availability?: InputMaybe<MarketplaceConsoleDevSpaceSupportAvailabilityInput>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactName?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  emergencyContact?: InputMaybe<Scalars['String']['input']>;
  slaUrl?: InputMaybe<Scalars['String']['input']>;
  targetResponseTimeInHrs?: InputMaybe<Scalars['Int']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export enum MarketplaceConsoleDevSpaceTier {
  Gold = 'GOLD',
  Platinum = 'PLATINUM',
  Silver = 'SILVER'
}

/**  --------------------------------------------------------------------------------------------- */
export type MarketplaceConsoleEditAppVersionRequest = {
  appKey: Scalars['ID']['input'];
  bonTermsSupported?: InputMaybe<Scalars['Boolean']['input']>;
  buildNumber: Scalars['ID']['input'];
  /** Information from Compatibilities tab */
  compatibilities?: InputMaybe<Array<MarketplaceConsoleAppSoftwareVersionCompatibilityInput>>;
  /** Information from Instructions tab */
  deploymentInstructions?: InputMaybe<Array<MarketplaceConsoleDeploymentInstructionInput>>;
  documentationUrl?: InputMaybe<Scalars['String']['input']>;
  eulaUrl?: InputMaybe<Scalars['String']['input']>;
  /** Information from Highlights tab */
  heroImageUrl?: InputMaybe<Scalars['String']['input']>;
  highlights?: InputMaybe<Array<MarketplaceConsoleListingHighLightInput>>;
  isBeta?: InputMaybe<Scalars['Boolean']['input']>;
  isSupported?: InputMaybe<Scalars['Boolean']['input']>;
  /** Information from Links tab */
  learnMoreUrl?: InputMaybe<Scalars['String']['input']>;
  licenseType?: InputMaybe<MarketplaceConsoleAppSoftwareVersionLicenseTypeId>;
  moreDetails?: InputMaybe<Scalars['String']['input']>;
  partnerSpecificTerms?: InputMaybe<Scalars['String']['input']>;
  purchaseUrl?: InputMaybe<Scalars['String']['input']>;
  releaseNotes?: InputMaybe<Scalars['String']['input']>;
  releaseSummary?: InputMaybe<Scalars['String']['input']>;
  /** Information from Media tab */
  screenshots?: InputMaybe<Array<MarketplaceConsoleListingScreenshotInput>>;
  sourceCodeLicenseUrl?: InputMaybe<Scalars['String']['input']>;
  /** Information from Details tab */
  status?: InputMaybe<MarketplaceConsoleAsvlLegacyVersionStatus>;
  youtubeId?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleEditionDetailsInput = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MarketplaceConsoleEditionInput = {
  cloudComplianceBoundary?: InputMaybe<MarketplaceConsoleCloudComplianceBoundary>;
  features: Array<MarketplaceConsoleFeatureInput>;
  id?: InputMaybe<Scalars['ID']['input']>;
  isDecoupled?: InputMaybe<Scalars['Boolean']['input']>;
  isDefault: Scalars['Boolean']['input'];
  parentProduct?: InputMaybe<Scalars['String']['input']>;
  pricingPlan: MarketplaceConsolePricingPlanInput;
  type: MarketplaceConsoleEditionType;
};

export enum MarketplaceConsoleEditionType {
  Advanced = 'ADVANCED',
  AdvancedMultiInstance = 'ADVANCED_MULTI_INSTANCE',
  Standard = 'STANDARD',
  StandardMultiInstance = 'STANDARD_MULTI_INSTANCE'
}

export type MarketplaceConsoleEditionsActivationRequest = {
  rejectionReason?: InputMaybe<Scalars['String']['input']>;
  status: MarketplaceConsoleEditionsActivationStatus;
};

/**  --------------------------------------------------------------------------------------------- */
export enum MarketplaceConsoleEditionsActivationStatus {
  Approved = 'APPROVED',
  Pending = 'PENDING',
  Rejected = 'REJECTED',
  Uninitiated = 'UNINITIATED'
}

/**  --------------------------------------------------------------------------------------------- */
export type MarketplaceConsoleEditionsFilterInput = {
  editionsGroup?: InputMaybe<MarketplaceConsoleEditionsGroup>;
};

export enum MarketplaceConsoleEditionsGroup {
  Default = 'DEFAULT',
  FedrampModerate = 'FEDRAMP_MODERATE',
  IsolatedCloud = 'ISOLATED_CLOUD'
}

export type MarketplaceConsoleEditionsInput = {
  appKey?: InputMaybe<Scalars['String']['input']>;
  productId?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleExternalFrameworkAttributesInput = {
  authorization: Scalars['Boolean']['input'];
  binaryUrl?: InputMaybe<Scalars['String']['input']>;
  learnMoreUrl?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleFeatureInput = {
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  position: Scalars['Int']['input'];
};

export type MarketplaceConsoleForgeFrameworkAttributesInput = {
  appId: Scalars['String']['input'];
  envId: Scalars['String']['input'];
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
  versionId: Scalars['String']['input'];
};

export type MarketplaceConsoleFrameworkAttributesInput = {
  connect?: InputMaybe<MarketplaceConsoleConnectFrameworkAttributesInput>;
  external?: InputMaybe<MarketplaceConsoleExternalFrameworkAttributesInput>;
  forge?: InputMaybe<MarketplaceConsoleForgeFrameworkAttributesInput>;
  plugin?: InputMaybe<MarketplaceConsolePluginFrameworkAttributesInput>;
  workflow?: InputMaybe<MarketplaceConsoleWorkflowFrameworkAttributesInput>;
};

export type MarketplaceConsoleGetVersionsListInput = {
  appSoftwareIds: Array<Scalars['ID']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
  legacyAppVersionApprovalStatus?: InputMaybe<Array<MarketplaceConsoleAsvlLegacyVersionApprovalStatus>>;
  legacyAppVersionStatus?: InputMaybe<Array<MarketplaceConsoleAsvlLegacyVersionStatus>>;
};

export type MarketplaceConsoleHighlightAssetInput = {
  screenshotUrl: Scalars['String']['input'];
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
};

/**
 * The file contains the common types that are used across
 * different parts of the Marketplace Console BFF GQL schema.
 */
export enum MarketplaceConsoleHosting {
  Cloud = 'CLOUD',
  DataCenter = 'DATA_CENTER',
  Server = 'SERVER'
}

export type MarketplaceConsoleImageAssetInput = {
  url: Scalars['String']['input'];
};

export type MarketplaceConsoleJsonPatchOperation = {
  op: MarketplaceConsoleJsonPatchOperationType;
  path: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export enum MarketplaceConsoleJsonPatchOperationType {
  Add = 'ADD',
  Remove = 'REMOVE',
  Replace = 'REPLACE'
}

export enum MarketplaceConsoleLegacyMongoPluginHiddenIn {
  HiddenInSiteAndAppMarketplace = 'HIDDEN_IN_SITE_AND_APP_MARKETPLACE',
  HiddenInSiteOnly = 'HIDDEN_IN_SITE_ONLY'
}

export enum MarketplaceConsoleLegacyMongoStatus {
  Notassigned = 'NOTASSIGNED',
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  Readytolaunch = 'READYTOLAUNCH',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED'
}

export type MarketplaceConsoleListingHighLightInput = {
  caption?: InputMaybe<Scalars['String']['input']>;
  screenshotUrl: Scalars['String']['input'];
  summary: Scalars['String']['input'];
  thumbnailUrl: Scalars['String']['input'];
  title: Scalars['String']['input'];
};

export type MarketplaceConsoleListingScreenshotInput = {
  caption?: InputMaybe<Scalars['String']['input']>;
  imageUrl: Scalars['String']['input'];
};

/** For the nullable fields in request, null value means that the input was not provided and therefore would not be updated */
export type MarketplaceConsoleMakeAppVersionPublicRequest = {
  acceptedAgreements?: InputMaybe<Array<Scalars['String']['input']>>;
  appKey: Scalars['ID']['input'];
  appStatusPageUrl?: InputMaybe<Scalars['String']['input']>;
  binaryUrl?: InputMaybe<Scalars['String']['input']>;
  bonTermsSupported?: InputMaybe<Scalars['Boolean']['input']>;
  buildNumber: Scalars['ID']['input'];
  categories?: InputMaybe<Array<Scalars['String']['input']>>;
  communityEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  compatibilities?: InputMaybe<Array<MarketplaceConsoleAppSoftwareVersionCompatibilityInput>>;
  dataCenterReviewIssueKey?: InputMaybe<Scalars['String']['input']>;
  deploymentInstructions?: InputMaybe<Array<MarketplaceConsoleDeploymentInstructionInput>>;
  documentationUrl?: InputMaybe<Scalars['String']['input']>;
  eulaUrl?: InputMaybe<Scalars['String']['input']>;
  forumsUrl?: InputMaybe<Scalars['String']['input']>;
  googleAnalytics4Id?: InputMaybe<Scalars['String']['input']>;
  googleAnalyticsId?: InputMaybe<Scalars['String']['input']>;
  heroImageUrl?: InputMaybe<Scalars['String']['input']>;
  highlights?: InputMaybe<Array<MarketplaceConsoleListingHighLightInput>>;
  isBeta?: InputMaybe<Scalars['Boolean']['input']>;
  isSupported?: InputMaybe<Scalars['Boolean']['input']>;
  issueTrackerUrl?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Array<Scalars['String']['input']>>;
  learnMoreUrl?: InputMaybe<Scalars['String']['input']>;
  licenseType?: InputMaybe<MarketplaceConsoleAppSoftwareVersionLicenseTypeId>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  marketingLabels?: InputMaybe<Array<Scalars['String']['input']>>;
  moreDetails?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  partnerSpecificTerms?: InputMaybe<Scalars['String']['input']>;
  paymentModel?: InputMaybe<MarketplaceConsolePaymentModel>;
  privacyUrl?: InputMaybe<Scalars['String']['input']>;
  productId: Scalars['ID']['input'];
  purchaseUrl?: InputMaybe<Scalars['String']['input']>;
  releaseNotes?: InputMaybe<Scalars['String']['input']>;
  releaseSummary?: InputMaybe<Scalars['String']['input']>;
  screenshots?: InputMaybe<Array<MarketplaceConsoleListingScreenshotInput>>;
  segmentWriteKey?: InputMaybe<Scalars['String']['input']>;
  sourceCodeLicenseUrl?: InputMaybe<Scalars['String']['input']>;
  statusAfterApproval?: InputMaybe<MarketplaceConsoleLegacyMongoStatus>;
  storesPersonalData?: InputMaybe<Scalars['Boolean']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supportTicketSystemUrl?: InputMaybe<Scalars['String']['input']>;
  tagLine?: InputMaybe<Scalars['String']['input']>;
  youtubeId?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleMakerContactCreateInput = {
  contactPayload: MarketplaceConsoleMakerContactPayload;
  email: Scalars['String']['input'];
  partnerId: Scalars['ID']['input'];
};

export type MarketplaceConsoleMakerContactDeleteInput = {
  accountId: Scalars['ID']['input'];
  partnerId: Scalars['ID']['input'];
};

export type MarketplaceConsoleMakerContactFilters = {
  role?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleMakerContactPayload = {
  permissions: Array<Scalars['String']['input']>;
  roles: Array<Scalars['String']['input']>;
};

export type MarketplaceConsoleMakerContactUpdateInput = {
  accountId: Scalars['ID']['input'];
  contactPayload: MarketplaceConsoleMakerContactPayload;
  partnerId: Scalars['ID']['input'];
};

export type MarketplaceConsoleMakerLogoImageInput = {
  id: Scalars['String']['input'];
  mimeType: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export type MarketplaceConsoleMakerPaymentInput = {
  bankDetails: MarketplaceConsoleBankDetailsInput;
  billingAddress: MarketplaceConsoleBillingAddressInput;
  billingContact: MarketplaceConsoleBillingContactInput;
  tax: MarketplaceConsoleTaxInput;
};

export type MarketplaceConsoleOfferingInput = {
  appKey: Scalars['String']['input'];
  productId: Scalars['String']['input'];
};

export enum MarketplaceConsoleOfferingStatus {
  Active = 'ACTIVE',
  AtNotice = 'AT_NOTICE',
  Draft = 'DRAFT',
  Expired = 'EXPIRED'
}

export type MarketplaceConsoleParentSoftwarePricingQueryInput = {
  parentProductId: Scalars['String']['input'];
};

export enum MarketplaceConsoleParentSoftwareState {
  Active = 'ACTIVE',
  Archived = 'ARCHIVED',
  Draft = 'DRAFT'
}

export enum MarketplaceConsolePartnerTier {
  /**  eslint-disable-next-line @graphql-eslint/naming-convention */
  Gold = 'gold',
  /**  eslint-disable-next-line @graphql-eslint/naming-convention */
  Platinum = 'platinum',
  /**  eslint-disable-next-line @graphql-eslint/naming-convention */
  Silver = 'silver'
}

export enum MarketplaceConsolePaymentModel {
  Free = 'FREE',
  PaidViaAtlassian = 'PAID_VIA_ATLASSIAN',
  PaidViaVendor = 'PAID_VIA_VENDOR'
}

export type MarketplaceConsolePluginFrameworkAttributesInput = {
  href: Scalars['String']['input'];
};

export enum MarketplaceConsolePluginFrameworkType {
  P1 = 'P1',
  P2 = 'P2'
}

export enum MarketplaceConsolePricingCurrency {
  Jpy = 'JPY',
  Usd = 'USD'
}

export type MarketplaceConsolePricingItemInput = {
  amount: Scalars['Float']['input'];
  ceiling: Scalars['Float']['input'];
  floor: Scalars['Float']['input'];
};

export type MarketplaceConsolePricingPlanInput = {
  currency: MarketplaceConsolePricingCurrency;
  expertDiscountOptOut: Scalars['Boolean']['input'];
  isDefaultPricing?: InputMaybe<Scalars['Boolean']['input']>;
  status: MarketplaceConsolePricingPlanStatus;
  tieredPricing: Array<MarketplaceConsolePricingItemInput>;
};

export enum MarketplaceConsolePricingPlanStatus {
  AtNotice = 'AT_NOTICE',
  Draft = 'DRAFT',
  Live = 'LIVE',
  Pending = 'PENDING'
}

export enum MarketplaceConsoleProductLifecycleJobStatus {
  Abandoned = 'ABANDONED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  Started = 'STARTED',
  Starting = 'STARTING',
  Stopped = 'STOPPED',
  Stopping = 'STOPPING',
  Unknown = 'UNKNOWN'
}

export enum MarketplaceConsoleProductLifecycleJobType {
  Archive = 'ARCHIVE',
  Delete = 'DELETE',
  Transfer = 'TRANSFER',
  Unarchive = 'UNARCHIVE'
}

export type MarketplaceConsoleProductListingAdditionalChecksInput = {
  cloudAppSoftwareId?: InputMaybe<Scalars['ID']['input']>;
  dataCenterAppSoftwareId?: InputMaybe<Scalars['ID']['input']>;
  productId: Scalars['ID']['input'];
  serverAppSoftwareId?: InputMaybe<Scalars['ID']['input']>;
};

export enum MarketplaceConsoleProductListingApprovalStatus {
  Archived = 'ARCHIVED',
  Notassigned = 'NOTASSIGNED',
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  Readytolaunch = 'READYTOLAUNCH',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED'
}

/**  Update Product Listing Approval Status Mutation */
export enum MarketplaceConsoleProductListingApprovalStatusUpdateAction {
  Approved = 'APPROVED',
  Rejected = 'REJECTED',
  Resubmit = 'RESUBMIT'
}

/**  Product Listing Approval Status Types */
export enum MarketplaceConsoleProductListingCurrentTaskStatus {
  Failed = 'FAILED',
  Processing = 'PROCESSING',
  Success = 'SUCCESS'
}

export enum MarketplaceConsoleProductListingReleaseAppListingStatus {
  Archived = 'ARCHIVED',
  Notassigned = 'NOTASSIGNED',
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  Readytolaunch = 'READYTOLAUNCH',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED'
}

/** Product Listing Release Status Types */
export enum MarketplaceConsoleProductListingReleaseCurrentStatus {
  Failed = 'FAILED',
  Processing = 'PROCESSING',
  Success = 'SUCCESS'
}

export type MarketplaceConsoleProgramInput = {
  baseUri?: InputMaybe<Scalars['String']['input']>;
  partnerTier?: InputMaybe<MarketplaceConsolePartnerTier>;
  program: MarketplaceConsoleDevSpaceProgram;
  programId?: InputMaybe<Scalars['ID']['input']>;
  solutionPartnerBenefit?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MarketplaceConsoleTaxInput = {
  id: Scalars['String']['input'];
  isGSTRegistered?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/**  --------------------------------------------------------------------------------------------- */
export type MarketplaceConsoleUpdateAppDetailsRequest = {
  appKey: Scalars['ID']['input'];
  appStatusPageUrl?: InputMaybe<Scalars['String']['input']>;
  bannerForUPMUrl?: InputMaybe<Scalars['String']['input']>;
  buildsUrl?: InputMaybe<Scalars['String']['input']>;
  categories?: InputMaybe<Array<Scalars['String']['input']>>;
  cloudHostingVisibility?: InputMaybe<MarketplaceConsoleLegacyMongoPluginHiddenIn>;
  communityEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  currentCategories?: InputMaybe<Array<Scalars['String']['input']>>;
  dataCenterHostingVisibility?: InputMaybe<MarketplaceConsoleLegacyMongoPluginHiddenIn>;
  dataCenterReviewIssueKey?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  forumsUrl?: InputMaybe<Scalars['String']['input']>;
  googleAnalytics4Id?: InputMaybe<Scalars['String']['input']>;
  googleAnalyticsId?: InputMaybe<Scalars['String']['input']>;
  issueTrackerUrl?: InputMaybe<Scalars['String']['input']>;
  jsdEmbeddedDataKey?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Array<Scalars['String']['input']>>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  marketingLabels?: InputMaybe<Array<Scalars['String']['input']>>;
  name?: InputMaybe<Scalars['String']['input']>;
  privacyUrl?: InputMaybe<Scalars['String']['input']>;
  productId: Scalars['ID']['input'];
  segmentWriteKey?: InputMaybe<Scalars['String']['input']>;
  serverHostingVisibility?: InputMaybe<MarketplaceConsoleLegacyMongoPluginHiddenIn>;
  sourceUrl?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<MarketplaceConsoleLegacyMongoStatus>;
  statusAfterApproval?: InputMaybe<MarketplaceConsoleLegacyMongoStatus>;
  storesPersonalData?: InputMaybe<Scalars['Boolean']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supportTicketSystemUrl?: InputMaybe<Scalars['String']['input']>;
  tagLine?: InputMaybe<Scalars['String']['input']>;
  wikiUrl?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceConsoleUpdateMakerListingInput = {
  developerId: Scalars['String']['input'];
  developerSpaceListing: MarketplaceConsoleDevSpaceListingInput;
  makerName: Scalars['String']['input'];
};

export type MarketplaceConsoleUpdateProductListingApprovalStatusInput = {
  productId: Scalars['ID']['input'];
  /** Required only when status is 'REJECTED' */
  reason?: InputMaybe<Scalars['String']['input']>;
  status: MarketplaceConsoleProductListingApprovalStatusUpdateAction;
};

export type MarketplaceConsoleUpdateVersionListingApprovalStatusInput = {
  appSoftwareId: Scalars['ID']['input'];
  buildNumber: Scalars['String']['input'];
  /** Required only when status is 'REJECTED' */
  reason?: InputMaybe<Scalars['String']['input']>;
  status: MarketplaceConsoleVersionListingApprovalStatusUpdateAction;
};

export type MarketplaceConsoleUpsertMakerPaymentInput = {
  developerId: Scalars['ID']['input'];
  paymentDetails: MarketplaceConsoleMakerPaymentInput;
};

export type MarketplaceConsoleUpsertProgramEnrollmentInput = {
  developerId: Scalars['String']['input'];
  programEnrollments: Array<MarketplaceConsoleProgramInput>;
};

export enum MarketplaceConsoleVersionListingApprovalStatus {
  Approved = 'APPROVED',
  Pending = 'PENDING',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED',
  Uninitiated = 'UNINITIATED'
}

/** Update Version Listing Approval Status Mutation */
export enum MarketplaceConsoleVersionListingApprovalStatusUpdateAction {
  Approved = 'APPROVED',
  Rejected = 'REJECTED',
  Resubmit = 'RESUBMIT'
}

/** Version Listing Approval Status Types */
export enum MarketplaceConsoleVersionListingCurrentTaskStatus {
  Failed = 'FAILED',
  Processing = 'PROCESSING',
  Success = 'SUCCESS'
}

export enum MarketplaceConsoleVersionType {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

export type MarketplaceConsoleWorkflowFrameworkAttributesInput = {
  href: Scalars['String']['input'];
};

/** Status of an entity in Marketplace system */
export enum MarketplaceEntityStatus {
  Active = 'ACTIVE',
  Archived = 'ARCHIVED'
}

/** Status of apps listing in Marketplace. */
export enum MarketplaceListingStatus {
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  ReadyToLaunch = 'READY_TO_LAUNCH',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED'
}

/** Marketplace location */
export enum MarketplaceLocation {
  InProduct = 'IN_PRODUCT',
  Website = 'WEBSITE'
}

/** Tells whether support is on holiday only one time or if it repeats annually. */
export enum MarketplacePartnerSupportHolidayFrequency {
  Annual = 'ANNUAL',
  OneTime = 'ONE_TIME'
}

export enum MarketplacePartnerTierType {
  Gold = 'GOLD',
  Platinum = 'PLATINUM',
  Silver = 'SILVER'
}

/** Tells if the Marketplace partner is an Atlassians internal one. */
export enum MarketplacePartnerType {
  AtlassianInternal = 'ATLASSIAN_INTERNAL'
}

/** Option parameters to fetch pricing plan for a marketplace entity */
export type MarketplacePricingPlanOptions = {
  /** Period for which Pricing Plan is to be fetched. Defaults to MONTHLY */
  billingCycle?: InputMaybe<MarketplaceBillingCycle>;
  /** Country code (ISO 3166-1 alpha-2) of the client. Either of currencyCode and countryCode is needed. If both are not present, fallback to default currency - USD */
  countryCode?: InputMaybe<Scalars['String']['input']>;
  /** Currency code (ISO 4217) to return the amount in pricing items. Either of currencyCode and countryCode is needed. If currency code is not present, fallback to country code to fetch currency */
  currencyCode?: InputMaybe<Scalars['String']['input']>;
  /** Fetch pricing plan with status: LIVE, PENDING, DRAFT. Unless, pricing plan will be fetched based on user access */
  planStatus?: InputMaybe<MarketplacePricingPlanStatus>;
};

/** Status of the plan : LIVE, PENDING or DRAFT */
export enum MarketplacePricingPlanStatus {
  Draft = 'DRAFT',
  Live = 'LIVE',
  Pending = 'PENDING'
}

/** Mode of the tier : GRADUATED (progressive PUP), VOLUME (constant for all users) */
export enum MarketplacePricingTierMode {
  Graduated = 'GRADUATED',
  Volume = 'VOLUME'
}

/** Policy of the tier : BLOCK (FLAT) or PER_UNIT (PUP) */
export enum MarketplacePricingTierPolicy {
  Block = 'BLOCK',
  PerUnit = 'PER_UNIT'
}

/** Type of the tier */
export enum MarketplacePricingTierType {
  RemoteAgentTiered = 'REMOTE_AGENT_TIERED',
  UserTiered = 'USER_TIERED'
}

export enum MarketplaceProgramStatus {
  Applied = 'APPLIED',
  Approved = 'APPROVED',
  NotAParticipant = 'NOT_A_PARTICIPANT',
  Rejected = 'REJECTED'
}

/**  --------------------------------------------------------------------------------------------- */
export type MarketplaceStoreAppDetailInput = {
  appId: Scalars['ID']['input'];
  appKey: Scalars['String']['input'];
};

export enum MarketplaceStoreAtlassianProductHostingType {
  Cloud = 'CLOUD',
  Datacenter = 'DATACENTER',
  Server = 'SERVER'
}

export enum MarketplaceStoreBillingSystem {
  Ccp = 'CCP',
  Hams = 'HAMS'
}

/**  --------------------------------------------------------------------------------------------- */
export type MarketplaceStoreBillingSystemInput = {
  cloudId: Scalars['String']['input'];
};

export enum MarketplaceStoreCloudComplianceBoundary {
  Commercial = 'COMMERCIAL',
  FedrampModerate = 'FEDRAMP_MODERATE',
  IsolatedCloud = 'ISOLATED_CLOUD'
}

export type MarketplaceStoreCreateOrUpdateReviewInput = {
  appKey: Scalars['String']['input'];
  hosting?: InputMaybe<MarketplaceStoreAtlassianProductHostingType>;
  review?: InputMaybe<Scalars['String']['input']>;
  stars: Scalars['Int']['input'];
  status?: InputMaybe<Scalars['String']['input']>;
  userHasComplianceConsent?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MarketplaceStoreCreateOrUpdateReviewResponseInput = {
  appKey: Scalars['String']['input'];
  reviewId: Scalars['ID']['input'];
  text: Scalars['String']['input'];
};

export type MarketplaceStoreDeleteReviewInput = {
  appKey: Scalars['String']['input'];
  reviewId: Scalars['ID']['input'];
};

export type MarketplaceStoreDeleteReviewResponseInput = {
  appKey: Scalars['String']['input'];
  reviewId: Scalars['ID']['input'];
};

export enum MarketplaceStoreDeveloperSpaceStatus {
  Active = 'ACTIVE',
  Archived = 'ARCHIVED',
  Inactive = 'INACTIVE'
}

export enum MarketplaceStoreEditionType {
  Advanced = 'ADVANCED',
  Free = 'FREE',
  Standard = 'STANDARD'
}

export type MarketplaceStoreEditionsByAppKeyInput = {
  appKey?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceStoreEditionsInput = {
  appId?: InputMaybe<Scalars['String']['input']>;
};

/**  eslint-disable-next-line @graphql-eslint/strict-id-in-types -- id is not required */
export type MarketplaceStoreEligibleAppOfferingsInput = {
  cloudComplianceBoundaries?: InputMaybe<Array<MarketplaceStoreCloudComplianceBoundary>>;
  cloudId: Scalars['String']['input'];
  product: MarketplaceStoreProduct;
  target?: InputMaybe<MarketplaceStoreEligibleAppOfferingsTargetInput>;
};

/**  eslint-disable-next-line @graphql-eslint/strict-id-in-types -- id is not required */
export type MarketplaceStoreEligibleAppOfferingsTargetInput = {
  product?: InputMaybe<MarketplaceStoreInstallationTargetProduct>;
};

/** Products onto which an app can be installed */
export enum MarketplaceStoreEnterpriseProduct {
  Confluence = 'CONFLUENCE',
  Jira = 'JIRA'
}

/**  --------------------------------------------------------------------------------------------- */
export enum MarketplaceStoreHomePageHighlightedSectionVariation {
  Prominent = 'PROMINENT'
}

/**  --------------------------------------------------------------------------------------------- */
export enum MarketplaceStoreHostInstanceType {
  Production = 'PRODUCTION',
  Sandbox = 'SANDBOX'
}

export type MarketplaceStoreInstallAppInput = {
  appKey: Scalars['String']['input'];
  chargeQuantity?: InputMaybe<Scalars['Int']['input']>;
  installationId?: InputMaybe<Scalars['String']['input']>;
  offeringId?: InputMaybe<Scalars['String']['input']>;
  secondaryTargetProducts?: InputMaybe<Array<MarketplaceStoreInstallationTargetProduct>>;
  target: MarketplaceStoreInstallAppTargetInput;
};

/** Status of an app installation request */
export enum MarketplaceStoreInstallAppStatus {
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  ProvisioningFailure = 'PROVISIONING_FAILURE',
  ProvisioningSuccessInstallPending = 'PROVISIONING_SUCCESS_INSTALL_PENDING',
  Success = 'SUCCESS',
  TimedOut = 'TIMED_OUT'
}

/** Input for specifying the target or "site" of an app installation. */
export type MarketplaceStoreInstallAppTargetInput = {
  cloudId: Scalars['ID']['input'];
  product: MarketplaceStoreInstallationTargetProduct;
};

/** Products onto which an app can be installed */
export enum MarketplaceStoreInstallationTargetProduct {
  Compass = 'COMPASS',
  Confluence = 'CONFLUENCE',
  Jira = 'JIRA',
  Jsm = 'JSM'
}

export enum MarketplaceStoreInstalledAppManageLinkType {
  Configure = 'CONFIGURE',
  GetStarted = 'GET_STARTED',
  Manage = 'MANAGE'
}

export type MarketplaceStoreMultiInstanceEntitlementForAppInput = {
  cloudId: Scalars['String']['input'];
  product: MarketplaceStoreProduct;
};

export type MarketplaceStoreMultiInstanceEntitlementsForUserInput = {
  cloudIds: Array<Scalars['String']['input']>;
  product: MarketplaceStoreEnterpriseProduct;
};

/**  --------------------------------------------------------------------------------------------- */
export enum MarketplaceStorePartnerEnrollmentProgram {
  MarketplacePartner = 'MARKETPLACE_PARTNER',
  SolutionPartner = 'SOLUTION_PARTNER'
}

export enum MarketplaceStorePartnerEnrollmentProgramValue {
  Gold = 'GOLD',
  Platinum = 'PLATINUM',
  Silver = 'SILVER'
}

export enum MarketplaceStorePartnerSupportAvailabilityDay {
  Friday = 'FRIDAY',
  Monday = 'MONDAY',
  Saturday = 'SATURDAY',
  Sunday = 'SUNDAY',
  Thursday = 'THURSDAY',
  Tuesday = 'TUESDAY',
  Wednesday = 'WEDNESDAY'
}

export enum MarketplaceStorePricingCurrency {
  Jpy = 'JPY',
  Usd = 'USD'
}

export type MarketplaceStoreProduct = {
  appKey?: InputMaybe<Scalars['String']['input']>;
};

export type MarketplaceStoreReviewFilterInput = {
  hosting?: InputMaybe<MarketplaceStoreAtlassianProductHostingType>;
  sort?: InputMaybe<MarketplaceStoreReviewsSorting>;
};

export enum MarketplaceStoreReviewsSorting {
  Helpful = 'HELPFUL',
  Recent = 'RECENT'
}

/** Fetch licensed user count for apps + products for LD */
export type MarketplaceStoreSiteDetailsInput = {
  cloudId: Scalars['String']['input'];
  product: MarketplaceStoreSiteProduct;
};

/** appKey and parentProduct for the app for which information to be fetched */
export type MarketplaceStoreSiteProduct = {
  appKey?: InputMaybe<Scalars['String']['input']>;
  parentProduct?: InputMaybe<MarketplaceStoreInstallationTargetProduct>;
};

export type MarketplaceStoreUpdateReviewFlagInput = {
  appKey: Scalars['String']['input'];
  reviewId: Scalars['ID']['input'];
  state: Scalars['Boolean']['input'];
};

export type MarketplaceStoreUpdateReviewVoteInput = {
  appKey: Scalars['String']['input'];
  reviewId: Scalars['ID']['input'];
  state: Scalars['Boolean']['input'];
};

export type MarketplaceStoreUpdateUserPreferencesInput = {
  preferences: MarketplaceStoreUserPreferencesInput;
  version: Scalars['Int']['input'];
};

export type MarketplaceStoreUserPreferencesInput = {
  notifyOnAppArchivalSchedule: Scalars['Boolean']['input'];
  notifyOnAppUninstallDisableFeedback: Scalars['Boolean']['input'];
  notifyOnReviewResponseOrUpdate: Scalars['Boolean']['input'];
};

export type MediaAttachmentInput = {
  file: MediaFile;
  minorEdit?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MediaFile = {
  /**  this is the media store ID */
  id: Scalars['ID']['input'];
  /**  optional mime type of the file */
  mimeType?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /**  size of the file in bytes */
  size: Scalars['Int']['input'];
};

/** The roles that a member can have within a team */
export enum MembershipRole {
  /** A team member with administrative permissions */
  Admin = 'ADMIN',
  /** A regular team member */
  Regular = 'REGULAR'
}

/** The settings which a team can have describing how members are added to the team */
export enum MembershipSetting {
  /** Members may invite others to join the team */
  MemberInvite = 'MEMBER_INVITE',
  /** Anyone may join */
  Open = 'OPEN'
}

/** The states that a member can have within a team */
export enum MembershipState {
  /** A member who was previously a full member of the team, but has been removed or has left the team */
  Alumni = 'ALUMNI',
  /** A full member of the team */
  FullMember = 'FULL_MEMBER',
  /** A member who has been invited to the team but has not yet joined */
  Invited = 'INVITED',
  /** A member who has requested to join the team and is pending approval */
  RequestingToJoin = 'REQUESTING_TO_JOIN'
}

export type MentionData = {
  mentionLocalIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  mentionedUserAccountId: Scalars['ID']['input'];
};

export type MercuryAddCustomFieldDefinitionOptionsInput = {
  /** The ID of the custom field definition. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The option values to set. This replaces all existing options. */
  options: Array<MercuryCustomSelectFieldOptionInput>;
};

/**
 *  ------------------------------------------------------
 *  Tags Inputs and Payloads
 *  ------------------------------------------------------
 */
export type MercuryAddTagsToProposalInput = {
  /** The ID of the Change Proposal to add tags to. */
  changeProposalId: Scalars['ID']['input'];
  /** The list of tag ARIs to add to a proposal. */
  tagIds: Array<Scalars['ID']['input']>;
};

/**
 *  ------------------------------------------------------
 *   Watch/Unwatch Focus Area mutations
 *  ------------------------------------------------------
 */
export type MercuryAddWatcherToFocusAreaInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};

export type MercuryArchiveFocusAreaChangeInput = {
  /** The ARI of the Focus Area to archive. */
  targetFocusAreaId: Scalars['ID']['input'];
};

/**
 *  ------------------------------------------------------
 *  Focus Area Archive/Unarchive
 *  ------------------------------------------------------
 */
export type MercuryArchiveFocusAreaInput = {
  cloudId: Scalars['ID']['input'];
  comment?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export type MercuryArchiveFocusAreaValidationInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

/**
 *  ------------------------------------------------------
 *   Focus Area User Access mutations
 *  ------------------------------------------------------
 */
export type MercuryAssignUserAccessToFocusAreaInput = {
  focusAreaAri: Scalars['ID']['input'];
  focusAreaUserAccessAssignment: Array<InputMaybe<MercuryFocusAreaUserAccessInput>>;
};

export type MercuryChangeParentFocusAreaChangeInput = {
  /** The ARI of the Focus Area being moved. */
  focusAreaId: Scalars['ID']['input'];
  /** The ARI of the new parent Focus Area. */
  targetFocusAreaId?: InputMaybe<Scalars['ID']['input']>;
};

export type MercuryChangeProposalSort = {
  /** Either 'field' or 'fieldKey' must be provided, but not both. */
  field?: InputMaybe<MercuryChangeProposalSortField>;
  fieldKey?: InputMaybe<Scalars['String']['input']>;
  order: SortOrder;
};

export enum MercuryChangeProposalSortField {
  Name = 'NAME'
}

export type MercuryChangeProposalsViewSort = {
  field: MercuryChangeProposalsViewSortField;
  order: SortOrder;
};

export enum MercuryChangeProposalsViewSortField {
  Name = 'NAME',
  UpdatedDate = 'UPDATED_DATE'
}

export type MercuryChangeSort = {
  field: MercuryChangeSortField;
  order: SortOrder;
};

export enum MercuryChangeSortField {
  Type = 'TYPE'
}

export type MercuryChangeSummaryInput = {
  /** Focus Area ARI */
  focusAreaId: Scalars['ID']['input'];
  /** Strategic Event ARI */
  hydrationContextId: Scalars['ID']['input'];
};

export enum MercuryChangeType {
  ArchiveFocusArea = 'ARCHIVE_FOCUS_AREA',
  ChangeParentFocusArea = 'CHANGE_PARENT_FOCUS_AREA',
  CreateFocusArea = 'CREATE_FOCUS_AREA',
  MoveFunds = 'MOVE_FUNDS',
  MovePositions = 'MOVE_POSITIONS',
  PositionAllocation = 'POSITION_ALLOCATION',
  RenameFocusArea = 'RENAME_FOCUS_AREA',
  RequestFunds = 'REQUEST_FUNDS',
  RequestPositions = 'REQUEST_POSITIONS'
}

export type MercuryCostSubtypeSort = {
  field: MercuryCostSubtypeSortField;
  order: SortOrder;
};

export enum MercuryCostSubtypeSortField {
  Name = 'NAME'
}

/**
 *  ----------------------------------------
 *   Custom field definitions inputs and payloads
 *  ----------------------------------------
 */
export type MercuryCreateBaseCustomFieldDefinitionInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

export type MercuryCreateChangeProposalCommentInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The content of the comment. */
  content: Scalars['String']['input'];
  /** ARI of the Change Proposal to comment on. */
  id: Scalars['ID']['input'];
};

export type MercuryCreateChangeProposalCustomFieldDefinitionInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** Input for core custom field definition types. */
  coreCustomFieldDefinition?: InputMaybe<MercuryCreateCoreCustomFieldDefinitionInput>;
};

/**
 * ###################################################################################################################
 *  CHANGE PROPOSAL - MUTATION TYPES
 * ###################################################################################################################
 */
export type MercuryCreateChangeProposalInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The description of the Change Proposal. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Focus Area the Change Proposal is associated with. */
  focusAreaId?: InputMaybe<Scalars['ID']['input']>;
  /** The expected impact of the Change Proposal. */
  impact?: InputMaybe<Scalars['Int']['input']>;
  /** The name of the Change Proposal. */
  name: Scalars['String']['input'];
  /** The Owner of the Change Proposal. Defaults to the current user. */
  owner?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the Strategic Event the Change Proposal is associated with. */
  strategicEventId: Scalars['ID']['input'];
};

export type MercuryCreateChangeProposalsViewInput = {
  /** Cloud ID for AGG routing */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The name of the Change Proposals View. */
  name: Scalars['String']['input'];
  settings?: InputMaybe<Array<InputMaybe<MercuryViewSettingInput>>>;
  /**
   * The Optional Strategic Event ID to associate the Change Proposals View with.
   * If not present, the Change Proposals View will be a global view.
   * Change Proposal prioritization will be allowed only if associated with a Strategic Event.
   */
  strategicEventId?: InputMaybe<Scalars['ID']['input']>;
};

export type MercuryCreateCommentInput = {
  cloudId: Scalars['ID']['input'];
  commentText: Scalars['MercuryJSONString']['input'];
  entityId: Scalars['ID']['input'];
  entityType: MercuryEntityType;
};

export type MercuryCreateCoreCustomFieldDefinitionInput = {
  dateField?: InputMaybe<MercuryCreateDateCustomFieldDefinitionInput>;
  multiSelectField?: InputMaybe<MercuryCreateMultiSelectCustomFieldDefinitionInput>;
  numberField?: InputMaybe<MercuryCreateNumberCustomFieldDefinitionInput>;
  singleSelectField?: InputMaybe<MercuryCreateSingleSelectCustomFieldDefinitionInput>;
  textField?: InputMaybe<MercuryCreateTextCustomFieldDefinitionInput>;
};

/**
 * ###################################################################################################################
 *  FUNDS - MUTATION TYPES
 * ###################################################################################################################
 *  ------------------------------------------------------
 *  Cost Subtypes
 *  ------------------------------------------------------
 */
export type MercuryCreateCostSubtypeInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The Cost Type of the Cost Subtype. */
  costTypeId: Scalars['ID']['input'];
  /** The name of the Cost Subtype. */
  name: Scalars['String']['input'];
};

export type MercuryCreateDateCustomFieldDefinitionInput = {
  base: MercuryCreateBaseCustomFieldDefinitionInput;
};

/**
 *  ------------------------------------------------------
 *  Fiscal Calendar Configuration
 *  ------------------------------------------------------
 */
export type MercuryCreateFiscalCalendarConfigurationInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The start month number of the Fiscal Calendar Configuration. */
  startMonthNumber: Scalars['Int']['input'];
};

export type MercuryCreateFocusAreaChangeInput = {
  /** The name of the proposed Focus Area. */
  focusAreaName: Scalars['String']['input'];
  /** The ARI of the Focus Area Type of the proposed Focus Area. */
  focusAreaTypeId: Scalars['ID']['input'];
  /** The ARI of the parent Focus Area of the proposed Focus Area. */
  targetFocusAreaId?: InputMaybe<Scalars['ID']['input']>;
};

export type MercuryCreateFocusAreaCustomFieldDefinitionInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** Input for core custom field definition types. */
  coreCustomFieldDefinition?: InputMaybe<MercuryCreateCoreCustomFieldDefinitionInput>;
};

export type MercuryCreateFocusAreaHierarchyInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  hierarchyTypeKey: MercuryFocusAreaHierarchyTypeKey;
  name: Scalars['String']['input'];
};

/**
 *  ------------------------------------------------------
 *   Focus Area
 *  ------------------------------------------------------
 */
export type MercuryCreateFocusAreaInput = {
  cloudId: Scalars['ID']['input'];
  /** Optional unique identifier for correlating a Focus Area with external systems or records. */
  externalId?: InputMaybe<Scalars['String']['input']>;
  focusAreaTypeId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  /** Optional ID of the parent Focus Area in the hierarchy. If not provided the Focus Area has no parent. */
  parentFocusAreaId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 *  ----------------------------------------
 *   Focus Area status update mutations
 *  ----------------------------------------
 */
export type MercuryCreateFocusAreaStatusUpdateInput = {
  cloudId: Scalars['ID']['input'];
  /** ID of the Focus Area for which an update is posted. */
  focusAreaId: Scalars['ID']['input'];
  /** The new target date for the Focus Area. */
  newTargetDate?: InputMaybe<MercuryFocusAreaTargetDateInput>;
  /** The ID of the status to transition the Focus Area to as part of the update. */
  statusTransitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The summary text (ADF) for the update. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/**
 *  ------------------------------------------------------
 *  Investment Categories
 *  ------------------------------------------------------
 */
export type MercuryCreateInvestmentCategoryInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The name of the Investment Category. */
  name: Scalars['String']['input'];
};

export type MercuryCreateMultiSelectCustomFieldDefinitionInput = {
  base: MercuryCreateBaseCustomFieldDefinitionInput;
  options: Array<MercuryCustomSelectFieldOptionInput>;
};

export type MercuryCreateNumberCustomFieldDefinitionInput = {
  base: MercuryCreateBaseCustomFieldDefinitionInput;
};

export type MercuryCreatePortfolioFocusAreasInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaIds: Array<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  viewType?: InputMaybe<MercuryViewType>;
};

/**
 * ###################################################################################################################
 *  RISKS - MUTATION TYPES
 * ###################################################################################################################
 */
export type MercuryCreateRiskInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The description of the Risk in ADF format. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the Risk. */
  name: Scalars['String']['input'];
  /** The owner of the Risk (user ARI). Defaults to the requesting user if not provided. */
  owner?: InputMaybe<Scalars['ID']['input']>;
};

export type MercuryCreateSingleSelectCustomFieldDefinitionInput = {
  base: MercuryCreateBaseCustomFieldDefinitionInput;
  options: Array<MercuryCustomSelectFieldOptionInput>;
};

export type MercuryCreateStrategicEventCommentInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The content of the comment. */
  content: Scalars['String']['input'];
  /** ARI of the Strategic Event to comment on. */
  id: Scalars['ID']['input'];
};

/**
 * ###################################################################################################################
 *  STRATEGIC EVENTS - MUTATION TYPES
 * ###################################################################################################################
 */
export type MercuryCreateStrategicEventInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The description of the Strategic Event. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the Strategic Event. */
  name: Scalars['String']['input'];
  /** The owner of the Strategic Event. Defaults to the current user. */
  owner?: InputMaybe<Scalars['ID']['input']>;
  /** The target date of the Strategic Event. */
  targetDate?: InputMaybe<Scalars['String']['input']>;
};

export type MercuryCreateTextCustomFieldDefinitionInput = {
  base: MercuryCreateBaseCustomFieldDefinitionInput;
};

export type MercuryCustomFieldDefinitionSort = {
  field: MercuryCustomFieldDefinitionSortField;
  order: SortOrder;
};

export enum MercuryCustomFieldDefinitionSortField {
  Name = 'NAME'
}

/**
 *  ----------------------------------------
 *   Custom field inputs and payloads
 *  ----------------------------------------
 */
export type MercuryCustomFieldInput = {
  dateField?: InputMaybe<MercuryDateCustomFieldInput>;
  multiSelectField?: InputMaybe<MercuryMultiSelectCustomFieldInput>;
  numberField?: InputMaybe<MercuryNumberCustomFieldInput>;
  singleSelectField?: InputMaybe<MercurySingleSelectCustomFieldInput>;
  textField?: InputMaybe<MercuryTextCustomFieldInput>;
};

export type MercuryCustomFieldSelectionOptionSettingInput = {
  key: MercuryCustomFieldSelectionOptionSettingKey;
  value?: InputMaybe<Scalars['String']['input']>;
};

export enum MercuryCustomFieldSelectionOptionSettingKey {
  Color = 'COLOR'
}

export type MercuryCustomSelectFieldOptionInput = {
  /** Settings associated to the Options field - for eg. color */
  settings?: InputMaybe<Array<MercuryCustomFieldSelectionOptionSettingInput>>;
  /** The value of the option for custom field. */
  value: Scalars['String']['input'];
};

export type MercuryDateCustomFieldInput = {
  /** The date value to set on the custom field. */
  dateValue?: InputMaybe<Scalars['Date']['input']>;
};

export type MercuryDeleteAllPreferenceInput = {
  cloudId: Scalars['ID']['input'];
};

export type MercuryDeleteChangeProposalCommentInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** ID of the comment to delete. */
  id: Scalars['ID']['input'];
};

export type MercuryDeleteChangeProposalInput = {
  id: Scalars['ID']['input'];
};

export type MercuryDeleteChangeProposalsViewInput = {
  /** The ARI of the Change Proposal View to delete. */
  id: Scalars['ID']['input'];
};

/**
 *  ------------------------------------------------------
 *  Deleting Changes
 *  ------------------------------------------------------
 */
export type MercuryDeleteChangesInput = {
  /** The ARIs of the Changes to delete. */
  changeIds: Array<Scalars['ID']['input']>;
};

export type MercuryDeleteCommentInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryDeleteCostSubtypeInput = {
  id: Scalars['ID']['input'];
};

export type MercuryDeleteCustomFieldDefinitionInput = {
  id: Scalars['ID']['input'];
};

export type MercuryDeleteCustomFieldDefinitionOptionsInput = {
  /** The ID of the custom field definition. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The option IDs to delete. */
  optionIds: Array<Scalars['ID']['input']>;
};

export type MercuryDeleteFocusAreaGoalLinkInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryDeleteFocusAreaGoalLinksInput = {
  atlasGoalAris: Array<Scalars['String']['input']>;
  focusAreaAri: Scalars['String']['input'];
};

export type MercuryDeleteFocusAreaInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryDeleteFocusAreaLinkInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryDeleteFocusAreaStatusUpdateInput = {
  cloudId: Scalars['ID']['input'];
  /** The ID of the Focus Area status update entry. */
  id: Scalars['ID']['input'];
};

export type MercuryDeleteFocusAreaWorkLinkInput = {
  cloudId: Scalars['ID']['input'];
  /** The ID of the link to delete. */
  id: Scalars['ID']['input'];
};

export type MercuryDeleteFocusAreaWorkLinksInput = {
  focusAreaAri: Scalars['String']['input'];
  workAris: Array<Scalars['String']['input']>;
};

export type MercuryDeleteInvestmentCategoryInput = {
  id: Scalars['ID']['input'];
};

export type MercuryDeletePortfolioFocusAreaLinkInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaIds: Array<Scalars['ID']['input']>;
  portfolioId: Scalars['ID']['input'];
};

export type MercuryDeletePortfolioInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryDeletePreferenceInput = {
  cloudId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
};

export type MercuryDeleteRiskInput = {
  /** The ID of the Risk to delete. */
  id: Scalars['ID']['input'];
};

export type MercuryDeleteStrategicEventCommentInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** ID of the comment to delete. */
  id: Scalars['ID']['input'];
};

export type MercuryDeleteStrategicEventInput = {
  id: Scalars['ID']['input'];
};

export type MercuryDismissSuggestedFocusAreaFollowersInput = {
  focusAreaId: Scalars['ID']['input'];
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum MercuryEntityType {
  ChangeProposal = 'CHANGE_PROPOSAL',
  Comment = 'COMMENT',
  FocusArea = 'FOCUS_AREA',
  FocusAreaStatusUpdate = 'FOCUS_AREA_STATUS_UPDATE',
  Program = 'PROGRAM',
  ProgramStatusUpdate = 'PROGRAM_STATUS_UPDATE',
  StrategicEvent = 'STRATEGIC_EVENT'
}

export enum MercuryEventType {
  Archive = 'ARCHIVE',
  Create = 'CREATE',
  CreateUpdate = 'CREATE_UPDATE',
  Delete = 'DELETE',
  DeleteUpdate = 'DELETE_UPDATE',
  EditUpdate = 'EDIT_UPDATE',
  Export = 'EXPORT',
  Import = 'IMPORT',
  Link = 'LINK',
  Unarchive = 'UNARCHIVE',
  Unlink = 'UNLINK',
  Update = 'UPDATE'
}

export type MercuryFiscalCalendarConfigurationSort = {
  field: MercuryFiscalCalendarConfigurationSortField;
  order: SortOrder;
};

export enum MercuryFiscalCalendarConfigurationSortField {
  CreatedDate = 'CREATED_DATE'
}

/**
 *  ----------------------------------------
 *   Focus Area Activity
 *  ----------------------------------------
 */
export type MercuryFocusAreaActivitySort = {
  order: SortOrder;
};

export enum MercuryFocusAreaHealthColor {
  Green = 'GREEN',
  Red = 'RED',
  Yellow = 'YELLOW'
}

export type MercuryFocusAreaHierarchySort = {
  field: MercuryFocusAreaHierarchySortField;
  order: SortOrder;
};

export enum MercuryFocusAreaHierarchySortField {
  Name = 'NAME'
}

export enum MercuryFocusAreaHierarchyTypeKey {
  Investment = 'INVESTMENT',
  Portfolio = 'PORTFOLIO'
}

export type MercuryFocusAreaInsightsFilter = {
  insightType?: InputMaybe<MercuryInsightTypeEnum>;
};

export enum MercuryFocusAreaPermission {
  Archive = 'ARCHIVE',
  CreateGoalLink = 'CREATE_GOAL_LINK',
  CreateLink = 'CREATE_LINK',
  CreateUpdate = 'CREATE_UPDATE',
  CreateWorkLink = 'CREATE_WORK_LINK',
  Delete = 'DELETE',
  DeleteGoalLink = 'DELETE_GOAL_LINK',
  DeleteLink = 'DELETE_LINK',
  DeleteUpdate = 'DELETE_UPDATE',
  DeleteWorkLink = 'DELETE_WORK_LINK',
  EditAbout = 'EDIT_ABOUT',
  EditName = 'EDIT_NAME',
  EditOwner = 'EDIT_OWNER',
  EditType = 'EDIT_TYPE',
  Export = 'EXPORT',
  ViewFund = 'VIEW_FUND'
}

export enum MercuryFocusAreaRankingValidationErrorCode {
  FaRanked = 'FA_RANKED',
  FaTypeMismatch = 'FA_TYPE_MISMATCH'
}

export type MercuryFocusAreaSort = {
  /** Either 'field' or 'fieldKey' must be provided, but not both. */
  field?: InputMaybe<MercuryFocusAreaSortField>;
  fieldKey?: InputMaybe<Scalars['String']['input']>;
  order: SortOrder;
};

export enum MercuryFocusAreaSortField {
  Budget = 'BUDGET',
  FocusAreaType = 'FOCUS_AREA_TYPE',
  HasParent = 'HAS_PARENT',
  Health = 'HEALTH',
  HierarchyLevel = 'HIERARCHY_LEVEL',
  LastUpdated = 'LAST_UPDATED',
  Name = 'NAME',
  Rank = 'RANK',
  Spend = 'SPEND',
  Starred = 'STARRED',
  Status = 'STATUS',
  TargetDate = 'TARGET_DATE',
  Watching = 'WATCHING'
}

/**
 *  ------------------------------------------------------
 *   Atlassian Intelligence
 *  ------------------------------------------------------
 */
export enum MercuryFocusAreaSummaryType {
  FocusArea = 'FOCUS_AREA',
  Goals = 'GOALS',
  Work = 'WORK'
}

export type MercuryFocusAreaTargetDateInput = {
  targetDate?: InputMaybe<Scalars['String']['input']>;
  targetDateType?: InputMaybe<MercuryTargetDateType>;
};

export type MercuryFocusAreaUserAccessInput = {
  accessLevel?: InputMaybe<MercuryFocusAreaUserAccessLevel>;
  addAsFollower?: InputMaybe<Scalars['Boolean']['input']>;
  principalId: Scalars['ID']['input'];
};

export enum MercuryFocusAreaUserAccessLevel {
  Edit = 'EDIT',
  View = 'VIEW'
}

export enum MercuryFocusAreaUserAccessReason {
  AccessGranted = 'ACCESS_GRANTED',
  AlreadyHasAccess = 'ALREADY_HAS_ACCESS',
  RequiresAppAccess = 'REQUIRES_APP_ACCESS',
  RequiresNewProductRole = 'REQUIRES_NEW_PRODUCT_ROLE',
  RequiresSiteAccess = 'REQUIRES_SITE_ACCESS'
}

export enum MercuryForYouInsightType {
  Own = 'OWN',
  Watch = 'WATCH'
}

export type MercuryForYouInsightsFilter = {
  forYouInsightType?: InputMaybe<MercuryForYouInsightType>;
  insightType?: InputMaybe<MercuryInsightTypeEnum>;
};

/**
 * ###################################################################################################################
 *  FUNDS - COMMON
 * ###################################################################################################################
 */
export enum MercuryFundsType {
  Actual = 'ACTUAL',
  Budget = 'BUDGET',
  Forecast = 'FORECAST'
}

export enum MercuryInsightTypeEnum {
  FocusArea = 'FOCUS_AREA',
  Fund = 'FUND',
  Goal = 'GOAL',
  Position = 'POSITION',
  Work = 'WORK'
}

export type MercuryInvestmentCategorySort = {
  field: MercuryInvestmentCategorySortField;
  order: SortOrder;
};

export enum MercuryInvestmentCategorySortField {
  Name = 'NAME'
}

export type MercuryInviteInput = {
  cloudId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};

export enum MercuryInviteStatus {
  Invited = 'INVITED',
  InvitedPendingApproval = 'INVITED_PENDING_APPROVAL',
  NotInvited = 'NOT_INVITED',
  PendingInviteExists = 'PENDING_INVITE_EXISTS',
  UserExists = 'USER_EXISTS'
}

export enum MercuryJiraAlignProjectTypeKey {
  JiraAlignCapability = 'JIRA_ALIGN_CAPABILITY',
  JiraAlignEpic = 'JIRA_ALIGN_EPIC',
  JiraAlignTheme = 'JIRA_ALIGN_THEME'
}

export enum MercuryJiraStatusCategoryColor {
  Blue = 'BLUE',
  Green = 'GREEN',
  Grey = 'GREY'
}

export type MercuryLinkAtlassianWorkToFocusAreaInput = {
  /** The focus area ARI the work is linked to. */
  focusAreaAri: Scalars['String']['input'];
  /** The external ARIs as they are in the 1P provider of the work to link. */
  workAris: Array<Scalars['String']['input']>;
};

/**
 *  ------------------------------------------------------
 *   Focus Area links
 *  ------------------------------------------------------
 */
export type MercuryLinkFocusAreasToFocusAreaInput = {
  childFocusAreaIds: Array<Scalars['ID']['input']>;
  cloudId: Scalars['ID']['input'];
  parentFocusAreaId: Scalars['ID']['input'];
};

/**
 *  ------------------------------------------------------
 *   Portfolio
 *  ------------------------------------------------------
 */
export type MercuryLinkFocusAreasToPortfolioInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaIds: Array<Scalars['ID']['input']>;
  portfolioId: Scalars['ID']['input'];
};

/**
 *  ----------------------------------------
 *   Goal to change proposal link mutations
 *  ----------------------------------------
 */
export type MercuryLinkGoalsToChangeProposalInput = {
  changeProposalAri: Scalars['ID']['input'];
  goalAris: Array<Scalars['ID']['input']>;
};

/**
 *  ------------------------------------------------------
 *   Goal links
 *  ------------------------------------------------------
 */
export type MercuryLinkGoalsToFocusAreaInput = {
  atlasGoalAris: Array<Scalars['String']['input']>;
  focusAreaAri: Scalars['String']['input'];
};

/**
 *  ------------------------------------------------------
 *   Work links
 *  ------------------------------------------------------
 */
export type MercuryLinkWorkToFocusAreaInput = {
  cloudId: Scalars['ID']['input'];
  /** The external IDs as they are in the 1P/3P provider of the work to link. */
  externalChildWorkIds: Array<Scalars['ID']['input']>;
  /** The focus area the work is linked to. */
  parentFocusAreaId: Scalars['ID']['input'];
  /** The provider of the work. */
  providerKey: Scalars['String']['input'];
  /** The provider container of the work(site ari for jira) */
  workContainerAri?: InputMaybe<Scalars['String']['input']>;
};

/**
 *  ------------------------------------------------------
 *  Moving Changes
 *  ------------------------------------------------------
 */
export type MercuryMoveChangesInput = {
  changeIds: Array<Scalars['ID']['input']>;
  /** The ARI of the Change Proposal the Changes are moving from. */
  sourceChangeProposalId: Scalars['ID']['input'];
  /** The ARI of the Change Proposal the Changes are moving to. */
  targetChangeProposalId: Scalars['ID']['input'];
};

export type MercuryMoveFundsChangeInput = {
  /** The amount of funds being requested to move. */
  amount: Scalars['BigDecimal']['input'];
  /** The ARI of the Focus Area the Funds are being requested to move to. */
  sourceFocusAreaId: Scalars['ID']['input'];
  /** The ARI of the Focus Area the Funds are being requested for. */
  targetFocusAreaId: Scalars['ID']['input'];
};

export type MercuryMovePositionsChangeInput = {
  /** The cost of the positions. */
  cost?: InputMaybe<Scalars['BigDecimal']['input']>;
  /** The amount of positions being requested to move. */
  positionsAmount: Scalars['Int']['input'];
  /** The ARI of the Focus Area the Positions are being requested to move to. */
  sourceFocusAreaId: Scalars['ID']['input'];
  /** The ARI of the Focus Area the Positions are being requested for. */
  targetFocusAreaId: Scalars['ID']['input'];
};

export type MercuryMultiSelectCustomFieldInput = {
  /** The option IDs to set on the custom field. */
  options?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum MercuryNormalizedWorkStatusColor {
  Blue = 'BLUE',
  Gray = 'GRAY',
  Green = 'GREEN',
  Red = 'RED',
  Yellow = 'YELLOW'
}

export enum MercuryNormalizedWorkTargetDateType {
  Day = 'DAY',
  Month = 'MONTH',
  Quarter = 'QUARTER'
}

export type MercuryNumberCustomFieldInput = {
  numberValue?: InputMaybe<Scalars['Float']['input']>;
};

export enum MercuryPermission {
  ArchiveFocusArea = 'ARCHIVE_FOCUS_AREA',
  CreateFocusArea = 'CREATE_FOCUS_AREA',
  CreateFocusAreaGoalLink = 'CREATE_FOCUS_AREA_GOAL_LINK',
  CreateFocusAreaLink = 'CREATE_FOCUS_AREA_LINK',
  CreateFocusAreaUpdate = 'CREATE_FOCUS_AREA_UPDATE',
  CreateFocusAreaWorkLink = 'CREATE_FOCUS_AREA_WORK_LINK',
  CreateProposal = 'CREATE_PROPOSAL',
  CreateStrategicEvent = 'CREATE_STRATEGIC_EVENT',
  DeleteFocusArea = 'DELETE_FOCUS_AREA',
  DeleteFocusAreaGoalLink = 'DELETE_FOCUS_AREA_GOAL_LINK',
  DeleteFocusAreaLink = 'DELETE_FOCUS_AREA_LINK',
  DeleteFocusAreaUpdate = 'DELETE_FOCUS_AREA_UPDATE',
  DeleteFocusAreaView = 'DELETE_FOCUS_AREA_VIEW',
  DeleteFocusAreaWorkLink = 'DELETE_FOCUS_AREA_WORK_LINK',
  DeleteProposal = 'DELETE_PROPOSAL',
  DeleteStrategicEvent = 'DELETE_STRATEGIC_EVENT',
  EditFocusAreaAbout = 'EDIT_FOCUS_AREA_ABOUT',
  EditFocusAreaName = 'EDIT_FOCUS_AREA_NAME',
  EditFocusAreaOwner = 'EDIT_FOCUS_AREA_OWNER',
  EditFocusAreaType = 'EDIT_FOCUS_AREA_TYPE',
  EditProposal = 'EDIT_PROPOSAL',
  EditProposalStatus = 'EDIT_PROPOSAL_STATUS',
  EditStrategicEvent = 'EDIT_STRATEGIC_EVENT',
  ExportFocusArea = 'EXPORT_FOCUS_AREA',
  ExportFocusAreaView = 'EXPORT_FOCUS_AREA_VIEW',
  Manage = 'MANAGE',
  Read = 'READ',
  ViewFocusAreaFund = 'VIEW_FOCUS_AREA_FUND',
  ViewStrategicEvent = 'VIEW_STRATEGIC_EVENT',
  Write = 'WRITE'
}

export type MercuryPositionAllocationChangeInput = {
  /** The ARI of the Position being allocated. */
  positionId: Scalars['ID']['input'];
  /** The ARI of the Focus Area the Position is being allocated from. */
  sourceFocusAreaId?: InputMaybe<Scalars['ID']['input']>;
  /** The ARI of the Focus Area the Position is being allocated to. */
  targetFocusAreaId: Scalars['ID']['input'];
};

export enum MercuryProjectStatusColor {
  Blue = 'BLUE',
  Gray = 'GRAY',
  Green = 'GREEN',
  /** @deprecated Mercury does not require this colour */
  Red = 'RED',
  /** @deprecated Mercury does not require this colour */
  Yellow = 'YELLOW'
}

export enum MercuryProjectTargetDateType {
  Day = 'DAY',
  Month = 'MONTH',
  Quarter = 'QUARTER'
}

/**
 * ###################################################################################################################
 *  CHANGE - MUTATION TYPES
 * ###################################################################################################################
 *  ------------------------------------------------------
 *  Proposing Changes
 *  ------------------------------------------------------
 */
export type MercuryProposeChangesInput = {
  /** Proposed Focus Area archive changes. */
  archiveFocusAreas?: InputMaybe<Array<MercuryArchiveFocusAreaChangeInput>>;
  /** Proposed Focus Area parent changes. */
  changeParentFocusAreas?: InputMaybe<Array<MercuryChangeParentFocusAreaChangeInput>>;
  /** The ARI of the Change Proposal the Change should be associated with. */
  changeProposalId: Scalars['ID']['input'];
  /** Proposed Focus Area creation changes. */
  createFocusAreas?: InputMaybe<Array<MercuryCreateFocusAreaChangeInput>>;
  /**
   * Indicates whether the changes should be applied/implemented immediately.
   * Defaults to true for this R4. Will likely be removed post R4.
   */
  implementFocusAreaChanges?: InputMaybe<Scalars['Boolean']['input']>;
  /** Proposed Funds move changes. */
  moveFunds?: InputMaybe<Array<MercuryMoveFundsChangeInput>>;
  /** Proposed Position move changes. */
  movePositions?: InputMaybe<Array<MercuryMovePositionsChangeInput>>;
  /** Proposed Position allocation changes. */
  positionAllocations?: InputMaybe<Array<MercuryPositionAllocationChangeInput>>;
  /** Proposed Focus Area rename changes. */
  renameFocusAreas?: InputMaybe<Array<MercuryRenameFocusAreaChangeInput>>;
  /** Proposed Funds request changes. */
  requestFunds?: InputMaybe<Array<MercuryRequestFundsChangeInput>>;
  /** Proposed Position request changes. */
  requestPositions?: InputMaybe<Array<MercuryRequestPositionsChangeInput>>;
};

export enum MercuryProviderConfigurationStatus {
  Connected = 'CONNECTED',
  SignUp = 'SIGN_UP'
}

export enum MercuryProviderWorkErrorType {
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  NoPermissions = 'NO_PERMISSIONS'
}

export type MercuryProviderWorkSearchFilters = {
  jql?: InputMaybe<Scalars['String']['input']>;
  project?: InputMaybe<MercuryProviderWorkSearchProjectFilters>;
};

export type MercuryProviderWorkSearchProjectFilters = {
  type?: InputMaybe<Scalars['String']['input']>;
};

export enum MercuryProviderWorkStatusColor {
  Blue = 'BLUE',
  Gray = 'GRAY',
  Green = 'GREEN',
  Red = 'RED',
  Yellow = 'YELLOW'
}

export enum MercuryProviderWorkTargetDateType {
  Day = 'DAY',
  Month = 'MONTH',
  Quarter = 'QUARTER'
}

export type MercuryPublishFocusAreaInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  id: Scalars['ID']['input'];
};

export type MercuryRecreatePortfolioFocusAreasInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaIds: Array<Scalars['ID']['input']>;
  id: Scalars['ID']['input'];
  rankVersion?: InputMaybe<Scalars['String']['input']>;
};

export type MercuryRemoveTagsFromProposalInput = {
  /** The ID of the Change Proposal to remove tags from. */
  changeProposalId: Scalars['ID']['input'];
  /** The list of tag ARIs to remove from a proposal. */
  tagIds: Array<Scalars['ID']['input']>;
};

export type MercuryRemoveUserAccessToFocusAreaInput = {
  focusAreaAri: Scalars['ID']['input'];
  principalIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type MercuryRemoveWatcherFromFocusAreaInput = {
  cloudId: Scalars['ID']['input'];
  focusAreaId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};

export type MercuryRenameFocusAreaChangeInput = {
  /** The new name of the Focus Area (current value calculated from current). */
  newFocusAreaName: Scalars['String']['input'];
  /** The ARI of the Focus Area being renamed. */
  targetFocusAreaId: Scalars['ID']['input'];
};

export type MercuryReorderCustomFieldDefinitionOptionsInput = {
  /** The ID of the custom field definition. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The option IDs in the desired order. */
  optionIds: Array<Scalars['ID']['input']>;
};

export type MercuryRequestFundsChangeInput = {
  /** The amount of funds being requested for. */
  amount: Scalars['BigDecimal']['input'];
  /** The ARI of the Focus Area the Funds are being requested for. */
  targetFocusAreaId: Scalars['ID']['input'];
};

export type MercuryRequestPositionsChangeInput = {
  /** The cost of the positions. */
  cost?: InputMaybe<Scalars['BigDecimal']['input']>;
  /** The amount of positions being requested. */
  positionsAmount?: InputMaybe<Scalars['Int']['input']>;
  /** The ARI of the Focus Area the Positions are being requested for. */
  targetFocusAreaId: Scalars['ID']['input'];
};

export enum MercuryRiskStatusColor {
  Gray = 'GRAY',
  Red = 'RED'
}

export type MercurySetChangeProposalCustomFieldInput = {
  /** The ARI of the change proposal to update. */
  changeProposalId: Scalars['ID']['input'];
  /** Input for core custom field types. */
  coreField?: InputMaybe<MercuryCustomFieldInput>;
  /** The ARI of the custom field definition to set the value for. */
  customFieldDefinitionId: Scalars['ID']['input'];
};

/**
 *  ----------------------------------------
 *   Custom fields (instances)
 *  ----------------------------------------
 */
export type MercurySetFocusAreaCustomFieldInput = {
  /** Input for core custom field types. */
  coreField?: InputMaybe<MercuryCustomFieldInput>;
  /** The ARI of the custom field definition to set the value for. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The ARI of the focus area to update. */
  focusAreaId: Scalars['ID']['input'];
};

/** Input for setting multiple custom fields */
export type MercurySetFocusAreaCustomFieldsInput = {
  /** Cloud ID only when routing via AGG */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** List of custom field to set. */
  customFields: Array<MercurySetFocusAreaCustomFieldInput>;
};

/**
 *  ----------------------------------------
 *   Preference Mutations
 *  ----------------------------------------
 */
export type MercurySetPreferenceInput = {
  cloudId: Scalars['ID']['input'];
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type MercurySingleSelectCustomFieldInput = {
  option?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * ###################################################################################################################
 *  STRATEGIC EVENTS - COMMON
 * ###################################################################################################################
 */
export enum MercuryStatusColor {
  Blue = 'BLUE',
  Gray = 'GRAY',
  Green = 'GREEN',
  Red = 'RED',
  Yellow = 'YELLOW'
}

export type MercuryStrategicEventSort = {
  field: MercuryStrategicEventSortField;
  order: SortOrder;
};

export enum MercuryStrategicEventSortField {
  Name = 'NAME',
  Status = 'STATUS',
  TargetDate = 'TARGET_DATE'
}

export enum MercuryTargetDateType {
  Day = 'DAY',
  Month = 'MONTH',
  Quarter = 'QUARTER'
}

export type MercuryTextCustomFieldInput = {
  textValue?: InputMaybe<Scalars['String']['input']>;
};

export type MercuryTransitionChangeProposalStatusInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the Change Proposal to transition. */
  id: Scalars['ID']['input'];
  /** The ID of the status transition to apply. */
  statusTransitionId: Scalars['ID']['input'];
};

/**
 *  ----------------------------------------
 *   Focus Area workflow mutations
 *  ----------------------------------------
 */
export type MercuryTransitionFocusAreaStatusInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
  statusTransitionId: Scalars['ID']['input'];
};

export type MercuryTransitionRiskStatusInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the Risk to transition. */
  id: Scalars['ID']['input'];
  /** The ID of the status transition to apply. */
  statusTransitionId: Scalars['ID']['input'];
};

export type MercuryTransitionStrategicEventStatusInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the Strategic Event to transition. */
  id: Scalars['ID']['input'];
  /** The ID of the status transition to apply. */
  statusTransitionId: Scalars['ID']['input'];
};

export type MercuryUnarchiveFocusAreaInput = {
  cloudId: Scalars['ID']['input'];
  comment?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export type MercuryUnlinkGoalsFromChangeProposalInput = {
  changeProposalAri: Scalars['ID']['input'];
  goalAris: Array<Scalars['ID']['input']>;
};

export type MercuryUnrankChangeProposalInViewInput = {
  /** The ARI of the Change Proposals to remove. */
  changeProposalId: Scalars['ID']['input'];
  /** The ARI of the Change Proposals View to remove Change Proposals from. */
  changeProposalsViewId: Scalars['ID']['input'];
};

export type MercuryUpdateChangeFocusAreaInput = {
  /**
   * The ARI of the Focus Area.
   *
   * Omit or set this field to null to clear the value.
   */
  focusAreaId?: InputMaybe<Scalars['ID']['input']>;
};

export type MercuryUpdateChangeMonetaryAmountInput = {
  /**
   * Monetary amount, e.g. cost, fundsAmount, etc.
   *
   * Omit or set this field to null to clear the value.
   */
  monetaryAmount?: InputMaybe<Scalars['BigDecimal']['input']>;
};

export type MercuryUpdateChangeNoteInput = {
  /**
   * The reason or business justification for the change.
   *
   * Omit or set this field to null to clear the value.
   */
  note?: InputMaybe<Scalars['String']['input']>;
};

export type MercuryUpdateChangeProposalCommentInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The new content of the comment. */
  content: Scalars['String']['input'];
  /** ID of the comment to update. */
  id: Scalars['ID']['input'];
};

export type MercuryUpdateChangeProposalDescriptionInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The new description of the Change Proposal. */
  description: Scalars['String']['input'];
  /** The ID of the Change Proposal to update. */
  id: Scalars['ID']['input'];
};

export type MercuryUpdateChangeProposalFocusAreaInput = {
  /** The new ID of the Focus Area the Change Proposal is associated with. If not set, the Change Proposal will be disassociated from the Focus Area. */
  focusAreaId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the Change Proposal to update. */
  id: Scalars['ID']['input'];
};

export type MercuryUpdateChangeProposalImpactInput = {
  /** The ID of the Change Proposal to update. */
  id: Scalars['ID']['input'];
  /** The new expected impact of the Change Proposal. */
  impact: Scalars['Int']['input'];
};

export type MercuryUpdateChangeProposalNameInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the Change Proposal to update. */
  id: Scalars['ID']['input'];
  /** The new name of the Change Proposal. */
  name: Scalars['String']['input'];
};

export type MercuryUpdateChangeProposalOwnerInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the Change Proposal to update. */
  id: Scalars['ID']['input'];
  /** The owner of the Change Proposal. The Atlassian Account ID (not full ARI) */
  owner: Scalars['ID']['input'];
};

export type MercuryUpdateChangeProposalRankInViewInput = {
  /**
   * The Change Proposal ID before which new Change Proposal will be positioned
   * If null, the Change Proposal will be added to the end of the list
   */
  beforeChangeProposalId?: InputMaybe<Scalars['ID']['input']>;
  /** The ARI of the Change Proposal to add. */
  changeProposalId: Scalars['ID']['input'];
  /** The ARI of the Change Proposals View to add the Change Proposal to. */
  changeProposalsViewId: Scalars['ID']['input'];
};

export type MercuryUpdateChangeProposalsViewNameInput = {
  /** The ARI of the Change Proposals View to update. */
  id: Scalars['ID']['input'];
  /** The new name for the Change Proposals View. */
  name: Scalars['String']['input'];
};

export type MercuryUpdateChangeProposalsViewSettingsInput = {
  /** The ARI of the Change Proposals View to update. */
  id: Scalars['ID']['input'];
  /** The settings for the Change Proposals View. A null value for a key will remove that setting. */
  settings?: InputMaybe<Array<InputMaybe<MercuryViewSettingInput>>>;
};

export type MercuryUpdateChangeQuantityInput = {
  /**
   * Quantity, e.g. positionCount, numberOfPositions, etc.
   *
   * Omit or set this field to null to clear the value.
   */
  quantity?: InputMaybe<Scalars['Int']['input']>;
};

export type MercuryUpdateCommentInput = {
  cloudId: Scalars['ID']['input'];
  commentText: Scalars['MercuryJSONString']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryUpdateCostSubtypeNameInput = {
  id: Scalars['ID']['input'];
  /** The name of the Cost Subtype. */
  name: Scalars['String']['input'];
};

export type MercuryUpdateCustomFieldDefinitionDescriptionInput = {
  /** Updated description for the payload. Nullable as a way to unset the description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of a custom field definition. */
  id: Scalars['ID']['input'];
};

export type MercuryUpdateCustomFieldDefinitionNameInput = {
  /** The ID of a custom field definition. */
  id: Scalars['ID']['input'];
  /** The new display name of the custom field. */
  name: Scalars['String']['input'];
};

export type MercuryUpdateCustomFieldDefinitionOptionInput = {
  /** The ID of the custom field definition. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** The ID of the option to update. */
  optionId: Scalars['ID']['input'];
  /** The settings for the option. */
  settings?: InputMaybe<Array<MercuryCustomFieldSelectionOptionSettingInput>>;
  /** The new value for the option. */
  value?: InputMaybe<Scalars['String']['input']>;
};

export type MercuryUpdateFocusAreaAboutContentInput = {
  aboutContent: Scalars['String']['input'];
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryUpdateFocusAreaHierarchyNameInput = {
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

export type MercuryUpdateFocusAreaNameInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

export type MercuryUpdateFocusAreaOwnerInput = {
  aaid: Scalars['String']['input'];
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

export type MercuryUpdateFocusAreaStatusUpdateInput = {
  cloudId: Scalars['ID']['input'];
  /** The ID of the Focus Area status update entry. */
  id: Scalars['ID']['input'];
  /** The new target date for the Focus Area. */
  newTargetDate?: InputMaybe<MercuryFocusAreaTargetDateInput>;
  /** The ID of the status to transition the Focus Area to as part of the update. */
  statusTransitionId?: InputMaybe<Scalars['ID']['input']>;
  /** Summary text (ADF) for the update. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

export type MercuryUpdateFocusAreaTargetDateInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
  targetDate?: InputMaybe<Scalars['String']['input']>;
  targetDateType?: InputMaybe<MercuryTargetDateType>;
};

export type MercuryUpdateInvestmentCategoryNameInput = {
  id: Scalars['ID']['input'];
  /** The name of the Investment Category. */
  name: Scalars['String']['input'];
};

export type MercuryUpdateMoveFundsChangeInput = {
  /** The amount of funds being requested. */
  amount?: InputMaybe<MercuryUpdateChangeMonetaryAmountInput>;
  /** The ARI of the Change. */
  changeId: Scalars['ID']['input'];
  /** The reason or business justification for the change. */
  note?: InputMaybe<MercuryUpdateChangeNoteInput>;
  /** The ARI of the Focus Area the Funds are being requested to move to. */
  sourceFocusAreaId?: InputMaybe<MercuryUpdateChangeFocusAreaInput>;
  /** The ARI of the Focus Area the Funds are being requested for. */
  targetFocusAreaId?: InputMaybe<MercuryUpdateChangeFocusAreaInput>;
};

export type MercuryUpdateMovePositionsChangeInput = {
  /** The ARI of the Change. */
  changeId: Scalars['ID']['input'];
  /** The cost of the positions. */
  cost?: InputMaybe<MercuryUpdateChangeMonetaryAmountInput>;
  /** The reason or business justification for the change. */
  note?: InputMaybe<MercuryUpdateChangeNoteInput>;
  /** The amount of positions being requested. */
  positionsAmount?: InputMaybe<MercuryUpdateChangeQuantityInput>;
  /** The ARI of the Focus Area the Positions are being requested to move to. */
  sourceFocusAreaId?: InputMaybe<MercuryUpdateChangeFocusAreaInput>;
  /** The ARI of the Focus Area the Positions are being requested for. */
  targetFocusAreaId?: InputMaybe<MercuryUpdateChangeFocusAreaInput>;
};

export type MercuryUpdatePortfolioNameInput = {
  cloudId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

export type MercuryUpdateRequestFundsChangeInput = {
  /** The amount of funds being requested for. */
  amount?: InputMaybe<MercuryUpdateChangeMonetaryAmountInput>;
  /** The ARI of the Change. */
  changeId: Scalars['ID']['input'];
  /** The reason or business justification for the change. */
  note?: InputMaybe<MercuryUpdateChangeNoteInput>;
  /** The ARI of the Focus Area the Funds are being requested for. */
  targetFocusAreaId?: InputMaybe<MercuryUpdateChangeFocusAreaInput>;
};

export type MercuryUpdateRequestPositionsChangeInput = {
  /** The ARI of the Change. */
  changeId: Scalars['ID']['input'];
  /** The cost of the positions. */
  cost?: InputMaybe<MercuryUpdateChangeMonetaryAmountInput>;
  /** The reason or business justification for the change. */
  note?: InputMaybe<MercuryUpdateChangeNoteInput>;
  /** The amount of positions being requested. */
  positionsAmount?: InputMaybe<MercuryUpdateChangeQuantityInput>;
  /** The ARI of the Focus Area the Positions are being requested for. */
  targetFocusAreaId?: InputMaybe<MercuryUpdateChangeFocusAreaInput>;
};

export type MercuryUpdateRiskDescriptionInput = {
  /** The new description of the Risk. */
  description: Scalars['String']['input'];
  /** The ID of the Risk to update. */
  id: Scalars['ID']['input'];
};

export type MercuryUpdateRiskNameInput = {
  /** The ID of the Risk to update. */
  id: Scalars['ID']['input'];
  /** The new name of the Risk. */
  name: Scalars['String']['input'];
};

export type MercuryUpdateRiskOwnerInput = {
  /** The ID of the Risk to update. */
  id: Scalars['ID']['input'];
  /** The new owner of the Risk. */
  owner: Scalars['ID']['input'];
};

export type MercuryUpdateStrategicEventBudgetInput = {
  /** The new budget for the Strategic Event. */
  budget?: InputMaybe<Scalars['BigDecimal']['input']>;
  /** The ID of the Strategic Event to update. */
  id: Scalars['ID']['input'];
};

export type MercuryUpdateStrategicEventCommentInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The new content of the comment. */
  content: Scalars['String']['input'];
  /** ID of the comment to update. */
  id: Scalars['ID']['input'];
};

export type MercuryUpdateStrategicEventDescriptionInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The new description of the Strategic Event. */
  description: Scalars['String']['input'];
  /** The ID of the Strategic Event to update. */
  id: Scalars['ID']['input'];
};

export type MercuryUpdateStrategicEventNameInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the Strategic Event to update. */
  id: Scalars['ID']['input'];
  /** The new name of the Strategic Event. */
  name: Scalars['String']['input'];
};

export type MercuryUpdateStrategicEventOwnerInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the Strategic Event to update. */
  id: Scalars['ID']['input'];
  /** The owner of the Strategic Event. The Atlassian Account ID (not full ARI) */
  owner: Scalars['ID']['input'];
};

export type MercuryUpdateStrategicEventTargetDateInput = {
  /** The site ID. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the Strategic Event to update. */
  id: Scalars['ID']['input'];
  /** The new target date of the Strategic Event. */
  targetDate?: InputMaybe<Scalars['String']['input']>;
};

export type MercuryValidateFocusAreasForRankingInput = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  focusAreaIds: Array<Scalars['ID']['input']>;
  rankingViewId?: InputMaybe<Scalars['ID']['input']>;
};

export type MercuryViewSettingInput = {
  key: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export enum MercuryViewType {
  HierarchyView = 'HIERARCHY_VIEW',
  RankingView = 'RANKING_VIEW'
}

export enum MercuryWorkTargetDateType {
  Day = 'DAY',
  Month = 'MONTH',
  Quarter = 'QUARTER'
}

export type MigrateComponentTypeInput = {
  /** The ID of the component type to which components will be migrated. */
  destinationTypeId: Scalars['ID']['input'];
  /** The ID of the component type from which components will be migrated. */
  sourceTypeId: Scalars['ID']['input'];
};

/** An enum of the possible statuses of a migration event. */
export enum MigrationEventStatus {
  Cancelled = 'CANCELLED',
  Cancelling = 'CANCELLING',
  Failed = 'FAILED',
  Incomplete = 'INCOMPLETE',
  InProgress = 'IN_PROGRESS',
  Paused = 'PAUSED',
  Ready = 'READY',
  Skipped = 'SKIPPED',
  Success = 'SUCCESS',
  TimedOut = 'TIMED_OUT'
}

/** An enum of the possible types of a migration event. */
export enum MigrationEventType {
  Container = 'CONTAINER',
  Migration = 'MIGRATION',
  Transfer = 'TRANSFER'
}

export enum MissionControlFeatureDiscoverySuggestion {
  SpaceManager = 'SPACE_MANAGER',
  SpaceReports = 'SPACE_REPORTS',
  UserAccess = 'USER_ACCESS'
}

export type MissionControlFeatureDiscoverySuggestionInput = {
  /** Date & time of dismissal in mm/dd/yyyy hh:mm:ss */
  dismissalDateTime?: InputMaybe<Scalars['String']['input']>;
  suggestion: MissionControlFeatureDiscoverySuggestion;
  /** Timezone for dismissalDateTime. If null, timezone will default to UTC */
  timezone?: InputMaybe<Scalars['String']['input']>;
};

export enum MissionControlMetricSuggestion {
  DeactivatedPageOwners = 'DEACTIVATED_PAGE_OWNERS',
  InactivePages = 'INACTIVE_PAGES',
  UnassignedGuests = 'UNASSIGNED_GUESTS'
}

export type MissionControlMetricSuggestionInput = {
  /** Date & time of dismissal in mm/dd/yyyy hh:mm:ss */
  dismissalDateTime?: InputMaybe<Scalars['String']['input']>;
  /** spaceId of suggestion, should be set to null if suggestion applies to site-wide Mission Control */
  spaceId?: InputMaybe<Scalars['Long']['input']>;
  suggestion: MissionControlMetricSuggestion;
  /** Timezone for dismissalDateTime. If null, timezone will default to UTC */
  timezone?: InputMaybe<Scalars['String']['input']>;
  /** Value of metric-based suggestion, either percentage or count */
  value: Scalars['Int']['input'];
};

export type MissionControlOverview = {
  metricOrder: Array<InputMaybe<Scalars['String']['input']>>;
  spaceId?: InputMaybe<Scalars['Long']['input']>;
};

export enum MobilePlatform {
  Android = 'ANDROID',
  Ios = 'IOS'
}

export type ModelRequestParams = {
  caller: Scalars['String']['input'];
  experience: Scalars['String']['input'];
};

export type MoveBlogInput = {
  blogPostId: Scalars['Long']['input'];
  targetSpaceId: Scalars['Long']['input'];
};

export type MovePageAsChildInput = {
  pageId: Scalars['ID']['input'];
  parentId: Scalars['ID']['input'];
};

export type MovePageAsSiblingInput = {
  pageId: Scalars['ID']['input'];
  siblingId: Scalars['ID']['input'];
};

export type MovePageTopLevelInput = {
  pageId: Scalars['ID']['input'];
  targetSpaceKey: Scalars['String']['input'];
};

/** Move sprint down */
export type MoveSprintDownInput = {
  boardId: Scalars['ID']['input'];
  sprintId: Scalars['ID']['input'];
};

/** Move sprint up */
export type MoveSprintUpInput = {
  boardId: Scalars['ID']['input'];
  sprintId: Scalars['ID']['input'];
};

export type MyActivityFilter = {
  arguments?: InputMaybe<ActivityFilterArgs>;
  /** set of top-level container ARIs (ex: Cloud ID, workspace ID) */
  rootContainerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Defines relationship between the filter arguments. Default: AND */
  type?: InputMaybe<ActivitiesFilterType>;
};

/**  =========================== */
export type NadelBatchObjectIdentifiedBy = {
  resultId: Scalars['String']['input'];
  sourceId: Scalars['String']['input'];
};

/** This allows you to hydrate new values into fields */
export type NadelHydrationArgument = {
  name: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** Specify a condition for the hydration to activate */
export type NadelHydrationCondition = {
  result: NadelHydrationResultCondition;
};

/** This allows you to hydrate new values into fields with the @hydratedFrom directive */
export type NadelHydrationFromArgument = {
  name: Scalars['String']['input'];
  valueFromArg?: InputMaybe<Scalars['String']['input']>;
  valueFromField?: InputMaybe<Scalars['String']['input']>;
};

/** Specify a condition for the hydration to activate based on the result */
export type NadelHydrationResultCondition = {
  predicate: NadelHydrationResultFieldPredicate;
  /** The exact name of the field to use, do not prefix with $source */
  sourceField: Scalars['String']['input'];
};

export type NadelHydrationResultFieldPredicate = {
  /** Can be Int, Boolean or String */
  equals?: InputMaybe<Scalars['JSON']['input']>;
  /** Supply a regex that the resulting String should match */
  matches?: InputMaybe<Scalars['String']['input']>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

/** This can be extended with new enums which are templates */
export enum NadelHydrationTemplate {
  NadelPlaceholder = 'NADEL_PLACEHOLDER'
}

export type NestedPageInput = {
  areChildrenIncluded?: InputMaybe<Scalars['Boolean']['input']>;
  excludedBranchRootPageIDs?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  isSelected?: InputMaybe<Scalars['Boolean']['input']>;
  pageID: Scalars['Long']['input'];
};

/**  Minimal details required to create a new card (as opposed to Card which is everything). */
export type NewCard = {
  assigneeId?: InputMaybe<Scalars['ID']['input']>;
  fixVersions?: InputMaybe<Array<Scalars['ID']['input']>>;
  issueTypeId: Scalars['ID']['input'];
  labels?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  parentId?: InputMaybe<Scalars['ID']['input']>;
  summary: Scalars['String']['input'];
};

export type NewCardParent = {
  issueTypeId: Scalars['ID']['input'];
  summary: Scalars['String']['input'];
};

export type NewPageInput = {
  page: PageInput;
  space: SpaceInput;
};

export type NewSplitIssueRequest = {
  destinationId?: InputMaybe<Scalars['ID']['input']>;
  estimate?: InputMaybe<Scalars['String']['input']>;
  estimateFieldId?: InputMaybe<Scalars['String']['input']>;
  summary: Scalars['String']['input'];
};

export enum NlpDisclaimer {
  WhoQuestion = 'WHO_QUESTION'
}

export enum NlpErrorState {
  AcceptableUseViolations = 'ACCEPTABLE_USE_VIOLATIONS',
  AiDisabled = 'AI_DISABLED',
  NoAnswer = 'NO_ANSWER',
  NoAnswerHydration = 'NO_ANSWER_HYDRATION',
  NoAnswerKeywords = 'NO_ANSWER_KEYWORDS',
  NoAnswerOpenAiResponseErr = 'NO_ANSWER_OPEN_AI_RESPONSE_ERR',
  NoAnswerRelevantContent = 'NO_ANSWER_RELEVANT_CONTENT',
  NoAnswerSearchResults = 'NO_ANSWER_SEARCH_RESULTS',
  NoAnswerWhoQuestion = 'NO_ANSWER_WHO_QUESTION',
  OpenaiRateLimitUserAbuse = 'OPENAI_RATE_LIMIT_USER_ABUSE',
  SubjectiveQuery = 'SUBJECTIVE_QUERY'
}

/** For Reading Aids */
export enum NlpGetKeywordsTextFormat {
  Adf = 'ADF',
  PlainText = 'PLAIN_TEXT'
}

export type NlpGetKeywordsTextInput = {
  format: NlpGetKeywordsTextFormat;
  text: Scalars['String']['input'];
};

export enum NlpSearchResultFormat {
  Adf = 'ADF',
  Json = 'JSON',
  Markdown = 'MARKDOWN',
  PlainText = 'PLAIN_TEXT'
}

export enum NlpSearchResultType {
  Blogpost = 'blogpost',
  Page = 'page',
  User = 'user'
}

export type NotesByCreatorInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isAscending?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<NotesByDateLastModifiedOrder>;
};

export enum NotesByDateLastModifiedOrder {
  DateLastModified = 'DATE_LAST_MODIFIED'
}

export enum NotesContentType {
  Livedoc = 'LIVEDOC',
  Page = 'PAGE'
}

export enum NotesProduct {
  Confluence = 'CONFLUENCE'
}

export enum NotificationAction {
  DontNotify = 'DONT_NOTIFY',
  Notify = 'NOTIFY'
}

export type NumberUserInput = {
  type: NumberUserInputType;
  value?: InputMaybe<Scalars['Float']['input']>;
  variableName: Scalars['String']['input'];
};

export enum NumberUserInputType {
  Number = 'NUMBER'
}

export type OfflineUserAuthTokenForExtensionInput = {
  contextIds: Array<Scalars['ID']['input']>;
  extensionId: Scalars['ID']['input'];
  userId: Scalars['String']['input'];
};

export type OfflineUserAuthTokenInput = {
  contextIds: Array<Scalars['ID']['input']>;
  userId: Scalars['String']['input'];
};

export type OnboardingStateInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export enum Operation {
  Assigned = 'ASSIGNED',
  Complete = 'COMPLETE',
  Deleted = 'DELETED',
  InComplete = 'IN_COMPLETE',
  Reworded = 'REWORDED',
  Unassigned = 'UNASSIGNED'
}

export type OperationCheckResultInput = {
  operation: Scalars['String']['input'];
  targetType: Scalars['String']['input'];
};

export type OriginalSplitIssue = {
  destinationId?: InputMaybe<Scalars['ID']['input']>;
  estimate?: InputMaybe<Scalars['String']['input']>;
  estimateFieldId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  summary: Scalars['String']['input'];
};

export enum OutputDeviceType {
  Desktop = 'DESKTOP',
  Email = 'EMAIL',
  Mobile = 'MOBILE'
}

export type PeapConfluenceSiteEnrollmentMutationInput = {
  cloudId: Scalars['ID']['input'];
  desiredStatus: Scalars['Boolean']['input'];
  programId: Scalars['ID']['input'];
};

export type PeapConfluenceSiteEnrollmentQueryInput = {
  cloudId: Scalars['ID']['input'];
  programId: Scalars['ID']['input'];
};

/**
 * input PEAPSiteEnrollmentQueryInput {
 *   programId: ID!
 *   cloudId: ID! #@ARI(....)
 * }
 *  input PEAPUserSiteEnrollmentQueryInput {
 *    programId: ID!
 *    cloudId: ID! #@ARI(....)
 *  }
 *  input PEAPOrgEnrollmentQueryInput {
 *    programId: ID!
 *    orgId: ID! @ARI(type: "org", owner: "platform")
 *  }
 *  input PEAPOrgUserEnrollmentQueryInput {
 *    programId: ID!
 *    orgId: ID! @ARI(type: "org", owner: "platform")
 *  }
 */
export type PeapJiraSiteEnrollmentMutationInput = {
  cloudId: Scalars['ID']['input'];
  desiredStatus: Scalars['Boolean']['input'];
  programId: Scalars['ID']['input'];
};

export type PeapJiraSiteEnrollmentQueryInput = {
  cloudId: Scalars['ID']['input'];
  programId: Scalars['ID']['input'];
};

/** Parameters that can be used to create new EAPs */
export type PeapNewProgramInput = {
  /** A short name that provides a crisp summary of the EAP */
  name: Scalars['String']['input'];
  /** Optionally specify the staffID of the EAP owner. If not specified, you will be the owner */
  owner?: InputMaybe<Scalars['String']['input']>;
};

/** All status values for EAPs */
export enum PeapProgramStatus {
  Abandoned = 'ABANDONED',
  Active = 'ACTIVE',
  Ended = 'ENDED',
  New = 'NEW'
}

/** Query Parameters when looking for EAPs */
export type PeapQueryParams = {
  /** Any term that should be used to lookup EAPs by name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** An array of statuses, to lookup EAPs that are only in any of the given statuses */
  status?: InputMaybe<Array<PeapProgramStatus>>;
};

/** Parameters that can be used to update existing EAPs */
export type PeapUpdateProgramInput = {
  /** A short name that provides a crisp summary of the EAP */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Optionally specify the staffID of the EAP owner. If not specified, you will be the owner */
  owner?: InputMaybe<Scalars['String']['input']>;
};

export enum PtGraphQlPageStatus {
  Current = 'CURRENT',
  Draft = 'DRAFT',
  Historical = 'HISTORICAL',
  Trashed = 'TRASHED'
}

export enum PageActivityAction {
  Created = 'created',
  Published = 'published',
  Snapshotted = 'snapshotted',
  Started = 'started',
  Updated = 'updated'
}

export enum PageActivityActionSubject {
  Comment = 'comment',
  Page = 'page'
}

/** Type of metric to group by */
export enum PageAnalyticsCountType {
  All = 'ALL',
  User = 'USER'
}

/** Type of metric to group by */
export enum PageAnalyticsTimeseriesCountType {
  All = 'ALL'
}

export type PageBodyInput = {
  representation?: InputMaybe<BodyFormatType>;
  value: Scalars['String']['input'];
};

export enum PageCardInPageTreeHoverPreference {
  NoOptionSelected = 'NO_OPTION_SELECTED',
  NoShowPagecard = 'NO_SHOW_PAGECARD',
  ShowPagecard = 'SHOW_PAGECARD'
}

export enum PageCopyRestrictionValidationStatus {
  InvalidMultiple = 'INVALID_MULTIPLE',
  InvalidSingle = 'INVALID_SINGLE',
  Valid = 'VALID'
}

export type PageGroupRestrictionInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
};

export type PageInput = {
  /**  the parent page ID, default is no parent page (i.e. root page in the space) */
  body?: InputMaybe<PageBodyInput>;
  parentId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<PageStatusInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export enum PageLoadType {
  Combined = 'COMBINED',
  Initial = 'INITIAL',
  Transition = 'TRANSITION'
}

export type PageRestrictionInput = {
  group?: InputMaybe<Array<PageGroupRestrictionInput>>;
  user?: InputMaybe<Array<PageUserRestrictionInput>>;
};

export type PageRestrictionsInput = {
  includeInvites?: InputMaybe<Scalars['Boolean']['input']>;
  read?: InputMaybe<PageRestrictionInput>;
  update?: InputMaybe<PageRestrictionInput>;
};

export enum PageStatusInput {
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export enum PageUpdateTrigger {
  CreatePage = 'CREATE_PAGE',
  DiscardChanges = 'DISCARD_CHANGES',
  EditPage = 'EDIT_PAGE',
  LinkRefactoring = 'LINK_REFACTORING',
  MigratePageCollab = 'MIGRATE_PAGE_COLLAB',
  OwnerChange = 'OWNER_CHANGE',
  PageRename = 'PAGE_RENAME',
  PersonalTasklist = 'PERSONAL_TASKLIST',
  Revert = 'REVERT',
  SpaceCreate = 'SPACE_CREATE',
  Unknown = 'UNKNOWN',
  ViewPage = 'VIEW_PAGE'
}

export type PageUserRestrictionInput = {
  id: Scalars['ID']['input'];
};

export enum PagesDisplayPersistenceOption {
  Cards = 'CARDS',
  CompactList = 'COMPACT_LIST',
  List = 'LIST'
}

export enum PagesSortField {
  LastModifiedDate = 'LAST_MODIFIED_DATE',
  Relevant = 'RELEVANT',
  Title = 'TITLE'
}

export enum PagesSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type PagesSortPersistenceOptionInput = {
  field: PagesSortField;
  order: PagesSortOrder;
};

export enum PartnerBtfLicenseType {
  Academic = 'ACADEMIC',
  Commercial = 'COMMERCIAL',
  Evaluation = 'EVALUATION',
  Starter = 'STARTER'
}

export enum PartnerCloudLicenseType {
  Academic = 'ACADEMIC',
  Commercial = 'COMMERCIAL',
  Community = 'COMMUNITY',
  Demonstration = 'DEMONSTRATION',
  Developer = 'DEVELOPER',
  Evaluation = 'EVALUATION',
  Free = 'FREE',
  OpenSource = 'OPEN_SOURCE',
  Starter = 'STARTER'
}

export enum PartnerCurrency {
  Jpy = 'JPY',
  Usd = 'USD'
}

export enum PartnerInvoiceJsonCurrency {
  Aud = 'AUD',
  Eur = 'EUR',
  Gbp = 'GBP',
  Jpy = 'JPY',
  Usd = 'USD'
}

/**  --------------------------------------------------------------------------------------------- */
export type PartnerInvoiceJsonFilter = {
  id?: InputMaybe<Scalars['ID']['input']>;
  number?: InputMaybe<Scalars['ID']['input']>;
};

export type PartnerOfferingBtfInput = {
  /** Available currencies for a BTF product or app */
  currency?: InputMaybe<Array<InputMaybe<PartnerCurrency>>>;
  /** Available license types for a BTF offering */
  licenseType?: InputMaybe<Array<InputMaybe<PartnerBtfLicenseType>>>;
  /** Unique identifier for a BTF product */
  productKey: Scalars['ID']['input'];
};

export type PartnerOfferingCloudInput = {
  /** Available currencies for a cloud product or app */
  currency?: InputMaybe<Array<InputMaybe<PartnerCurrency>>>;
  /** Unique identifier for a cloud product */
  id: Scalars['ID']['input'];
  /** Available license types for a cloud offering */
  pricingPlanType?: InputMaybe<Array<InputMaybe<PartnerCloudLicenseType>>>;
};

/** Search for available product offerings */
export type PartnerOfferingFilter = {
  /** Search BTF offerings by product key */
  btfProduct?: InputMaybe<PartnerOfferingBtfInput>;
  /** Search cloud offerings by product key */
  cloudProduct?: InputMaybe<PartnerOfferingCloudInput>;
};

export enum PathType {
  Absolute = 'ABSOLUTE',
  Relative = 'RELATIVE',
  RelativeNoContext = 'RELATIVE_NO_CONTEXT'
}

export enum PaywallStatus {
  Active = 'ACTIVE',
  Deactivated = 'DEACTIVATED',
  Unset = 'UNSET'
}

export enum PermissionDisplayType {
  Anonymous = 'ANONYMOUS',
  Group = 'GROUP',
  GuestUser = 'GUEST_USER',
  LicensedUser = 'LICENSED_USER'
}

export enum PermsReportTargetType {
  Group = 'GROUP',
  User = 'USER'
}

/** ## Plan mode create cards ### */
export type PlanModeCardCreateInput = {
  boardId: Scalars['ID']['input'];
  destination: PlanModeDestination;
  destinationId?: InputMaybe<Scalars['ID']['input']>;
  newCards: Array<InputMaybe<NewCard>>;
  rankBeforeCardId?: InputMaybe<Scalars['Long']['input']>;
};

export type PlanModeCardMoveInput = {
  boardId: Scalars['ID']['input'];
  cardIds: Array<Scalars['ID']['input']>;
  destination: PlanModeDestination;
  rankAfterCardId?: InputMaybe<Scalars['Long']['input']>;
  rankBeforeCardId?: InputMaybe<Scalars['Long']['input']>;
  sprintId?: InputMaybe<Scalars['ID']['input']>;
};

export enum PlanModeDestination {
  Backlog = 'BACKLOG',
  Board = 'BOARD',
  Sprint = 'SPRINT'
}

export enum Platform {
  Android = 'ANDROID',
  Ios = 'IOS',
  Web = 'WEB'
}

/** Category of the playbook template */
export enum PlaybookTemplateCategory {
  Hrsm = 'HRSM',
  Itsm = 'ITSM',
  ItOperations = 'IT_OPERATIONS'
}

/** Color for the playbook template */
export enum PlaybookTemplateColor {
  Blue = 'BLUE',
  Gray = 'GRAY',
  Green = 'GREEN',
  Lime = 'LIME',
  Magenta = 'MAGENTA',
  Orange = 'ORANGE',
  Purple = 'PURPLE',
  Teal = 'TEAL',
  Yellow = 'YELLOW'
}

/** Icon for the playbook template */
export enum PlaybookTemplateIcon {
  ChangeManagement_4Icon = 'CHANGE_MANAGEMENT_4_ICON',
  Chat_5Icon = 'CHAT_5_ICON',
  DataPrivacyIcon = 'DATA_PRIVACY_ICON',
  OnboardingIcon = 'ONBOARDING_ICON',
  RainstormIncidentIcon = 'RAINSTORM_INCIDENT_ICON',
  RefreshUpdateIcon = 'REFRESH_UPDATE_ICON'
}

export type PolarisAddReactionInput = {
  ari: Scalars['String']['input'];
  containerAri: Scalars['String']['input'];
  emojiId: Scalars['String']['input'];
  metadata?: InputMaybe<Scalars['JSON']['input']>;
};

export enum PolarisColorStyle {
  Background = 'BACKGROUND',
  Highlight = 'HIGHLIGHT'
}

export enum PolarisColumnSize {
  Default = 'DEFAULT',
  Large = 'LARGE',
  Small = 'SMALL'
}

/** # Types */
export enum PolarisCommentKind {
  PlayContribution = 'PLAY_CONTRIBUTION',
  View = 'VIEW'
}

export enum PolarisConnectionsLayout {
  Cards = 'CARDS',
  List = 'LIST',
  Summary = 'SUMMARY'
}

export type PolarisDeleteReactionInput = {
  ari: Scalars['String']['input'];
  containerAri: Scalars['String']['input'];
  emojiId: Scalars['String']['input'];
  metadata?: InputMaybe<Scalars['JSON']['input']>;
};

export enum PolarisFilterEnumType {
  BoardColumn = 'BOARD_COLUMN',
  ViewGroup = 'VIEW_GROUP'
}

export type PolarisFilterInput = {
  jql?: InputMaybe<Scalars['String']['input']>;
};

export type PolarisGetDetailedReactionInput = {
  ari: Scalars['String']['input'];
  containerAri: Scalars['String']['input'];
  emojiId: Scalars['String']['input'];
};

export type PolarisGetReactionsInput = {
  aris?: InputMaybe<Array<Scalars['String']['input']>>;
  containerAri: Scalars['String']['input'];
};

export type PolarisGroupValueInput = {
  /**  a label value (which has no identity besides its string value) */
  id?: InputMaybe<Scalars['String']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};

export enum PolarisPlayKind {
  PolarisBudgetAllocationPlay = 'PolarisBudgetAllocationPlay'
}

export enum PolarisRefreshError {
  InternalError = 'INTERNAL_ERROR',
  InvalidSnippet = 'INVALID_SNIPPET',
  NeedAuth = 'NEED_AUTH',
  NotFound = 'NOT_FOUND'
}

/** # Types */
export enum PolarisResolvedObjectAuthType {
  ApiKey = 'API_KEY',
  Oauth2 = 'OAUTH2'
}

export enum PolarisSnippetPropertyKind {
  /**  1-5 integer rating */
  Labels = 'LABELS',
  Number = 'NUMBER',
  /**  generic number */
  Rating = 'RATING'
}

export type PolarisSortFieldInput = {
  field: Scalars['ID']['input'];
  order?: InputMaybe<PolarisSortOrder>;
};

export enum PolarisSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export enum PolarisTimelineMode {
  Months = 'MONTHS',
  Quarters = 'QUARTERS',
  Years = 'YEARS'
}

export enum PolarisTimelineTodayMarker {
  Disabled = 'DISABLED',
  Enabled = 'ENABLED'
}

export type PolarisViewFieldRollupInput = {
  field: Scalars['ID']['input'];
  /**  polaris field ID */
  rollup: PolarisViewFieldRollupType;
};

export enum PolarisViewFieldRollupType {
  Avg = 'AVG',
  Count = 'COUNT',
  Empty = 'EMPTY',
  Filled = 'FILLED',
  Max = 'MAX',
  Median = 'MEDIAN',
  Min = 'MIN',
  Range = 'RANGE',
  Sum = 'SUM'
}

export type PolarisViewFilterGroupInput = {
  /** Filter enums currently for group/column matches for connections */
  filterEnums?: InputMaybe<Array<PolarisFilterEnumType>>;
  /** The filters to apply within this group */
  filters: Array<PolarisViewFilterInput>;
  /** The filter that defines this group (e.g., issue type = "Opportunity") */
  groupFilter: PolarisViewFilterInput;
};

export type PolarisViewFilterInput = {
  field?: InputMaybe<Scalars['ID']['input']>;
  kind: PolarisViewFilterKind;
  values: Array<PolarisViewFilterValueInput>;
};

/** # Types */
export enum PolarisViewFilterKind {
  ConnectionFieldIdentity = 'CONNECTION_FIELD_IDENTITY',
  FieldHasValue = 'FIELD_HAS_VALUE',
  FieldIdentity = 'FIELD_IDENTITY',
  /**  a field being matched by identity */
  FieldNumeric = 'FIELD_NUMERIC',
  Interval = 'INTERVAL',
  /**  a field being matched by numeric comparison */
  Text = 'TEXT'
}

export enum PolarisViewFilterOperator {
  EndAfterNow = 'END_AFTER_NOW',
  EndBeforeNow = 'END_BEFORE_NOW',
  Eq = 'EQ',
  Gt = 'GT',
  Gte = 'GTE',
  ItemEndsAfter = 'ITEM_ENDS_AFTER',
  ItemEndsAfterPast = 'ITEM_ENDS_AFTER_PAST',
  ItemStartsBefore = 'ITEM_STARTS_BEFORE',
  ItemStartsBeforeNext = 'ITEM_STARTS_BEFORE_NEXT',
  Lt = 'LT',
  Lte = 'LTE',
  Neq = 'NEQ',
  StartAfterNow = 'START_AFTER_NOW',
  StartBeforeNow = 'START_BEFORE_NOW'
}

export type PolarisViewFilterValueInput = {
  enumValue?: InputMaybe<PolarisFilterEnumType>;
  operator?: InputMaybe<PolarisViewFilterOperator>;
  text?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['Float']['input']>;
};

export enum PolarisViewLayoutType {
  Compact = 'COMPACT',
  Detailed = 'DETAILED',
  Summary = 'SUMMARY'
}

/** # Types */
export enum PolarisViewSetType {
  Capture = 'CAPTURE',
  Custom = 'CUSTOM',
  Deliver = 'DELIVER',
  Prioritize = 'PRIORITIZE',
  /**  for views that are used to manage the display of single ideas (e.g., Idea views) */
  Section = 'SECTION',
  Single = 'SINGLE',
  System = 'SYSTEM'
}

export enum PolarisViewSortMode {
  FieldsSort = 'FIELDS_SORT',
  ProjectRank = 'PROJECT_RANK',
  ViewRank = 'VIEW_RANK'
}

export type PolarisViewTableColumnSizeInput = {
  field: Scalars['ID']['input'];
  /**  polaris field ID */
  size: Scalars['Int']['input'];
};

export enum PolarisVisualizationType {
  Board = 'BOARD',
  Collection = 'COLLECTION',
  Matrix = 'MATRIX',
  Section = 'SECTION',
  Table = 'TABLE',
  Timeline = 'TIMELINE',
  Twoxtwo = 'TWOXTWO'
}

export enum PrincipalFilterType {
  App = 'APP',
  Group = 'GROUP',
  Guest = 'GUEST',
  User = 'USER',
  UserClass = 'USER_CLASS'
}

/**
 * Principals types that App can allow for unlicensed access. This maps to different type of users in product.
 * For example - in case of JSM users can be UNLICENSED, CUSTOMER and ANONYMOUS.
 * UNLICENSED is Atlassian Account users who do not have a license on the underlying product where the extension is rendering
 * CUSTOMER - A site-specific Customer Account (accountId in format qm:{uuid}:{uuid} see https://developer.atlassian.com/platform/identity/rest/v1/))
 * ANONYMOUS - An invocation by a user that is not authenticated i.e. a Public JSM Portal/Confluence Space/Jira Project etc
 */
export enum PrincipalType {
  Anonymous = 'ANONYMOUS',
  Customer = 'CUSTOMER',
  Unlicensed = 'UNLICENSED'
}

export enum Product {
  Confluence = 'CONFLUENCE'
}

export type PropInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export enum PublicLinkAdminAction {
  Block = 'BLOCK',
  Off = 'OFF',
  On = 'ON',
  Unblock = 'UNBLOCK'
}

export enum PublicLinkContentType {
  Page = 'page',
  Whiteboard = 'whiteboard'
}

export enum PublicLinkDefaultSpaceStatus {
  Off = 'OFF',
  On = 'ON'
}

export enum PublicLinkPageStatus {
  BlockedByClassificationLevel = 'BLOCKED_BY_CLASSIFICATION_LEVEL',
  BlockedByContainerPolicy = 'BLOCKED_BY_CONTAINER_POLICY',
  BlockedByOrg = 'BLOCKED_BY_ORG',
  BlockedByProduct = 'BLOCKED_BY_PRODUCT',
  BlockedBySpace = 'BLOCKED_BY_SPACE',
  Off = 'OFF',
  On = 'ON',
  SiteBlocked = 'SITE_BLOCKED',
  SiteDisabled = 'SITE_DISABLED',
  SpaceBlocked = 'SPACE_BLOCKED',
  SpaceDisabled = 'SPACE_DISABLED'
}

export enum PublicLinkPermissionsObjectType {
  Content = 'CONTENT'
}

export enum PublicLinkPermissionsType {
  Edit = 'EDIT'
}

export enum PublicLinkSiteStatus {
  BlockedByOrg = 'BLOCKED_BY_ORG',
  Off = 'OFF',
  On = 'ON'
}

export enum PublicLinkSpaceStatus {
  BlockedByContainerPolicy = 'BLOCKED_BY_CONTAINER_POLICY',
  BlockedByOrg = 'BLOCKED_BY_ORG',
  BlockedByProduct = 'BLOCKED_BY_PRODUCT',
  Off = 'OFF',
  On = 'ON'
}

export enum PublicLinkSpacesByCriteriaOrder {
  ActiveLinks = 'ACTIVE_LINKS',
  Name = 'NAME',
  Status = 'STATUS'
}

export enum PublicLinkStatus {
  BlockedByClassificationLevel = 'BLOCKED_BY_CLASSIFICATION_LEVEL',
  BlockedByContainerPolicy = 'BLOCKED_BY_CONTAINER_POLICY',
  BlockedByOrg = 'BLOCKED_BY_ORG',
  BlockedByProduct = 'BLOCKED_BY_PRODUCT',
  BlockedBySpace = 'BLOCKED_BY_SPACE',
  Off = 'OFF',
  On = 'ON',
  SiteBlocked = 'SITE_BLOCKED',
  SiteDisabled = 'SITE_DISABLED',
  SpaceBlocked = 'SPACE_BLOCKED',
  SpaceDisabled = 'SPACE_DISABLED'
}

export enum PublicLinksByCriteriaOrder {
  DateEnabled = 'DATE_ENABLED',
  Status = 'STATUS',
  Title = 'TITLE'
}

/** Accepts input to find pull requests based on the status and time range. */
export type PullRequestStatusInTimeRangeQueryFilter = {
  /** Returns the pull requests with this status. */
  status: CompassPullRequestStatusForStatusInTimeRangeFilter;
  /** The time range of the query. */
  timeRange: CompassQueryTimeRange;
};

export type PushNotificationCustomSettingsInput = {
  comment: Scalars['Boolean']['input'];
  commentContentCreator: Scalars['Boolean']['input'];
  commentReply: Scalars['Boolean']['input'];
  createBlogPost: Scalars['Boolean']['input'];
  createPage: Scalars['Boolean']['input'];
  dailyDigest?: InputMaybe<Scalars['Boolean']['input']>;
  editBlogPost: Scalars['Boolean']['input'];
  editPage: Scalars['Boolean']['input'];
  grantContentAccessEdit?: InputMaybe<Scalars['Boolean']['input']>;
  grantContentAccessView?: InputMaybe<Scalars['Boolean']['input']>;
  likeBlogPost: Scalars['Boolean']['input'];
  likeComment: Scalars['Boolean']['input'];
  likePage: Scalars['Boolean']['input'];
  mentionBlogPost: Scalars['Boolean']['input'];
  mentionComment: Scalars['Boolean']['input'];
  mentionPage: Scalars['Boolean']['input'];
  reactionBlogPost?: InputMaybe<Scalars['Boolean']['input']>;
  reactionComment?: InputMaybe<Scalars['Boolean']['input']>;
  reactionPage?: InputMaybe<Scalars['Boolean']['input']>;
  requestContentAccess?: InputMaybe<Scalars['Boolean']['input']>;
  share: Scalars['Boolean']['input'];
  shareGroup: Scalars['Boolean']['input'];
  taskAssign: Scalars['Boolean']['input'];
};

export enum PushNotificationGroupInputType {
  None = 'NONE',
  Quiet = 'QUIET',
  Standard = 'STANDARD'
}

export enum PushNotificationSettingGroup {
  Custom = 'CUSTOM',
  None = 'NONE',
  Quiet = 'QUIET',
  Standard = 'STANDARD'
}

/** #################### INPUT SQLSlowQuery ##################### */
export type QueryInterval = {
  /** The end time of the interval */
  endTime: Scalars['String']['input'];
  /** The start time of the interval */
  startTime: Scalars['String']['input'];
};

/** Metadata on any analytics related fields, these do not affect the search */
export type QuerySuggestionAnalyticsInput = {
  queryVersion?: InputMaybe<Scalars['Int']['input']>;
  searchReferrerId?: InputMaybe<Scalars['String']['input']>;
  searchSessionId?: InputMaybe<Scalars['String']['input']>;
  /** The product which is running the experience e.g. confluence. */
  sourceProduct?: InputMaybe<Scalars['String']['input']>;
};

/** Filters to apply to query suggestions */
export type QuerySuggestionFilterInput = {
  /**
   * ATI strings of which entities to search for. In this context, these entities correspond to the 'product.indexType'.
   * For our specific use case, they should be represented as 'query-suggestion.query-suggestion-item'.
   * These inputs are sent to the 'xpsearch-aggregator' to perform a search in the content index."
   */
  entities: Array<Scalars['String']['input']>;
  /** ARIs of which cloudIds or orgs to search in */
  locations: Array<Scalars['String']['input']>;
};

export enum QueryType {
  All = 'ALL',
  Delete = 'DELETE',
  Insert = 'INSERT',
  Other = 'OTHER',
  Select = 'SELECT',
  Update = 'UPDATE'
}

export type RadarClearFocusAreaProposalInput = {
  /** Proposal ARI for which Talent should delete the proposal */
  proposalAri: Scalars['ID']['input'];
};

/**  --------------------------------------------------------------------------------------------- */
export enum RadarConnectorType {
  Csv = 'CSV',
  HrisS3 = 'HRIS_S3',
  Workday = 'WORKDAY'
}

export type RadarConnectorsInput = {
  connectorId: Scalars['ID']['input'];
  connectorName?: InputMaybe<Scalars['String']['input']>;
  hasData?: InputMaybe<Scalars['Boolean']['input']>;
  isEnabled: Scalars['Boolean']['input'];
  type?: InputMaybe<RadarConnectorType>;
};

export type RadarCustomFieldInput = {
  /** User defined Display name of the field */
  displayName: Scalars['String']['input'];
  /** Source of the field such as position, worker, etc. */
  entity: RadarEntityType;
  /** internal */
  relativeId?: InputMaybe<Scalars['String']['input']>;
  /** Visibility level of the field such as RESTRICTED, OPEN, etc. */
  sensitivityLevel: RadarSensitivityLevel;
  /** User defined Source name of the field */
  sourceField: Scalars['String']['input'];
  /** Field type of the field such as STRING, NUMBER etc. */
  type: RadarCustomFieldType;
  /** optional, IDs of principal groups which are granted access to specifically view this field */
  viewPrincipalIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum RadarCustomFieldSyncStatus {
  Found = 'FOUND',
  NotFound = 'NOT_FOUND',
  Pending = 'PENDING'
}

export enum RadarCustomFieldType {
  Date = 'DATE',
  String = 'STRING'
}

export type RadarDeleteConnectorInput = {
  /** Input used to delete a connector configuration */
  connectorId: Scalars['ID']['input'];
};

export type RadarDeleteCustomFieldInput = {
  entity: RadarEntityType;
  relativeId: Scalars['String']['input'];
};

export type RadarDeleteFocusAreaProposalChangesInput = {
  /** Change Request ARI */
  changeAri: Scalars['ID']['input'];
  /** Position ARI for which the Focus Area change request should be deleted */
  positionAri: Scalars['ID']['input'];
};

export type RadarDeleteLaborCostEstimateDataInput = {
  deleteDefaultAmount: Scalars['Boolean']['input'];
};

/**
 * ========================================
 *                Entity
 * ========================================
 */
export enum RadarEntityType {
  FocusArea = 'focusArea',
  FocusAreaType = 'focusAreaType',
  Position = 'position',
  Proposal = 'proposal',
  ProposedMovement = 'proposedMovement',
  Team = 'team',
  View = 'view',
  Worker = 'worker'
}

export type RadarFieldPermissionsInput = {
  /** ID of the field to grant or remove permissions for */
  fieldId: Scalars['ID']['input'];
  /** IDs of the principals (group) */
  principalId: Array<Scalars['ID']['input']>;
};

/** Updatable settings for fields */
export type RadarFieldSettingsInput = {
  /** The entity the field belongs to */
  entity: RadarEntityType;
  /** Optional, permission updates for the field */
  permissionUpdates?: InputMaybe<RadarFieldSettingsPermissionsInput>;
  /** The relative id of the field */
  relativeId: Scalars['String']['input'];
  /** Optional, the new sensitivity level */
  sensitivityLevel?: InputMaybe<RadarSensitivityLevel>;
  /** Optional, the new sourceField */
  sourceField?: InputMaybe<Scalars['String']['input']>;
};

export type RadarFieldSettingsPermissionsInput = {
  addedViewSensitiveFieldGroups?: InputMaybe<Array<Scalars['ID']['input']>>;
  removedViewSensitiveFieldGroups?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum RadarFieldType {
  Ari = 'ARI',
  Boolean = 'BOOLEAN',
  Date = 'DATE',
  Group = 'GROUP',
  Keyword = 'KEYWORD',
  Money = 'MONEY',
  Number = 'NUMBER',
  Status = 'STATUS',
  String = 'STRING',
  Url = 'URL',
  User = 'USER'
}

export enum RadarFilterInputType {
  Checkbox = 'CHECKBOX',
  Radio = 'RADIO',
  Range = 'RANGE',
  Textfield = 'TEXTFIELD'
}

export enum RadarFilterOperators {
  Equals = 'EQUALS',
  GreaterThan = 'GREATER_THAN',
  GreaterThanOrEqual = 'GREATER_THAN_OR_EQUAL',
  In = 'IN',
  Is = 'IS',
  IsNot = 'IS_NOT',
  LessThan = 'LESS_THAN',
  LessThanOrEqual = 'LESS_THAN_OR_EQUAL',
  Like = 'LIKE',
  NotEquals = 'NOT_EQUALS',
  NotIn = 'NOT_IN',
  NotLike = 'NOT_LIKE'
}

/**  --------------------------------------------------------------------------------------------- */
export type RadarFocusAreaMappingsInput = {
  /** Focus Area ARI mapping */
  focusAreaAri?: InputMaybe<Scalars['ID']['input']>;
  /** Position ARI */
  positionAri: Scalars['ID']['input'];
};

export enum RadarFunctionId {
  Currentuser = 'CURRENTUSER',
  Under = 'UNDER'
}

export type RadarLastAppliedFilterInput = {
  /** The name of the page the filter was applied to */
  pageName: Scalars['String']['input'];
  /** The RQL query that was applied to the page */
  rqlQuery?: InputMaybe<Scalars['String']['input']>;
};

/**
 * ========================================
 *          Labor Cost Estimates
 * ========================================
 */
export type RadarMoneyInput = {
  /**
   * The amount, represented in the smallest currency unit (e.g. $100,000.50 USD would
   * be represented as the number of cents: "10000050").
   */
  amount: Scalars['String']['input'];
  /** The ISO 4217 currency code (e.g. USD, JPY, etc.). */
  currency: Scalars['String']['input'];
};

export enum RadarNumericAppearance {
  Duration = 'DURATION',
  Number = 'NUMBER'
}

/**
 * ========================================
 *              Permissions
 * ========================================
 * Permissions object for workspace settings
 */
export type RadarPermissionsInput = {
  /** Determines whether managers can allocate positions */
  canManagersAllocate?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines whether managers can view sensitive fields */
  canManagersViewSensitiveFields?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RadarPositionProposalChangeInput = {
  /** Change Proposal ARI */
  changeProposalAri: Scalars['ID']['input'];
  /** Position ARI */
  positionAri: Scalars['ID']['input'];
  /** Source Focus Area ARI, can be null if the position is not currently allocated to any focus area */
  sourceFocusAreaAri?: InputMaybe<Scalars['ID']['input']>;
  /** Target Focus Area ARI */
  targetFocusAreaAri: Scalars['ID']['input'];
};

/**
 * ========================================
 *          Position Enums & Inputs
 * ========================================
 */
export enum RadarPositionRole {
  IndividualContributor = 'INDIVIDUAL_CONTRIBUTOR',
  Manager = 'MANAGER'
}

export type RadarPositionsByEntityInput = {
  entity: RadarPositionsByEntityType;
  fieldValue?: InputMaybe<Scalars['ID']['input']>;
};

export enum RadarPositionsByEntityType {
  FocusArea = 'focusArea',
  Position = 'position'
}

/** Input type for role assignment request */
export type RadarRoleAssignmentRequest = {
  /**  ID of the principal (group) */
  principalId: Scalars['ID']['input'];
  /**  ARI of the role being assigned */
  roleId: Scalars['ID']['input'];
};

export enum RadarSensitivityLevel {
  Open = 'OPEN',
  Private = 'PRIVATE',
  Restricted = 'RESTRICTED'
}

export enum RadarStatusAppearance {
  Default = 'default',
  Inprogress = 'inprogress',
  Moved = 'moved',
  New = 'new',
  Removed = 'removed',
  Success = 'success'
}

export type RadarUpdatePositionLaborCostEstimateSettingsInput = {
  currency?: InputMaybe<Scalars['String']['input']>;
  defaultAmount?: InputMaybe<RadarMoneyInput>;
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Input for creating or updating a view */
export type RadarUpsertViewInput = {
  /** The grouping field for this view */
  groupingField?: InputMaybe<Scalars['String']['input']>;
  /** The ARI of the view to update (omit when creating a new view) */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The ordered columns for this view */
  orderedColumns?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The page this view is associated with */
  pageName: RadarViewPageName;
  /** The RQL query associated with this view */
  rql?: InputMaybe<Scalars['String']['input']>;
  /** The name of the view */
  viewName: Scalars['String']['input'];
  /** AAIDs of users to grant viewer access (only used when visibility is RESTRICTED) */
  viewerAaids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The visibility setting of the view */
  visibility: RadarViewVisibility;
};

export enum RadarUserFieldPermission {
  /** The user has full permissions to the field regardless of the context */
  Full = 'Full',
  /** The user has no permissions to the field under any circumstance */
  None = 'None',
  /** The user has permissions to view data only if the data exist below the user's reporting line */
  PartialBelowReportingLine = 'PartialBelowReportingLine',
  /** The user has permissions to view data on their own position or positions below the user's reporting line */
  PartialOnSelfOrBelowReportingLine = 'PartialOnSelfOrBelowReportingLine',
  /** The user has permissions to view data if the data exist on their own position */
  PartialOnlySelf = 'PartialOnlySelf'
}

/** Page name that the view is associated with */
export enum RadarViewPageName {
  /** Talent positions page */
  TalentPositionsPage = 'TALENT_POSITIONS_PAGE'
}

/** Visibility setting for a view */
export enum RadarViewVisibility {
  /** View is restricted to specific users with granted permissions */
  Restricted = 'RESTRICTED',
  /** View is shared and read-only to all users */
  SharedReadOnly = 'SHARED_READ_ONLY'
}

/** Input for work type allocation */
export type RadarWorkTypeAllocationInput = {
  /** Work type allocation percentage for ctb */
  ctb: Scalars['Int']['input'];
  /** Organisation ID to which the work type allocation belongs */
  organisationId: Scalars['ID']['input'];
  /** Work type allocation percentage for productivity */
  productivity: Scalars['Int']['input'];
  /** Work type allocation percentage for rtb */
  rtb: Scalars['Int']['input'];
};

/** Input type for workspace settings, including key-value pairs */
export type RadarWorkspaceSettingsInput = {
  permissions?: InputMaybe<RadarPermissionsInput>;
};

export type RankColumnInput = {
  boardId: Scalars['ID']['input'];
  columnId: Scalars['ID']['input'];
  position: Scalars['Int']['input'];
};

export type RankCustomFilterInput = {
  afterFilterId?: InputMaybe<Scalars['String']['input']>;
  boardId: Scalars['ID']['input'];
  customFilterIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id: Scalars['String']['input'];
};

export type RateLimitPolicyProperty = {
  argumentPath: Scalars['String']['input'];
  useCloudIdFromARI?: Scalars['Boolean']['input'];
};

export enum RateLimitingCurrency {
  CannedResponseMutationCurrency = 'CANNED_RESPONSE_MUTATION_CURRENCY',
  CannedResponseQueryCurrency = 'CANNED_RESPONSE_QUERY_CURRENCY',
  CompassSynchronizeLinkAssociationsCurrency = 'COMPASS_SYNCHRONIZE_LINK_ASSOCIATIONS_CURRENCY',
  DevopsContainerRelationshipsReadCurrency = 'DEVOPS_CONTAINER_RELATIONSHIPS_READ_CURRENCY',
  DevopsContainerRelationshipsWriteCurrency = 'DEVOPS_CONTAINER_RELATIONSHIPS_WRITE_CURRENCY',
  DevopsServiceReadCurrency = 'DEVOPS_SERVICE_READ_CURRENCY',
  DevopsServiceWriteCurrency = 'DEVOPS_SERVICE_WRITE_CURRENCY',
  DevConsoleMutationCurrency = 'DEV_CONSOLE_MUTATION_CURRENCY',
  DevConsoleQueryCurrency = 'DEV_CONSOLE_QUERY_CURRENCY',
  ExportMetricsCurrency = 'EXPORT_METRICS_CURRENCY',
  ForgeAlertsCurrency = 'FORGE_ALERTS_CURRENCY',
  ForgeAppContributorCurrency = 'FORGE_APP_CONTRIBUTOR_CURRENCY',
  ForgeAuditLogsCurrency = 'FORGE_AUDIT_LOGS_CURRENCY',
  ForgeCustomMetricsCurrency = 'FORGE_CUSTOM_METRICS_CURRENCY',
  ForgeMetricsCurrency = 'FORGE_METRICS_CURRENCY',
  HelpCenterCurrency = 'HELP_CENTER_CURRENCY',
  HelpLayoutCurrency = 'HELP_LAYOUT_CURRENCY',
  HelpObjectStoreCurrency = 'HELP_OBJECT_STORE_CURRENCY',
  KnowledgeBaseCurrency = 'KNOWLEDGE_BASE_CURRENCY',
  PolarisBetaUserCurrency = 'POLARIS_BETA_USER_CURRENCY',
  PolarisCollabTokenQueryCurrency = 'POLARIS_COLLAB_TOKEN_QUERY_CURRENCY',
  PolarisCommentCurrency = 'POLARIS_COMMENT_CURRENCY',
  PolarisCurrency = 'POLARIS_CURRENCY',
  PolarisFieldCurrency = 'POLARIS_FIELD_CURRENCY',
  PolarisIdeaCurrency = 'POLARIS_IDEA_CURRENCY',
  PolarisIdeaTemplatesQueryCurrency = 'POLARIS_IDEA_TEMPLATES_QUERY_CURRENCY',
  PolarisIdeaTemplateCurrency = 'POLARIS_IDEA_TEMPLATE_CURRENCY',
  PolarisInsightsQueryCurrency = 'POLARIS_INSIGHTS_QUERY_CURRENCY',
  PolarisInsightsWithErrorsQueryCurrency = 'POLARIS_INSIGHTS_WITH_ERRORS_QUERY_CURRENCY',
  PolarisInsightCurrency = 'POLARIS_INSIGHT_CURRENCY',
  PolarisInsightQueryCurrency = 'POLARIS_INSIGHT_QUERY_CURRENCY',
  PolarisLabelsQueryCurrency = 'POLARIS_LABELS_QUERY_CURRENCY',
  PolarisOnboardingCurrency = 'POLARIS_ONBOARDING_CURRENCY',
  PolarisPlayCurrency = 'POLARIS_PLAY_CURRENCY',
  PolarisProjectConfigCurrency = 'POLARIS_PROJECT_CONFIG_CURRENCY',
  PolarisProjectQueryCurrency = 'POLARIS_PROJECT_QUERY_CURRENCY',
  PolarisRankingCurrency = 'POLARIS_RANKING_CURRENCY',
  PolarisReactionCurrency = 'POLARIS_REACTION_CURRENCY',
  PolarisSnippetCurrency = 'POLARIS_SNIPPET_CURRENCY',
  PolarisSnippetPropertiesConfigQueryCurrency = 'POLARIS_SNIPPET_PROPERTIES_CONFIG_QUERY_CURRENCY',
  PolarisUnfurlCurrency = 'POLARIS_UNFURL_CURRENCY',
  PolarisViewsetCurrency = 'POLARIS_VIEWSET_CURRENCY',
  PolarisViewArrangementInfoQueryCurrency = 'POLARIS_VIEW_ARRANGEMENT_INFO_QUERY_CURRENCY',
  PolarisViewCurrency = 'POLARIS_VIEW_CURRENCY',
  PolarisViewQueryCurrency = 'POLARIS_VIEW_QUERY_CURRENCY',
  PolarisWriteCurrency = 'POLARIS_WRITE_CURRENCY',
  TeamsCurrency = 'TEAMS_CURRENCY',
  TeamMembersCurrency = 'TEAM_MEMBERS_CURRENCY',
  TeamMembersV2Currency = 'TEAM_MEMBERS_V2_CURRENCY',
  TeamRoleGrantsMutatePrincipalsCurrency = 'TEAM_ROLE_GRANTS_MUTATE_PRINCIPALS_CURRENCY',
  TeamRoleGrantsQueryPrincipalsCurrency = 'TEAM_ROLE_GRANTS_QUERY_PRINCIPALS_CURRENCY',
  TeamSearchCurrency = 'TEAM_SEARCH_CURRENCY',
  /** This isn't used anywhere but we're keeping it around so pipelines don't break */
  TeamSearchV2Currency = 'TEAM_SEARCH_V2_CURRENCY',
  TeamV2Currency = 'TEAM_V2_CURRENCY',
  TestingService = 'TESTING_SERVICE',
  TrelloAiCurrency = 'TRELLO_AI_CURRENCY',
  TrelloCurrency = 'TRELLO_CURRENCY',
  TrelloMutationCurrency = 'TRELLO_MUTATION_CURRENCY'
}

export type ReactionsId = {
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  containerId: Scalars['ID']['input'];
  containerType: Scalars['String']['input'];
  contentId: Scalars['ID']['input'];
  contentType: Scalars['String']['input'];
};

export type ReattachInlineCommentInput = {
  commentId: Scalars['ID']['input'];
  containerId: Scalars['ID']['input'];
  lastFetchTimeMillis: Scalars['Long']['input'];
  /** matchIndex must be greater than or equal to 0. */
  matchIndex: Scalars['Int']['input'];
  /** numMatches must be positive and greater than matchIndex. */
  numMatches: Scalars['Int']['input'];
  originalSelection: Scalars['String']['input'];
  publishedVersion?: InputMaybe<Scalars['Int']['input']>;
  step?: InputMaybe<Step>;
};

export enum RecentFilter {
  All = 'ALL',
  CollaboratedOn = 'COLLABORATED_ON',
  Created = 'CREATED',
  WorkedOn = 'WORKED_ON'
}

export enum ReclassificationFilterScope {
  Content = 'CONTENT',
  Space = 'SPACE',
  Workspace = 'WORKSPACE'
}

export enum RecommendedPagesSpaceBehavior {
  Hidden = 'HIDDEN',
  Shown = 'SHOWN'
}

export type RecoverSpaceAdminPermissionInput = {
  spaceKey: Scalars['String']['input'];
};

export type RecoverSpaceWithAdminRoleAssignmentInput = {
  spaceId: Scalars['Long']['input'];
};

export type RefreshPolarisSnippetsInput = {
  project: Scalars['ID']['input'];
  /**
   * Specifies a set of snippets to be refreshed for finer-grain control than
   * at the project level (a required property for this API).  This field
   * is optional, and if specified must refer to either an issue, an
   * insight, or a snippet.
   */
  subject?: InputMaybe<Scalars['ID']['input']>;
  /**
   * An optional flag indicating whether or not the refresh should be performed
   * synchronously.  By default (if this flag is not included, or if its value
   * is false), the refresh is performed asynchronously.
   */
  synchronous?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RefreshTokenInput = {
  refreshTokenRotation: Scalars['Boolean']['input'];
};

/**
 * Establish tunnels for a specific environment of an app.
 *
 * This will create a cloudflare tunnel for forge app debugging
 */
export type RegisterTunnelInput = {
  /** The app to setup a tunnel for */
  appId: Scalars['ID']['input'];
  /** The environment key */
  environmentKey: Scalars['String']['input'];
};

export enum RelationSourceType {
  User = 'user'
}

export enum RelationTargetType {
  Content = 'content',
  Space = 'space'
}

export enum RelationType {
  Collaborator = 'collaborator',
  Favourite = 'favourite',
  Touched = 'touched'
}

export enum RelevantUserFilter {
  Collaborators = 'collaborators'
}

export enum RelevantUsersSortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type RemoveAppContributorsInput = {
  accountIds?: InputMaybe<Array<Scalars['String']['input']>>;
  appId: Scalars['ID']['input'];
  emails?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Accepts input for removing labels from a component. */
export type RemoveCompassComponentLabelsInput = {
  /** The ID of the component to remove the labels from. */
  componentId: Scalars['ID']['input'];
  /** The collection of labels to remove from the component. */
  labelNames: Array<Scalars['String']['input']>;
};

export type RemoveGroupSpacePermissionsInput = {
  groupIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  groupNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  spaceKey: Scalars['String']['input'];
};

export type RemovePublicLinkPermissionsInput = {
  objectId: Scalars['ID']['input'];
  objectType: PublicLinkPermissionsObjectType;
  permissions: Array<PublicLinkPermissionsType>;
};

export type RemoveUserSpacePermissionsInput = {
  accountId: Scalars['String']['input'];
  spaceKey: Scalars['String']['input'];
};

export type ReplyInlineCommentInput = {
  commentBody: CommentBody;
  commentSource?: InputMaybe<Platform>;
  containerId: Scalars['ID']['input'];
  createdFrom?: InputMaybe<CommentCreationLocation>;
  parentCommentId: Scalars['ID']['input'];
};

export type RequestPageAccessInput = {
  accessType: AccessType;
  pageId: Scalars['String']['input'];
};

export type ResetExCoSpacePermissionsInput = {
  accountId: Scalars['String']['input'];
  spaceKey?: InputMaybe<Scalars['String']['input']>;
};

export type ResetSpaceRolesFromAnotherSpaceInput = {
  sourceSpaceId: Scalars['Long']['input'];
  targetSpaceId: Scalars['Long']['input'];
};

export type ResetToDefaultSpaceRoleAssignmentsInput = {
  spaceId: Scalars['Long']['input'];
};

export type ResolvePolarisObjectInput = {
  /** Custom auth token that will be used in unfurl request and saved if request was successful */
  authToken?: InputMaybe<Scalars['String']['input']>;
  /** Issue ARI */
  issue: Scalars['ID']['input'];
  /** Project ARI */
  project: Scalars['ID']['input'];
  /** Resource url that will be used to unfurl data */
  resourceUrl: Scalars['String']['input'];
};

export type ResolveRestrictionsForSubjectsInput = {
  accessType: ResourceAccessType;
  contentId: Scalars['Long']['input'];
  spaceRoleId?: InputMaybe<Scalars['ID']['input']>;
  subjects: Array<InputMaybe<BlockedAccessSubjectInput>>;
};

export enum ResourceAccessType {
  Edit = 'EDIT',
  View = 'VIEW'
}

export enum ResourceType {
  Database = 'DATABASE',
  Folder = 'FOLDER',
  Page = 'PAGE',
  Space = 'SPACE',
  Whiteboard = 'WHITEBOARD'
}

export enum ResponseType {
  BulletListAdf = 'BULLET_LIST_ADF',
  BulletListMarkdown = 'BULLET_LIST_MARKDOWN',
  ParagraphPlaintext = 'PARAGRAPH_PLAINTEXT'
}

export enum ReverseTrialCohort {
  Control = 'CONTROL',
  Enrolled = 'ENROLLED',
  NotEnrolled = 'NOT_ENROLLED',
  Unassigned = 'UNASSIGNED',
  Unknown = 'UNKNOWN',
  Variant = 'VARIANT'
}

export enum RevertToLegacyEditorResult {
  NotReverted = 'NOT_REVERTED',
  Reverted = 'REVERTED'
}

/**  Input of a roadmap add item mutation. */
export type RoadmapAddItemInput = {
  /**  AccountId of the assignee. */
  assignee?: InputMaybe<Scalars['String']['input']>;
  /**  What color should be shown for this item */
  color?: InputMaybe<RoadmapPaletteColor>;
  /**  List of ids of the components on this item */
  componentIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**  When this item is due; date in RFC3339 DateTime format */
  dueDate?: InputMaybe<Scalars['Date']['input']>;
  /**  The type of this item */
  itemTypeId: Scalars['ID']['input'];
  /**  Jql of the board the issue is being created for */
  jql?: InputMaybe<Scalars['String']['input']>;
  /**  A list of Jql of the board the issue is being created for */
  jqlContexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  List of labels to be added to the newly created issue. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  The ID of the parent */
  parentId?: InputMaybe<Scalars['ID']['input']>;
  /**  Roadmap project ID; used only to fetch custom fields and won't have any impact on the item itself */
  projectId: Scalars['ID']['input'];
  /**  Item rank request */
  rank?: InputMaybe<RoadmapAddItemRank>;
  /**  When this item is set to start; date in RFC3339 DateTime format */
  startDate?: InputMaybe<Scalars['Date']['input']>;
  /**  The summary of this item */
  summary: Scalars['String']['input'];
  /**  List of ids of the versions on this item */
  versionIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type RoadmapAddItemRank = {
  /**  Rank before ID; used only to rank the item before the input item ID */
  beforeId?: InputMaybe<Scalars['ID']['input']>;
};

export type RoadmapAddLevelOneIssueTypeHealthcheckResolution = {
  /**  Information required to create a new level one issue type */
  create?: InputMaybe<RoadmapCreateLevelOneIssueType>;
  /**  Information required to promote an existing issue type to a level one issue type */
  promote?: InputMaybe<RoadmapPromoteLevelOneIssueType>;
};

/**  Child Issue Planning Mode */
export enum RoadmapChildIssuePlanningMode {
  /**  Use Date based planning */
  Date = 'DATE',
  /**  Disabled child issue planning */
  Disabled = 'DISABLED',
  /**  Use Sprint based planning */
  Sprint = 'SPRINT'
}

export type RoadmapCreateLevelOneIssueType = {
  /**  The description of the epic type */
  epicTypeDescription: Scalars['String']['input'];
  /**  The name of the epic type */
  epicTypeName: Scalars['String']['input'];
};

/** View settings for epics on the roadmap */
export enum RoadmapEpicView {
  /** All epics regardless of status */
  All = 'ALL',
  /** Epics with status complete */
  Completed = 'COMPLETED',
  /** Epics with status incomplete */
  Incomplete = 'INCOMPLETE'
}

export type RoadmapItemRankInput = {
  /**  The existing item to rank the updated or created item before/after */
  id: Scalars['ID']['input'];
  /**  The position relative to id to rank the item */
  position: RoadmapRankPosition;
};

/** View settings for hierarchy level one items on the roadmap */
export enum RoadmapLevelOneView {
  /** Show level one items completed within last 1 month */
  Complete1M = 'COMPLETE1M',
  /** Show level one items completed within last 3 months */
  Complete3M = 'COMPLETE3M',
  /** Show level one items completed within last 6 months */
  Complete6M = 'COMPLETE6M',
  /** Show level one items completed within last 9 months */
  Complete9M = 'COMPLETE9M',
  /** Show level one items completed within last 12 months */
  Complete12M = 'COMPLETE12M',
  /** Do not show completed level one items */
  Incomplete = 'INCOMPLETE'
}

/** Supported colors in the Palette */
export enum RoadmapPaletteColor {
  Blue = 'BLUE',
  DarkBlue = 'DARK_BLUE',
  DarkGreen = 'DARK_GREEN',
  DarkGrey = 'DARK_GREY',
  DarkOrange = 'DARK_ORANGE',
  DarkPurple = 'DARK_PURPLE',
  DarkTeal = 'DARK_TEAL',
  DarkYellow = 'DARK_YELLOW',
  Green = 'GREEN',
  Grey = 'GREY',
  Orange = 'ORANGE',
  Purple = 'PURPLE',
  Teal = 'TEAL',
  Yellow = 'YELLOW'
}

export type RoadmapPromoteLevelOneIssueType = {
  /**  The numeric id of the item type that will be promoted to level one */
  promoteItemTypeId: Scalars['ID']['input'];
};

export enum RoadmapRankPosition {
  /**  Rank the item after the provided id */
  After = 'AFTER',
  /**  Rank the item before the provided id */
  Before = 'BEFORE'
}

/**  Input for setting up a project with a roadmap */
export type RoadmapResolveHealthcheckInput = {
  /**  The healthcheck action id */
  actionId: Scalars['ID']['input'];
  /**  Required to fix add-level-one-issue-type healthcheck */
  addLevelOneIssueType?: InputMaybe<RoadmapAddLevelOneIssueTypeHealthcheckResolution>;
};

/**  Input for a single roadmap schedule item. */
export type RoadmapScheduleItemInput = {
  /**  When this item is due; date in RFC3339 DateTime format */
  dueDate?: InputMaybe<Scalars['Date']['input']>;
  /**  Roadmap item ID */
  itemId: Scalars['ID']['input'];
  /**  When this item is set to start; date in RFC3339 DateTime format */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/**  Input of a roadmap schedule items mutation. */
export type RoadmapScheduleItemsInput = {
  /**  List of schedule requests */
  scheduleRequests: Array<InputMaybe<RoadmapScheduleItemInput>>;
};

/** States that a sprint can be in */
export enum RoadmapSprintState {
  /** A current sprint */
  Active = 'ACTIVE',
  /** A sprint that was completed in the past */
  Closed = 'CLOSED',
  /** A sprint that is planned for the future */
  Future = 'FUTURE'
}

/** Defines the available timeline modes */
export enum RoadmapTimelineMode {
  /** Months */
  Months = 'MONTHS',
  /** Quarters */
  Quarters = 'QUARTERS',
  /** Weeks */
  Weeks = 'WEEKS'
}

export type RoadmapToggleDependencyInput = {
  /**  "dependee" requires/depends on "dependency" */
  dependee: Scalars['ID']['input'];
  /**  "dependency" is required/depended on by "dependee" */
  dependency: Scalars['ID']['input'];
};

/**  Input of a roadmap update item mutation. */
export type RoadmapUpdateItemInput = {
  /**  Field to be cleared; clearFields take precedence over other field input */
  clearFields?: InputMaybe<Array<Scalars['String']['input']>>;
  /**  What color should be shown for this item */
  color?: InputMaybe<RoadmapPaletteColor>;
  /**  When this item is due; date in RFC3339 DateTime format */
  dueDate?: InputMaybe<Scalars['Date']['input']>;
  /**  Roadmap item ID */
  itemId: Scalars['ID']['input'];
  /**  The id of the parent of the issue */
  parentId?: InputMaybe<Scalars['ID']['input']>;
  /**  Roadmap project ID; used only to fetch custom fields and won't have any impact on the item itself */
  projectId: Scalars['ID']['input'];
  /**  Item rank request */
  rank?: InputMaybe<RoadmapItemRankInput>;
  /**  Sprint id of the roadmap item */
  sprintId?: InputMaybe<Scalars['ID']['input']>;
  /**  When this item is set to start; date in RFC3339 DateTime format */
  startDate?: InputMaybe<Scalars['Date']['input']>;
  /**  The summary of this item */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/**  Input for updating roadmap settings */
export type RoadmapUpdateSettingsInput = {
  /**  indicates to enable or disable child issue planning on the roadmap */
  childIssuePlanningEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /**  The child issue planning mode */
  childIssuePlanningMode?: InputMaybe<RoadmapChildIssuePlanningMode>;
  /**  indicates to enable or disable the roadmap */
  roadmapEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Avaliable version statuses */
export enum RoadmapVersionStatus {
  /** version has been archived */
  Archived = 'ARCHIVED',
  /** version has been released */
  Released = 'RELEASED',
  /** version has not been released */
  Unreleased = 'UNRELEASED'
}

export type RoleAssignment = {
  principal: RoleAssignmentPrincipalInput;
  roleId: Scalars['ID']['input'];
};

export type RoleAssignmentPrincipalInput = {
  principalId: Scalars['ID']['input'];
  principalType: RoleAssignmentPrincipalType;
};

export enum RoleAssignmentPrincipalType {
  AccessClass = 'ACCESS_CLASS',
  App = 'APP',
  Group = 'GROUP',
  User = 'USER'
}

export type RunImportInput = {
  accessToken: Scalars['String']['input'];
  application: Scalars['String']['input'];
  collectionMediaToken?: InputMaybe<Scalars['String']['input']>;
  /**  Auxiliary references to filestoreId needed to confirm User's access to importing file. */
  collectionName?: InputMaybe<Scalars['String']['input']>;
  /** Signifies if the import involves an automated export from an external source */
  exportEntities?: InputMaybe<Scalars['Boolean']['input']>;
  filestoreId: Scalars['String']['input'];
  fullImport: Scalars['Boolean']['input'];
  importPageData: Scalars['Boolean']['input'];
  importPermissions?: InputMaybe<Scalars['String']['input']>;
  importUsers: Scalars['Boolean']['input'];
  /** integration token */
  integrationToken: Scalars['String']['input'];
  /** The auth token used to access the Miro Board & Board Export APIs */
  miroAuthToken?: InputMaybe<Scalars['String']['input']>;
  /** Optional Project ID to filter on */
  miroProjectId?: InputMaybe<Scalars['String']['input']>;
  /** Team ID to filter on */
  miroTeamId?: InputMaybe<Scalars['String']['input']>;
  oauthAccessRefreshToken?: InputMaybe<Scalars['String']['input']>;
  oauthAccessToken?: InputMaybe<Scalars['String']['input']>;
  oauthAccessTokenExpiry?: InputMaybe<Scalars['String']['input']>;
  orgId: Scalars['String']['input'];
  parentId?: InputMaybe<Scalars['String']['input']>;
  /** spaceId not required, used when importing into an existing space. */
  spaceId?: InputMaybe<Scalars['ID']['input']>;
  /** spaceName not required, this will be required on the UI if fullImport is false */
  spaceName?: InputMaybe<Scalars['String']['input']>;
};

/** An enum of the possible values of a sandbox event result. */
export enum SandboxEventResult {
  Failed = 'failed',
  Incomplete = 'incomplete',
  Successful = 'successful',
  Unknown = 'unknown'
}

/** An enum of the possible values of a sandbox event source. */
export enum SandboxEventSource {
  Admin = 'admin',
  System = 'system',
  User = 'user'
}

/** An enum of the possible values of a sandbox event status. */
export enum SandboxEventStatus {
  AwaitingReplay = 'awaiting_replay',
  Cancelled = 'cancelled',
  Completed = 'completed',
  Started = 'started'
}

/** An enum of the possible values of a sandbox event type. */
export enum SandboxEventType {
  Create = 'create',
  DataClone = 'data_clone',
  DataCloneSelective = 'data_clone_selective',
  HardDelete = 'hard_delete',
  Reset = 'reset',
  Reshard = 'reshard',
  Rollback = 'rollback',
  SoftDelete = 'soft_delete'
}

export type ScanPolarisProjectInput = {
  project: Scalars['ID']['input'];
  refresh?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum Scope {
  /** outbound-auth */
  AdminContainer = 'ADMIN_CONTAINER',
  ApiAccess = 'API_ACCESS',
  /**
   * jira - granular scopes.
   * Each Jira Mutation and Query should have one or more of these in an `@scope` tag and one of the non-granular scopes above
   */
  ApplicationRoleRead = 'APPLICATION_ROLE_READ',
  AsyncTaskDelete = 'ASYNC_TASK_DELETE',
  AttachmentDelete = 'ATTACHMENT_DELETE',
  AttachmentRead = 'ATTACHMENT_READ',
  AttachmentWrite = 'ATTACHMENT_WRITE',
  AuditLogRead = 'AUDIT_LOG_READ',
  AuthConfluenceUser = 'AUTH_CONFLUENCE_USER',
  AvatarDelete = 'AVATAR_DELETE',
  AvatarRead = 'AVATAR_READ',
  AvatarWrite = 'AVATAR_WRITE',
  /** papi */
  CatalogRead = 'CATALOG_READ',
  CommentDelete = 'COMMENT_DELETE',
  CommentPropertyDelete = 'COMMENT_PROPERTY_DELETE',
  CommentPropertyRead = 'COMMENT_PROPERTY_READ',
  CommentPropertyWrite = 'COMMENT_PROPERTY_WRITE',
  CommentRead = 'COMMENT_READ',
  CommentWrite = 'COMMENT_WRITE',
  /** compass */
  CompassAtlassianExternal = 'COMPASS_ATLASSIAN_EXTERNAL',
  /** confluence */
  ConfluenceAtlassianExternal = 'CONFLUENCE_ATLASSIAN_EXTERNAL',
  CustomFieldContextualConfigurationRead = 'CUSTOM_FIELD_CONTEXTUAL_CONFIGURATION_READ',
  CustomFieldContextualConfigurationWrite = 'CUSTOM_FIELD_CONTEXTUAL_CONFIGURATION_WRITE',
  DashboardDelete = 'DASHBOARD_DELETE',
  DashboardPropertyDelete = 'DASHBOARD_PROPERTY_DELETE',
  DashboardPropertyRead = 'DASHBOARD_PROPERTY_READ',
  DashboardPropertyWrite = 'DASHBOARD_PROPERTY_WRITE',
  DashboardRead = 'DASHBOARD_READ',
  DashboardWrite = 'DASHBOARD_WRITE',
  DeleteConfluenceAttachment = 'DELETE_CONFLUENCE_ATTACHMENT',
  DeleteConfluenceBlogpost = 'DELETE_CONFLUENCE_BLOGPOST',
  DeleteConfluenceComment = 'DELETE_CONFLUENCE_COMMENT',
  DeleteConfluenceCustomContent = 'DELETE_CONFLUENCE_CUSTOM_CONTENT',
  DeleteConfluenceDatabase = 'DELETE_CONFLUENCE_DATABASE',
  DeleteConfluenceFolder = 'DELETE_CONFLUENCE_FOLDER',
  DeleteConfluencePage = 'DELETE_CONFLUENCE_PAGE',
  DeleteConfluenceSpace = 'DELETE_CONFLUENCE_SPACE',
  DeleteConfluenceWhiteboard = 'DELETE_CONFLUENCE_WHITEBOARD',
  DeleteJswBoardScopeAdmin = 'DELETE_JSW_BOARD_SCOPE_ADMIN',
  DeleteJswSprint = 'DELETE_JSW_SPRINT',
  DeleteOrganization = 'DELETE_ORGANIZATION',
  DeleteOrganizationProperty = 'DELETE_ORGANIZATION_PROPERTY',
  DeleteOrganizationUser = 'DELETE_ORGANIZATION_USER',
  DeleteRequesttypeProperty = 'DELETE_REQUESTTYPE_PROPERTY',
  DeleteRequestFeedback = 'DELETE_REQUEST_FEEDBACK',
  DeleteRequestNotification = 'DELETE_REQUEST_NOTIFICATION',
  DeleteRequestParticipant = 'DELETE_REQUEST_PARTICIPANT',
  DeleteServicedeskCustomer = 'DELETE_SERVICEDESK_CUSTOMER',
  DeleteServicedeskOrganization = 'DELETE_SERVICEDESK_ORGANIZATION',
  DeleteServicedeskProperty = 'DELETE_SERVICEDESK_PROPERTY',
  DeployAppEnvironment = 'DEPLOY_APP_ENVIRONMENT',
  DevelopAppEnvironment = 'DEVELOP_APP_ENVIRONMENT',
  FieldConfigurationDelete = 'FIELD_CONFIGURATION_DELETE',
  FieldConfigurationRead = 'FIELD_CONFIGURATION_READ',
  FieldConfigurationSchemeDelete = 'FIELD_CONFIGURATION_SCHEME_DELETE',
  FieldConfigurationSchemeRead = 'FIELD_CONFIGURATION_SCHEME_READ',
  FieldConfigurationSchemeWrite = 'FIELD_CONFIGURATION_SCHEME_WRITE',
  FieldConfigurationWrite = 'FIELD_CONFIGURATION_WRITE',
  FieldDefaultValueRead = 'FIELD_DEFAULT_VALUE_READ',
  FieldDefaultValueWrite = 'FIELD_DEFAULT_VALUE_WRITE',
  FieldDelete = 'FIELD_DELETE',
  FieldOptionsRead = 'FIELD_OPTIONS_READ',
  FieldOptionDelete = 'FIELD_OPTION_DELETE',
  FieldOptionRead = 'FIELD_OPTION_READ',
  FieldOptionWrite = 'FIELD_OPTION_WRITE',
  FieldRead = 'FIELD_READ',
  FieldWrite = 'FIELD_WRITE',
  FilterColumnDelete = 'FILTER_COLUMN_DELETE',
  FilterColumnRead = 'FILTER_COLUMN_READ',
  FilterColumnWrite = 'FILTER_COLUMN_WRITE',
  FilterDefaultShareScopeRead = 'FILTER_DEFAULT_SHARE_SCOPE_READ',
  FilterDefaultShareScopeWrite = 'FILTER_DEFAULT_SHARE_SCOPE_WRITE',
  FilterDelete = 'FILTER_DELETE',
  FilterRead = 'FILTER_READ',
  FilterWrite = 'FILTER_WRITE',
  GroupDelete = 'GROUP_DELETE',
  GroupRead = 'GROUP_READ',
  GroupWrite = 'GROUP_WRITE',
  IdentityAtlassianExternal = 'IDENTITY_ATLASSIAN_EXTERNAL',
  InstanceConfigurationRead = 'INSTANCE_CONFIGURATION_READ',
  InstanceConfigurationWrite = 'INSTANCE_CONFIGURATION_WRITE',
  IssueAdjustmentsDelete = 'ISSUE_ADJUSTMENTS_DELETE',
  IssueAdjustmentsRead = 'ISSUE_ADJUSTMENTS_READ',
  IssueAdjustmentsWrite = 'ISSUE_ADJUSTMENTS_WRITE',
  IssueChangelogRead = 'ISSUE_CHANGELOG_READ',
  IssueDelete = 'ISSUE_DELETE',
  IssueDetailsRead = 'ISSUE_DETAILS_READ',
  IssueEventRead = 'ISSUE_EVENT_READ',
  IssueFieldValuesRead = 'ISSUE_FIELD_VALUES_READ',
  IssueLinkDelete = 'ISSUE_LINK_DELETE',
  IssueLinkRead = 'ISSUE_LINK_READ',
  IssueLinkTypeDelete = 'ISSUE_LINK_TYPE_DELETE',
  IssueLinkTypeRead = 'ISSUE_LINK_TYPE_READ',
  IssueLinkTypeWrite = 'ISSUE_LINK_TYPE_WRITE',
  IssueLinkWrite = 'ISSUE_LINK_WRITE',
  IssueMetaRead = 'ISSUE_META_READ',
  IssuePropertyDelete = 'ISSUE_PROPERTY_DELETE',
  IssuePropertyRead = 'ISSUE_PROPERTY_READ',
  IssuePropertyWrite = 'ISSUE_PROPERTY_WRITE',
  IssueRead = 'ISSUE_READ',
  IssueRemoteLinkDelete = 'ISSUE_REMOTE_LINK_DELETE',
  IssueRemoteLinkRead = 'ISSUE_REMOTE_LINK_READ',
  IssueRemoteLinkWrite = 'ISSUE_REMOTE_LINK_WRITE',
  IssueSecurityLevelRead = 'ISSUE_SECURITY_LEVEL_READ',
  IssueSecuritySchemeRead = 'ISSUE_SECURITY_SCHEME_READ',
  IssueStatusRead = 'ISSUE_STATUS_READ',
  IssueTimeTrackingRead = 'ISSUE_TIME_TRACKING_READ',
  IssueTimeTrackingWrite = 'ISSUE_TIME_TRACKING_WRITE',
  IssueTransitionRead = 'ISSUE_TRANSITION_READ',
  IssueTypeDelete = 'ISSUE_TYPE_DELETE',
  IssueTypeHierarchyRead = 'ISSUE_TYPE_HIERARCHY_READ',
  IssueTypePropertyDelete = 'ISSUE_TYPE_PROPERTY_DELETE',
  IssueTypePropertyRead = 'ISSUE_TYPE_PROPERTY_READ',
  IssueTypePropertyWrite = 'ISSUE_TYPE_PROPERTY_WRITE',
  IssueTypeRead = 'ISSUE_TYPE_READ',
  IssueTypeSchemeDelete = 'ISSUE_TYPE_SCHEME_DELETE',
  IssueTypeSchemeRead = 'ISSUE_TYPE_SCHEME_READ',
  IssueTypeSchemeWrite = 'ISSUE_TYPE_SCHEME_WRITE',
  IssueTypeScreenSchemeDelete = 'ISSUE_TYPE_SCREEN_SCHEME_DELETE',
  IssueTypeScreenSchemeRead = 'ISSUE_TYPE_SCREEN_SCHEME_READ',
  IssueTypeScreenSchemeWrite = 'ISSUE_TYPE_SCREEN_SCHEME_WRITE',
  IssueTypeWrite = 'ISSUE_TYPE_WRITE',
  IssueVotesRead = 'ISSUE_VOTES_READ',
  IssueVoteRead = 'ISSUE_VOTE_READ',
  IssueVoteWrite = 'ISSUE_VOTE_WRITE',
  IssueWatcherRead = 'ISSUE_WATCHER_READ',
  IssueWatcherWrite = 'ISSUE_WATCHER_WRITE',
  IssueWorklogDelete = 'ISSUE_WORKLOG_DELETE',
  IssueWorklogPropertyDelete = 'ISSUE_WORKLOG_PROPERTY_DELETE',
  IssueWorklogPropertyRead = 'ISSUE_WORKLOG_PROPERTY_READ',
  IssueWorklogPropertyWrite = 'ISSUE_WORKLOG_PROPERTY_WRITE',
  IssueWorklogRead = 'ISSUE_WORKLOG_READ',
  IssueWorklogWrite = 'ISSUE_WORKLOG_WRITE',
  IssueWrite = 'ISSUE_WRITE',
  JiraAtlassianExternal = 'JIRA_ATLASSIAN_EXTERNAL',
  JiraExpressionsRead = 'JIRA_EXPRESSIONS_READ',
  JqlRead = 'JQL_READ',
  JqlValidate = 'JQL_VALIDATE',
  LabelRead = 'LABEL_READ',
  LicenseRead = 'LICENSE_READ',
  /** ecosystem */
  ManageApp = 'MANAGE_APP',
  ManageAppInstallation = 'MANAGE_APP_INSTALLATION',
  ManageDirectory = 'MANAGE_DIRECTORY',
  ManageJiraConfiguration = 'MANAGE_JIRA_CONFIGURATION',
  ManageJiraDataProvider = 'MANAGE_JIRA_DATA_PROVIDER',
  ManageJiraProject = 'MANAGE_JIRA_PROJECT',
  ManageJiraWebhook = 'MANAGE_JIRA_WEBHOOK',
  /** identity */
  ManageOrg = 'MANAGE_ORG',
  ManageOrgPublicApis = 'MANAGE_ORG_PUBLIC_APIS',
  ManageServicedeskCustomer = 'MANAGE_SERVICEDESK_CUSTOMER',
  /** platform */
  MigrateConfluence = 'MIGRATE_CONFLUENCE',
  NotificationSchemeRead = 'NOTIFICATION_SCHEME_READ',
  NotificationSend = 'NOTIFICATION_SEND',
  PermissionDelete = 'PERMISSION_DELETE',
  PermissionRead = 'PERMISSION_READ',
  PermissionSchemeDelete = 'PERMISSION_SCHEME_DELETE',
  PermissionSchemeRead = 'PERMISSION_SCHEME_READ',
  PermissionSchemeWrite = 'PERMISSION_SCHEME_WRITE',
  PermissionWrite = 'PERMISSION_WRITE',
  PriorityRead = 'PRIORITY_READ',
  ProjectAvatarDelete = 'PROJECT_AVATAR_DELETE',
  ProjectAvatarRead = 'PROJECT_AVATAR_READ',
  ProjectAvatarWrite = 'PROJECT_AVATAR_WRITE',
  ProjectCategoryDelete = 'PROJECT_CATEGORY_DELETE',
  ProjectCategoryRead = 'PROJECT_CATEGORY_READ',
  ProjectCategoryWrite = 'PROJECT_CATEGORY_WRITE',
  ProjectComponentDelete = 'PROJECT_COMPONENT_DELETE',
  ProjectComponentRead = 'PROJECT_COMPONENT_READ',
  ProjectComponentWrite = 'PROJECT_COMPONENT_WRITE',
  ProjectDelete = 'PROJECT_DELETE',
  ProjectEmailRead = 'PROJECT_EMAIL_READ',
  ProjectEmailWrite = 'PROJECT_EMAIL_WRITE',
  ProjectFeatureRead = 'PROJECT_FEATURE_READ',
  ProjectFeatureWrite = 'PROJECT_FEATURE_WRITE',
  ProjectPropertyDelete = 'PROJECT_PROPERTY_DELETE',
  ProjectPropertyRead = 'PROJECT_PROPERTY_READ',
  ProjectPropertyWrite = 'PROJECT_PROPERTY_WRITE',
  ProjectRead = 'PROJECT_READ',
  ProjectRoleDelete = 'PROJECT_ROLE_DELETE',
  ProjectRoleRead = 'PROJECT_ROLE_READ',
  ProjectRoleWrite = 'PROJECT_ROLE_WRITE',
  ProjectTypeRead = 'PROJECT_TYPE_READ',
  ProjectVersionDelete = 'PROJECT_VERSION_DELETE',
  ProjectVersionRead = 'PROJECT_VERSION_READ',
  ProjectVersionWrite = 'PROJECT_VERSION_WRITE',
  ProjectWrite = 'PROJECT_WRITE',
  /** bitbucket_repository_access_token */
  PullRequest = 'PULL_REQUEST',
  PullRequestWrite = 'PULL_REQUEST_WRITE',
  ReadAccount = 'READ_ACCOUNT',
  ReadAppDetails = 'READ_APP_DETAILS',
  ReadAppEnvironment = 'READ_APP_ENVIRONMENT',
  ReadAppInstallation = 'READ_APP_INSTALLATION',
  ReadAppLogs = 'READ_APP_LOGS',
  ReadAppSystemToken = 'READ_APP_SYSTEM_TOKEN',
  ReadCompassAttentionItem = 'READ_COMPASS_ATTENTION_ITEM',
  ReadCompassComponent = 'READ_COMPASS_COMPONENT',
  ReadCompassEvent = 'READ_COMPASS_EVENT',
  ReadCompassMetric = 'READ_COMPASS_METRIC',
  ReadCompassScorecard = 'READ_COMPASS_SCORECARD',
  ReadConfluenceAttachment = 'READ_CONFLUENCE_ATTACHMENT',
  ReadConfluenceAuditLog = 'READ_CONFLUENCE_AUDIT_LOG',
  ReadConfluenceBlogpost = 'READ_CONFLUENCE_BLOGPOST',
  ReadConfluenceComment = 'READ_CONFLUENCE_COMMENT',
  ReadConfluenceConfiguration = 'READ_CONFLUENCE_CONFIGURATION',
  ReadConfluenceContentAnalytics = 'READ_CONFLUENCE_CONTENT_ANALYTICS',
  ReadConfluenceContentMetadata = 'READ_CONFLUENCE_CONTENT_METADATA',
  ReadConfluenceContentPermission = 'READ_CONFLUENCE_CONTENT_PERMISSION',
  ReadConfluenceContentProperty = 'READ_CONFLUENCE_CONTENT_PROPERTY',
  ReadConfluenceContentRestriction = 'READ_CONFLUENCE_CONTENT_RESTRICTION',
  ReadConfluenceCustomContent = 'READ_CONFLUENCE_CUSTOM_CONTENT',
  ReadConfluenceDatabase = 'READ_CONFLUENCE_DATABASE',
  ReadConfluenceFolder = 'READ_CONFLUENCE_FOLDER',
  ReadConfluenceGroup = 'READ_CONFLUENCE_GROUP',
  ReadConfluenceInlineTask = 'READ_CONFLUENCE_INLINE_TASK',
  ReadConfluenceLabel = 'READ_CONFLUENCE_LABEL',
  ReadConfluencePage = 'READ_CONFLUENCE_PAGE',
  ReadConfluenceRelation = 'READ_CONFLUENCE_RELATION',
  ReadConfluenceSpace = 'READ_CONFLUENCE_SPACE',
  ReadConfluenceSpacePermission = 'READ_CONFLUENCE_SPACE_PERMISSION',
  ReadConfluenceSpaceProperty = 'READ_CONFLUENCE_SPACE_PROPERTY',
  ReadConfluenceSpaceSetting = 'READ_CONFLUENCE_SPACE_SETTING',
  ReadConfluenceTemplate = 'READ_CONFLUENCE_TEMPLATE',
  ReadConfluenceUser = 'READ_CONFLUENCE_USER',
  ReadConfluenceUserProperty = 'READ_CONFLUENCE_USER_PROPERTY',
  ReadConfluenceWatcher = 'READ_CONFLUENCE_WATCHER',
  ReadConfluenceWhiteboard = 'READ_CONFLUENCE_WHITEBOARD',
  ReadContainer = 'READ_CONTAINER',
  /**
   * jira-servicedesk - granular
   * Each JSM Mutation and Query should have one or more of these in an `@scope` tag and one of the non-granular scopes above.
   * You can mix them with Jira scopes if needed.
   */
  ReadCustomer = 'READ_CUSTOMER',
  ReadDesign = 'READ_DESIGN',
  ReadDeveloperSpace = 'READ_DEVELOPER_SPACE',
  /** feedback */
  ReadFeedbackFeedback = 'READ_FEEDBACK_FEEDBACK',
  /**
   * jira - non granular
   * Please add a granular scope as well.
   */
  ReadJiraUser = 'READ_JIRA_USER',
  ReadJiraWork = 'READ_JIRA_WORK',
  /**
   * jsw scopes
   * Note - JSW does not have non granular scopes so it does not need two scope tags like JSM/Jira
   */
  ReadJswBoardScope = 'READ_JSW_BOARD_SCOPE',
  ReadJswBoardScopeAdmin = 'READ_JSW_BOARD_SCOPE_ADMIN',
  ReadJswBuild = 'READ_JSW_BUILD',
  ReadJswDeployment = 'READ_JSW_DEPLOYMENT',
  ReadJswEpic = 'READ_JSW_EPIC',
  ReadJswFeatureFlag = 'READ_JSW_FEATURE_FLAG',
  ReadJswIssue = 'READ_JSW_ISSUE',
  ReadJswRemoteLink = 'READ_JSW_REMOTE_LINK',
  ReadJswSourceCode = 'READ_JSW_SOURCE_CODE',
  ReadJswSprint = 'READ_JSW_SPRINT',
  ReadKnowledgebase = 'READ_KNOWLEDGEBASE',
  ReadMe = 'READ_ME',
  /** notification-log */
  ReadNotifications = 'READ_NOTIFICATIONS',
  ReadOrganization = 'READ_ORGANIZATION',
  ReadOrganizationProperty = 'READ_ORGANIZATION_PROPERTY',
  ReadOrganizationUser = 'READ_ORGANIZATION_USER',
  ReadQueue = 'READ_QUEUE',
  ReadRequest = 'READ_REQUEST',
  ReadRequesttype = 'READ_REQUESTTYPE',
  ReadRequesttypeProperty = 'READ_REQUESTTYPE_PROPERTY',
  ReadRequestAction = 'READ_REQUEST_ACTION',
  ReadRequestApproval = 'READ_REQUEST_APPROVAL',
  ReadRequestAttachment = 'READ_REQUEST_ATTACHMENT',
  ReadRequestComment = 'READ_REQUEST_COMMENT',
  ReadRequestFeedback = 'READ_REQUEST_FEEDBACK',
  ReadRequestNotification = 'READ_REQUEST_NOTIFICATION',
  ReadRequestParticipant = 'READ_REQUEST_PARTICIPANT',
  ReadRequestSla = 'READ_REQUEST_SLA',
  ReadRequestStatus = 'READ_REQUEST_STATUS',
  ReadServicedesk = 'READ_SERVICEDESK',
  ReadServicedeskCustomer = 'READ_SERVICEDESK_CUSTOMER',
  ReadServicedeskOrganization = 'READ_SERVICEDESK_ORGANIZATION',
  ReadServicedeskProperty = 'READ_SERVICEDESK_PROPERTY',
  /**
   * jira-servicedesk - non-granular
   * Please add a granular scope as well.
   */
  ReadServicedeskRequest = 'READ_SERVICEDESK_REQUEST',
  /** teams */
  ReadTeam = 'READ_TEAM',
  ReadTeamMembers = 'READ_TEAM_MEMBERS',
  ReadTeamMembersTemp = 'READ_TEAM_MEMBERS_TEMP',
  /**
   * teams-temp
   * Note: These are temporary scopes and will be removed very soon. This is an intermittent solution to unblock customer to
   * create 3LO apps and use Teams capabilities.
   * More details at: https://hello.atlassian.net/wiki/x/L840XAE
   */
  ReadTeamTemp = 'READ_TEAM_TEMP',
  ReadTownsquareComment = 'READ_TOWNSQUARE_COMMENT',
  ReadTownsquareGoal = 'READ_TOWNSQUARE_GOAL',
  /** townsquare (Atlas) */
  ReadTownsquareProject = 'READ_TOWNSQUARE_PROJECT',
  ReadTownsquareWorkspace = 'READ_TOWNSQUARE_WORKSPACE',
  ResolutionRead = 'RESOLUTION_READ',
  /** rovo */
  RovoAtlassianExternal = 'ROVO_ATLASSIAN_EXTERNAL',
  ScreenableFieldDelete = 'SCREENABLE_FIELD_DELETE',
  ScreenableFieldRead = 'SCREENABLE_FIELD_READ',
  ScreenableFieldWrite = 'SCREENABLE_FIELD_WRITE',
  ScreenDelete = 'SCREEN_DELETE',
  ScreenFieldRead = 'SCREEN_FIELD_READ',
  ScreenRead = 'SCREEN_READ',
  ScreenSchemeDelete = 'SCREEN_SCHEME_DELETE',
  ScreenSchemeRead = 'SCREEN_SCHEME_READ',
  ScreenSchemeWrite = 'SCREEN_SCHEME_WRITE',
  ScreenTabDelete = 'SCREEN_TAB_DELETE',
  ScreenTabRead = 'SCREEN_TAB_READ',
  ScreenTabWrite = 'SCREEN_TAB_WRITE',
  ScreenWrite = 'SCREEN_WRITE',
  StatusRead = 'STATUS_READ',
  StorageApp = 'STORAGE_APP',
  /** trello */
  TrelloAtlassianExternal = 'TRELLO_ATLASSIAN_EXTERNAL',
  UserColumnsRead = 'USER_COLUMNS_READ',
  UserConfigurationDelete = 'USER_CONFIGURATION_DELETE',
  UserConfigurationRead = 'USER_CONFIGURATION_READ',
  UserConfigurationWrite = 'USER_CONFIGURATION_WRITE',
  UserPropertyDelete = 'USER_PROPERTY_DELETE',
  UserPropertyRead = 'USER_PROPERTY_READ',
  UserPropertyWrite = 'USER_PROPERTY_WRITE',
  UserRead = 'USER_READ',
  ViewUserprofile = 'VIEW_USERPROFILE',
  WebhookDelete = 'WEBHOOK_DELETE',
  WebhookRead = 'WEBHOOK_READ',
  WebhookWrite = 'WEBHOOK_WRITE',
  WorkflowDelete = 'WORKFLOW_DELETE',
  WorkflowPropertyDelete = 'WORKFLOW_PROPERTY_DELETE',
  WorkflowPropertyRead = 'WORKFLOW_PROPERTY_READ',
  WorkflowPropertyWrite = 'WORKFLOW_PROPERTY_WRITE',
  WorkflowRead = 'WORKFLOW_READ',
  WorkflowSchemeDelete = 'WORKFLOW_SCHEME_DELETE',
  WorkflowSchemeRead = 'WORKFLOW_SCHEME_READ',
  WorkflowSchemeWrite = 'WORKFLOW_SCHEME_WRITE',
  WorkflowWrite = 'WORKFLOW_WRITE',
  WriteAppDetails = 'WRITE_APP_DETAILS',
  WriteCompassComponent = 'WRITE_COMPASS_COMPONENT',
  WriteCompassEvent = 'WRITE_COMPASS_EVENT',
  WriteCompassMetric = 'WRITE_COMPASS_METRIC',
  WriteCompassScorecard = 'WRITE_COMPASS_SCORECARD',
  WriteConfluenceAttachment = 'WRITE_CONFLUENCE_ATTACHMENT',
  WriteConfluenceAuditLog = 'WRITE_CONFLUENCE_AUDIT_LOG',
  WriteConfluenceBlogpost = 'WRITE_CONFLUENCE_BLOGPOST',
  WriteConfluenceComment = 'WRITE_CONFLUENCE_COMMENT',
  WriteConfluenceConfiguration = 'WRITE_CONFLUENCE_CONFIGURATION',
  WriteConfluenceContentProperty = 'WRITE_CONFLUENCE_CONTENT_PROPERTY',
  WriteConfluenceContentRestriction = 'WRITE_CONFLUENCE_CONTENT_RESTRICTION',
  WriteConfluenceCustomContent = 'WRITE_CONFLUENCE_CUSTOM_CONTENT',
  WriteConfluenceDatabase = 'WRITE_CONFLUENCE_DATABASE',
  WriteConfluenceFolder = 'WRITE_CONFLUENCE_FOLDER',
  WriteConfluenceGroup = 'WRITE_CONFLUENCE_GROUP',
  WriteConfluenceInlineTask = 'WRITE_CONFLUENCE_INLINE_TASK',
  WriteConfluenceLabel = 'WRITE_CONFLUENCE_LABEL',
  WriteConfluencePage = 'WRITE_CONFLUENCE_PAGE',
  WriteConfluenceRelation = 'WRITE_CONFLUENCE_RELATION',
  WriteConfluenceSpace = 'WRITE_CONFLUENCE_SPACE',
  WriteConfluenceSpacePermission = 'WRITE_CONFLUENCE_SPACE_PERMISSION',
  WriteConfluenceSpaceProperty = 'WRITE_CONFLUENCE_SPACE_PROPERTY',
  WriteConfluenceSpaceSetting = 'WRITE_CONFLUENCE_SPACE_SETTING',
  WriteConfluenceTemplate = 'WRITE_CONFLUENCE_TEMPLATE',
  WriteConfluenceUserProperty = 'WRITE_CONFLUENCE_USER_PROPERTY',
  WriteConfluenceWatcher = 'WRITE_CONFLUENCE_WATCHER',
  WriteConfluenceWhiteboard = 'WRITE_CONFLUENCE_WHITEBOARD',
  WriteContainer = 'WRITE_CONTAINER',
  WriteCustomer = 'WRITE_CUSTOMER',
  WriteDesign = 'WRITE_DESIGN',
  WriteDeveloperSpace = 'WRITE_DEVELOPER_SPACE',
  WriteFeedbackFeedback = 'WRITE_FEEDBACK_FEEDBACK',
  WriteJiraWork = 'WRITE_JIRA_WORK',
  WriteJswBoardScope = 'WRITE_JSW_BOARD_SCOPE',
  WriteJswBoardScopeAdmin = 'WRITE_JSW_BOARD_SCOPE_ADMIN',
  WriteJswBuild = 'WRITE_JSW_BUILD',
  WriteJswDeployment = 'WRITE_JSW_DEPLOYMENT',
  WriteJswEpic = 'WRITE_JSW_EPIC',
  WriteJswFeatureFlag = 'WRITE_JSW_FEATURE_FLAG',
  WriteJswIssue = 'WRITE_JSW_ISSUE',
  WriteJswRemoteLink = 'WRITE_JSW_REMOTE_LINK',
  WriteJswSourceCode = 'WRITE_JSW_SOURCE_CODE',
  WriteJswSprint = 'WRITE_JSW_SPRINT',
  WriteNotifications = 'WRITE_NOTIFICATIONS',
  WriteOrganization = 'WRITE_ORGANIZATION',
  WriteOrganizationProperty = 'WRITE_ORGANIZATION_PROPERTY',
  WriteOrganizationUser = 'WRITE_ORGANIZATION_USER',
  WriteRequest = 'WRITE_REQUEST',
  WriteRequesttype = 'WRITE_REQUESTTYPE',
  WriteRequesttypeProperty = 'WRITE_REQUESTTYPE_PROPERTY',
  WriteRequestApproval = 'WRITE_REQUEST_APPROVAL',
  WriteRequestAttachment = 'WRITE_REQUEST_ATTACHMENT',
  WriteRequestComment = 'WRITE_REQUEST_COMMENT',
  WriteRequestFeedback = 'WRITE_REQUEST_FEEDBACK',
  WriteRequestNotification = 'WRITE_REQUEST_NOTIFICATION',
  WriteRequestParticipant = 'WRITE_REQUEST_PARTICIPANT',
  WriteRequestStatus = 'WRITE_REQUEST_STATUS',
  WriteServicedesk = 'WRITE_SERVICEDESK',
  WriteServicedeskCustomer = 'WRITE_SERVICEDESK_CUSTOMER',
  WriteServicedeskOrganization = 'WRITE_SERVICEDESK_ORGANIZATION',
  WriteServicedeskProperty = 'WRITE_SERVICEDESK_PROPERTY',
  WriteServicedeskRequest = 'WRITE_SERVICEDESK_REQUEST',
  WriteTeam = 'WRITE_TEAM',
  WriteTeamMembersTemp = 'WRITE_TEAM_MEMBERS_TEMP',
  WriteTeamTemp = 'WRITE_TEAM_TEMP',
  WriteTownsquareGoal = 'WRITE_TOWNSQUARE_GOAL',
  WriteTownsquareProject = 'WRITE_TOWNSQUARE_PROJECT',
  WriteTownsquareRelationship = 'WRITE_TOWNSQUARE_RELATIONSHIP'
}

/** Metadata on any analytics related fields, these do not affect the search */
export type SearchAnalyticsInput = {
  queryVersion?: InputMaybe<Scalars['Int']['input']>;
  searchReferrerId?: InputMaybe<Scalars['String']['input']>;
  searchSessionId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for correlating user activity within a product session. */
  sessionId?: InputMaybe<Scalars['String']['input']>;
  /** The product which is running the experience e.g. confluence. */
  sourceProduct?: InputMaybe<Scalars['String']['input']>;
};

export type SearchAssetsFilter = {
  objectSchemaFilter?: InputMaybe<SearchAssetsObjectSchemaFilter>;
  objectTypeFilter?: InputMaybe<SearchAssetsObjectTypeFilter>;
};

export type SearchAssetsObjectSchemaFilter = {
  /** Assets Object Schema ARIs */
  schemaARIs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type SearchAssetsObjectTypeFilter = {
  /** Assets Object Type ARIs */
  typeARIs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type SearchBoardFilter = {
  negateProjectFilter?: InputMaybe<Scalars['Boolean']['input']>;
  projectARI?: InputMaybe<Scalars['ID']['input']>;
  userARI?: InputMaybe<Scalars['ID']['input']>;
};

export enum SearchBoardProductType {
  Business = 'BUSINESS',
  Software = 'SOFTWARE'
}

export enum SearchCombinationType {
  And = 'AND',
  Or = 'OR'
}

export type SearchCommonFilter = {
  /** 1P AccountIds of the users. */
  contributorsFilter?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for entities based on participant relationships (mentions, contributors, presence) */
  participants?: InputMaybe<SearchParticipants>;
  /** Search for only entities that have match the date range for the specified field */
  range?: InputMaybe<SearchCommonRangeFilter>;
};

export type SearchCommonRangeFilter = {
  /** Created date filter */
  created?: InputMaybe<SearchCommonRangeFilterFields>;
  /** Last modified date filter */
  lastModified?: InputMaybe<SearchCommonRangeFilterFields>;
};

export type SearchCommonRangeFilterFields = {
  /** Specify the timestamp that the field should be greater than */
  gt?: InputMaybe<Scalars['String']['input']>;
  /** Specify the timestamp that the field should be less than */
  lt?: InputMaybe<Scalars['String']['input']>;
};

export type SearchCompassComponentFilter = {
  /** The component state */
  componentStates: Array<Scalars['String']['input']>;
};

export type SearchCompassFilter = {
  componentFilter?: InputMaybe<SearchCompassComponentFilter>;
};

export enum SearchConfluenceDocumentStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export type SearchConfluenceFilter = {
  /** Id of the pages which must be parent of the result. */
  ancestorIdsFilter?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Space or Page ARI under which the search will have to be made. Includes the space or page itself. Maps to Containers filter. */
  containerARIs?: InputMaybe<Array<Scalars['String']['input']>>;
  containerStatus?: InputMaybe<Array<InputMaybe<SearchContainerStatus>>>;
  /** Confluence document status */
  contentStatuses?: InputMaybe<Array<SearchConfluenceDocumentStatus>>;
  /** AccountIds of the users. */
  contributorsFilter?: InputMaybe<Array<Scalars['String']['input']>>;
  /** AccountIds of the users. */
  creatorsFilter?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for Verified pages or blogposts */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Labels which must be present on the page or blogpost. */
  labelsFilter?: InputMaybe<Array<Scalars['String']['input']>>;
  /** AccountIds of users mentioned in the content. */
  mentions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for pages owned by particular users. The values should be Atlassian Account IDs. */
  owners?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for pages or blogposts with a specific page status */
  pageStatus?: InputMaybe<Array<Scalars['String']['input']>>;
  range?: InputMaybe<Array<InputMaybe<SearchConfluenceRangeFilter>>>;
  /** Space keys from which the results are desired. */
  spacesFilter?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for only entities that have a title that contains the given query */
  titleMatchOnly?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum SearchConfluenceRangeField {
  Created = 'CREATED',
  Lastmodified = 'LASTMODIFIED'
}

export type SearchConfluenceRangeFilter = {
  /** The field to use to calculate the range */
  field: SearchConfluenceRangeField;
  /** Specify the timestamp that the field should be greater than */
  gt?: InputMaybe<Scalars['String']['input']>;
  /** Specify the timestamp that the field should be less than */
  lt?: InputMaybe<Scalars['String']['input']>;
};

export enum SearchContainerStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT'
}

/** Context for the search experiment */
export type SearchExperimentContextInput = {
  /** experimentId to override the default experimentId for scraping purposes */
  experimentId?: InputMaybe<Scalars['String']['input']>;
  /** Context for Aggregator's experimentation, including L3 and pre-query phase */
  experimentLayers?: InputMaybe<Array<InputMaybe<SearchExperimentLayer>>>;
};

export type SearchExperimentLayer = {
  /** List of layers defined for each 1P and 3P product */
  definitions?: InputMaybe<Array<InputMaybe<SearchLayerDefinition>>>;
  /** ID for the Statsig layer */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type SearchExternalContainerFilter = {
  /** The container type */
  type: Scalars['String']['input'];
  /** The list of containers */
  values: Array<Scalars['String']['input']>;
};

export type SearchExternalContentFormatFilter = {
  /** The content format type */
  type: Scalars['String']['input'];
  /** The content formats */
  values: Array<Scalars['String']['input']>;
};

export type SearchExternalDepthFilter = {
  /** The depth values */
  depth: Scalars['Int']['input'];
  /** The depth type */
  type: Scalars['String']['input'];
};

export type SearchExternalFilter = {
  /** The list of containers */
  containers?: InputMaybe<Array<InputMaybe<SearchExternalContainerFilter>>>;
  /** The external content format filters */
  contentFormats?: InputMaybe<Array<InputMaybe<SearchExternalContentFormatFilter>>>;
  /** The depth of search */
  depth?: InputMaybe<Array<InputMaybe<SearchExternalDepthFilter>>>;
};

/** Filters to apply to a search */
export type SearchFilterInput = {
  /** Assets Filters */
  assetsFilters?: InputMaybe<SearchAssetsFilter>;
  /** Common filters that apply to all products */
  commonFilters?: InputMaybe<SearchCommonFilter>;
  /** Compass filters */
  compassFilters?: InputMaybe<SearchCompassFilter>;
  /** Confluence specific filters */
  confluenceFilters?: InputMaybe<SearchConfluenceFilter>;
  /** ATI strings of which entities to search for */
  entities: Array<Scalars['String']['input']>;
  /** External filters */
  externalFilters?: InputMaybe<SearchExternalFilter>;
  /** Jira Board filters */
  jiraFilters?: InputMaybe<SearchJiraFilter>;
  /** ARIs of which workspaces, cloudIds or orgs to search in */
  locations: Array<Scalars['String']['input']>;
  /** Mercury filters */
  mercuryFilters?: InputMaybe<SearchMercuryFilter>;
  /** Talent filters */
  talentFilters?: InputMaybe<SearchTalentFilter>;
  /** Third party search filters */
  thirdPartyFilters?: InputMaybe<SearchThirdPartyFilter>;
  /** Trello filters */
  trelloFilters?: InputMaybe<SearchTrelloFilter>;
};

/** Consolidated input for search operations */
export type SearchInput = {
  /** This is a cursor after which (exclusive) the data should be fetched from */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Contains metadata on any analytics related fields, these do not affect the search */
  analytics?: InputMaybe<SearchAnalyticsInput>;
  /** This is a cursor before which (exclusive) the data should be fetched from */
  before?: InputMaybe<Scalars['String']['input']>;
  /** When enabled, this option skips the query replacement for the search. */
  disableQueryReplacement?: InputMaybe<Scalars['Boolean']['input']>;
  /** When enabled, this option skips wildcard query generation for '*' or '?' characters in search terms. */
  disableWildcardMatching?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not query text should be highlighted in the description. */
  enableHighlighting?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the query should generate relevance debug events for consumption in the query debugger tool. */
  enableRelevanceDebugging?: InputMaybe<Scalars['Boolean']['input']>;
  /** String describing which experience the search is being called from, e.g. confluence.advanced_search */
  experience: Scalars['String']['input'];
  /** Contains context for the search experiment */
  experimentContext?: InputMaybe<SearchExperimentContextInput>;
  /** The cohort for 3P fanout experiment */
  fanoutExperimentCohort?: InputMaybe<Scalars['String']['input']>;
  /**
   * This object determines the tenants/locations where the search should be performed.
   * It also determines the kind of results which must be returned.
   */
  filters: SearchFilterInput;
  /** The maximum number of items to search for */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** When enabled, boosted smartlink results are included in the search results. */
  includeBoostedLinks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether results should be interleaved between products */
  interleaveResults?: InputMaybe<Scalars['Boolean']['input']>;
  /** The maximum number of items to search for */
  last?: InputMaybe<Scalars['Int']['input']>;
  /** Query to search */
  query?: InputMaybe<Scalars['String']['input']>;
  /** Collection of sorting inputs that will be used to sort the query result */
  sort?: InputMaybe<Array<InputMaybe<SearchSortInput>>>;
};

export enum SearchIssueStatusCategory {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Open = 'OPEN',
  Undefined = 'UNDEFINED'
}

export type SearchJiraFilter = {
  /**  boardFilter can have at most one element only - multiple project ARI's to filter by are not supported */
  boardFilter?: InputMaybe<SearchBoardFilter>;
  issueFilter?: InputMaybe<SearchJiraIssueFilter>;
  projectFilter?: InputMaybe<SearchJiraProjectFilter>;
};

export type SearchJiraIssueFilter = {
  /** Account ARIs of the issue assignees. */
  assigneeARIs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Account ARI of the issue commenter. */
  commenterARIs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Label IDs */
  issueLabels?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Issue type IDs */
  issueTypeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Issue type strings like - Epic, Story etc */
  issueTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Project ARIs the issues reside in. */
  projectARIs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Account ARIs of the issue reporters. */
  reporterARIs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The status category the issue is currently in. */
  statusCategories?: InputMaybe<Array<SearchIssueStatusCategory>>;
  /** Account ARI of the issue watcher. */
  watcherARIs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type SearchJiraProjectFilter = {
  projectTypes?: InputMaybe<Array<SearchProjectType>>;
};

export type SearchLayerDefinition = {
  /** The ID of the experiment the layerId and shadowId are associated with */
  abTestId?: InputMaybe<Scalars['String']['input']>;
  /** List of connector sources that this search experiment can target */
  connectorSources?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** ari or product - eg "ari:cloud:platform::integration/google" "confluence" */
  entity?: InputMaybe<Scalars['String']['input']>;
  /** The ARI of the graph product to be experimented on */
  integrationARI?: InputMaybe<Scalars['String']['input']>;
  /** Layer Id - eg "L1-optimus" */
  layerId?: InputMaybe<Scalars['String']['input']>;
  /** ProviderId for the third party product */
  providerId?: InputMaybe<Scalars['String']['input']>;
  /** Experiment ID for shadowing - currently used for Searcher-based layers. */
  shadowId?: InputMaybe<Scalars['String']['input']>;
  /** Sub Entity - eg "document" */
  subEntity?: InputMaybe<Scalars['String']['input']>;
};

export enum SearchLinkedEntitiesType {
  Messages = 'messages',
  Thread = 'thread'
}

export enum SearchLinkedEntityGranularity {
  AllMatchingMessages = 'ALL_MATCHING_MESSAGES',
  Default = 'DEFAULT',
  FullThread = 'FULL_THREAD'
}

export enum SearchLinkedResultCategory {
  MentionedBy = 'mentionedBy',
  Mentions = 'mentions',
  Similar = 'similar'
}

export type SearchMercuryFilter = {
  /** Ids of the ancestors of the result. */
  ancestorIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Ids of the focus area types of the result. */
  focusAreaTypeIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for focus areas owned by particular users. The values should be Atlassian Account IDs. */
  owners?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type SearchParticipant = {
  /** Combination logic for users within this participant group */
  combination: SearchCombinationType;
  /** The type of participant relationship */
  type: SearchParticipantType;
  /** List of users */
  users: Array<Scalars['ID']['input']>;
};

export enum SearchParticipantType {
  Contributor = 'CONTRIBUTOR',
  Mentions = 'MENTIONS',
  Presence = 'PRESENCE'
}

export type SearchParticipants = {
  /** Combination logic between different participant groups */
  combination: SearchCombinationType;
  /** List of participant groups */
  items: Array<SearchParticipant>;
};

export enum SearchProjectType {
  Business = 'business',
  CustomerService = 'customer_service',
  ProductDiscovery = 'product_discovery',
  ServiceDesk = 'service_desk',
  Software = 'software'
}

/** Filters to apply to recent query */
export type SearchRecentFilterInput = {
  /** ATI strings of which entities to search for */
  entities: Array<Scalars['String']['input']>;
  /** ARIs of which workspaces, cloudIds or orgs to search in */
  locations: Array<Scalars['String']['input']>;
};

export enum SearchResultType {
  Ask = 'ask',
  Attachment = 'attachment',
  Blogpost = 'blogpost',
  Board = 'board',
  Comment = 'comment',
  Component = 'component',
  Dashboard = 'dashboard',
  Database = 'database',
  Document = 'document',
  Embed = 'embed',
  Filter = 'filter',
  FocusArea = 'focus_area',
  FocusAreaStatusUpdate = 'focus_area_status_update',
  Folder = 'folder',
  Goal = 'goal',
  GoalUpdate = 'goal_update',
  Issue = 'issue',
  Learning = 'learning',
  Message = 'message',
  Object = 'object',
  Page = 'page',
  Plan = 'plan',
  Position = 'position',
  Presentation = 'presentation',
  Project = 'project',
  ProjectUpdate = 'project_update',
  Question = 'question',
  Repository = 'repository',
  Schema = 'schema',
  Space = 'space',
  Spreadsheet = 'spreadsheet',
  Tag = 'tag',
  Type = 'type',
  Unrecognised = 'unrecognised',
  Whiteboard = 'whiteboard'
}

/** Fields used to sort the query */
export type SearchSortInput = {
  /** Name of the document field on which to sort. May be a computed field such as "_score". */
  field: Scalars['String']['input'];
  /**
   * Field to sort by if a content property was specified in the field section. This is ignored if the field is not
   * a content property.
   */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Order to sort the result by. */
  order: SearchSortOrder;
};

/** SearchSortOrder describes the sorting order of the query. */
export enum SearchSortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type SearchTalentFilter = {
  /** Search for position with specific employment types */
  employmentTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for position under focus areas. */
  focusAreas?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for position belonging to specific job family */
  jobFamilies?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for position owned by particular users. The values should be Atlassian Account IDs. */
  owners?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for position with the identified statuses */
  statuses?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for position from a specific team */
  teams?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type SearchTeamsFilters = {
  /** Search for only entities that have the given attachment file types */
  attachmentFileTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for only entities that has attachments */
  hasAttachment?: InputMaybe<Scalars['Boolean']['input']>;
  /** Search for only entities that has links */
  hasLink?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SearchThirdPartyFilter = {
  /** Search for text stored under additional text field; for BYOD we can index domain URLs. */
  additionalTexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Restrict search only to the given ancestors represented by ARIs */
  ancestorAris?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for only entities that have assignee ids specified */
  assignees?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for only entities that have the containerARIs specified */
  containerAris?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for only entities that have the containerNames specified */
  containerNames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for only entities that have the specified container types. */
  containerTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for only the entities that have createdBy account ids specified */
  createdBy?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Exclude the entities that have the subtypes specified */
  excludeSubtypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for only entities that have the integration ids specified */
  integrations?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Search for labels in any thirdparty filter */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search entities by user who last modified them */
  lastUpdatedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for only entities that have match the date range for the specified field */
  range?: InputMaybe<Array<InputMaybe<SearchThirdPartyRangeFilter>>>;
  /** Search for only entities that have the subtypes specified */
  subtypes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Microsoft Teams search filters */
  teamsFilters?: InputMaybe<SearchTeamsFilters>;
  /** Mapping of each third party product and its subtypes, providerId and integrationId */
  thirdPartyProducts?: InputMaybe<Array<SearchThirdPartyProduct>>;
  /** Search for only entities that have the types specified */
  thirdPartyTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Search for only entities that have a title that contains the given query */
  titleMatchOnly?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SearchThirdPartyProduct = {
  /** Optional array of connection IDs to filter results by specific connections */
  connectionIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Indicates if the product is a smartlink connector, full connector, or both */
  connectorSources?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Specifies any container types eg: for slack we may want to limit to ["direct-message", "group-direct-message"] */
  containerTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Specifies the datasourceId (aka connectorId) for 3P products (e.g. "471293c5-0de9-47ca-be18-fc8a244e1279") */
  datasourceId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Optional list of entity types to search within this third-party product.
   * If provided, only these entities will be searched (filtered against both the main query's entities and the product's supported entities).
   * If not provided, all entities from the main query that are supported by the product will be searched.
   * This works for all third-party products, including dynamic Forge connectors and predefined products like Google Drive, SharePoint, etc.
   */
  entities?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The given product's integration ari */
  integrationId?: InputMaybe<Scalars['String']['input']>;
  /** Specifies how much content to return for linked entities */
  linkedEntityGranularity?: InputMaybe<SearchLinkedEntityGranularity>;
  /** ProductKey from frontend code to identify the product for feature gate purposes */
  product?: InputMaybe<Scalars['String']['input']>;
  /** The given product's provider id from twg */
  providerId?: InputMaybe<Scalars['String']['input']>;
  /** Subtypes mapped to this product for the given query */
  subtypes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum SearchThirdPartyRangeField {
  Created = 'CREATED',
  Lastmodified = 'LASTMODIFIED'
}

export type SearchThirdPartyRangeFilter = {
  /** The field to use to calculate the range */
  field: SearchThirdPartyRangeField;
  /** Specify the timestamp that the field should be greater than */
  gt?: InputMaybe<Scalars['String']['input']>;
  /** Specify the timestamp that the field should be less than */
  lt?: InputMaybe<Scalars['String']['input']>;
};

export type SearchTrelloFilter = {
  /** Whether to search for recent boards */
  isRecentBias?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum SearchesByTermColumns {
  PageViewedPercentage = 'pageViewedPercentage',
  SearchClickCount = 'searchClickCount',
  SearchSessionCount = 'searchSessionCount',
  SearchTerm = 'searchTerm',
  Total = 'total',
  UniqueUsers = 'uniqueUsers'
}

export enum SearchesByTermPeriod {
  Day = 'day',
  Month = 'month',
  Week = 'week'
}

export type SetAppEnvironmentVariableInput = {
  environment: AppEnvironmentInput;
  /** The input identifying the environment variable to insert */
  environmentVariable: AppEnvironmentVariableInput;
};

/** Input payload for setAppLicenseId mutation */
export type SetAppLicenseIdInput = {
  appHostKey: Scalars['String']['input'];
  appId: Scalars['ID']['input'];
  environmentKey: Scalars['String']['input'];
  licenseId: Scalars['ID']['input'];
};

export type SetAppStoredCustomEntityMutationInput = {
  /** The ARI to store this entity within */
  contextAri?: InputMaybe<Scalars['ID']['input']>;
  /** Specify the entity name for custom schema */
  entityName: Scalars['String']['input'];
  /** The identifier for the entity */
  key: Scalars['ID']['input'];
  /**
   * Entities may be up to ${maxValidContentLength} bytes long. Note that size within ESS may differ from
   * the size of the entity sent to this service. The entity size is counted within this service.
   */
  value: Scalars['JSON']['input'];
};

export type SetAppStoredEntityMutationInput = {
  /** The ARI to store this entity within */
  contextAri?: InputMaybe<Scalars['ID']['input']>;
  /** Specify whether value should be encrypted */
  encrypted?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The identifier for the entity
   *
   * Keys must be between 1-100 characters long and must match the following pattern /^[a-zA-Z0-9:._\s-]+$/
   */
  key: Scalars['ID']['input'];
  /**
   * Entities may be up to 2000 bytes long. Note that size within ESS may differ from
   * the size of the entity sent to this service. The entity size is counted within this service.
   */
  value: Scalars['JSON']['input'];
};

export type SetBoardEstimationTypeInput = {
  estimationType: Scalars['String']['input'];
  featureId: Scalars['String']['input'];
};

export type SetCardColorStrategyInput = {
  boardId: Scalars['ID']['input'];
  strategy: Scalars['String']['input'];
};

export type SetColumnLimitInput = {
  boardId: Scalars['ID']['input'];
  columnId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type SetColumnNameInput = {
  boardId: Scalars['ID']['input'];
  columnId: Scalars['ID']['input'];
  columnName: Scalars['String']['input'];
};

export type SetDefaultSpaceRoleAssignmentsInput = {
  spaceRoleAssignmentList: Array<RoleAssignment>;
};

/** Estimation Mutation */
export type SetEstimationTypeInput = {
  boardId: Scalars['ID']['input'];
  estimationType: Scalars['String']['input'];
};

export type SetExternalAuthCredentialsInput = {
  /** An object representing the credentials to set */
  credentials: ExternalAuthCredentialsInput;
  /** The input identifying what environment to set credentials for */
  environment: AppEnvironmentInput;
  /** The key for the service we're setting the credentials for (must already exist via previous deployment) */
  serviceKey: Scalars['String']['input'];
};

export type SetFeedUserConfigInput = {
  followSpaces?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  followUsers?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  unfollowSpaces?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  unfollowUsers?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type SetIssueMediaVisibilityInput = {
  boardId: Scalars['ID']['input'];
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SetPolarisSelectedDeliveryProjectInput = {
  projectId: Scalars['ID']['input'];
  selectedDeliveryProjectId: Scalars['ID']['input'];
};

export type SetPolarisSnippetPropertiesConfigInput = {
  /** Config */
  config?: InputMaybe<Scalars['JSON']['input']>;
  /** Snippet group id */
  groupId: Scalars['String']['input'];
  /** OauthClientId of CaaS app */
  oauthClientId: Scalars['String']['input'];
  /** project ARI */
  project: Scalars['ID']['input'];
};

export type SetRecommendedPagesSpaceStatusInput = {
  defaultBehavior?: InputMaybe<RecommendedPagesSpaceBehavior>;
  enableRecommendedPages?: InputMaybe<Scalars['Boolean']['input']>;
  entityId: Scalars['ID']['input'];
};

export type SetRecommendedPagesStatusInput = {
  enableRecommendedPages: Scalars['Boolean']['input'];
  entityId: Scalars['ID']['input'];
  entityType: Scalars['String']['input'];
};

export type SetSpaceRoleAssignmentsInput = {
  spaceId: Scalars['Long']['input'];
  spaceRoleAssignmentList: Array<RoleAssignment>;
};

/** Swimlane Mutations */
export type SetSwimlaneStrategyInput = {
  boardId: Scalars['ID']['input'];
  strategy: SwimlaneStrategy;
};

/** Represents a creation property with key and value */
export type SettingsCreationPropertyInput = {
  key: Scalars['ID']['input'];
  value: Scalars['String']['input'];
};

/** Input for mutation to update creation settings */
export type SettingsCreationSettingsInput = {
  autoApply?: InputMaybe<Scalars['Boolean']['input']>;
  ownerAri: Scalars['ID']['input'];
  properties?: InputMaybe<Array<SettingsCreationPropertyInput>>;
  tenantId: Scalars['ID']['input'];
};

/** Represents a navigation property with key and value */
export type SettingsDisplayPropertyInput = {
  key: Scalars['ID']['input'];
  value: Scalars['String']['input'];
};

/** Represents a navigation menu item with customisable attributes (e.g. visible) */
export type SettingsMenuItemInput = {
  menuId: Scalars['ID']['input'];
  visible: Scalars['Boolean']['input'];
};

/** Input for mutation to update navigation customisation settings */
export type SettingsNavigationCustomisationInput = {
  entityAri: Scalars['ID']['input'];
  ownerAri?: InputMaybe<Scalars['ID']['input']>;
  properties?: InputMaybe<Array<InputMaybe<SettingsDisplayPropertyInput>>>;
  sidebar?: InputMaybe<Array<InputMaybe<SettingsMenuItemInput>>>;
};

export type ShardedGraphStoreAriFilterInput = {
  is?: InputMaybe<Array<Scalars['String']['input']>>;
  isNot?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type ShardedGraphStoreAskHasImpactedWorkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAskHasOwnerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAskHasReceivingTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAskHasSubmitterSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAskHasSubmittingTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtiFilterInput = {
  is?: InputMaybe<Array<Scalars['String']['input']>>;
  isNot?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type ShardedGraphStoreAtlasGoalHasContributorSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasGoalHasFollowerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasGoalHasGoalUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasGoalHasJiraAlignProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasGoalHasOwnerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasGoalHasSubAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasHomeRankingCriteria = {
  /** An enum representing the ranking criteria used to pick `limit` feed items among all the sources */
  criteria: ShardedGraphStoreAtlasHomeRankingCriteriaEnum;
  /** The maximum number of feed items to return after ranking; defaults to 5 */
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export enum ShardedGraphStoreAtlasHomeRankingCriteriaEnum {
  /** From the prioritized list of sources pick one item (at random from each source) at a time until we reach the target / limit */
  RoundRobinRandom = 'ROUND_ROBIN_RANDOM'
}

export enum ShardedGraphStoreAtlasHomeSourcesEnum {
  JiraEpicWithoutProject = 'JIRA_EPIC_WITHOUT_PROJECT',
  JiraIssueAssigned = 'JIRA_ISSUE_ASSIGNED',
  JiraIssueNearOverdue = 'JIRA_ISSUE_NEAR_OVERDUE',
  JiraIssueOverdue = 'JIRA_ISSUE_OVERDUE',
  UserJoinFirstTeam = 'USER_JOIN_FIRST_TEAM',
  UserPageNotViewedByOthers = 'USER_PAGE_NOT_VIEWED_BY_OTHERS',
  UserShouldFollowGoal = 'USER_SHOULD_FOLLOW_GOAL',
  UserShouldViewSharedPage = 'USER_SHOULD_VIEW_SHARED_PAGE',
  UserViewAssignedIssue = 'USER_VIEW_ASSIGNED_ISSUE',
  UserViewNegativeGoal = 'USER_VIEW_NEGATIVE_GOAL',
  UserViewNegativeProject = 'USER_VIEW_NEGATIVE_PROJECT',
  UserViewPageComments = 'USER_VIEW_PAGE_COMMENTS',
  UserViewSharedVideo = 'USER_VIEW_SHARED_VIDEO',
  UserViewTaggedVideoComment = 'USER_VIEW_TAGGED_VIDEO_COMMENT',
  UserViewUpdatedGoal = 'USER_VIEW_UPDATED_GOAL',
  UserViewUpdatedPriorityIssue = 'USER_VIEW_UPDATED_PRIORITY_ISSUE',
  UserViewUpdatedProject = 'USER_VIEW_UPDATED_PROJECT'
}

export type ShardedGraphStoreAtlasProjectContributesToAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasProjectDependsOnAtlasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasProjectHasContributorSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasProjectHasFollowerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasProjectHasOwnerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasProjectHasProjectUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasProjectIsRelatedToAtlasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreAtlasProjectIsTrackedOnJiraEpicSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreBoardBelongsToProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreBooleanFilterInput = {
  is?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreBranchInRepoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreCalendarHasLinkedDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreChangeProposalHasAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreCommitBelongsToPullRequestSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreCommitInRepoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreComponentHasComponentLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreComponentImpactedByIncidentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreComponentLinkIsJiraProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreComponentLinkedJswIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConfluenceBlogpostHasCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConfluenceBlogpostSharedWithUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConfluencePageHasCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConfluencePageHasConfluenceCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConfluencePageHasConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConfluencePageHasParentPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConfluencePageSharedWithGroupSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConfluencePageSharedWithUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConfluenceSpaceHasConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConfluenceSpaceHasConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConfluenceSpaceHasConfluenceFolderSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConfluenceSpaceHasConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreContentReferencedEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreConversationHasMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreCreateComponentImpactedByIncidentInput = {
  /** The list of relationships of type component-impacted-by-incident to persist */
  relationships: Array<ShardedGraphStoreCreateComponentImpactedByIncidentRelationshipInput>;
};

export enum ShardedGraphStoreCreateComponentImpactedByIncidentJiraIncidentPriorityInput {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export enum ShardedGraphStoreCreateComponentImpactedByIncidentJiraIncidentStatusInput {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export type ShardedGraphStoreCreateComponentImpactedByIncidentRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** Object metadata for this relationship */
  objectMetadata?: InputMaybe<ShardedGraphStoreCreateComponentImpactedByIncidentRelationshipObjectMetadataInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateComponentImpactedByIncidentRelationshipObjectMetadataInput = {
  affectedServiceAris?: InputMaybe<Scalars['String']['input']>;
  assigneeAri?: InputMaybe<Scalars['String']['input']>;
  majorIncident?: InputMaybe<Scalars['Boolean']['input']>;
  priority?: InputMaybe<ShardedGraphStoreCreateComponentImpactedByIncidentJiraIncidentPriorityInput>;
  reporterAri?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ShardedGraphStoreCreateComponentImpactedByIncidentJiraIncidentStatusInput>;
};

export type ShardedGraphStoreCreateIncidentAssociatedPostIncidentReviewLinkInput = {
  /** The list of relationships of type incident-associated-post-incident-review-link to persist */
  relationships: Array<ShardedGraphStoreCreateIncidentAssociatedPostIncidentReviewLinkRelationshipInput>;
};

export type ShardedGraphStoreCreateIncidentAssociatedPostIncidentReviewLinkRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link, ati:cloud:jira:post-incident-review, ati:cloud:graph:post-incident-review] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link, ati:cloud:jira:post-incident-review, ati:cloud:graph:post-incident-review] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateIncidentHasActionItemInput = {
  /** The list of relationships of type incident-has-action-item to persist */
  relationships: Array<ShardedGraphStoreCreateIncidentHasActionItemRelationshipInput>;
};

export type ShardedGraphStoreCreateIncidentHasActionItemRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateIncidentLinkedJswIssueInput = {
  /** The list of relationships of type incident-linked-jsw-issue to persist */
  relationships: Array<ShardedGraphStoreCreateIncidentLinkedJswIssueRelationshipInput>;
};

export type ShardedGraphStoreCreateIncidentLinkedJswIssueRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateIssueToWhiteboardInput = {
  /** The list of relationships of type issue-to-whiteboard to persist */
  relationships: Array<ShardedGraphStoreCreateIssueToWhiteboardRelationshipInput>;
};

export type ShardedGraphStoreCreateIssueToWhiteboardRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:whiteboard */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export enum ShardedGraphStoreCreateJcsIssueAssociatedSupportEscalationEscalationLinkTypeInput {
  ExistingWorkItem = 'EXISTING_WORK_ITEM',
  NewWorkItem = 'NEW_WORK_ITEM',
  NotSet = 'NOT_SET'
}

export enum ShardedGraphStoreCreateJcsIssueAssociatedSupportEscalationEscalationStatusInput {
  Accepted = 'ACCEPTED',
  Open = 'OPEN',
  Rejected = 'REJECTED'
}

export type ShardedGraphStoreCreateJcsIssueAssociatedSupportEscalationInput = {
  /** The list of relationships of type jcs-issue-associated-support-escalation to persist */
  relationships: Array<ShardedGraphStoreCreateJcsIssueAssociatedSupportEscalationRelationshipInput>;
};

export type ShardedGraphStoreCreateJcsIssueAssociatedSupportEscalationRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:jira:issue] */
  from: Scalars['ID']['input'];
  /** Relationship specific metadata */
  relationshipMetadata?: InputMaybe<ShardedGraphStoreCreateJcsIssueAssociatedSupportEscalationRelationshipMetadataInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:jira:issue] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateJcsIssueAssociatedSupportEscalationRelationshipMetadataInput = {
  SupportEscalationLastUpdated?: InputMaybe<Scalars['Long']['input']>;
  creatorAri?: InputMaybe<Scalars['String']['input']>;
  linkType?: InputMaybe<ShardedGraphStoreCreateJcsIssueAssociatedSupportEscalationEscalationLinkTypeInput>;
  status?: InputMaybe<ShardedGraphStoreCreateJcsIssueAssociatedSupportEscalationEscalationStatusInput>;
};

export type ShardedGraphStoreCreateJswProjectAssociatedComponentInput = {
  /** The list of relationships of type jsw-project-associated-component to persist */
  relationships: Array<ShardedGraphStoreCreateJswProjectAssociatedComponentRelationshipInput>;
};

export type ShardedGraphStoreCreateJswProjectAssociatedComponentRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:graph:service, ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:graph:service, ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateLoomVideoHasConfluencePageInput = {
  /** The list of relationships of type loom-video-has-confluence-page to persist */
  relationships: Array<ShardedGraphStoreCreateLoomVideoHasConfluencePageRelationshipInput>;
};

export type ShardedGraphStoreCreateLoomVideoHasConfluencePageRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:page */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateMeetingRecordingOwnerHasMeetingNotesFolderInput = {
  /** The list of relationships of type meeting-recording-owner-has-meeting-notes-folder to persist */
  relationships: Array<ShardedGraphStoreCreateMeetingRecordingOwnerHasMeetingNotesFolderRelationshipInput>;
};

export type ShardedGraphStoreCreateMeetingRecordingOwnerHasMeetingNotesFolderRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:confluence:folder, ati:cloud:confluence:content] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:confluence:folder, ati:cloud:confluence:content] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateParentTeamHasChildTeamInput = {
  /** The list of relationships of type parent-team-has-child-team to persist */
  relationships: Array<ShardedGraphStoreCreateParentTeamHasChildTeamRelationshipInput>;
};

export type ShardedGraphStoreCreateParentTeamHasChildTeamRelationshipInput = {
  /** An ARI of type ati:cloud:identity:team */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:identity:team */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateProjectAssociatedOpsgenieTeamInput = {
  /** The list of relationships of type project-associated-opsgenie-team to persist */
  relationships: Array<ShardedGraphStoreCreateProjectAssociatedOpsgenieTeamRelationshipInput>;
};

export type ShardedGraphStoreCreateProjectAssociatedOpsgenieTeamRelationshipInput = {
  /** An ARI of type ati:cloud:opsgenie:team */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:opsgenie:team */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateProjectAssociatedToSecurityContainerInput = {
  /** The list of relationships of type project-associated-to-security-container to persist */
  relationships: Array<ShardedGraphStoreCreateProjectAssociatedToSecurityContainerRelationshipInput>;
};

export type ShardedGraphStoreCreateProjectAssociatedToSecurityContainerRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:security-container, ati:cloud:graph:security-container] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:security-container, ati:cloud:graph:security-container] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateProjectDisassociatedRepoInput = {
  /** The list of relationships of type project-disassociated-repo to persist */
  relationships: Array<ShardedGraphStoreCreateProjectDisassociatedRepoRelationshipInput>;
};

export type ShardedGraphStoreCreateProjectDisassociatedRepoRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:repository, ati:cloud:graph:repository] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:repository, ati:cloud:graph:repository] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateProjectDocumentationEntityInput = {
  /** The list of relationships of type project-documentation-entity to persist */
  relationships: Array<ShardedGraphStoreCreateProjectDocumentationEntityRelationshipInput>;
};

export type ShardedGraphStoreCreateProjectDocumentationEntityRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:confluence:space, ati:cloud:confluence:page, ati:cloud:jira:document, ati:cloud:graph:document] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:confluence:space, ati:cloud:confluence:page, ati:cloud:jira:document, ati:cloud:graph:document] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateProjectDocumentationPageInput = {
  /** The list of relationships of type project-documentation-page to persist */
  relationships: Array<ShardedGraphStoreCreateProjectDocumentationPageRelationshipInput>;
};

export type ShardedGraphStoreCreateProjectDocumentationPageRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:page */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateProjectDocumentationSpaceInput = {
  /** The list of relationships of type project-documentation-space to persist */
  relationships: Array<ShardedGraphStoreCreateProjectDocumentationSpaceRelationshipInput>;
};

export type ShardedGraphStoreCreateProjectDocumentationSpaceRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:space */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:space */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateProjectHasRelatedWorkWithProjectInput = {
  /** The list of relationships of type project-has-related-work-with-project to persist */
  relationships: Array<ShardedGraphStoreCreateProjectHasRelatedWorkWithProjectRelationshipInput>;
};

export type ShardedGraphStoreCreateProjectHasRelatedWorkWithProjectRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateProjectHasSharedVersionWithInput = {
  /** The list of relationships of type project-has-shared-version-with to persist */
  relationships: Array<ShardedGraphStoreCreateProjectHasSharedVersionWithRelationshipInput>;
};

export type ShardedGraphStoreCreateProjectHasSharedVersionWithRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateProjectHasVersionInput = {
  /** The list of relationships of type project-has-version to persist */
  relationships: Array<ShardedGraphStoreCreateProjectHasVersionRelationshipInput>;
};

export type ShardedGraphStoreCreateProjectHasVersionRelationshipInput = {
  /** An ARI of type ati:cloud:jira:version */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:version */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateSprintRetrospectivePageInput = {
  /** The list of relationships of type sprint-retrospective-page to persist */
  relationships: Array<ShardedGraphStoreCreateSprintRetrospectivePageRelationshipInput>;
};

export type ShardedGraphStoreCreateSprintRetrospectivePageRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:page */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateSprintRetrospectiveWhiteboardInput = {
  /** The list of relationships of type sprint-retrospective-whiteboard to persist */
  relationships: Array<ShardedGraphStoreCreateSprintRetrospectiveWhiteboardRelationshipInput>;
};

export type ShardedGraphStoreCreateSprintRetrospectiveWhiteboardRelationshipInput = {
  /** An ARI of type ati:cloud:confluence:whiteboard */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateTeamConnectedToContainerInput = {
  /** The list of relationships of type team-connected-to-container to persist */
  relationships: Array<ShardedGraphStoreCreateTeamConnectedToContainerRelationshipInput>;
  /** If true, the request will wait until the relationship is created before returning. This will make the request twice as expensive and should not be used unless absolutely necessary. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreCreateTeamConnectedToContainerRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:confluence:space, ati:cloud:loom:space] */
  from: Scalars['ID']['input'];
  /** Relationship specific metadata */
  relationshipMetadata?: InputMaybe<ShardedGraphStoreCreateTeamConnectedToContainerRelationshipMetadataInput>;
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:confluence:space, ati:cloud:loom:space] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateTeamConnectedToContainerRelationshipMetadataInput = {
  createdFromAutocreate?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreCreateTownsquareTagIsAliasOfTownsquareTagInput = {
  /** The list of relationships of type townsquare-tag-is-alias-of-townsquare-tag to persist */
  relationships: Array<ShardedGraphStoreCreateTownsquareTagIsAliasOfTownsquareTagRelationshipInput>;
};

export type ShardedGraphStoreCreateTownsquareTagIsAliasOfTownsquareTagRelationshipInput = {
  /** An ARI of type ati:cloud:townsquare:tag */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:townsquare:tag */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateUserHasRelevantProjectInput = {
  /** The list of relationships of type user-has-relevant-project to persist */
  relationships: Array<ShardedGraphStoreCreateUserHasRelevantProjectRelationshipInput>;
};

export type ShardedGraphStoreCreateUserHasRelevantProjectRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateVersionUserAssociatedFeatureFlagInput = {
  /** The list of relationships of type version-user-associated-feature-flag to persist */
  relationships: Array<ShardedGraphStoreCreateVersionUserAssociatedFeatureFlagRelationshipInput>;
};

export type ShardedGraphStoreCreateVersionUserAssociatedFeatureFlagRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:feature-flag, ati:cloud:graph:feature-flag] */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** An ARI of any of the following [ati:cloud:jira:feature-flag, ati:cloud:graph:feature-flag] */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateVulnerabilityAssociatedIssueContainerInput = {
  containerAri?: InputMaybe<Scalars['String']['input']>;
};

export type ShardedGraphStoreCreateVulnerabilityAssociatedIssueInput = {
  /** The list of relationships of type vulnerability-associated-issue to persist */
  relationships: Array<ShardedGraphStoreCreateVulnerabilityAssociatedIssueRelationshipInput>;
};

export type ShardedGraphStoreCreateVulnerabilityAssociatedIssueRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** Sequence number of this relationship, used for versioning. updatedAt as millis will be used if omitted */
  sequenceNumber?: InputMaybe<Scalars['Long']['input']>;
  /** Subject metadata for this relationship */
  subjectMetadata?: InputMaybe<ShardedGraphStoreCreateVulnerabilityAssociatedIssueRelationshipSubjectMetadataInput>;
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
  /** Time at which these relationships were last observed. Current time will be assumed if omitted. */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreCreateVulnerabilityAssociatedIssueRelationshipSubjectMetadataInput = {
  container?: InputMaybe<ShardedGraphStoreCreateVulnerabilityAssociatedIssueContainerInput>;
  introducedDate?: InputMaybe<Scalars['DateTime']['input']>;
  severity?: InputMaybe<ShardedGraphStoreCreateVulnerabilityAssociatedIssueVulnerabilitySeverityInput>;
  status?: InputMaybe<ShardedGraphStoreCreateVulnerabilityAssociatedIssueVulnerabilityStatusInput>;
  type?: InputMaybe<ShardedGraphStoreCreateVulnerabilityAssociatedIssueVulnerabilityTypeInput>;
};

export enum ShardedGraphStoreCreateVulnerabilityAssociatedIssueVulnerabilitySeverityInput {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export enum ShardedGraphStoreCreateVulnerabilityAssociatedIssueVulnerabilityStatusInput {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum ShardedGraphStoreCreateVulnerabilityAssociatedIssueVulnerabilityTypeInput {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreCustomerAssociatedIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

/** A single query request containing the query and pagination parameters */
export type ShardedGraphStoreCypherQueryV2BatchQueryRequestInput = {
  /** Cursor for where to start fetching the page */
  after?: InputMaybe<Scalars['String']['input']>;
  /**
   * How many rows to include in the result.
   * Note the response could include less rows than requested (including be empty), and still have more pages to be fetched.
   * Must not exceed 1000, default is 100
   */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Cypher query to execute */
  query: Scalars['String']['input'];
};

export enum ShardedGraphStoreCypherQueryV2BatchVersionEnum {
  /** V2 */
  V2 = 'V2',
  /** V3 */
  V3 = 'V3'
}

export enum ShardedGraphStoreCypherQueryV2VersionEnum {
  /** V2 */
  V2 = 'V2',
  /** V3 */
  V3 = 'V3'
}

export type ShardedGraphStoreDateFilterInput = {
  after?: InputMaybe<Scalars['DateTime']['input']>;
  before?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ShardedGraphStoreDeleteComponentImpactedByIncidentInput = {
  /** The list of relationships of type component-impacted-by-incident to delete */
  relationships: Array<ShardedGraphStoreDeleteComponentImpactedByIncidentRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteComponentImpactedByIncidentRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteIncidentAssociatedPostIncidentReviewLinkInput = {
  /** The list of relationships of type incident-associated-post-incident-review-link to delete */
  relationships: Array<ShardedGraphStoreDeleteIncidentAssociatedPostIncidentReviewLinkRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteIncidentAssociatedPostIncidentReviewLinkRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:post-incident-review-link, ati:cloud:jira:post-incident-review, ati:cloud:graph:post-incident-review] */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteIncidentHasActionItemInput = {
  /** The list of relationships of type incident-has-action-item to delete */
  relationships: Array<ShardedGraphStoreDeleteIncidentHasActionItemRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteIncidentHasActionItemRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteIncidentLinkedJswIssueInput = {
  /** The list of relationships of type incident-linked-jsw-issue to delete */
  relationships: Array<ShardedGraphStoreDeleteIncidentLinkedJswIssueRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteIncidentLinkedJswIssueRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:issue, ati:cloud:jira:incident, ati:cloud:graph:incident] */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteIssueToWhiteboardInput = {
  /** The list of relationships of type issue-to-whiteboard to delete */
  relationships: Array<ShardedGraphStoreDeleteIssueToWhiteboardRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteIssueToWhiteboardRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteJcsIssueAssociatedSupportEscalationInput = {
  /** The list of relationships of type jcs-issue-associated-support-escalation to delete */
  relationships: Array<ShardedGraphStoreDeleteJcsIssueAssociatedSupportEscalationRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteJcsIssueAssociatedSupportEscalationRelationshipInput = {
  /** An ARI of type ati:cloud:jira:issue */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:jira:issue] */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteJswProjectAssociatedComponentInput = {
  /** The list of relationships of type jsw-project-associated-component to delete */
  relationships: Array<ShardedGraphStoreDeleteJswProjectAssociatedComponentRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteJswProjectAssociatedComponentRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:graph:service, ati:cloud:compass:component, ati:cloud:jira:devops-component, ati:cloud:graph:devops-component] */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteLoomVideoHasConfluencePageInput = {
  /** The list of relationships of type loom-video-has-confluence-page to delete */
  relationships: Array<ShardedGraphStoreDeleteLoomVideoHasConfluencePageRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteLoomVideoHasConfluencePageRelationshipInput = {
  /** An ARI of type ati:cloud:loom:video */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteMeetingRecordingOwnerHasMeetingNotesFolderInput = {
  /** The list of relationships of type meeting-recording-owner-has-meeting-notes-folder to delete */
  relationships: Array<ShardedGraphStoreDeleteMeetingRecordingOwnerHasMeetingNotesFolderRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteMeetingRecordingOwnerHasMeetingNotesFolderRelationshipInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:confluence:folder, ati:cloud:confluence:content] */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteParentTeamHasChildTeamInput = {
  /** The list of relationships of type parent-team-has-child-team to delete */
  relationships: Array<ShardedGraphStoreDeleteParentTeamHasChildTeamRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteParentTeamHasChildTeamRelationshipInput = {
  /** An ARI of type ati:cloud:identity:team */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:identity:team */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteProjectAssociatedOpsgenieTeamInput = {
  /** The list of relationships of type project-associated-opsgenie-team to delete */
  relationships: Array<ShardedGraphStoreDeleteProjectAssociatedOpsgenieTeamRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteProjectAssociatedOpsgenieTeamRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:opsgenie:team */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteProjectAssociatedToSecurityContainerInput = {
  /** The list of relationships of type project-associated-to-security-container to delete */
  relationships: Array<ShardedGraphStoreDeleteProjectAssociatedToSecurityContainerRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteProjectAssociatedToSecurityContainerRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:security-container, ati:cloud:graph:security-container] */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteProjectDisassociatedRepoInput = {
  /** The list of relationships of type project-disassociated-repo to delete */
  relationships: Array<ShardedGraphStoreDeleteProjectDisassociatedRepoRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteProjectDisassociatedRepoRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:repository, ati:cloud:graph:repository] */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteProjectDocumentationEntityInput = {
  /** The list of relationships of type project-documentation-entity to delete */
  relationships: Array<ShardedGraphStoreDeleteProjectDocumentationEntityRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteProjectDocumentationEntityRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:confluence:space, ati:cloud:confluence:page, ati:cloud:jira:document, ati:cloud:graph:document] */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteProjectDocumentationPageInput = {
  /** The list of relationships of type project-documentation-page to delete */
  relationships: Array<ShardedGraphStoreDeleteProjectDocumentationPageRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteProjectDocumentationPageRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteProjectDocumentationSpaceInput = {
  /** The list of relationships of type project-documentation-space to delete */
  relationships: Array<ShardedGraphStoreDeleteProjectDocumentationSpaceRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteProjectDocumentationSpaceRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:space */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteProjectHasRelatedWorkWithProjectInput = {
  /** The list of relationships of type project-has-related-work-with-project to delete */
  relationships: Array<ShardedGraphStoreDeleteProjectHasRelatedWorkWithProjectRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteProjectHasRelatedWorkWithProjectRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteProjectHasSharedVersionWithInput = {
  /** The list of relationships of type project-has-shared-version-with to delete */
  relationships: Array<ShardedGraphStoreDeleteProjectHasSharedVersionWithRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteProjectHasSharedVersionWithRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteProjectHasVersionInput = {
  /** The list of relationships of type project-has-version to delete */
  relationships: Array<ShardedGraphStoreDeleteProjectHasVersionRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteProjectHasVersionRelationshipInput = {
  /** An ARI of type ati:cloud:jira:project */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:version */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteSprintRetrospectivePageInput = {
  /** The list of relationships of type sprint-retrospective-page to delete */
  relationships: Array<ShardedGraphStoreDeleteSprintRetrospectivePageRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteSprintRetrospectivePageRelationshipInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:page */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteSprintRetrospectiveWhiteboardInput = {
  /** The list of relationships of type sprint-retrospective-whiteboard to delete */
  relationships: Array<ShardedGraphStoreDeleteSprintRetrospectiveWhiteboardRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteSprintRetrospectiveWhiteboardRelationshipInput = {
  /** An ARI of type ati:cloud:jira:sprint */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:confluence:whiteboard */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteTeamConnectedToContainerInput = {
  /** The list of relationships of type team-connected-to-container to delete */
  relationships: Array<ShardedGraphStoreDeleteTeamConnectedToContainerRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteTeamConnectedToContainerRelationshipInput = {
  /** An ARI of type ati:cloud:identity:team */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:project, ati:cloud:confluence:space, ati:cloud:loom:space] */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteTownsquareTagIsAliasOfTownsquareTagInput = {
  /** The list of relationships of type townsquare-tag-is-alias-of-townsquare-tag to delete */
  relationships: Array<ShardedGraphStoreDeleteTownsquareTagIsAliasOfTownsquareTagRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteTownsquareTagIsAliasOfTownsquareTagRelationshipInput = {
  /** An ARI of type ati:cloud:townsquare:tag */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:townsquare:tag */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteUserHasRelevantProjectInput = {
  /** The list of relationships of type user-has-relevant-project to delete */
  relationships: Array<ShardedGraphStoreDeleteUserHasRelevantProjectRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteUserHasRelevantProjectRelationshipInput = {
  /** An ARI of type ati:cloud:identity:user */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:project */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteVersionUserAssociatedFeatureFlagInput = {
  /** The list of relationships of type version-user-associated-feature-flag to delete */
  relationships: Array<ShardedGraphStoreDeleteVersionUserAssociatedFeatureFlagRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteVersionUserAssociatedFeatureFlagRelationshipInput = {
  /** An ARI of type ati:cloud:jira:version */
  from: Scalars['ID']['input'];
  /** An ARI of any of the following [ati:cloud:jira:feature-flag, ati:cloud:graph:feature-flag] */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeleteVulnerabilityAssociatedIssueInput = {
  /** The list of relationships of type vulnerability-associated-issue to delete */
  relationships: Array<ShardedGraphStoreDeleteVulnerabilityAssociatedIssueRelationshipInput>;
  /** If true, the request will wait until the relationship is deleted before returning. This will make the request twice as expensive and should not be used unless really needed. */
  synchronousWrite?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShardedGraphStoreDeleteVulnerabilityAssociatedIssueRelationshipInput = {
  /** An ARI of any of the following [ati:cloud:jira:vulnerability, ati:cloud:graph:vulnerability] */
  from: Scalars['ID']['input'];
  /** An ARI of type ati:cloud:jira:issue */
  to: Scalars['ID']['input'];
};

export type ShardedGraphStoreDeploymentAssociatedDeploymentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreDeploymentAssociatedRepoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreDeploymentContainsCommitSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreEntityIsRelatedToEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreExternalOrgHasExternalPositionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreExternalOrgHasExternalWorkerSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreExternalOrgHasUserAsMemberSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreExternalOrgIsParentOfExternalOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreExternalPositionIsFilledByExternalWorkerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreExternalPositionManagesExternalOrgSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreExternalPositionManagesExternalPositionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreExternalWorkerConflatesToIdentity3pUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreExternalWorkerConflatesToUserSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreFloatFilterInput = {
  greaterThan?: InputMaybe<Scalars['Float']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['Float']['input']>;
  is?: InputMaybe<Array<Scalars['Float']['input']>>;
  isNot?: InputMaybe<Array<Scalars['Float']['input']>>;
  lessThan?: InputMaybe<Scalars['Float']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['Float']['input']>;
};

export type ShardedGraphStoreFocusAreaAssociatedToProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreFocusAreaHasAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreFocusAreaHasFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreFocusAreaHasPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreFocusAreaHasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreFocusAreaHasWatcherSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreGraphDocument3pDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreGraphEntityReplicates3pEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreGroupCanViewConfluenceSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIncidentAssociatedPostIncidentReviewLinkSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIncidentAssociatedPostIncidentReviewSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIncidentHasActionItemSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIncidentLinkedJswIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIntFilterInput = {
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['Int']['input']>;
  is?: InputMaybe<Array<Scalars['Int']['input']>>;
  isNot?: InputMaybe<Array<Scalars['Int']['input']>>;
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['Int']['input']>;
};

export type ShardedGraphStoreIssueAssociatedBranchSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueAssociatedBuildSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueAssociatedCommitSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueAssociatedDeploymentAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreIssueAssociatedDeploymentAuthorFilterInput>>>;
  authorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreIssueAssociatedDeploymentAuthorFilterInput>>>;
};

export type ShardedGraphStoreIssueAssociatedDeploymentAuthorSortInput = {
  authorAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueAssociatedDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_author?: InputMaybe<ShardedGraphStoreIssueAssociatedDeploymentAuthorFilterInput>;
  to_environmentType?: InputMaybe<ShardedGraphStoreIssueAssociatedDeploymentEnvironmentTypeFilterInput>;
  to_state?: InputMaybe<ShardedGraphStoreIssueAssociatedDeploymentDeploymentStateFilterInput>;
};

export enum ShardedGraphStoreIssueAssociatedDeploymentDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreIssueAssociatedDeploymentDeploymentStateFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreIssueAssociatedDeploymentDeploymentState>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreIssueAssociatedDeploymentDeploymentState>>;
};

export enum ShardedGraphStoreIssueAssociatedDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type ShardedGraphStoreIssueAssociatedDeploymentEnvironmentTypeFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreIssueAssociatedDeploymentEnvironmentType>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreIssueAssociatedDeploymentEnvironmentType>>;
};

/** Conditional selection for filter field of issue-associated-deployment relationship queries */
export type ShardedGraphStoreIssueAssociatedDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreIssueAssociatedDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreIssueAssociatedDeploymentConditionalFilterInput>>>;
};

export type ShardedGraphStoreIssueAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_author?: InputMaybe<ShardedGraphStoreIssueAssociatedDeploymentAuthorSortInput>;
  to_environmentType?: InputMaybe<ShardedGraphStoreSortInput>;
  to_state?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueAssociatedDesignSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_status?: InputMaybe<ShardedGraphStoreSortInput>;
  to_type?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueAssociatedFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueAssociatedIssueRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueAssociatedPrSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueAssociatedRemoteLinkSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueChangesComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueHasAssigneeSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export enum ShardedGraphStoreIssueHasAutodevJobAutodevJobStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreIssueHasAutodevJobAutodevJobStatusFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreIssueHasAutodevJobAutodevJobStatus>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreIssueHasAutodevJobAutodevJobStatus>>;
};

export type ShardedGraphStoreIssueHasAutodevJobConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_agentAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_createdAt?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  to_jobOwnerAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_status?: InputMaybe<ShardedGraphStoreIssueHasAutodevJobAutodevJobStatusFilterInput>;
  to_updatedAt?: InputMaybe<ShardedGraphStoreLongFilterInput>;
};

/** Conditional selection for filter field of issue-has-autodev-job relationship queries */
export type ShardedGraphStoreIssueHasAutodevJobFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreIssueHasAutodevJobConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreIssueHasAutodevJobConditionalFilterInput>>>;
};

export type ShardedGraphStoreIssueHasAutodevJobSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_agentAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  to_jobOwnerAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_status?: InputMaybe<ShardedGraphStoreSortInput>;
  to_updatedAt?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueHasChangedPrioritySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueHasChangedStatusSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueHasCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueMentionedInConversationSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueMentionedInMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueRecursiveAssociatedPrSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueRelatedToIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreIssueToWhiteboardConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of issue-to-whiteboard relationship queries */
export type ShardedGraphStoreIssueToWhiteboardFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreIssueToWhiteboardConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreIssueToWhiteboardConditionalFilterInput>>>;
};

export type ShardedGraphStoreIssueToWhiteboardSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreJcsIssueAssociatedSupportEscalationConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  relationship_SupportEscalationLastUpdated?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  relationship_creatorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_linkType?: InputMaybe<ShardedGraphStoreJcsIssueAssociatedSupportEscalationEscalationLinkTypeFilterInput>;
  relationship_status?: InputMaybe<ShardedGraphStoreJcsIssueAssociatedSupportEscalationEscalationStatusFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
};

export enum ShardedGraphStoreJcsIssueAssociatedSupportEscalationEscalationLinkType {
  ExistingWorkItem = 'EXISTING_WORK_ITEM',
  NewWorkItem = 'NEW_WORK_ITEM',
  NotSet = 'NOT_SET'
}

export type ShardedGraphStoreJcsIssueAssociatedSupportEscalationEscalationLinkTypeFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreJcsIssueAssociatedSupportEscalationEscalationLinkType>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreJcsIssueAssociatedSupportEscalationEscalationLinkType>>;
};

export enum ShardedGraphStoreJcsIssueAssociatedSupportEscalationEscalationStatus {
  Accepted = 'ACCEPTED',
  Open = 'OPEN',
  Rejected = 'REJECTED'
}

export type ShardedGraphStoreJcsIssueAssociatedSupportEscalationEscalationStatusFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreJcsIssueAssociatedSupportEscalationEscalationStatus>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreJcsIssueAssociatedSupportEscalationEscalationStatus>>;
};

/** Conditional selection for filter field of jcs-issue-associated-support-escalation relationship queries */
export type ShardedGraphStoreJcsIssueAssociatedSupportEscalationFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreJcsIssueAssociatedSupportEscalationConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreJcsIssueAssociatedSupportEscalationConditionalFilterInput>>>;
};

export type ShardedGraphStoreJcsIssueAssociatedSupportEscalationSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_SupportEscalationLastUpdated?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_linkType?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_status?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreJiraEpicContributesToAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreJiraIssueBlockedByJiraIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreJiraIssueToJiraPrioritySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreJiraProjectAssociatedAtlasGoalSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreJiraRepoIsProviderRepoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreJsmProjectAssociatedServiceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreJsmProjectLinkedKbSourcesSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreJswProjectAssociatedComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreJswProjectAssociatedIncidentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_affectedServiceAris?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_assigneeAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_majorIncident?: InputMaybe<ShardedGraphStoreBooleanFilterInput>;
  to_priority?: InputMaybe<ShardedGraphStoreJswProjectAssociatedIncidentJiraIncidentPriorityFilterInput>;
  to_reporterAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_status?: InputMaybe<ShardedGraphStoreJswProjectAssociatedIncidentJiraIncidentStatusFilterInput>;
};

/** Conditional selection for filter field of jsw-project-associated-incident relationship queries */
export type ShardedGraphStoreJswProjectAssociatedIncidentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreJswProjectAssociatedIncidentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreJswProjectAssociatedIncidentConditionalFilterInput>>>;
};

export enum ShardedGraphStoreJswProjectAssociatedIncidentJiraIncidentPriority {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreJswProjectAssociatedIncidentJiraIncidentPriorityFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreJswProjectAssociatedIncidentJiraIncidentPriority>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreJswProjectAssociatedIncidentJiraIncidentPriority>>;
};

export enum ShardedGraphStoreJswProjectAssociatedIncidentJiraIncidentStatus {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export type ShardedGraphStoreJswProjectAssociatedIncidentJiraIncidentStatusFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreJswProjectAssociatedIncidentJiraIncidentStatus>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreJswProjectAssociatedIncidentJiraIncidentStatus>>;
};

export type ShardedGraphStoreJswProjectAssociatedIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_affectedServiceAris?: InputMaybe<ShardedGraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_majorIncident?: InputMaybe<ShardedGraphStoreSortInput>;
  to_priority?: InputMaybe<ShardedGraphStoreSortInput>;
  to_reporterAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_status?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreJswProjectSharesComponentWithJsmProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreLinkedProjectHasVersionSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreLongFilterInput = {
  greaterThan?: InputMaybe<Scalars['Long']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['Long']['input']>;
  is?: InputMaybe<Array<Scalars['Long']['input']>>;
  isNot?: InputMaybe<Array<Scalars['Long']['input']>>;
  lessThan?: InputMaybe<Scalars['Long']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['Long']['input']>;
};

export type ShardedGraphStoreLoomVideoHasConfluencePageSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreMediaAttachedToContentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreMeetingHasMeetingNotesPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreMeetingRecordingOwnerHasMeetingNotesFolderSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreMeetingRecurrenceHasMeetingRecurrenceNotesPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreOperationsContainerImpactedByIncidentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreOperationsContainerImprovedByActionItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreParentCommentHasChildCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreParentDocumentHasChildDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreParentIssueHasChildIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreParentMessageHasChildMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreParentTeamHasChildTeamSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStorePositionAllocatedToFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStorePositionAssociatedExternalPositionSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStorePrHasCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStorePrInProviderRepoSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStorePrInRepoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export enum ShardedGraphStoreProjectAssociatedAutodevJobAutodevJobStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreProjectAssociatedAutodevJobAutodevJobStatusFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedAutodevJobAutodevJobStatus>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedAutodevJobAutodevJobStatus>>;
};

export type ShardedGraphStoreProjectAssociatedAutodevJobConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_agentAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_createdAt?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  to_jobOwnerAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_status?: InputMaybe<ShardedGraphStoreProjectAssociatedAutodevJobAutodevJobStatusFilterInput>;
  to_updatedAt?: InputMaybe<ShardedGraphStoreLongFilterInput>;
};

/** Conditional selection for filter field of project-associated-autodev-job relationship queries */
export type ShardedGraphStoreProjectAssociatedAutodevJobFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedAutodevJobConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedAutodevJobConditionalFilterInput>>>;
};

export type ShardedGraphStoreProjectAssociatedAutodevJobSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_agentAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  to_jobOwnerAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_status?: InputMaybe<ShardedGraphStoreSortInput>;
  to_updatedAt?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedBranchSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export enum ShardedGraphStoreProjectAssociatedBuildBuildState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreProjectAssociatedBuildBuildStateFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedBuildBuildState>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedBuildBuildState>>;
};

export type ShardedGraphStoreProjectAssociatedBuildConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_sprintAris?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_state?: InputMaybe<ShardedGraphStoreProjectAssociatedBuildBuildStateFilterInput>;
  to_testInfo?: InputMaybe<ShardedGraphStoreProjectAssociatedBuildTestInfoFilterInput>;
};

/** Conditional selection for filter field of project-associated-build relationship queries */
export type ShardedGraphStoreProjectAssociatedBuildFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedBuildConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedBuildConditionalFilterInput>>>;
};

export type ShardedGraphStoreProjectAssociatedBuildSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_state?: InputMaybe<ShardedGraphStoreSortInput>;
  to_testInfo?: InputMaybe<ShardedGraphStoreProjectAssociatedBuildTestInfoSortInput>;
};

export type ShardedGraphStoreProjectAssociatedBuildTestInfoFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedBuildTestInfoFilterInput>>>;
  numberFailed?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  numberPassed?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  numberSkipped?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedBuildTestInfoFilterInput>>>;
  totalNumber?: InputMaybe<ShardedGraphStoreLongFilterInput>;
};

export type ShardedGraphStoreProjectAssociatedBuildTestInfoSortInput = {
  numberFailed?: InputMaybe<ShardedGraphStoreSortInput>;
  numberPassed?: InputMaybe<ShardedGraphStoreSortInput>;
  numberSkipped?: InputMaybe<ShardedGraphStoreSortInput>;
  totalNumber?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedDeploymentAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedDeploymentAuthorFilterInput>>>;
  authorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedDeploymentAuthorFilterInput>>>;
};

export type ShardedGraphStoreProjectAssociatedDeploymentAuthorSortInput = {
  authorAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_fixVersionIds?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  relationship_issueAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  relationship_issueTypeAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_reporterAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_sprintAris?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_author?: InputMaybe<ShardedGraphStoreProjectAssociatedDeploymentAuthorFilterInput>;
  to_deploymentLastUpdated?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  to_environmentType?: InputMaybe<ShardedGraphStoreProjectAssociatedDeploymentEnvironmentTypeFilterInput>;
  to_state?: InputMaybe<ShardedGraphStoreProjectAssociatedDeploymentDeploymentStateFilterInput>;
};

export enum ShardedGraphStoreProjectAssociatedDeploymentDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreProjectAssociatedDeploymentDeploymentStateFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedDeploymentDeploymentState>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedDeploymentDeploymentState>>;
};

export enum ShardedGraphStoreProjectAssociatedDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type ShardedGraphStoreProjectAssociatedDeploymentEnvironmentTypeFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedDeploymentEnvironmentType>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedDeploymentEnvironmentType>>;
};

/** Conditional selection for filter field of project-associated-deployment relationship queries */
export type ShardedGraphStoreProjectAssociatedDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedDeploymentConditionalFilterInput>>>;
};

export type ShardedGraphStoreProjectAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_fixVersionIds?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueTypeAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_author?: InputMaybe<ShardedGraphStoreProjectAssociatedDeploymentAuthorSortInput>;
  to_deploymentLastUpdated?: InputMaybe<ShardedGraphStoreSortInput>;
  to_environmentType?: InputMaybe<ShardedGraphStoreSortInput>;
  to_state?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedIncidentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of project-associated-incident relationship queries */
export type ShardedGraphStoreProjectAssociatedIncidentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedIncidentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedIncidentConditionalFilterInput>>>;
};

export type ShardedGraphStoreProjectAssociatedIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedOpsgenieTeamSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedPrAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedPrAuthorFilterInput>>>;
  authorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedPrAuthorFilterInput>>>;
};

export type ShardedGraphStoreProjectAssociatedPrAuthorSortInput = {
  authorAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedPrConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_sprintAris?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_author?: InputMaybe<ShardedGraphStoreProjectAssociatedPrAuthorFilterInput>;
  to_reviewers?: InputMaybe<ShardedGraphStoreProjectAssociatedPrReviewerFilterInput>;
  to_status?: InputMaybe<ShardedGraphStoreProjectAssociatedPrPullRequestStatusFilterInput>;
  to_taskCount?: InputMaybe<ShardedGraphStoreFloatFilterInput>;
};

/** Conditional selection for filter field of project-associated-pr relationship queries */
export type ShardedGraphStoreProjectAssociatedPrFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedPrConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedPrConditionalFilterInput>>>;
};

export enum ShardedGraphStoreProjectAssociatedPrPullRequestStatus {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreProjectAssociatedPrPullRequestStatusFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedPrPullRequestStatus>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedPrPullRequestStatus>>;
};

export type ShardedGraphStoreProjectAssociatedPrReviewerFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedPrReviewerFilterInput>>>;
  approvalStatus?: InputMaybe<ShardedGraphStoreProjectAssociatedPrReviewerReviewerStatusFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedPrReviewerFilterInput>>>;
  reviewerAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
};

export enum ShardedGraphStoreProjectAssociatedPrReviewerReviewerStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export type ShardedGraphStoreProjectAssociatedPrReviewerReviewerStatusFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedPrReviewerReviewerStatus>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedPrReviewerReviewerStatus>>;
};

export type ShardedGraphStoreProjectAssociatedPrReviewerSortInput = {
  approvalStatus?: InputMaybe<ShardedGraphStoreSortInput>;
  reviewerAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedPrSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_author?: InputMaybe<ShardedGraphStoreProjectAssociatedPrAuthorSortInput>;
  to_reviewers?: InputMaybe<ShardedGraphStoreProjectAssociatedPrReviewerSortInput>;
  to_status?: InputMaybe<ShardedGraphStoreSortInput>;
  to_taskCount?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedRepoConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_providerAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of project-associated-repo relationship queries */
export type ShardedGraphStoreProjectAssociatedRepoFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedRepoConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedRepoConditionalFilterInput>>>;
};

export type ShardedGraphStoreProjectAssociatedRepoSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_providerAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedServiceConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of project-associated-service relationship queries */
export type ShardedGraphStoreProjectAssociatedServiceFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedServiceConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedServiceConditionalFilterInput>>>;
};

export type ShardedGraphStoreProjectAssociatedServiceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedToIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedToOperationsContainerSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedToSecurityContainerSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectAssociatedVulnerabilityConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_container?: InputMaybe<ShardedGraphStoreProjectAssociatedVulnerabilityContainerFilterInput>;
  to_severity?: InputMaybe<ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverityFilterInput>;
  to_status?: InputMaybe<ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilityStatusFilterInput>;
  to_type?: InputMaybe<ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilityTypeFilterInput>;
};

export type ShardedGraphStoreProjectAssociatedVulnerabilityContainerFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedVulnerabilityContainerFilterInput>>>;
  containerAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedVulnerabilityContainerFilterInput>>>;
};

export type ShardedGraphStoreProjectAssociatedVulnerabilityContainerSortInput = {
  containerAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

/** Conditional selection for filter field of project-associated-vulnerability relationship queries */
export type ShardedGraphStoreProjectAssociatedVulnerabilityFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedVulnerabilityConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectAssociatedVulnerabilityConditionalFilterInput>>>;
};

export type ShardedGraphStoreProjectAssociatedVulnerabilitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_container?: InputMaybe<ShardedGraphStoreProjectAssociatedVulnerabilityContainerSortInput>;
  to_severity?: InputMaybe<ShardedGraphStoreSortInput>;
  to_status?: InputMaybe<ShardedGraphStoreSortInput>;
  to_type?: InputMaybe<ShardedGraphStoreSortInput>;
};

export enum ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverityFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverity>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilitySeverity>>;
};

export enum ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilityStatusFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilityStatus>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilityStatus>>;
};

export enum ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilityType {
  Dast = 'DAST',
  NotSet = 'NOT_SET',
  Sast = 'SAST',
  Sca = 'SCA',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilityTypeFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilityType>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreProjectAssociatedVulnerabilityVulnerabilityType>>;
};

export type ShardedGraphStoreProjectDisassociatedRepoSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectDocumentationEntitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectDocumentationPageSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectDocumentationSpaceSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectExplicitlyAssociatedRepoSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_providerAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectHasIssueConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  relationship_sprintAris?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_assigneeAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_creatorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_fixVersionIds?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  to_issueAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_issueTypeAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_reporterAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_statusAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of project-has-issue relationship queries */
export type ShardedGraphStoreProjectHasIssueFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectHasIssueConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreProjectHasIssueConditionalFilterInput>>>;
};

export type ShardedGraphStoreProjectHasIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_sprintAris?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_creatorAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_fixVersionIds?: InputMaybe<ShardedGraphStoreSortInput>;
  to_issueAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_issueTypeAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_reporterAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_statusAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectHasRelatedWorkWithProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectHasSharedVersionWithSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectHasVersionSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreProjectLinkedToCompassComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStorePullRequestLinksToServiceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreScorecardHasAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreSecurityContainerAssociatedToVulnerabilitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreServiceAssociatedBranchSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreServiceAssociatedBuildSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreServiceAssociatedCommitSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreServiceAssociatedDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of service-associated-deployment relationship queries */
export type ShardedGraphStoreServiceAssociatedDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreServiceAssociatedDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreServiceAssociatedDeploymentConditionalFilterInput>>>;
};

export type ShardedGraphStoreServiceAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreServiceAssociatedFeatureFlagSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreServiceAssociatedPrSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreServiceAssociatedRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreServiceAssociatedTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreServiceLinkedIncidentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_affectedServiceAris?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_assigneeAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_majorIncident?: InputMaybe<ShardedGraphStoreBooleanFilterInput>;
  to_priority?: InputMaybe<ShardedGraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriorityFilterInput>;
  to_reporterAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_status?: InputMaybe<ShardedGraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatusFilterInput>;
};

/** Conditional selection for filter field of service-linked-incident relationship queries */
export type ShardedGraphStoreServiceLinkedIncidentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreServiceLinkedIncidentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreServiceLinkedIncidentConditionalFilterInput>>>;
};

export enum ShardedGraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriority {
  NotSet = 'NOT_SET',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3',
  P4 = 'P4',
  P5 = 'P5'
}

export type ShardedGraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriorityFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriority>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreServiceLinkedIncidentJiraServiceManagementIncidentPriority>>;
};

export enum ShardedGraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatus {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  NotSet = 'NOT_SET',
  Undefined = 'UNDEFINED'
}

export type ShardedGraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatusFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatus>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreServiceLinkedIncidentJiraServiceManagementIncidentStatus>>;
};

export type ShardedGraphStoreServiceLinkedIncidentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_affectedServiceAris?: InputMaybe<ShardedGraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_majorIncident?: InputMaybe<ShardedGraphStoreSortInput>;
  to_priority?: InputMaybe<ShardedGraphStoreSortInput>;
  to_reporterAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_status?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreSortInput = {
  /** The direction of the sort. For enums the order is determined by the order of enum values in the protobuf schema. */
  direction: SortDirection;
  /** The priority of the field. Higher keys are used to resolve ties when lower keys have the same value. If there is only one sorting option, the priority value becomes irrelevant. */
  priority: Scalars['Int']['input'];
};

export type ShardedGraphStoreSpaceAssociatedWithProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreSpaceHasPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreSprintAssociatedDeploymentAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintAssociatedDeploymentAuthorFilterInput>>>;
  authorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintAssociatedDeploymentAuthorFilterInput>>>;
};

export type ShardedGraphStoreSprintAssociatedDeploymentAuthorSortInput = {
  authorAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreSprintAssociatedDeploymentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_author?: InputMaybe<ShardedGraphStoreSprintAssociatedDeploymentAuthorFilterInput>;
  to_environmentType?: InputMaybe<ShardedGraphStoreSprintAssociatedDeploymentEnvironmentTypeFilterInput>;
  to_state?: InputMaybe<ShardedGraphStoreSprintAssociatedDeploymentDeploymentStateFilterInput>;
};

export enum ShardedGraphStoreSprintAssociatedDeploymentDeploymentState {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  NotSet = 'NOT_SET',
  Pending = 'PENDING',
  RolledBack = 'ROLLED_BACK',
  Successful = 'SUCCESSFUL',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreSprintAssociatedDeploymentDeploymentStateFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedDeploymentDeploymentState>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedDeploymentDeploymentState>>;
};

export enum ShardedGraphStoreSprintAssociatedDeploymentEnvironmentType {
  Development = 'DEVELOPMENT',
  NotSet = 'NOT_SET',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type ShardedGraphStoreSprintAssociatedDeploymentEnvironmentTypeFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedDeploymentEnvironmentType>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedDeploymentEnvironmentType>>;
};

/** Conditional selection for filter field of sprint-associated-deployment relationship queries */
export type ShardedGraphStoreSprintAssociatedDeploymentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintAssociatedDeploymentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintAssociatedDeploymentConditionalFilterInput>>>;
};

export type ShardedGraphStoreSprintAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_author?: InputMaybe<ShardedGraphStoreSprintAssociatedDeploymentAuthorSortInput>;
  to_environmentType?: InputMaybe<ShardedGraphStoreSortInput>;
  to_state?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreSprintAssociatedPrAuthorFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintAssociatedPrAuthorFilterInput>>>;
  authorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintAssociatedPrAuthorFilterInput>>>;
};

export type ShardedGraphStoreSprintAssociatedPrAuthorSortInput = {
  authorAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreSprintAssociatedPrConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_creatorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_issueAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  relationship_reporterAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_author?: InputMaybe<ShardedGraphStoreSprintAssociatedPrAuthorFilterInput>;
  to_reviewers?: InputMaybe<ShardedGraphStoreSprintAssociatedPrReviewerFilterInput>;
  to_status?: InputMaybe<ShardedGraphStoreSprintAssociatedPrPullRequestStatusFilterInput>;
  to_taskCount?: InputMaybe<ShardedGraphStoreFloatFilterInput>;
};

/** Conditional selection for filter field of sprint-associated-pr relationship queries */
export type ShardedGraphStoreSprintAssociatedPrFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintAssociatedPrConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintAssociatedPrConditionalFilterInput>>>;
};

export enum ShardedGraphStoreSprintAssociatedPrPullRequestStatus {
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  Merged = 'MERGED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreSprintAssociatedPrPullRequestStatusFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedPrPullRequestStatus>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedPrPullRequestStatus>>;
};

export type ShardedGraphStoreSprintAssociatedPrReviewerFilterInput = {
  /** Logical AND of all children of this field */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintAssociatedPrReviewerFilterInput>>>;
  approvalStatus?: InputMaybe<ShardedGraphStoreSprintAssociatedPrReviewerReviewerStatusFilterInput>;
  /** Logical OR of all children of this field */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintAssociatedPrReviewerFilterInput>>>;
  reviewerAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
};

export enum ShardedGraphStoreSprintAssociatedPrReviewerReviewerStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  NotSet = 'NOT_SET',
  Unapproved = 'UNAPPROVED'
}

export type ShardedGraphStoreSprintAssociatedPrReviewerReviewerStatusFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedPrReviewerReviewerStatus>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedPrReviewerReviewerStatus>>;
};

export type ShardedGraphStoreSprintAssociatedPrReviewerSortInput = {
  approvalStatus?: InputMaybe<ShardedGraphStoreSortInput>;
  reviewerAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreSprintAssociatedPrSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_creatorAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_reporterAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_author?: InputMaybe<ShardedGraphStoreSprintAssociatedPrAuthorSortInput>;
  to_reviewers?: InputMaybe<ShardedGraphStoreSprintAssociatedPrReviewerSortInput>;
  to_status?: InputMaybe<ShardedGraphStoreSortInput>;
  to_taskCount?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreSprintAssociatedVulnerabilityConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  relationship_assigneeAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_statusAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_statusCategory?: InputMaybe<ShardedGraphStoreSprintAssociatedVulnerabilityStatusCategoryFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_introducedDate?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  to_severity?: InputMaybe<ShardedGraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverityFilterInput>;
  to_status?: InputMaybe<ShardedGraphStoreSprintAssociatedVulnerabilityVulnerabilityStatusFilterInput>;
};

/** Conditional selection for filter field of sprint-associated-vulnerability relationship queries */
export type ShardedGraphStoreSprintAssociatedVulnerabilityFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintAssociatedVulnerabilityConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintAssociatedVulnerabilityConditionalFilterInput>>>;
};

export type ShardedGraphStoreSprintAssociatedVulnerabilitySortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_assigneeAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_statusAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_statusCategory?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_introducedDate?: InputMaybe<ShardedGraphStoreSortInput>;
  to_severity?: InputMaybe<ShardedGraphStoreSortInput>;
  to_status?: InputMaybe<ShardedGraphStoreSortInput>;
};

export enum ShardedGraphStoreSprintAssociatedVulnerabilityStatusCategory {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type ShardedGraphStoreSprintAssociatedVulnerabilityStatusCategoryFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedVulnerabilityStatusCategory>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedVulnerabilityStatusCategory>>;
};

export enum ShardedGraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  NotSet = 'NOT_SET',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverityFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverity>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedVulnerabilityVulnerabilitySeverity>>;
};

export enum ShardedGraphStoreSprintAssociatedVulnerabilityVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  NotSet = 'NOT_SET',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreSprintAssociatedVulnerabilityVulnerabilityStatusFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedVulnerabilityVulnerabilityStatus>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreSprintAssociatedVulnerabilityVulnerabilityStatus>>;
};

export type ShardedGraphStoreSprintContainsIssueConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_assigneeAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_creatorAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_issueAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_reporterAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_statusAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_statusCategory?: InputMaybe<ShardedGraphStoreSprintContainsIssueStatusCategoryFilterInput>;
};

/** Conditional selection for filter field of sprint-contains-issue relationship queries */
export type ShardedGraphStoreSprintContainsIssueFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintContainsIssueConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreSprintContainsIssueConditionalFilterInput>>>;
};

export type ShardedGraphStoreSprintContainsIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_issueLastUpdatedOn?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_assigneeAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_creatorAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_issueAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_reporterAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_statusAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_statusCategory?: InputMaybe<ShardedGraphStoreSortInput>;
};

export enum ShardedGraphStoreSprintContainsIssueStatusCategory {
  Done = 'DONE',
  Indeterminate = 'INDETERMINATE',
  New = 'NEW',
  Undefined = 'UNDEFINED'
}

export type ShardedGraphStoreSprintContainsIssueStatusCategoryFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreSprintContainsIssueStatusCategory>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreSprintContainsIssueStatusCategory>>;
};

export type ShardedGraphStoreSprintRetrospectivePageSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreSprintRetrospectiveWhiteboardSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreTeamConnectedToContainerSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_createdFromAutocreate?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreTeamHasAgentsSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreTeamOwnsComponentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreTeamWorksOnProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreThirdPartyToGraphRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreTopicHasRelatedEntitySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserAssignedIncidentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserAssignedIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserAssignedPirSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserAssignedWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserAttendedCalendarEventConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_eventEndTime?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  to_eventStartTime?: InputMaybe<ShardedGraphStoreLongFilterInput>;
};

/** Conditional selection for filter field of user-attended-calendar-event relationship queries */
export type ShardedGraphStoreUserAttendedCalendarEventFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreUserAttendedCalendarEventConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreUserAttendedCalendarEventConditionalFilterInput>>>;
};

export type ShardedGraphStoreUserAttendedCalendarEventSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_eventEndTime?: InputMaybe<ShardedGraphStoreSortInput>;
  to_eventStartTime?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserAuthoredCommitSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserAuthoredPrSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserAuthoritativelyLinkedThirdPartyUserConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  relationship_graphworkspaceAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_integrationAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_graphworkspaceAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_integrationAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of user-authoritatively-linked-third-party-user relationship queries */
export type ShardedGraphStoreUserAuthoritativelyLinkedThirdPartyUserFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreUserAuthoritativelyLinkedThirdPartyUserConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreUserAuthoritativelyLinkedThirdPartyUserConditionalFilterInput>>>;
};

export type ShardedGraphStoreUserAuthoritativelyLinkedThirdPartyUserSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_graphworkspaceAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_integrationAri?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_graphworkspaceAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_integrationAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCanViewConfluenceSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCollaboratedOnDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserContributedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserContributedConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserContributedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserContributedConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedAtlasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedBranchSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedCalendarEventConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_eventEndTime?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  to_eventStartTime?: InputMaybe<ShardedGraphStoreLongFilterInput>;
};

/** Conditional selection for filter field of user-created-calendar-event relationship queries */
export type ShardedGraphStoreUserCreatedCalendarEventFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreUserCreatedCalendarEventConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreUserCreatedCalendarEventConditionalFilterInput>>>;
};

export type ShardedGraphStoreUserCreatedCalendarEventSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_eventEndTime?: InputMaybe<ShardedGraphStoreSortInput>;
  to_eventStartTime?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedConfluenceCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedConfluenceEmbedSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedConfluenceSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedDesignSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedIssueCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedIssueWorklogSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedReleaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedRepositorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedTownsquareCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedVideoCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedVideoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserCreatedWorkItemSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserFavoritedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserFavoritedConfluenceDatabaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserFavoritedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserFavoritedConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserFavoritedFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserHasExternalPositionSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserHasRelevantProjectSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserHasTopCollaboratorSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserHasTopProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserIsInTeamSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserLastUpdatedDesignSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserLaunchedReleaseSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserLikedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserLinkedThirdPartyUserConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  relationship_graphworkspaceAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  relationship_integrationAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_graphworkspaceAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
  to_integrationAri?: InputMaybe<ShardedGraphStoreAriFilterInput>;
};

/** Conditional selection for filter field of user-linked-third-party-user relationship queries */
export type ShardedGraphStoreUserLinkedThirdPartyUserFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreUserLinkedThirdPartyUserConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreUserLinkedThirdPartyUserConditionalFilterInput>>>;
};

export type ShardedGraphStoreUserLinkedThirdPartyUserSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_graphworkspaceAri?: InputMaybe<ShardedGraphStoreSortInput>;
  relationship_integrationAri?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_graphworkspaceAri?: InputMaybe<ShardedGraphStoreSortInput>;
  to_integrationAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserMemberOfConversationSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserMentionedInConversationSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserMentionedInMessageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserMentionedInVideoCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserOwnedBranchSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserOwnedCalendarEventSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserOwnedDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserOwnedRemoteLinkSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserOwnedRepositorySortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserOwnsComponentConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
};

/** Conditional selection for filter field of user-owns-component relationship queries */
export type ShardedGraphStoreUserOwnsComponentFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreUserOwnsComponentConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreUserOwnsComponentConditionalFilterInput>>>;
};

export type ShardedGraphStoreUserOwnsComponentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserOwnsFocusAreaSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserOwnsPageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserReactionVideoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserReportedIncidentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserReportsIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserReviewsPrSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserSnapshottedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserTaggedInCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserTaggedInConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserTaggedInIssueCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserTrashedConfluenceContentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserTriggeredDeploymentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserUpdatedAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserUpdatedAtlasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserUpdatedCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserUpdatedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserUpdatedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserUpdatedConfluenceSpaceSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserUpdatedConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserUpdatedGraphDocumentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserUpdatedIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserViewedAtlasGoalSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserViewedAtlasProjectSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserViewedConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserViewedConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserViewedGoalUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserViewedJiraIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserViewedProjectUpdateSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserViewedVideoSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserWatchesConfluenceBlogpostSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserWatchesConfluencePageSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreUserWatchesConfluenceWhiteboardSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVersionAssociatedBranchSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVersionAssociatedBuildSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVersionAssociatedCommitSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVersionAssociatedDeploymentSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVersionAssociatedDesignConditionalFilterInput = {
  /** Filter by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  /** Filter by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreDateFilterInput>;
  /** Filter by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreAtiFilterInput>;
  to_designLastUpdated?: InputMaybe<ShardedGraphStoreLongFilterInput>;
  to_status?: InputMaybe<ShardedGraphStoreVersionAssociatedDesignDesignStatusFilterInput>;
  to_type?: InputMaybe<ShardedGraphStoreVersionAssociatedDesignDesignTypeFilterInput>;
};

export enum ShardedGraphStoreVersionAssociatedDesignDesignStatus {
  None = 'NONE',
  NotSet = 'NOT_SET',
  ReadyForDevelopment = 'READY_FOR_DEVELOPMENT',
  Unknown = 'UNKNOWN'
}

export type ShardedGraphStoreVersionAssociatedDesignDesignStatusFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreVersionAssociatedDesignDesignStatus>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreVersionAssociatedDesignDesignStatus>>;
};

export enum ShardedGraphStoreVersionAssociatedDesignDesignType {
  Canvas = 'CANVAS',
  File = 'FILE',
  Group = 'GROUP',
  Node = 'NODE',
  NotSet = 'NOT_SET',
  Other = 'OTHER',
  Prototype = 'PROTOTYPE'
}

export type ShardedGraphStoreVersionAssociatedDesignDesignTypeFilterInput = {
  is?: InputMaybe<Array<ShardedGraphStoreVersionAssociatedDesignDesignType>>;
  isNot?: InputMaybe<Array<ShardedGraphStoreVersionAssociatedDesignDesignType>>;
};

/** Conditional selection for filter field of version-associated-design relationship queries */
export type ShardedGraphStoreVersionAssociatedDesignFilterInput = {
  /** Logical AND of the filter */
  and?: InputMaybe<Array<InputMaybe<ShardedGraphStoreVersionAssociatedDesignConditionalFilterInput>>>;
  /** Logical OR of the filter */
  or?: InputMaybe<Array<InputMaybe<ShardedGraphStoreVersionAssociatedDesignConditionalFilterInput>>>;
};

export type ShardedGraphStoreVersionAssociatedDesignSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
  to_designLastUpdated?: InputMaybe<ShardedGraphStoreSortInput>;
  to_status?: InputMaybe<ShardedGraphStoreSortInput>;
  to_type?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVersionAssociatedFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVersionAssociatedIssueSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVersionAssociatedPullRequestSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVersionAssociatedRemoteLinkSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVersionUserAssociatedFeatureFlagSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVideoHasCommentSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVideoSharedWithUserSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVulnerabilityAssociatedIssueContainerSortInput = {
  containerAri?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreVulnerabilityAssociatedIssueSortInput = {
  /** Sort by the creation date of the relationship */
  createdAt?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the from node */
  fromAti?: InputMaybe<ShardedGraphStoreSortInput>;
  from_container?: InputMaybe<ShardedGraphStoreVulnerabilityAssociatedIssueContainerSortInput>;
  from_introducedDate?: InputMaybe<ShardedGraphStoreSortInput>;
  from_severity?: InputMaybe<ShardedGraphStoreSortInput>;
  from_status?: InputMaybe<ShardedGraphStoreSortInput>;
  from_type?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
  /** Sort by the ATI of the to node */
  toAti?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShardedGraphStoreWorkerAssociatedExternalWorkerSortInput = {
  /** Sort by the date the relationship was last changed */
  lastModified?: InputMaybe<ShardedGraphStoreSortInput>;
};

export type ShareResourceInput = {
  atlOrigin: Scalars['String']['input'];
  contextualPageId: Scalars['String']['input'];
  emails: Array<InputMaybe<Scalars['String']['input']>>;
  entityId: Scalars['String']['input'];
  entityType: Scalars['String']['input'];
  groupIds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  groups: Array<InputMaybe<Scalars['String']['input']>>;
  isShareEmailExperiment: Scalars['Boolean']['input'];
  note: Scalars['String']['input'];
  shareType: ShareType;
  users: Array<InputMaybe<Scalars['String']['input']>>;
};

export enum ShareType {
  InviteToEdit = 'INVITE_TO_EDIT',
  SharePage = 'SHARE_PAGE'
}

/** The kind of action that was performed and caused or contributed to an alert. */
export enum ShepherdActionType {
  Activate = 'ACTIVATE',
  Archive = 'ARCHIVE',
  Crawl = 'CRAWL',
  Create = 'CREATE',
  Deactivate = 'DEACTIVATE',
  Delete = 'DELETE',
  Download = 'DOWNLOAD',
  Export = 'EXPORT',
  Grant = 'GRANT',
  Install = 'INSTALL',
  Login = 'LOGIN',
  LoginAs = 'LOGIN_AS',
  Publish = 'PUBLISH',
  Read = 'READ',
  Revoke = 'REVOKE',
  Search = 'SEARCH',
  Uninstall = 'UNINSTALL',
  Update = 'UPDATE'
}

/** Contextual information about the activity that originated the alert. */
export type ShepherdActivityHighlightInput = {
  /** What kind of action is relevant. */
  action?: InputMaybe<ShepherdActionType>;
  /** Who has done it (Atlassian account ID). */
  actor?: InputMaybe<Scalars['ID']['input']>;
  /** Information about a user's session when they login. */
  actorSessionInfo?: InputMaybe<ShepherdActorSessionInfoInput>;
  /**
   * The StreamHub event IDs of the events corresponding to the alert.
   * In some cases, these are the same as the audit log event IDs.
   */
  eventIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Representation of numerical data distribution about the alert. */
  histogram?: InputMaybe<Array<InputMaybe<ShepherdHistogramBucketInput>>>;
  /**
   * The resources that were acted upon to trigger the alert along with the time of action corresponding to each ARI.
   * Typically used when StreamHub or Audit Log `eventIds` are not available (e.g. analytics-based detections).
   */
  resourceEvents?: InputMaybe<Array<ShepherdResourceEventInput>>;
  /** What resource was acted on. */
  subject?: InputMaybe<ShepherdSubjectInput>;
  /** When did this occur (instant or interval)? */
  time: ShepherdTimeInput;
};

/**
 * Defines the actor of the alert when creating an alert.
 *
 * Requires one and only one of the fields as each one represent a type of actor.
 */
export type ShepherdActorInput = {
  /** An Atlassian Account ID that represents an Atlassian cloud user. */
  aaid?: InputMaybe<Scalars['ID']['input']>;
  /** Represents an anonymous user that performed an action on a public resource. */
  anonymous?: InputMaybe<ShepherdAnonymousActorInput>;
  /**
   * If true, it means the user is unknown. Use this field when its impossible to determine who performed the action
   * that triggered the alert.
   */
  unknown?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum ShepherdActorOrgStatus {
  Active = 'ACTIVE',
  Deactivated = 'DEACTIVATED',
  Suspended = 'SUSPENDED'
}

export type ShepherdActorSessionInfoInput = {
  /** Which authentication factors were used to login (SAML, password, social, etc.). */
  authFactors: Array<Scalars['String']['input']>;
  /** IP address from which the user created the session. */
  ipAddress: Scalars['String']['input'];
  /** ID of the unique session. */
  sessionId: Scalars['String']['input'];
  /** User agent of the session (browser, OS, etc.). */
  userAgent: Scalars['String']['input'];
};

export enum ShepherdAlertAction {
  AddLabel = 'ADD_LABEL',
  Redact = 'REDACT',
  Restrict = 'RESTRICT',
  UpdateDataClassification = 'UPDATE_DATA_CLASSIFICATION'
}

export enum ShepherdAlertDetectionCategory {
  Data = 'DATA',
  Threat = 'THREAT'
}

export enum ShepherdAlertSnippetRedactionFailureReason {
  ContainerId = 'CONTAINER_ID',
  ContainerIdFormat = 'CONTAINER_ID_FORMAT',
  EntityId = 'ENTITY_ID',
  HashMismatch = 'HASH_MISMATCH',
  InvalidAdfPointer = 'INVALID_ADF_POINTER',
  InvalidPointer = 'INVALID_POINTER',
  MaxFieldLength = 'MAX_FIELD_LENGTH',
  OverlappingRequestsForContentItem = 'OVERLAPPING_REQUESTS_FOR_CONTENT_ITEM',
  RedactionIdAlreadyExists = 'REDACTION_ID_ALREADY_EXISTS',
  TooManyRequestsPerContentItem = 'TOO_MANY_REQUESTS_PER_CONTENT_ITEM',
  Unknown = 'UNKNOWN'
}

export enum ShepherdAlertSnippetRedactionStatus {
  Redacted = 'REDACTED',
  RedactedHistoryScanFailed = 'REDACTED_HISTORY_SCAN_FAILED',
  RedactionFailed = 'REDACTION_FAILED',
  RedactionPending = 'REDACTION_PENDING',
  Unredacted = 'UNREDACTED'
}

export enum ShepherdAlertStatus {
  InProgress = 'IN_PROGRESS',
  TriagedExpectedActivity = 'TRIAGED_EXPECTED_ACTIVITY',
  TriagedTruePositive = 'TRIAGED_TRUE_POSITIVE',
  Untriaged = 'UNTRIAGED'
}

export enum ShepherdAlertTemplateType {
  AddedConfluenceGlobalPermission = 'ADDED_CONFLUENCE_GLOBAL_PERMISSION',
  AddedConfluenceSpacePermission = 'ADDED_CONFLUENCE_SPACE_PERMISSION',
  AddedDomain = 'ADDED_DOMAIN',
  AddedJiraGlobalPermission = 'ADDED_JIRA_GLOBAL_PERMISSION',
  AddedOrgadmin = 'ADDED_ORGADMIN',
  BitbucketRepositoryPrivacy = 'BITBUCKET_REPOSITORY_PRIVACY',
  BitbucketWorkspacePrivacy = 'BITBUCKET_WORKSPACE_PRIVACY',
  ClassificationLevelArchived = 'CLASSIFICATION_LEVEL_ARCHIVED',
  ClassificationLevelPublished = 'CLASSIFICATION_LEVEL_PUBLISHED',
  CompromisedMobileDevice = 'COMPROMISED_MOBILE_DEVICE',
  ConfluenceCustomDetection = 'CONFLUENCE_CUSTOM_DETECTION',
  ConfluenceDataDiscovery = 'CONFLUENCE_DATA_DISCOVERY',
  ConfluenceDataDiscoveryAtlassianToken = 'CONFLUENCE_DATA_DISCOVERY_ATLASSIAN_TOKEN',
  ConfluenceDataDiscoveryAuTfn = 'CONFLUENCE_DATA_DISCOVERY_AU_TFN',
  ConfluenceDataDiscoveryAwsKeys = 'CONFLUENCE_DATA_DISCOVERY_AWS_KEYS',
  ConfluenceDataDiscoveryCreditCard = 'CONFLUENCE_DATA_DISCOVERY_CREDIT_CARD',
  ConfluenceDataDiscoveryCrypto = 'CONFLUENCE_DATA_DISCOVERY_CRYPTO',
  ConfluenceDataDiscoveryIban = 'CONFLUENCE_DATA_DISCOVERY_IBAN',
  ConfluenceDataDiscoveryJwtKey = 'CONFLUENCE_DATA_DISCOVERY_JWT_KEY',
  ConfluenceDataDiscoveryPassword = 'CONFLUENCE_DATA_DISCOVERY_PASSWORD',
  ConfluenceDataDiscoveryPrivateKey = 'CONFLUENCE_DATA_DISCOVERY_PRIVATE_KEY',
  ConfluenceDataDiscoveryUsSsn = 'CONFLUENCE_DATA_DISCOVERY_US_SSN',
  ConfluencePageCrawling = 'CONFLUENCE_PAGE_CRAWLING',
  ConfluencePageExports = 'CONFLUENCE_PAGE_EXPORTS',
  ConfluenceSiteBackupDownloaded = 'CONFLUENCE_SITE_BACKUP_DOWNLOADED',
  ConfluenceSpaceExports = 'CONFLUENCE_SPACE_EXPORTS',
  ConfluenceSuspiciousSearch = 'CONFLUENCE_SUSPICIOUS_SEARCH',
  CreatedAuthPolicy = 'CREATED_AUTH_POLICY',
  CreatedMobileAppPolicy = 'CREATED_MOBILE_APP_POLICY',
  CreatedPolicy = 'CREATED_POLICY',
  CreatedSamlConfig = 'CREATED_SAML_CONFIG',
  CreatedTunnel = 'CREATED_TUNNEL',
  CreatedUserProvisioning = 'CREATED_USER_PROVISIONING',
  DataSecurityPolicyActivated = 'DATA_SECURITY_POLICY_ACTIVATED',
  DataSecurityPolicyDeactivated = 'DATA_SECURITY_POLICY_DEACTIVATED',
  DataSecurityPolicyDeleted = 'DATA_SECURITY_POLICY_DELETED',
  DataSecurityPolicyUpdated = 'DATA_SECURITY_POLICY_UPDATED',
  Default = 'DEFAULT',
  DeletedAuthPolicy = 'DELETED_AUTH_POLICY',
  DeletedDomain = 'DELETED_DOMAIN',
  DeletedMobileAppPolicy = 'DELETED_MOBILE_APP_POLICY',
  DeletedPolicy = 'DELETED_POLICY',
  DeletedTunnel = 'DELETED_TUNNEL',
  EcosystemAuditLogInstallationCreated = 'ECOSYSTEM_AUDIT_LOG_INSTALLATION_CREATED',
  EcosystemAuditLogInstallationDeleted = 'ECOSYSTEM_AUDIT_LOG_INSTALLATION_DELETED',
  EducationalAlert = 'EDUCATIONAL_ALERT',
  ExportedOrgeventscsv = 'EXPORTED_ORGEVENTSCSV',
  GrantAssignedJiraPermissionScheme = 'GRANT_ASSIGNED_JIRA_PERMISSION_SCHEME',
  IdentityPasswordResetCompletedUser = 'IDENTITY_PASSWORD_RESET_COMPLETED_USER',
  ImpossibleTravel = 'IMPOSSIBLE_TRAVEL',
  InitiatedGsyncConnection = 'INITIATED_GSYNC_CONNECTION',
  JiraCustomDetection = 'JIRA_CUSTOM_DETECTION',
  JiraDataDiscoveryAtlassianToken = 'JIRA_DATA_DISCOVERY_ATLASSIAN_TOKEN',
  JiraDataDiscoveryAuTfn = 'JIRA_DATA_DISCOVERY_AU_TFN',
  JiraDataDiscoveryAwsKeys = 'JIRA_DATA_DISCOVERY_AWS_KEYS',
  JiraDataDiscoveryCreditCard = 'JIRA_DATA_DISCOVERY_CREDIT_CARD',
  JiraDataDiscoveryCrypto = 'JIRA_DATA_DISCOVERY_CRYPTO',
  JiraDataDiscoveryIban = 'JIRA_DATA_DISCOVERY_IBAN',
  JiraDataDiscoveryJwtKey = 'JIRA_DATA_DISCOVERY_JWT_KEY',
  JiraDataDiscoveryPassword = 'JIRA_DATA_DISCOVERY_PASSWORD',
  JiraDataDiscoveryPrivateKey = 'JIRA_DATA_DISCOVERY_PRIVATE_KEY',
  JiraDataDiscoveryUsSsn = 'JIRA_DATA_DISCOVERY_US_SSN',
  JiraIssueCrawling = 'JIRA_ISSUE_CRAWLING',
  JiraSuspiciousSearch = 'JIRA_SUSPICIOUS_SEARCH',
  LoginFromMaliciousIpAddress = 'LOGIN_FROM_MALICIOUS_IP_ADDRESS',
  LoginFromTorExitNode = 'LOGIN_FROM_TOR_EXIT_NODE',
  MobileScreenLock = 'MOBILE_SCREEN_LOCK',
  OrgLoggedInAsUser = 'ORG_LOGGED_IN_AS_USER',
  ProjectClassificationLevelDecreased = 'PROJECT_CLASSIFICATION_LEVEL_DECREASED',
  ProjectClassificationLevelIncreased = 'PROJECT_CLASSIFICATION_LEVEL_INCREASED',
  RotateScimDirectoryToken = 'ROTATE_SCIM_DIRECTORY_TOKEN',
  SpaceClassificationLevelDecreased = 'SPACE_CLASSIFICATION_LEVEL_DECREASED',
  SpaceClassificationLevelIncreased = 'SPACE_CLASSIFICATION_LEVEL_INCREASED',
  TestAlert = 'TEST_ALERT',
  TokenCreated = 'TOKEN_CREATED',
  TokenRevoked = 'TOKEN_REVOKED',
  UpdatedAuthPolicy = 'UPDATED_AUTH_POLICY',
  UpdatedMobileAppPolicy = 'UPDATED_MOBILE_APP_POLICY',
  UpdatedPolicy = 'UPDATED_POLICY',
  UpdatedSamlConfig = 'UPDATED_SAML_CONFIG',
  UserAddedToBeacon = 'USER_ADDED_TO_BEACON',
  UserGrantedRole = 'USER_GRANTED_ROLE',
  UserRemovedFromBeacon = 'USER_REMOVED_FROM_BEACON',
  UserRevokedRole = 'USER_REVOKED_ROLE',
  UserTokenCreated = 'USER_TOKEN_CREATED',
  UserTokenRevoked = 'USER_TOKEN_REVOKED'
}

export type ShepherdAnonymousActorInput = {
  /** An optional IP address */
  ipAddress?: InputMaybe<Scalars['String']['input']>;
};

export enum ShepherdAtlassianProduct {
  AdminHub = 'ADMIN_HUB',
  Bitbucket = 'BITBUCKET',
  Confluence = 'CONFLUENCE',
  ConfluenceDc = 'CONFLUENCE_DC',
  GuardDetect = 'GUARD_DETECT',
  JiraDc = 'JIRA_DC',
  JiraSoftware = 'JIRA_SOFTWARE',
  Marketplace = 'MARKETPLACE'
}

/** Input used when performing a bulk redaction. */
export type ShepherdBulkRedactionInput = {
  /** The items to be redacted */
  redactions: Array<ShepherdBulkRedactionItemInput>;
  /** The ARI of the workspace on which the bulk redaction is being performed. */
  workspaceId: Scalars['ID']['input'];
};

/** Individual piece of content to be redacted in a bulk redaction. */
export type ShepherdBulkRedactionItemInput = {
  /** The SHA-256 hash of the content to be redacted. Necessary for Jira redactions. */
  contentHash?: InputMaybe<Scalars['String']['input']>;
  /** The detection that triggered the redaction. */
  detection: Scalars['String']['input'];
  /** The end location of the content to be redacted. */
  end: ShepherdContentLocationInput;
  /** The location (e.g. "body" or "title" for Confluence or the work item field for Jira) of the content to be redacted. */
  fieldId: Scalars['String']['input'];
  /** ID of the redaction item. Must be a UUID. One will be created if not provided. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The ARI of the resource (e.g. Jira work item, Confluence page, etc.) that contains the content to be redacted. */
  resourceAri: Scalars['ID']['input'];
  /** The start location of the content to be redacted. */
  start: ShepherdContentLocationInput;
  /** The timestamp of the most recent update of the document that contains the content to be redacted. Necessary for Confluence redactions. */
  timestamp?: InputMaybe<Scalars['DateTime']['input']>;
};

export enum ShepherdBulkRedactionItemStatus {
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Succeeded = 'SUCCEEDED'
}

export enum ShepherdBulkRedactionJobStatus {
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  PartiallySucceeded = 'PARTIALLY_SUCCEEDED',
  Succeeded = 'SUCCEEDED'
}

export enum ShepherdClassificationStatus {
  Archived = 'ARCHIVED',
  Draft = 'DRAFT',
  Published = 'PUBLISHED'
}

/** Location of the start or end of content to be redacted. */
export type ShepherdContentLocationInput = {
  /** The index of the content to be redacted within the string. */
  index: Scalars['Int']['input'];
  /** The the JSON pointer to the location within the ADF of the string containging the sensitive information. Use 'text' for plain text content. */
  pointer: Scalars['String']['input'];
};

export type ShepherdCreateAlertInput = {
  actor?: InputMaybe<ShepherdActorInput>;
  assignee?: InputMaybe<Scalars['ID']['input']>;
  /** The site ID. Required if `workspaceId` is not provided. */
  cloudId?: InputMaybe<Scalars['ID']['input']>;
  customFields?: InputMaybe<Scalars['JSON']['input']>;
  /**
   * An optional key that is intended to prevent creating duplicate alerts via the API. It can help in cases such as the
   * consumer retries a request after a timeout or wants to sync alerts after a work item where it's clear which alerts
   * have been created.
   */
  deduplicationKey?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ShepherdAlertStatus>;
  time?: InputMaybe<ShepherdTimeInput>;
  /** The title of the alert. */
  title: Scalars['String']['input'];
  /** Type of the alert. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Workspace ARI. Required if `cloudId` is not provided. */
  workspaceId?: InputMaybe<Scalars['ID']['input']>;
};

export type ShepherdCreateSlackInput = {
  authToken: Scalars['String']['input'];
  callbackURL: Scalars['URL']['input'];
  channelId: Scalars['String']['input'];
  status: ShepherdSubscriptionStatus;
  teamId: Scalars['String']['input'];
};

export type ShepherdCreateWebhookInput = {
  authHeader?: InputMaybe<Scalars['String']['input']>;
  callbackURL: Scalars['URL']['input'];
  category?: InputMaybe<ShepherdWebhookSubscriptionCategory>;
  destinationType?: InputMaybe<ShepherdWebhookDestinationType>;
  status?: InputMaybe<ShepherdSubscriptionStatus>;
};

export type ShepherdCustomDetectionHighlightInput = {
  customDetectionId: Scalars['ID']['input'];
  matchedRules?: InputMaybe<Array<InputMaybe<ShepherdCustomScanningStringMatchRuleInput>>>;
};

export enum ShepherdCustomScanningMatchType {
  Regex = 'REGEX',
  String = 'STRING',
  Word = 'WORD'
}

/**  GraphQL doesn't allow unions in input types so this is to allow for different rule types in the future. */
export type ShepherdCustomScanningRuleInput = {
  stringMatch?: InputMaybe<ShepherdCustomScanningStringMatchRuleInput>;
};

/** Input type for a rule to match against content. Contains a term and whether it's a `string` match or `word` match. */
export type ShepherdCustomScanningStringMatchRuleInput = {
  matchType: ShepherdCustomScanningMatchType;
  term: Scalars['String']['input'];
};

export enum ShepherdDetectionScanningFrequency {
  RealTime = 'REAL_TIME',
  Scheduled = 'SCHEDULED'
}

export type ShepherdDetectionSettingSetValueEntryInput = {
  key: Scalars['String']['input'];
  scanningRules?: InputMaybe<Array<ShepherdCustomScanningRuleInput>>;
};

export type ShepherdDetectionSettingSetValueInput = {
  /**
   * A list of mapped entries.
   *
   * For exclusions: add all `scanningRules` items to the setting.
   */
  entries?: InputMaybe<Array<ShepherdDetectionSettingSetValueEntryInput>>;
  /**
   * A list of string values.
   *
   * For exclusions: add all ARIs to the setting.
   */
  stringValues?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Update the threshold value for the setting. */
  thresholdValue?: InputMaybe<ShepherdRateThresholdValue>;
};

/**
 * A highlight contains contextual information produced by the detection that created the alert.
 *
 * One field is required and only one can be informed at a time.
 */
export type ShepherdHighlightInput = {
  /** Information about the activity that originated the alert. */
  activityHighlight?: InputMaybe<ShepherdActivityHighlightInput>;
};

export type ShepherdHistogramBucketInput = {
  /** Name of the bucket that contributes to the signal histogram. */
  name: Scalars['String']['input'];
  /** Numerical representation of the bucket value. */
  value: Scalars['Int']['input'];
};

export type ShepherdLinkedResourceInput = {
  id: Scalars['ID']['input'];
  url?: InputMaybe<Scalars['String']['input']>;
};

export enum ShepherdLoginDeviceType {
  Computer = 'COMPUTER',
  Console = 'CONSOLE',
  Embedded = 'EMBEDDED',
  Mobile = 'MOBILE',
  SmartTv = 'SMART_TV',
  Tablet = 'TABLET',
  Wearable = 'WEARABLE'
}

/** #### Types: Mutation ##### */
export enum ShepherdMutationErrorType {
  BadRequest = 'BAD_REQUEST',
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  NoProductAccess = 'NO_PRODUCT_ACCESS',
  Unauthorized = 'UNAUTHORIZED'
}

/** #### Types: Query ##### */
export enum ShepherdQueryErrorType {
  BadRequest = 'BAD_REQUEST',
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  NoProductAccess = 'NO_PRODUCT_ACCESS',
  Unauthorized = 'UNAUTHORIZED'
}

/**
 * A rate type detection has 3 modes:
 *
 * * `LOW` will produce the most alerts.
 * * `MEDIUM` is in the middle.
 * * `HIGH` will product the least alerts.
 */
export enum ShepherdRateThresholdValue {
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM'
}

export enum ShepherdRedactedContentStatus {
  Redacted = 'REDACTED',
  RedactionFailed = 'REDACTION_FAILED',
  RedactionPending = 'REDACTION_PENDING'
}

/** Input used when redacting content. */
export type ShepherdRedactionInput = {
  /** The alert ARI that the redaction is associated with. */
  alertId: Scalars['ID']['input'];
  /** The list of `contentId`s to redact. `contentId`s should be taken from `ShepherdAlertSnippet` objects. */
  redactions: Array<Scalars['ID']['input']>;
  /** Whether or not to delete previous versions that contain the redacted content. */
  removeHistory: Scalars['Boolean']['input'];
  /** The creation timestamp for the version of the document that is intended to be redacted. */
  timestamp: Scalars['String']['input'];
};

export enum ShepherdRedactionStatus {
  Failed = 'FAILED',
  PartiallyRedacted = 'PARTIALLY_REDACTED',
  Pending = 'PENDING',
  Redacted = 'REDACTED'
}

export enum ShepherdRemediationActionType {
  AnonAccessDspRemediation = 'ANON_ACCESS_DSP_REMEDIATION',
  ApplyClassificationRemediation = 'APPLY_CLASSIFICATION_REMEDIATION',
  AppsAccessDspRemediation = 'APPS_ACCESS_DSP_REMEDIATION',
  ArchiveRestoreClassificationRemediation = 'ARCHIVE_RESTORE_CLASSIFICATION_REMEDIATION',
  BlockchainExplorerRemediation = 'BLOCKCHAIN_EXPLORER_REMEDIATION',
  BlockIpAllowlistRemediation = 'BLOCK_IP_ALLOWLIST_REMEDIATION',
  ChangeConfluenceSpaceAttachmentPermissionsRemediation = 'CHANGE_CONFLUENCE_SPACE_ATTACHMENT_PERMISSIONS_REMEDIATION',
  ChangeJiraAttachmentPermissionsRemediation = 'CHANGE_JIRA_ATTACHMENT_PERMISSIONS_REMEDIATION',
  CheckAutomationsRemediation = 'CHECK_AUTOMATIONS_REMEDIATION',
  ClassificationLevelChangeRemediation = 'CLASSIFICATION_LEVEL_CHANGE_REMEDIATION',
  CompromisedDeviceRemediation = 'COMPROMISED_DEVICE_REMEDIATION',
  ConfluenceAnonAccessRemediation = 'CONFLUENCE_ANON_ACCESS_REMEDIATION',
  DeleteDataRemediation = 'DELETE_DATA_REMEDIATION',
  DeleteFilesRemediation = 'DELETE_FILES_REMEDIATION',
  EditCustomDetectionRemediation = 'EDIT_CUSTOM_DETECTION_REMEDIATION',
  EmailWithAutomationRemediation = 'EMAIL_WITH_AUTOMATION_REMEDIATION',
  ExcludePageRemediation = 'EXCLUDE_PAGE_REMEDIATION',
  ExcludeUserRemediation = 'EXCLUDE_USER_REMEDIATION',
  ExportsDspRemediation = 'EXPORTS_DSP_REMEDIATION',
  ExportDspRemediation = 'EXPORT_DSP_REMEDIATION',
  ExportSpacePermissionsRemediation = 'EXPORT_SPACE_PERMISSIONS_REMEDIATION',
  JiraGlobalPermissionsRemediation = 'JIRA_GLOBAL_PERMISSIONS_REMEDIATION',
  KeyOwnerRemediation = 'KEY_OWNER_REMEDIATION',
  LimitJiraPermissionsRemediation = 'LIMIT_JIRA_PERMISSIONS_REMEDIATION',
  ManageAppsRemediation = 'MANAGE_APPS_REMEDIATION',
  ManageDomainRemediation = 'MANAGE_DOMAIN_REMEDIATION',
  ManageDspRemediation = 'MANAGE_DSP_REMEDIATION',
  MoveOrRemoveAttachmentRemediation = 'MOVE_OR_REMOVE_ATTACHMENT_REMEDIATION',
  PublicAccessDspRemediation = 'PUBLIC_ACCESS_DSP_REMEDIATION',
  ResetAccountPasswordRemediation = 'RESET_ACCOUNT_PASSWORD_REMEDIATION',
  RestoreAccessRemediation = 'RESTORE_ACCESS_REMEDIATION',
  RestrictPageAutomationRemediation = 'RESTRICT_PAGE_AUTOMATION_REMEDIATION',
  ReviewAccessRemediation = 'REVIEW_ACCESS_REMEDIATION',
  ReviewApiKeysRemediation = 'REVIEW_API_KEYS_REMEDIATION',
  ReviewApiTokensRemediation = 'REVIEW_API_TOKENS_REMEDIATION',
  ReviewAuditLogRemediation = 'REVIEW_AUDIT_LOG_REMEDIATION',
  ReviewAuthPolicyRemediation = 'REVIEW_AUTH_POLICY_REMEDIATION',
  ReviewGsyncRemediation = 'REVIEW_GSYNC_REMEDIATION',
  ReviewIpAllowlistRemediation = 'REVIEW_IP_ALLOWLIST_REMEDIATION',
  ReviewIssueRemediation = 'REVIEW_ISSUE_REMEDIATION',
  ReviewMobileAppPolicyRemediation = 'REVIEW_MOBILE_APP_POLICY_REMEDIATION',
  ReviewOtherAuthPoliciesRemediation = 'REVIEW_OTHER_AUTH_POLICIES_REMEDIATION',
  ReviewOtherIpAllowlistRemediation = 'REVIEW_OTHER_IP_ALLOWLIST_REMEDIATION',
  ReviewPageRemediation = 'REVIEW_PAGE_REMEDIATION',
  ReviewSamlRemediation = 'REVIEW_SAML_REMEDIATION',
  ReviewScimRemediation = 'REVIEW_SCIM_REMEDIATION',
  ReviewTunnelsConfigurationRemediation = 'REVIEW_TUNNELS_CONFIGURATION_REMEDIATION',
  ReviewTunnelsRemediation = 'REVIEW_TUNNELS_REMEDIATION',
  RevokeAccessRemediation = 'REVOKE_ACCESS_REMEDIATION',
  RevokeApiKeyRemediation = 'REVOKE_API_KEY_REMEDIATION',
  RevokeApiTokensRemediation = 'REVOKE_API_TOKENS_REMEDIATION',
  RevokeUserApiTokenRemediation = 'REVOKE_USER_API_TOKEN_REMEDIATION',
  SpacePermissionsRemediation = 'SPACE_PERMISSIONS_REMEDIATION',
  SuspendActorRemediation = 'SUSPEND_ACTOR_REMEDIATION',
  SuspendSubjectRemediation = 'SUSPEND_SUBJECT_REMEDIATION',
  TurnOffJiraPermissionsRemediation = 'TURN_OFF_JIRA_PERMISSIONS_REMEDIATION',
  TwoStepPolicyRemediation = 'TWO_STEP_POLICY_REMEDIATION',
  UseAuthPolicyRemediation = 'USE_AUTH_POLICY_REMEDIATION',
  ViewSpacePermissionsRemediation = 'VIEW_SPACE_PERMISSIONS_REMEDIATION'
}

export type ShepherdResourceEventInput = {
  /** Name resource ARI of the event. */
  ari: Scalars['String']['input'];
  /** The timestamp of the event. */
  time: Scalars['DateTime']['input'];
};

/** Input used when restoring redacted content. */
export type ShepherdRestoreRedactionInput = {
  /** The ID of the redaction to restore. */
  redactionId: Scalars['ID']['input'];
};

export enum ShepherdSearchOrigin {
  AdvancedSearch = 'ADVANCED_SEARCH',
  Ai = 'AI',
  QuickSearch = 'QUICK_SEARCH'
}

/** The resource was acted on. */
export type ShepherdSubjectInput = {
  /** ARI of the resource acted on. */
  ari?: InputMaybe<Scalars['String']['input']>;
  /** ATI with type of resource or group of resources, when a specific resource cannot be referenced directly. */
  ati?: InputMaybe<Scalars['String']['input']>;
  /** ARI of where it happened. An ARI pointing to an org, site, or other type of container. */
  containerAri: Scalars['String']['input'];
};

export type ShepherdSubscriptionCreateInput = {
  slack?: InputMaybe<ShepherdCreateSlackInput>;
  webhook?: InputMaybe<ShepherdCreateWebhookInput>;
};

export type ShepherdSubscriptionDeleteInput = {
  hardDelete?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents Subscriptions in the Guard Detect system. */
export enum ShepherdSubscriptionStatus {
  Active = 'ACTIVE',
  Error = 'ERROR',
  Inactive = 'INACTIVE'
}

export type ShepherdSubscriptionUpdateInput = {
  slack?: InputMaybe<ShepherdUpdateSlackInput>;
  webhook?: InputMaybe<ShepherdUpdateWebhookInput>;
};

/** Time or interval. */
export type ShepherdTimeInput = {
  /** When present, indicates an interval should be created, otherwise a simple timestamp will be created. */
  end?: InputMaybe<Scalars['DateTime']['input']>;
  /** The timestamp (when only `start` is specified) or interval (when `end` is also specified). */
  start: Scalars['DateTime']['input'];
};

export type ShepherdUnlinkAlertResourcesInput = {
  unlinkResources?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type ShepherdUpdateAlertInput = {
  assignee?: InputMaybe<Scalars['ID']['input']>;
  linkedResources?: InputMaybe<Array<ShepherdLinkedResourceInput>>;
  status?: InputMaybe<ShepherdAlertStatus>;
};

export type ShepherdUpdateSlackInput = {
  status: ShepherdSubscriptionStatus;
};

export type ShepherdUpdateWebhookInput = {
  authHeader?: InputMaybe<Scalars['String']['input']>;
  callbackURL?: InputMaybe<Scalars['URL']['input']>;
  destinationType?: InputMaybe<ShepherdWebhookDestinationType>;
  status?: InputMaybe<ShepherdSubscriptionStatus>;
};

/** Represents the possible `vortexMode` values for a workspace. */
export enum ShepherdVortexModeStatus {
  Disabled = 'DISABLED',
  Enabled = 'ENABLED'
}

/** Represents a type of Webhook payload. */
export enum ShepherdWebhookDestinationType {
  Default = 'DEFAULT',
  MicrosoftTeams = 'MICROSOFT_TEAMS'
}

/** Represents the category of a Webhook subscription */
export enum ShepherdWebhookSubscriptionCategory {
  MicrosoftTeams = 'MICROSOFT_TEAMS',
  Webhook = 'WEBHOOK'
}

export type ShepherdWorkspaceCreateCustomDetectionInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  products: Array<ShepherdAtlassianProduct>;
  rules: Array<ShepherdCustomScanningRuleInput>;
  title: Scalars['String']['input'];
};

export type ShepherdWorkspaceSettingUpdateInput = {
  detectionId: Scalars['ID']['input'];
  settingId: Scalars['ID']['input'];
  value: ShepherdWorkspaceSettingValueInput;
};

/**
 * Contains the setting value for a detection.
 *
 * Only one value is supported at a time, according to each type of setting.
 */
export type ShepherdWorkspaceSettingValueInput = {
  confluenceEnabledValue?: InputMaybe<Scalars['Boolean']['input']>;
  jiraEnabledValue?: InputMaybe<Scalars['Boolean']['input']>;
  thresholdValue?: InputMaybe<ShepherdRateThresholdValue>;
  userActivityEnabledValue?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * Input used to update a custom detection.
 *
 * Any optional field that is left empty (i.e. `null` or `undefined`) will leave the previous value unchanged.
 */
export type ShepherdWorkspaceUpdateCustomDetectionInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  products?: InputMaybe<Array<ShepherdAtlassianProduct>>;
  rules?: InputMaybe<Array<ShepherdCustomScanningRuleInput>>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ShepherdWorkspaceUpdateInput = {
  shouldOnboard: Scalars['Boolean']['input'];
};

export type SignInvocationTokenForUiInput = {
  forgeContextToken: Scalars['String']['input'];
  /**  The remote key is not normally an ARI but since the service is marked as a tenanted service, one field in each path has to annotated as an ARI  */
  remoteKey: Scalars['String']['input'];
};

export type SitePermissionInput = {
  permissionsToAdd?: InputMaybe<UpdateSitePermissionInput>;
  permissionsToRemove?: InputMaybe<UpdateSitePermissionInput>;
};

export enum SitePermissionOperationType {
  AdministerConfluence = 'ADMINISTER_CONFLUENCE',
  AdministerSystem = 'ADMINISTER_SYSTEM',
  CreateProfileattachment = 'CREATE_PROFILEATTACHMENT',
  CreateSpace = 'CREATE_SPACE',
  ExternalCollaborator = 'EXTERNAL_COLLABORATOR',
  LimitedUseConfluence = 'LIMITED_USE_CONFLUENCE',
  ReadUserprofile = 'READ_USERPROFILE',
  UpdateUserstatus = 'UPDATE_USERSTATUS',
  UseConfluence = 'USE_CONFLUENCE',
  UsePersonalspace = 'USE_PERSONALSPACE'
}

export enum SitePermissionType {
  Anonymous = 'ANONYMOUS',
  App = 'APP',
  External = 'EXTERNAL',
  Internal = 'INTERNAL',
  Jsd = 'JSD'
}

export enum SitePermissionTypeFilter {
  All = 'ALL',
  Externalcollaborator = 'EXTERNALCOLLABORATOR',
  None = 'NONE'
}

/** Used as an input for get requests to Sky Bridge */
export type SkyBridgeIdInput = {
  id: Scalars['ID']['input'];
  shardingContext: Scalars['String']['input'];
};

export type SmartFeaturesInput = {
  entityIds: Array<Scalars['String']['input']>;
  entityType: Scalars['String']['input'];
  features?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/**
 * Provides context about who and where the recommendation or request is being made. The context determines:
 *   1. The search space (e.g. the set of users that are eligible to be recommended).
 *   2. The model that will be applied to the search results.
 *   3. The input feature values that are piped into the prediction model to generate the ranking score. The model used
 *      determines which context fields are used for prediction (see
 *      [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model)).
 */
export type SmartsContext = {
  /** Any additional context to be passed to the model. */
  additionalContextList?: InputMaybe<Array<SmartsKeyValue>>;
  /**
   * The ID of the container for which the recommendation is being made.
   *
   * A container is analogous to entities such as a Jira Project or Confluence Space. Depending on the model, it is either
   * optional or can be used as an input to provide more specific recommendations.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  containerId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the object for which the recommendation is being made.
   *
   * An object is analogous to entities such as a Jira Issue or Confluence Page.
   */
  objectId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The product for which the recommendation is being made.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  product?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the tenant for which the recommendation is being made. Analogous to siteId/cloudId optional context fields.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  tenantId: Scalars['String']['input'];
  /**
   * The ID (AAID) of the user for whom the recommendation is being made. Can be set to 'context', upon which it will use
   * the requesting user's ID.
   */
  userId: Scalars['String']['input'];
};

export type SmartsFieldContext = {
  /**
   * List of field keys and values to be passed for prediction.
   * e.g. [{"key": "15615", "value": "xpsearch-aggregator"}]
   */
  additionalContextList?: InputMaybe<Array<SmartsKeyValue>>;
  /**
   * The ID of the container for which the recommendation is being made.
   *
   * A container is analogous to entities such as a Jira Project. Depending on the model, it is either
   * optional or can be used as an input to provide more specific recommendations.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  containerId?: InputMaybe<Scalars['String']['input']>;
  /**
   * This is the identifier for the field that recommendations are to be provided for.
   * Valid values are: labels, components, versions and fixVersions
   */
  fieldId: Scalars['String']['input'];
  /**
   * The ID of the object for which the recommendation is being made.
   *
   * An object is analogous to entities such as a Jira Issue.
   */
  objectId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The product for which the recommendation is being made.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  product?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the tenant for which the recommendation is being made. Analogous to siteId/cloudId optional context fields.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  tenantId: Scalars['String']['input'];
  /**
   * The UserId (AAID) for which the recommendation is being made. Can be set to 'context'
   * if calling from Stargate, upon which it will use the requesting user's ID. Can be set to an empty
   * string '' for anonymous use cases.
   */
  userId: Scalars['String']['input'];
};

export type SmartsKeyValue = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** Provides information about the requester, for model selection and monitoring. */
export type SmartsModelRequestParams = {
  /**
   * This is some identifying information about the caller. It can be the microservice ID, AK package, etc.
   *
   * We use this internally for metrics and analytics. Please use a descriptive caller so we can easily locate your
   * consumer.
   */
  caller: Scalars['String']['input'];
  /**
   * The experience being used; used for selecting a model.
   *
   * See [Choosing a model](https://developer.atlassian.com/platform/collaboration-graph/guides/choosing-a-model) for a
   * guide on choosing an experience and configuring the context.
   */
  experience: Scalars['String']['input'];
};

export type SmartsRecommendationsFieldQuery = {
  /**
   * Provides context about who and where the recommendation or collaboration graph request is
   * being made. The context determines: 1. The search space (e.g. the set of users that are eligible
   * to be recommended; 2. The model that will be applied to the search results. 3. the input feature values that are
   * piped into the prediction model to generate the ranking score. The model used determines which context fields
   * are used for prediction (see DAC: Choosing a model).
   */
  context: SmartsFieldContext;
  /**
   * The maximum number of nearby entities that should be returned.
   *
   * Defaults to 100. If provided, must be in the range [1,500].
   */
  maxNumberOfResults?: InputMaybe<Scalars['Int']['input']>;
  /**
   * Provides information about the requester, for model selection and monitoring.
   * Valid values for the experience field are: JiraFields, JiraLabels and JiraComponents
   */
  modelRequestParams: SmartsModelRequestParams;
  /**
   * The ID (AtlassianID) of the user who is making the request. Used to perform permission checks and hydration.
   *
   * If the `requestingUserId` is set to the string 'context', Collaboration Graph will use the `requestingUserId` from
   * headers.
   */
  requestingUserId: Scalars['String']['input'];
  /** The unique identifier for the session. */
  sessionId?: InputMaybe<Scalars['String']['input']>;
};

export type SmartsRecommendationsQuery = {
  /**
   * Provides context about who and where the recommendation or collaboration graph request is
   * being made. The context determines: 1. The search space (e.g. the set of users that are eligible
   * to be recommended; 2. The model that will be applied to the search results. 3. the input feature values that are
   * piped into the prediction model to generate the ranking score. The model used determines which context fields
   * are used for prediction (see DAC: Choosing a model).
   */
  context: SmartsContext;
  /**
   * The maximum number of nearby entities that should be returned.
   *
   * Defaults to 100. If provided, must be in the range [1,500].
   */
  maxNumberOfResults?: InputMaybe<Scalars['Int']['input']>;
  /** Provides information about the requester, for model selection and monitoring. */
  modelRequestParams: SmartsModelRequestParams;
  /**
   * The ID (AtlassianID) of the user who is making the request. Used to perform permission checks and hydration.
   *
   * If the `requestingUserId` is set to the string 'context', Collaboration Graph will use the `requestingUserId` from
   * headers.
   */
  requestingUserId: Scalars['String']['input'];
  /** The unique identifier for the session. */
  sessionId?: InputMaybe<Scalars['String']['input']>;
};

export type SoftwareCardsDestination = {
  destination?: InputMaybe<SoftwareCardsDestinationEnum>;
  sprintId?: InputMaybe<Scalars['ID']['input']>;
};

export enum SoftwareCardsDestinationEnum {
  Backlog = 'BACKLOG',
  ExistingSprint = 'EXISTING_SPRINT',
  NewSprint = 'NEW_SPRINT'
}

/** The sort direction of the collection */
export enum SortDirection {
  /** Sort in ascending order */
  Asc = 'ASC',
  /** Sort in descending order */
  Desc = 'DESC'
}

export enum SortOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export enum SpaceAssignmentType {
  Assigned = 'ASSIGNED',
  Unassigned = 'UNASSIGNED'
}

export type SpaceInput = {
  key: Scalars['ID']['input'];
};

export enum SpaceManagerFilterType {
  Personal = 'PERSONAL',
  TeamAndProject = 'TEAM_AND_PROJECT'
}

export type SpaceManagerFilters = {
  /** Allows to find spaces based on the search query. */
  searchQuery?: InputMaybe<Scalars['String']['input']>;
  /** Allows to filter spaces by their status. */
  status?: InputMaybe<ConfluenceSpaceStatus>;
  /** Allows to filter spaces by their type. */
  types?: InputMaybe<Array<InputMaybe<SpaceManagerFilterType>>>;
};

export enum SpaceManagerOrderColumn {
  Key = 'KEY',
  Title = 'TITLE'
}

export enum SpaceManagerOrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type SpaceManagerOrdering = {
  /** Allows to order spaces by their column name. */
  column?: InputMaybe<SpaceManagerOrderColumn>;
  /** Specifies ordering direction. */
  direction?: InputMaybe<SpaceManagerOrderDirection>;
};

export enum SpaceManagerOwnerType {
  Group = 'GROUP',
  User = 'USER'
}

export type SpaceManagerQueryInput = {
  /** Contains inclusive cursor value after which items should be retrieved */
  after?: InputMaybe<Scalars['String']['input']>;
  /** Space manager filters */
  filters?: InputMaybe<SpaceManagerFilters>;
  /** Specifies max amount of items to return */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** Space manager order info */
  orderInfo?: InputMaybe<SpaceManagerOrdering>;
};

export type SpacePagesDisplayView = {
  spaceKey: Scalars['String']['input'];
  spacePagesPersistenceOption: PagesDisplayPersistenceOption;
};

export type SpacePagesSortView = {
  spaceKey: Scalars['String']['input'];
  spacePagesSortPersistenceOption: PagesSortPersistenceOptionInput;
};

export enum SpacePermissionType {
  AdministerSpace = 'ADMINISTER_SPACE',
  ArchivePage = 'ARCHIVE_PAGE',
  ArchiveSpace = 'ARCHIVE_SPACE',
  Comment = 'COMMENT',
  CreateAttachment = 'CREATE_ATTACHMENT',
  CreateBlog = 'CREATE_BLOG',
  CreateEditPage = 'CREATE_EDIT_PAGE',
  DeleteOwnComment = 'DELETE_OWN_COMMENT',
  DeleteSpace = 'DELETE_SPACE',
  EditBlog = 'EDIT_BLOG',
  EditNativeContent = 'EDIT_NATIVE_CONTENT',
  ExportContent = 'EXPORT_CONTENT',
  ExportPage = 'EXPORT_PAGE',
  ExportSpace = 'EXPORT_SPACE',
  ManageContent = 'MANAGE_CONTENT',
  ManageGuestUsers = 'MANAGE_GUEST_USERS',
  ManageLookAndFeel = 'MANAGE_LOOK_AND_FEEL',
  ManageNonlicensedUsers = 'MANAGE_NONLICENSED_USERS',
  ManagePublicLinks = 'MANAGE_PUBLIC_LINKS',
  ManageTemplates = 'MANAGE_TEMPLATES',
  ManageUsers = 'MANAGE_USERS',
  RemoveAttachment = 'REMOVE_ATTACHMENT',
  RemoveBlog = 'REMOVE_BLOG',
  RemoveComment = 'REMOVE_COMMENT',
  RemoveMail = 'REMOVE_MAIL',
  RemoveOwnContent = 'REMOVE_OWN_CONTENT',
  RemovePage = 'REMOVE_PAGE',
  SetPagePermissions = 'SET_PAGE_PERMISSIONS',
  ViewSpace = 'VIEW_SPACE'
}

export enum SpaceRoleType {
  Custom = 'CUSTOM',
  System = 'SYSTEM'
}

export enum SpaceSidebarLinkType {
  ExternalLink = 'EXTERNAL_LINK',
  Forge = 'FORGE',
  PinnedAttachment = 'PINNED_ATTACHMENT',
  PinnedBlogPost = 'PINNED_BLOG_POST',
  PinnedPage = 'PINNED_PAGE',
  PinnedSpace = 'PINNED_SPACE',
  PinnedUserInfo = 'PINNED_USER_INFO',
  WebItem = 'WEB_ITEM'
}

export type SpaceTypeSettingsInput = {
  enabledContentTypes?: InputMaybe<EnabledContentTypesInput>;
  enabledFeatures?: InputMaybe<EnabledFeaturesInput>;
};

export type SpaceViewsPersistence = {
  persistenceOption: SpaceViewsPersistenceOption;
  spaceKey: Scalars['String']['input'];
};

export enum SpaceViewsPersistenceOption {
  Popularity = 'POPULARITY',
  RecentlyModified = 'RECENTLY_MODIFIED',
  RecentlyViewed = 'RECENTLY_VIEWED',
  TitleAz = 'TITLE_AZ',
  Tree = 'TREE'
}

export type SpfAddPlanApproverInput = {
  approverId: Scalars['String']['input'];
  planId: Scalars['ID']['input'];
};

export type SpfAddPlanOwnerInput = {
  ownerId: Scalars['String']['input'];
  planId: Scalars['ID']['input'];
};

export enum SpfAskActivityAttribute {
  Description = 'DESCRIPTION',
  ImpactedWork = 'IMPACTED_WORK',
  Justification = 'JUSTIFICATION',
  Link = 'LINK',
  Name = 'NAME',
  Owner = 'OWNER',
  Priority = 'PRIORITY',
  ProposedDate = 'PROPOSED_DATE',
  ReceivingTeam = 'RECEIVING_TEAM',
  Status = 'STATUS',
  Submitter = 'SUBMITTER',
  SubmittingTeam = 'SUBMITTING_TEAM',
  TargetDate = 'TARGET_DATE'
}

export enum SpfAskActivityType {
  Created = 'CREATED',
  Updated = 'UPDATED'
}

export enum SpfAskPriority {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Highest = 'HIGHEST',
  Low = 'LOW',
  Medium = 'MEDIUM'
}

export enum SpfAskStatus {
  Accepted = 'ACCEPTED',
  Canceled = 'CANCELED',
  Deferred = 'DEFERRED',
  Draft = 'DRAFT',
  InReview = 'IN_REVIEW',
  Revising = 'REVISING',
  Submitted = 'SUBMITTED'
}

export type SpfAskTargetDateInput = {
  targetDate: Scalars['String']['input'];
  targetDateType: SpfAskTargetDateType;
};

export enum SpfAskTargetDateType {
  Day = 'DAY',
  Month = 'MONTH',
  Quarter = 'QUARTER'
}

export type SpfAskUpdateDescriptionInput = {
  description: Scalars['String']['input'];
  id: Scalars['ID']['input'];
};

export type SpfAskUpdateStatusInput = {
  id: Scalars['ID']['input'];
  status: SpfAskStatus;
};

export type SpfAskUpdateTargetDateInput = {
  id: Scalars['ID']['input'];
  targetDate: SpfAskTargetDateInput;
};

export type SpfAttachAskLinkInput = {
  askId: Scalars['ID']['input'];
  linkText?: InputMaybe<Scalars['String']['input']>;
  url: Scalars['URL']['input'];
};

export type SpfCreateAskCommentInput = {
  askId: Scalars['ID']['input'];
  data: Scalars['String']['input'];
  parentCommentId?: InputMaybe<Scalars['ID']['input']>;
};

export type SpfCreateAskInput = {
  cloudId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  impactedWorkId?: InputMaybe<Scalars['String']['input']>;
  justification?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['String']['input']>;
  priority: SpfAskPriority;
  receivingTeamId?: InputMaybe<Scalars['String']['input']>;
  status: SpfAskStatus;
  submitterId: Scalars['String']['input'];
  submittingTeamId?: InputMaybe<Scalars['String']['input']>;
  targetDate?: InputMaybe<SpfAskTargetDateInput>;
};

export type SpfCreateAskUpdateInput = {
  askId: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  proposedDate?: InputMaybe<SpfAskTargetDateInput>;
  status?: InputMaybe<SpfAskStatus>;
  targetDate?: InputMaybe<SpfAskTargetDateInput>;
};

export type SpfCreatePlanInput = {
  approverIds?: InputMaybe<Array<Scalars['String']['input']>>;
  cloudId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  ownerIds: Array<Scalars['String']['input']>;
  portfolioId: Scalars['String']['input'];
  status: SpfPlanStatus;
  timeframe: SpfPlanTimeframeInput;
};

export type SpfCreatePlanScenarioInput = {
  name: Scalars['String']['input'];
  planId: Scalars['ID']['input'];
  status: SpfPlanScenarioStatus;
};

export type SpfCreatePlanScenarioInvestmentInput = {
  committedEffort?: InputMaybe<Scalars['Int']['input']>;
  committedOwnerId?: InputMaybe<Scalars['String']['input']>;
  groupType?: InputMaybe<SpfPlanScenarioInvestmentGroupType>;
  investmentId: Scalars['String']['input'];
  planScenarioId: Scalars['ID']['input'];
};

export type SpfDeleteAskCommentInput = {
  id: Scalars['ID']['input'];
};

export type SpfDeleteAskInput = {
  id: Scalars['ID']['input'];
};

export type SpfDeleteAskLinkInput = {
  id: Scalars['ID']['input'];
};

export type SpfDeleteAskUpdateInput = {
  id: Scalars['ID']['input'];
};

export type SpfDeletePlanInput = {
  id: Scalars['ID']['input'];
};

export type SpfDeletePlanScenarioInput = {
  id: Scalars['ID']['input'];
};

export type SpfDeletePlanScenarioInvestmentsInput = {
  ids: Array<Scalars['ID']['input']>;
};

export enum SpfMediaTokenUsageType {
  Read = 'READ',
  Write = 'WRITE'
}

export enum SpfPlanScenarioInvestmentGroupType {
  Prioritized = 'PRIORITIZED',
  Unprioritized = 'UNPRIORITIZED'
}

export enum SpfPlanScenarioStatus {
  Draft = 'DRAFT'
}

export enum SpfPlanStatus {
  Canceled = 'CANCELED',
  Draft = 'DRAFT',
  Final = 'FINAL'
}

export enum SpfPlanTimeframeGranularity {
  Month = 'MONTH',
  Quarter = 'QUARTER',
  Week = 'WEEK'
}

export type SpfPlanTimeframeInput = {
  endDate: Scalars['String']['input'];
  startDate: Scalars['String']['input'];
  timeframeGranularity: SpfPlanTimeframeGranularity;
};

export type SpfRemovePlanApproverInput = {
  approverId: Scalars['String']['input'];
  planId: Scalars['ID']['input'];
};

export type SpfRemovePlanOwnerInput = {
  ownerId: Scalars['String']['input'];
  planId: Scalars['ID']['input'];
};

export type SpfResolveProposedDateInput = {
  askId: Scalars['String']['input'];
};

export type SpfUpdateAskCommentDataInput = {
  data: Scalars['String']['input'];
  id: Scalars['ID']['input'];
};

export type SpfUpdateAskDescriptionInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export type SpfUpdateAskImpactedWorkInput = {
  id: Scalars['ID']['input'];
  impactedWorkId?: InputMaybe<Scalars['String']['input']>;
};

export type SpfUpdateAskJustificationInput = {
  id: Scalars['ID']['input'];
  justification?: InputMaybe<Scalars['String']['input']>;
};

export type SpfUpdateAskNameInput = {
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

export type SpfUpdateAskOwnerInput = {
  id: Scalars['ID']['input'];
  ownerId?: InputMaybe<Scalars['String']['input']>;
};

export type SpfUpdateAskPriorityInput = {
  id: Scalars['ID']['input'];
  priority: SpfAskPriority;
};

export type SpfUpdateAskReceivingTeamInput = {
  id: Scalars['ID']['input'];
  receivingTeamId?: InputMaybe<Scalars['String']['input']>;
};

export type SpfUpdateAskSubmitterInput = {
  id: Scalars['ID']['input'];
  submitterId: Scalars['String']['input'];
};

export type SpfUpdateAskSubmittingTeamInput = {
  id: Scalars['ID']['input'];
  submittingTeamId?: InputMaybe<Scalars['String']['input']>;
};

export type SpfUpdatePlanDescriptionInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export type SpfUpdatePlanNameInput = {
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

export type SpfUpdatePlanPortfolioInput = {
  id: Scalars['ID']['input'];
  portfolioId: Scalars['String']['input'];
};

export type SpfUpdatePlanScenarioInvestmentCommittedEffortInput = {
  committedEffort?: InputMaybe<Scalars['Int']['input']>;
  id: Scalars['ID']['input'];
};

export type SpfUpdatePlanScenarioInvestmentCommittedOwnerInput = {
  committedOwnerId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export type SpfUpdatePlanScenarioInvestmentInvestmentInput = {
  id: Scalars['ID']['input'];
  investmentId: Scalars['String']['input'];
};

export type SpfUpdatePlanScenarioNameInput = {
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

export type SpfUpdatePlanScenarioStatusInput = {
  id: Scalars['ID']['input'];
  status: SpfPlanScenarioStatus;
};

export type SpfUpdatePlanStatusInput = {
  id: Scalars['ID']['input'];
  status: SpfPlanStatus;
};

export type SpfUpdatePlanTimeframeInput = {
  id: Scalars['ID']['input'];
  timeframe: SpfPlanTimeframeInput;
};

export type SplitIssueInput = {
  newIssues: Array<InputMaybe<NewSplitIssueRequest>>;
  originalIssue: OriginalSplitIssue;
};

export enum SprintReportsEstimationStatisticType {
  IssueCount = 'ISSUE_COUNT',
  OriginalEstimate = 'ORIGINAL_ESTIMATE',
  StoryPoints = 'STORY_POINTS'
}

export enum SprintState {
  Active = 'ACTIVE',
  Closed = 'CLOSED',
  Future = 'FUTURE'
}

export enum StakeholderCommsAddedFromType {
  Jsm = 'JSM',
  Statuspage = 'STATUSPAGE'
}

export type StakeholderCommsAssignmentConnectionInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  stakeholderIdInput: StakeholderCommsStakeholderIdInput;
};

export type StakeholderCommsAssignmentIdInput = {
  ari?: InputMaybe<Scalars['String']['input']>;
  assignmentId?: InputMaybe<Scalars['ID']['input']>;
  assignmentType?: InputMaybe<StakeholderCommsAssignmentType>;
  externalAssignmentId?: InputMaybe<Scalars['String']['input']>;
};

export enum StakeholderCommsAssignmentType {
  Asset = 'ASSET',
  Incident = 'INCIDENT',
  Org = 'ORG',
  Page = 'PAGE',
  Product = 'PRODUCT',
  Services = 'SERVICES',
  Site = 'SITE'
}

export type StakeholderCommsBatchComponentProcessRequest = {
  createUpdateComponents?: InputMaybe<Array<InputMaybe<StakeholderCommsNestedDraftComponentInput>>>;
  deleteComponents?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  pageId?: InputMaybe<Scalars['String']['input']>;
};

export type StakeholderCommsBodyConfigInput = {
  componentStyle?: InputMaybe<StakeholderCommsComponentStyle>;
  componentUptimeDisplay?: InputMaybe<Scalars['String']['input']>;
  componentUptimeRange?: InputMaybe<Scalars['Int']['input']>;
  enableSearchAndFilter?: InputMaybe<Scalars['Boolean']['input']>;
  numberOfCardsPerRow?: InputMaybe<Scalars['Int']['input']>;
  overallUptimeDisplay?: InputMaybe<Scalars['String']['input']>;
  overallUptimeRange?: InputMaybe<Scalars['Int']['input']>;
  uptimeStyle?: InputMaybe<StakeholderCommsUptimeStyle>;
};

export type StakeholderCommsColoursInput = {
  cssBlueColor?: InputMaybe<Scalars['String']['input']>;
  cssBodyBackgroundColor?: InputMaybe<Scalars['String']['input']>;
  cssBorderColor?: InputMaybe<Scalars['String']['input']>;
  cssFontColor?: InputMaybe<Scalars['String']['input']>;
  cssGraphColor?: InputMaybe<Scalars['String']['input']>;
  cssGreenColor?: InputMaybe<Scalars['String']['input']>;
  cssLightFontColor?: InputMaybe<Scalars['String']['input']>;
  cssLinkColor?: InputMaybe<Scalars['String']['input']>;
  cssNoDataColor?: InputMaybe<Scalars['String']['input']>;
  cssOrangeColor?: InputMaybe<Scalars['String']['input']>;
  cssRedColor?: InputMaybe<Scalars['String']['input']>;
  cssYellowColor?: InputMaybe<Scalars['String']['input']>;
};

export enum StakeholderCommsComponentStatus {
  DegradedPerformance = 'DEGRADED_PERFORMANCE',
  MajorOutage = 'MAJOR_OUTAGE',
  Operational = 'OPERATIONAL',
  PartialOutage = 'PARTIAL_OUTAGE',
  UnderMaintenance = 'UNDER_MAINTENANCE'
}

export enum StakeholderCommsComponentStyle {
  Card = 'CARD',
  Table = 'TABLE'
}

export enum StakeholderCommsComponentType {
  Component = 'COMPONENT',
  GroupComponent = 'GROUP_COMPONENT'
}

export type StakeholderCommsComponentUpdateInput = {
  componentId: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  incidentId?: InputMaybe<Scalars['String']['input']>;
  newStatus?: InputMaybe<StakeholderCommsComponentStatus>;
  oldStatus?: InputMaybe<StakeholderCommsComponentStatus>;
  pageId: Scalars['String']['input'];
  type?: InputMaybe<StakeholderCommsComponentType>;
};

export type StakeholderCommsCreatePageInputType = {
  activityScore?: InputMaybe<Scalars['Int']['input']>;
  allowPageSubscribers?: InputMaybe<Scalars['Boolean']['input']>;
  allowRssAtomFields?: InputMaybe<Scalars['Boolean']['input']>;
  blackHole?: InputMaybe<Scalars['Boolean']['input']>;
  bodyConfig?: InputMaybe<StakeholderCommsBodyConfigInput>;
  cloudId?: InputMaybe<Scalars['String']['input']>;
  colours?: InputMaybe<StakeholderCommsColoursInput>;
  components?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  createdAt?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  customCss?: InputMaybe<Scalars['String']['input']>;
  customFooterHtml?: InputMaybe<Scalars['String']['input']>;
  customHeaderHtml?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  domain?: InputMaybe<Scalars['String']['input']>;
  externalAccounts?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  footerData?: InputMaybe<StakeholderCommsFooterDataInput>;
  googleAnalyticsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  googleAnalyticsTrackingId?: InputMaybe<Scalars['String']['input']>;
  headerData?: InputMaybe<StakeholderCommsHeaderDataInput>;
  helpCenterUrl?: InputMaybe<Scalars['String']['input']>;
  hiddenFromSearch?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  pageTheme?: InputMaybe<StakeholderCommsPageTheme>;
  pageThemeMode?: InputMaybe<StakeholderCommsPageThemeMode>;
  pageType?: InputMaybe<StakeholderCommsPageType>;
  privacyPolicyUrl?: InputMaybe<Scalars['String']['input']>;
  seoConfig?: InputMaybe<StakeholderCommsSeoConfigInput>;
  statusEmbedEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  subdomain?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

export type StakeholderCommsCreateStakeholderGroupInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  insertedAt?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  ownerId: Scalars['String']['input'];
  services?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  status: StakeholderCommsStakeholderGroupStatus;
  updatedAt?: InputMaybe<Scalars['String']['input']>;
};

export type StakeholderCommsCreateStakeholderInput = {
  aaid?: InputMaybe<Scalars['String']['input']>;
  addedFrom: StakeholderCommsAddedFromType;
  assignmentType: StakeholderCommsAssignmentType;
  atlassianTeamId?: InputMaybe<Scalars['String']['input']>;
  emailId?: InputMaybe<Scalars['String']['input']>;
  externalAssignmentId: Scalars['String']['input'];
  phoneCountry?: InputMaybe<Scalars['String']['input']>;
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
  preference: StakeholderCommsPreferencesInput;
  skipConfirmation: Scalars['Boolean']['input'];
  stakeholderGroupId?: InputMaybe<Scalars['String']['input']>;
  stakeholderType: StakeholderCommsStakeholderType;
  webhook?: InputMaybe<Scalars['String']['input']>;
};

export enum StakeholderCommsDnsRecordStatus {
  Failed = 'FAILED',
  Pending = 'PENDING',
  Skipped = 'SKIPPED',
  Verified = 'VERIFIED'
}

export enum StakeholderCommsErrorType {
  SystemError = 'SYSTEM_ERROR',
  ValidationError = 'VALIDATION_ERROR'
}

export enum StakeholderCommsExternalIncidentSource {
  Jsm = 'JSM',
  Statuspage = 'STATUSPAGE'
}

export type StakeholderCommsFooterDataInput = {
  copyrightText?: InputMaybe<Scalars['String']['input']>;
  footerLogoId?: InputMaybe<Scalars['String']['input']>;
  footerText?: InputMaybe<Scalars['String']['input']>;
  links?: InputMaybe<Array<InputMaybe<StakeholderCommsLinkInput>>>;
};

export type StakeholderCommsGetIncidentInput = {
  externalIncidentId?: InputMaybe<Scalars['String']['input']>;
  incidentCode?: InputMaybe<Scalars['String']['input']>;
  incidentId?: InputMaybe<Scalars['String']['input']>;
};

export type StakeholderCommsHeaderDataInput = {
  coverImageId?: InputMaybe<Scalars['String']['input']>;
  coverImageImmersive?: InputMaybe<Scalars['Boolean']['input']>;
  faviconIconId?: InputMaybe<Scalars['String']['input']>;
  headerLogoId?: InputMaybe<Scalars['String']['input']>;
  headerText?: InputMaybe<Scalars['String']['input']>;
  links?: InputMaybe<Array<InputMaybe<StakeholderCommsLinkInput>>>;
};

export type StakeholderCommsIncidentComponentStatusInput = {
  componentId: Scalars['String']['input'];
  status?: InputMaybe<StakeholderCommsComponentStatus>;
};

export type StakeholderCommsIncidentCreateRequest = {
  affectedComponents?: InputMaybe<Array<InputMaybe<StakeholderCommsIncidentComponentStatusInput>>>;
  impact?: InputMaybe<StakeholderCommsIncidentImpact>;
  jiraIncidentId?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  pageId: Scalars['String']['input'];
  shouldSendNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<StakeholderCommsIncidentStatus>;
};

export enum StakeholderCommsIncidentImpact {
  Critical = 'CRITICAL',
  Major = 'MAJOR',
  Minor = 'MINOR',
  None = 'NONE'
}

export enum StakeholderCommsIncidentStatus {
  Identified = 'IDENTIFIED',
  Investigating = 'INVESTIGATING',
  Monitoring = 'MONITORING',
  Resolved = 'RESOLVED'
}

export type StakeholderCommsIncidentUpdateRequest = {
  affectedComponents?: InputMaybe<Array<InputMaybe<StakeholderCommsIncidentComponentStatusInput>>>;
  impact?: InputMaybe<StakeholderCommsIncidentImpact>;
  jiraIncidentId?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pageId: Scalars['String']['input'];
  shouldSendNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<StakeholderCommsIncidentStatus>;
};

export type StakeholderCommsIncidentWithUpdatesConnectionInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  pageId: Scalars['String']['input'];
  showActive?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StakeholderCommsIssueSslInput = {
  domain: Scalars['String']['input'];
  pageId: Scalars['String']['input'];
};

export type StakeholderCommsLinkInput = {
  label?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type StakeholderCommsListIncidentInput = {
  pageId?: InputMaybe<Scalars['String']['input']>;
  showActive?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StakeholderCommsListSubscriberInput = {
  itemId: Scalars['String']['input'];
  itemType: StakeholderCommsSubscriberItemType;
};

export type StakeholderCommsModePreferenceInput = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StakeholderCommsNestedComponentConnectionInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  pageId: Scalars['String']['input'];
};

export type StakeholderCommsNestedComponentWithUptimeConnectionInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  pageId: Scalars['String']['input'];
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['String']['input']>;
  statusFilter?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type StakeholderCommsNestedDraftComponentInput = {
  components?: InputMaybe<Array<InputMaybe<StakeholderCommsNestedDraftComponentInput>>>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pageId: Scalars['String']['input'];
  position?: InputMaybe<Scalars['Int']['input']>;
  serviceId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<StakeholderCommsComponentStatus>;
  type: StakeholderCommsComponentType;
};

export type StakeholderCommsNotificationPreferenceInput = {
  emailId?: InputMaybe<Scalars['String']['input']>;
  phoneCountry?: InputMaybe<Scalars['String']['input']>;
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
  preference?: InputMaybe<StakeholderCommsPreferencesInput>;
  webhook?: InputMaybe<Scalars['String']['input']>;
};

/** Represents the loading status of a risk assessment component */
export enum StakeholderCommsOpsgenieLoadingStatus {
  Loaded = 'LOADED',
  Loading = 'LOADING',
  NotStarted = 'NOT_STARTED'
}

export enum StakeholderCommsOpsgenieRiskCategoryType {
  Business = 'BUSINESS',
  Operational = 'OPERATIONAL',
  SecurityCompliance = 'SECURITY_COMPLIANCE',
  Technical = 'TECHNICAL'
}

export enum StakeholderCommsOpsgenieRiskScore {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM'
}

export enum StakeholderCommsOrderType {
  EmailId = 'EMAIL_ID',
  Status = 'STATUS'
}

export enum StakeholderCommsPageStatus {
  Draft = 'DRAFT',
  Published = 'PUBLISHED',
  PublishedWithChanges = 'PUBLISHED_WITH_CHANGES',
  SoftDeleted = 'SOFT_DELETED',
  Unpublished = 'UNPUBLISHED',
  UnpublishedWithChanges = 'UNPUBLISHED_WITH_CHANGES'
}

export enum StakeholderCommsPageStatusFilter {
  All = 'ALL',
  Draft = 'DRAFT',
  Published = 'PUBLISHED'
}

export enum StakeholderCommsPageTheme {
  AllSystemsGlow = 'ALL_SYSTEMS_GLOW',
  Blank = 'BLANK',
  ClearSkies = 'CLEAR_SKIES',
  UpAndRunning = 'UP_AND_RUNNING'
}

export enum StakeholderCommsPageThemeMode {
  Dark = 'DARK',
  Light = 'LIGHT'
}

export enum StakeholderCommsPageType {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

export type StakeholderCommsPaginatedAssignmentByStakeholderInput = {
  cursor?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  stakeholderIdInput: StakeholderCommsStakeholderIdInput;
};

export type StakeholderCommsPaginatedStakeholderInput = {
  assignmentIdInput: StakeholderCommsAssignmentIdInput;
  cursor?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type StakeholderCommsPreSignedUrlInput = {
  filename: Scalars['String']['input'];
  filetype: Scalars['String']['input'];
};

export type StakeholderCommsPreferencesInput = {
  email?: InputMaybe<StakeholderCommsModePreferenceInput>;
  sms?: InputMaybe<StakeholderCommsModePreferenceInput>;
  webhook?: InputMaybe<StakeholderCommsModePreferenceInput>;
};

export type StakeholderCommsRemoveCustomDomainInput = {
  domain: Scalars['String']['input'];
  pageId: Scalars['String']['input'];
};

export type StakeholderCommsResendInviteInput = {
  aaid?: InputMaybe<Scalars['String']['input']>;
  emailId: Scalars['String']['input'];
};

export enum StakeholderCommsSearchField {
  EmailId = 'EMAIL_ID'
}

/**  Unified search types */
export enum StakeholderCommsSearchFilterType {
  Groups = 'GROUPS',
  Teams = 'TEAMS',
  Users = 'USERS'
}

export type StakeholderCommsSeoConfigInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export enum StakeholderCommsSslStatus {
  Deprovisioning = 'DEPROVISIONING',
  Expired = 'EXPIRED',
  Failed = 'FAILED',
  Issued = 'ISSUED',
  NotConfigured = 'NOT_CONFIGURED',
  Pending = 'PENDING'
}

export type StakeholderCommsStakeholderAssignmentIdInput = {
  assignmentIdInput: StakeholderCommsAssignmentIdInput;
  stakeholderIdInput: StakeholderCommsStakeholderIdInput;
};

export type StakeholderCommsStakeholderConnectionFilter = {
  status?: InputMaybe<Array<StakeholderCommsStakeholderStatus>>;
  type?: InputMaybe<Array<StakeholderCommsStakeholderType>>;
};

export type StakeholderCommsStakeholderConnectionInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  assignmentIdInput: StakeholderCommsAssignmentIdInput;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type StakeholderCommsStakeholderConnectionOrder = {
  descending?: InputMaybe<Scalars['Boolean']['input']>;
  orderBy?: InputMaybe<StakeholderCommsOrderType>;
};

export type StakeholderCommsStakeholderConnectionSearch = {
  searchField?: InputMaybe<StakeholderCommsSearchField>;
  searchValue?: InputMaybe<Scalars['String']['input']>;
};

export type StakeholderCommsStakeholderGroupMemberRoleMapEntry = {
  memberId: Scalars['String']['input'];
  type: StakeholderCommsStakeholderType;
};

export enum StakeholderCommsStakeholderGroupStatus {
  Active = 'ACTIVE',
  Deleted = 'DELETED',
  Inactive = 'INACTIVE',
  Suspended = 'SUSPENDED'
}

export type StakeholderCommsStakeholderIdInput = {
  aaid?: InputMaybe<Scalars['String']['input']>;
  ari?: InputMaybe<Scalars['String']['input']>;
  atlassianTeamId?: InputMaybe<Scalars['String']['input']>;
  emailId?: InputMaybe<Scalars['String']['input']>;
  stakeholderGroupId?: InputMaybe<Scalars['String']['input']>;
  stakeholderId?: InputMaybe<Scalars['ID']['input']>;
  stakeholderType?: InputMaybe<StakeholderCommsStakeholderType>;
};

export enum StakeholderCommsStakeholderStatus {
  Active = 'ACTIVE',
  Deleted = 'DELETED',
  Invited = 'INVITED',
  InvitedPendingApproval = 'INVITED_PENDING_APPROVAL',
  NotInvited = 'NOT_INVITED',
  PendingIdentitySetup = 'PENDING_IDENTITY_SETUP',
  Quarantined = 'QUARANTINED'
}

export enum StakeholderCommsStakeholderType {
  External = 'EXTERNAL',
  Group = 'GROUP',
  Internal = 'INTERNAL',
  Team = 'TEAM'
}

export type StakeholderCommsSubscriberConnectionFilter = {
  statuses?: InputMaybe<Array<InputMaybe<StakeholderCommsSubscriberStatus>>>;
  subscriptionTypes?: InputMaybe<Array<InputMaybe<StakeholderCommsSubscriptionType>>>;
};

export type StakeholderCommsSubscriberConnectionOrder = {
  descending?: InputMaybe<Scalars['Boolean']['input']>;
  orderBy?: InputMaybe<StakeholderCommsSubscriberOrderByType>;
};

export type StakeholderCommsSubscriberConnectionSearch = {
  query?: InputMaybe<Scalars['String']['input']>;
};

export enum StakeholderCommsSubscriberItemType {
  ComponentSubscriber = 'COMPONENT_SUBSCRIBER',
  IncidentSubscriber = 'INCIDENT_SUBSCRIBER',
  PageSubscriber = 'PAGE_SUBSCRIBER'
}

export enum StakeholderCommsSubscriberOrderByType {
  CreatedAt = 'CREATED_AT',
  Email = 'EMAIL',
  Status = 'STATUS',
  UpdatedAt = 'UPDATED_AT'
}

export enum StakeholderCommsSubscriberStatus {
  Deactivated = 'DEACTIVATED',
  PendingConfirmation = 'PENDING_CONFIRMATION',
  Quarantined = 'QUARANTINED',
  Subscribed = 'SUBSCRIBED',
  Suspended = 'SUSPENDED',
  Unsubscribed = 'UNSUBSCRIBED',
  Unverified = 'UNVERIFIED'
}

export enum StakeholderCommsSubscriptionChannel {
  Email = 'EMAIL',
  Slack = 'SLACK',
  Sms = 'SMS',
  Webhook = 'WEBHOOK'
}

export type StakeholderCommsSubscriptionData = {
  email?: InputMaybe<Scalars['String']['input']>;
  phoneCountry?: InputMaybe<Scalars['String']['input']>;
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
  webhookEndpoint?: InputMaybe<Scalars['String']['input']>;
};

export type StakeholderCommsSubscriptionRequest = {
  captchaToken?: InputMaybe<Scalars['String']['input']>;
  itemId: Scalars['String']['input'];
  itemType: StakeholderCommsSubscriberItemType;
  subscriptionData?: InputMaybe<StakeholderCommsSubscriptionData>;
  subscriptionType: StakeholderCommsSubscriptionChannel;
};

export enum StakeholderCommsSubscriptionType {
  Email = 'EMAIL',
  MsTeams = 'MS_TEAMS',
  Slack = 'SLACK',
  Sms = 'SMS',
  Webhook = 'WEBHOOK'
}

export type StakeholderCommsUnifiedSearchInput = {
  filters?: InputMaybe<Array<InputMaybe<StakeholderCommsSearchFilterType>>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  organizationId: Scalars['String']['input'];
  searchString: Scalars['String']['input'];
};

export type StakeholderCommsUpdateCustomDomainInput = {
  domain: Scalars['String']['input'];
  pageId: Scalars['String']['input'];
};

export type StakeholderCommsUpdatePageInputType = {
  activityScore?: InputMaybe<Scalars['Int']['input']>;
  allowPageSubscribers?: InputMaybe<Scalars['Boolean']['input']>;
  allowRssAtomFields?: InputMaybe<Scalars['Boolean']['input']>;
  blackHole?: InputMaybe<Scalars['Boolean']['input']>;
  bodyConfig?: InputMaybe<StakeholderCommsBodyConfigInput>;
  cloudId?: InputMaybe<Scalars['String']['input']>;
  colours?: InputMaybe<StakeholderCommsColoursInput>;
  components?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  createdAt?: InputMaybe<Scalars['String']['input']>;
  customCss?: InputMaybe<Scalars['String']['input']>;
  customFooterHtml?: InputMaybe<Scalars['String']['input']>;
  customHeaderHtml?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  domain?: InputMaybe<Scalars['String']['input']>;
  externalAccounts?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  footerData?: InputMaybe<StakeholderCommsFooterDataInput>;
  googleAnalyticsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  googleAnalyticsTrackingId?: InputMaybe<Scalars['String']['input']>;
  headerData?: InputMaybe<StakeholderCommsHeaderDataInput>;
  helpCenterUrl?: InputMaybe<Scalars['String']['input']>;
  hiddenFromSearch?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  pageTheme?: InputMaybe<StakeholderCommsPageTheme>;
  pageThemeMode?: InputMaybe<StakeholderCommsPageThemeMode>;
  pageType?: InputMaybe<StakeholderCommsPageType>;
  privacyPolicyUrl?: InputMaybe<Scalars['String']['input']>;
  seoConfig?: InputMaybe<StakeholderCommsSeoConfigInput>;
  statusEmbedEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  subdomain?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

export type StakeholderCommsUpdateStakeholderGroupInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  insertedAt?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  ownerId: Scalars['String']['input'];
  services?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  status: StakeholderCommsStakeholderGroupStatus;
  updatedAt?: InputMaybe<Scalars['String']['input']>;
};

export type StakeholderCommsUpdateStakeholderInput = {
  notificationPreference?: InputMaybe<StakeholderCommsNotificationPreferenceInput>;
  stakeholderIdInput: StakeholderCommsStakeholderIdInput;
  status?: InputMaybe<StakeholderCommsStakeholderStatus>;
};

export enum StakeholderCommsUptimeStyle {
  DetailCard = 'DETAIL_CARD',
  OnlyStatus = 'ONLY_STATUS'
}

export type StakeholderCommsVerifyDnsInput = {
  domain: Scalars['String']['input'];
  pageId: Scalars['String']['input'];
};

export enum StalePageStatus {
  Archived = 'ARCHIVED',
  Current = 'CURRENT',
  Draft = 'DRAFT'
}

export enum StalePagesSortingType {
  Asc = 'ASC',
  Desc = 'DESC'
}

/** Start sprint */
export type StartSprintInput = {
  boardId: Scalars['ID']['input'];
  endDate: Scalars['String']['input'];
  goal?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  sprintId: Scalars['ID']['input'];
  startDate: Scalars['String']['input'];
};

export type Step = {
  from?: InputMaybe<Scalars['Long']['input']>;
  mark: Mark;
  pos?: InputMaybe<Scalars['Long']['input']>;
  to?: InputMaybe<Scalars['Long']['input']>;
};

export type StringUserInput = {
  type: StringUserInputType;
  value?: InputMaybe<Scalars['String']['input']>;
  variableName: Scalars['String']['input'];
};

export enum StringUserInputType {
  Dropdown = 'DROPDOWN',
  Paragraph = 'PARAGRAPH',
  Text = 'TEXT'
}

export type SubjectPermissionDeltas = {
  permissionsToAdd: Array<InputMaybe<SpacePermissionType>>;
  permissionsToRemove: Array<InputMaybe<SpacePermissionType>>;
  subjectKeyInput: UpdatePermissionSubjectKeyInput;
};

export type SubjectPermissionDeltasV2 = {
  permissionsToAdd: Array<InputMaybe<Scalars['String']['input']>>;
  permissionsToRemove: Array<InputMaybe<Scalars['String']['input']>>;
  principalInput: RoleAssignmentPrincipalInput;
};

export enum SummaryType {
  Blogpost = 'BLOGPOST',
  Page = 'PAGE'
}

export type SupportInquiryChannelPlatformIdentityHashRequest = {
  clientName?: InputMaybe<Scalars['String']['input']>;
};

export type SupportInquiryEntitlementQueryFilter = {
  productCatalogId?: InputMaybe<Scalars['String']['input']>;
};

export type SupportRequestAddCommentInput = {
  /** unique key/id of the request ticket */
  issueKey: Scalars['String']['input'];
  /** The comment message in wiki markup format (Jira format). */
  message: Scalars['String']['input'];
};

export type SupportRequestAdditionalTicketData = {
  /** chat transcript from AI agent conversation to be added as a comment */
  chatTranscript?: InputMaybe<Scalars['String']['input']>;
  /** operation that should be done for the new ticket example: PROBLEM_TICKET_CREATION */
  operationType?: InputMaybe<Scalars['String']['input']>;
  /** parent issue id or key of the ticket that should be newly created */
  parentIssueIdOrKey?: InputMaybe<Scalars['String']['input']>;
};

export type SupportRequestContextSetNotificationInput = {
  /** unique key/id of the request ticket */
  requestKey: Scalars['String']['input'];
  status: Scalars['Boolean']['input'];
};

/** Enum that specify the data type of the field. */
export enum SupportRequestFieldDataType {
  Boolean = 'BOOLEAN',
  Date = 'DATE',
  Number = 'NUMBER',
  String = 'STRING'
}

export type SupportRequestMigrationTaskInput = {
  /** comment to be added on task. This can be null when completed is false i.e marking a task incomplete from complete */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** task status */
  completedByPartner: Scalars['Boolean']['input'];
  /** unique key/id of the request ticket */
  requestKey: Scalars['String']['input'];
  /** task name to be updated */
  taskName: Scalars['String']['input'];
};

/** Query parameter for how this user has access to the request, e.g. they were the reporter or added as a participant. */
export enum SupportRequestNamedContactOperation {
  Add = 'ADD',
  Remove = 'REMOVE'
}

export type SupportRequestOrganizationsInput = {
  /** List of request participants. */
  orgIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** unique key/id of the request ticket */
  requestKey: Scalars['String']['input'];
};

export type SupportRequestParticipantsInput = {
  aaids?: InputMaybe<Array<Scalars['String']['input']>>;
  /** list of request participants emails */
  emails?: InputMaybe<Array<Scalars['String']['input']>>;
  /** list of request participants username */
  gsacUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** unique key/id of the request ticket */
  requestKey: Scalars['String']['input'];
};

/** Query parameter for how this user has access to the request, e.g. they were the reporter or added as a participant. */
export enum SupportRequestQueryOwnership {
  Participant = 'PARTICIPANT',
  Reporter = 'REPORTER'
}

/** The general category for the status of the ticket. */
export enum SupportRequestQueryStatusCategory {
  Done = 'DONE',
  Open = 'OPEN'
}

/** The general category for the status of the ticket. */
export enum SupportRequestStatusCategory {
  Done = 'DONE',
  InProgress = 'IN_PROGRESS',
  Open = 'OPEN'
}

export type SupportRequestTicketFields = {
  /** Specifies the datatype of field */
  dataType: SupportRequestFieldDataType;
  /** custom field id */
  fieldId: Scalars['Long']['input'];
  /** value of the field */
  fieldValue: Scalars['String']['input'];
};

export type SupportRequestTransitionInput = {
  /** The comment message in wiki markup format (Jira format). */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** unique key/id of the request ticket */
  requestKey: Scalars['String']['input'];
  /** transition Id of from workflow */
  transitionId: Scalars['ID']['input'];
  /** transition name from workflow */
  transitionName?: InputMaybe<Scalars['String']['input']>;
};

export type SupportRequestUpdateFieldInput = {
  /** Unique Id of the field, for example description, custom_field_1234 */
  id: Scalars['String']['input'];
  /** The public facing value of the field. */
  value: Scalars['String']['input'];
};

export type SupportRequestUpdateInput = {
  /** Experience fields might vary for personas. */
  experienceFields?: InputMaybe<Array<SupportRequestUpdateFieldInput>>;
  /** The unique identifier for this request. It will make it unique across multiple systems, for example 'GSAC-CA-1000' for GSAC requests. */
  requestKey: Scalars['ID']['input'];
};

/**  The supported usertype of user in system */
export enum SupportRequestUserType {
  Customer = 'CUSTOMER',
  Partner = 'PARTNER'
}

/** How to group cards on the board into swimlanes */
export enum SwimlaneStrategy {
  Assignee = 'ASSIGNEE',
  Issuechildren = 'ISSUECHILDREN',
  Issueparent = 'ISSUEPARENT',
  None = 'NONE',
  Townsquareproject = 'TOWNSQUAREPROJECT'
}

export type SystemSpaceHomepageInput = {
  systemSpaceHomepageTemplate: SystemSpaceHomepageTemplate;
};

export enum SystemSpaceHomepageTemplate {
  Eap = 'EAP',
  Minimal = 'MINIMAL',
  Visual = 'VISUAL'
}

export enum TargetTransition {
  Done = 'DONE',
  Undone = 'UNDONE'
}

export enum TaskStatus {
  Checked = 'CHECKED',
  Unchecked = 'UNCHECKED'
}

export enum TeamCalendarDayOfWeek {
  Friday = 'FRIDAY',
  Monday = 'MONDAY',
  Saturday = 'SATURDAY',
  Sunday = 'SUNDAY',
  Thursday = 'THURSDAY',
  Tuesday = 'TUESDAY',
  Wednesday = 'WEDNESDAY'
}

/** Input payload for creating a custom field. */
export type TeamCreateCustomFieldPayload = {
  /** The cardinality of the custom field. */
  cardinality: TeamCustomFieldCardinality;
  /** Optional description of the custom field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The display name of the custom field. */
  name: Scalars['String']['input'];
  /** List of options (required for SELECTOR type). */
  options?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The type of the custom field. */
  type: TeamCustomFieldType;
};

/** Input payload for creating a custom field value (option). */
export type TeamCreateCustomFieldValuePayload = {
  /** The ARI of the custom field to add the value to. */
  customFieldAri: Scalars['ID']['input'];
  /** The display value for this option. */
  value: Scalars['String']['input'];
};

export type TeamCreateTeamInput = {
  /**
   * Description of the new team
   * Required but can be blank, max 360 characters
   */
  description: Scalars['String']['input'];
  /**
   * Display name of the new team
   * Must not be blank, max 250 characters
   */
  displayName: Scalars['String']['input'];
  /** Initial members of the team, max 50 */
  members?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** How members are able to be added to the team */
  membershipSettings: TeamMembershipSettings;
  /** Directory ID to create the team in */
  scopeId: Scalars['ID']['input'];
  /** The ID of the new team's type */
  typeId?: InputMaybe<Scalars['ID']['input']>;
};

/** The cardinality of a custom field (single or multiple values). */
export enum TeamCustomFieldCardinality {
  /** Multiple values allowed. */
  Multi = 'MULTI',
  /** Single value only. */
  Single = 'SINGLE'
}

/** The type of a custom field. */
export enum TeamCustomFieldType {
  /** A numeric field. */
  Number = 'NUMBER',
  /** A selector field with predefined options. */
  Selector = 'SELECTOR',
  /** A free-text string field. */
  String = 'STRING',
  /** A team reference field. */
  Team = 'TEAM',
  /** A user reference field. */
  User = 'USER'
}

export type TeamDeleteTeamInput = {
  /** Scope ID (userbase ARI) for the team */
  scopeId: Scalars['ID']['input'];
  /** ID of the team to delete */
  teamId: Scalars['ID']['input'];
};

/** Enum representing the errors that can be there in a ancestor list */
export enum TeamHierarchyErrorCode {
  AncestorHierarchyExceedsMaxDepth = 'ANCESTOR_HIERARCHY_EXCEEDS_MAX_DEPTH',
  AncestorInCycle = 'ANCESTOR_IN_CYCLE',
  InvalidAncestorInHierarchy = 'INVALID_ANCESTOR_IN_HIERARCHY',
  TeamInCycle = 'TEAM_IN_CYCLE'
}

/** Member filter used as input on team search filter */
export type TeamMembershipFilter = {
  /** List of members AccountIDs */
  memberIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** The roles that a member can have within a team */
export enum TeamMembershipRole {
  /** A team member with administrative permissions */
  Admin = 'ADMIN',
  /** A regular team member */
  Regular = 'REGULAR'
}

/** The settings which a team can have describing how members are added to the team */
export enum TeamMembershipSettings {
  /** Membership is externally defined (not yet supported) */
  External = 'EXTERNAL',
  /** Members may invite others to join the team */
  MemberInvite = 'MEMBER_INVITE',
  /** Anyone may join */
  Open = 'OPEN',
  /** Only organization admins can manage membership */
  OrgAdminManaged = 'ORG_ADMIN_MANAGED'
}

/** The states that a member can have within a team */
export enum TeamMembershipState {
  /** A member who was previously a full member of the team, but has been removed or has left the team */
  Alumni = 'ALUMNI',
  /** A full member of the team */
  FullMember = 'FULL_MEMBER',
  /** A member who has requested to join the team and is pending approval */
  RequestingToJoin = 'REQUESTING_TO_JOIN'
}

/** The channel through which a notification is sent. */
export enum TeamNotificationChannel {
  /** Email notification. */
  Email = 'EMAIL',
  /** In-app notification. */
  InApp = 'IN_APP'
}

/** The type of team notification. */
export enum TeamNotificationType {
  /** User was added to a team. */
  UserAddedToTeam = 'USER_ADDED_TO_TEAM',
  /** User archived a team. */
  UserArchivedTeam = 'USER_ARCHIVED_TEAM',
  /** User deleted a team. */
  UserDeletedTeam = 'USER_DELETED_TEAM',
  /** User was invited to a team. */
  UserInvitedToTeam = 'USER_INVITED_TO_TEAM',
  /** User requested to join a team. */
  UserRequestedToJoinTeam = 'USER_REQUESTED_TO_JOIN_TEAM',
  /** User restored a team. */
  UserRestoredTeam = 'USER_RESTORED_TEAM',
  /** User unarchived a team. */
  UserUnarchivedTeam = 'USER_UNARCHIVED_TEAM'
}

/** The permission level a user has for a team */
export enum TeamPermission {
  /** Full read permission for the team */
  FullRead = 'FULL_READ',
  /** Full read and write permission for the team */
  FullWrite = 'FULL_WRITE',
  /** No permission to access the team */
  None = 'NONE'
}

export enum TeamRole {
  TeamsAdmin = 'TEAMS_ADMIN',
  TeamsObserver = 'TEAMS_OBSERVER',
  TeamsUser = 'TEAMS_USER'
}

/** Enum representing the search fields for teams. */
export enum TeamSearchField {
  /** Search by team description */
  Description = 'DESCRIPTION',
  /** Search by team name */
  Name = 'NAME'
}

/** Team filter used as input on team search */
export type TeamSearchFilter = {
  /** Team Membership Filter, optional */
  membership?: InputMaybe<TeamMembershipFilter>;
  /** String query to search, optional */
  query?: InputMaybe<Scalars['String']['input']>;
  /** Filter by Team Type filter, optional input */
  teamTypes?: InputMaybe<TeamTypeFilter>;
};

/** Input for setting a notification configuration. */
export type TeamSetNotificationConfigurationInput = {
  /** The ARI of the scope (org or userbase). */
  ari: Scalars['ID']['input'];
  /** Whether to enable or disable notifications. */
  enabled: Scalars['Boolean']['input'];
  /** The channel through which the notification is sent. */
  notificationChannel: TeamNotificationChannel;
  /** The type of notification. */
  notificationType: TeamNotificationType;
};

/** Input for setting a scope-level notification configuration. */
export type TeamSetScopeNotificationConfigurationInput = {
  /** The ARI of the scope (org or userbase). */
  ari: Scalars['ID']['input'];
  /** Whether to enable or disable notifications at the scope level. */
  enabled: Scalars['Boolean']['input'];
  /** The channel through which the notification is sent. */
  notificationChannel: TeamNotificationChannel;
  /** The type of notification. */
  notificationType: TeamNotificationType;
};

/** Team sort used as input on team search */
export type TeamSort = {
  /** Team sort field */
  field: TeamSortField;
  /** Team sort order */
  order?: InputMaybe<TeamSortOrder>;
};

/** Team sort fields */
export enum TeamSortField {
  /** Team name field */
  DisplayName = 'DISPLAY_NAME',
  /** Identifier Team field */
  Id = 'ID',
  /** Team isExternallyManaged field */
  IsVerified = 'IS_VERIFIED',
  /** Team state field */
  State = 'STATE'
}

/** Team Sort Order */
export enum TeamSortOrder {
  /** Ascendant order */
  Asc = 'ASC',
  /** Descendent order */
  Desc = 'DESC'
}

/** The states that a team can have */
export enum TeamState {
  /** The team is currently active */
  Active = 'ACTIVE',
  /** The team has been disbanded and is currently inactive */
  Disbanded = 'DISBANDED',
  /** All members of the team have been deleted */
  Purged = 'PURGED'
}

/** The states that a team can have */
export enum TeamStateV2 {
  /** The team is currently active */
  Active = 'ACTIVE',
  /** The team is currently archived */
  Disbanded = 'DISBANDED',
  /** All members of the team have been deleted */
  Purged = 'PURGED'
}

export type TeamTypeCreationPayload = {
  /**
   * The description of the new team type
   * Optional, max 75 characters
   */
  description?: InputMaybe<Scalars['String']['input']>;
  /**
   * The name of the new team type
   * Must not be blank, max 25 characters
   */
  name: Scalars['String']['input'];
};

export enum TeamTypeDefaultFor {
  /** Default team type for admin managed teams */
  Admin = 'ADMIN',
  /** Default team type for user managed teams */
  UserManaged = 'USER_MANAGED',
  /** Default team type for verified teams */
  Verified = 'VERIFIED'
}

/** Team Type filter used as input on team search filter */
export type TeamTypeFilter = {
  /** List of Team Type IDs */
  teamTypeIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export enum TeamTypeState {
  /** Type is active */
  Active = 'ACTIVE',
  /** Type is active, but soon to be deleted */
  DeleteInProgress = 'DELETE_IN_PROGRESS'
}

export type TeamTypeUpdatePayload = {
  /**
   * The updated description of the team type
   * Optional, max 75 characters
   * If not provided, then description will not be modified
   */
  description?: InputMaybe<Scalars['String']['input']>;
  /**
   * The updated name of the team type
   * Optional, If provided must not be blank, max 25 characters
   * If not provided, then name will not be modified
   */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type TeamUpdateTeamInput = {
  /**
   * Updated description of the team
   * Optional, max 360 characters
   */
  description?: InputMaybe<Scalars['String']['input']>;
  /**
   * Updated display name of the team
   * Optional, if provided must not be blank, max 250 characters
   */
  displayName?: InputMaybe<Scalars['String']['input']>;
  /** Scope ID (userbase ARI) for the team */
  scopeId: Scalars['ID']['input'];
  /** ID of the team to update */
  teamId: Scalars['ID']['input'];
};

export enum TeamworkGraphUserViewedEntityType {
  ConfluenceBlogpost = 'ConfluenceBlogpost',
  ConfluencePage = 'ConfluencePage',
  JiraIssue = 'JiraIssue',
  LoomVideo = 'LoomVideo',
  TownsquareGoal = 'TownsquareGoal',
  TownsquareGoalUpdate = 'TownsquareGoalUpdate',
  TownsquareProject = 'TownsquareProject',
  TownsquareProjectUpdate = 'TownsquareProjectUpdate'
}

export type TemplateEntityFavouriteStatus = {
  isFavourite: Scalars['Boolean']['input'];
  templateEntityId: Scalars['String']['input'];
};

export type TemplatePropertySetInput = {
  /** appearance of the template */
  contentAppearance?: InputMaybe<GraphQlTemplateContentAppearance>;
};

export type TemplatizeInput = {
  contentId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
};

/** The input for a Third Party Repository */
export type ThirdPartyRepositoryInput = {
  /** Avatar details for the third party repository. */
  avatar?: InputMaybe<AvatarInput>;
  /** The ID of the third party repository. */
  id: Scalars['ID']['input'];
  /** The name of the third party repository. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the third party repository. */
  webUrl?: InputMaybe<Scalars['String']['input']>;
};

export type ToggleBoardFeatureInput = {
  enabled: Scalars['Boolean']['input'];
  featureId: Scalars['String']['input'];
};

export type ToolchainAssociateContainerInput = {
  containerId: Scalars['ID']['input'];
  jiraProjectId: Scalars['ID']['input'];
  workspaceId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * #########################
 *  Mutation Inputs
 * #########################
 */
export type ToolchainAssociateContainersInput = {
  associations: Array<ToolchainAssociateContainerInput>;
  cloudId: Scalars['ID']['input'];
  providerId: Scalars['ID']['input'];
  providerType?: InputMaybe<ToolchainProviderType>;
};

export enum ToolchainAssociateEntitiesErrorCode {
  /** The entity identified by the given URL was rejected */
  EntityRejected = 'ENTITY_REJECTED',
  /** The given URL is invalid */
  EntityUrlInvalid = 'ENTITY_URL_INVALID',
  /** You do not have permission to fetch the Entity */
  ProviderEntityFetchForbidden = 'PROVIDER_ENTITY_FETCH_FORBIDDEN',
  /** The entity identified by the given URL does not exist */
  ProviderEntityNotFound = 'PROVIDER_ENTITY_NOT_FOUND',
  /** An unexpected provider error occurred */
  ProviderError = 'PROVIDER_ERROR',
  /** The given URL is not supported by the provider */
  ProviderInputInvalid = 'PROVIDER_INPUT_INVALID'
}

export type ToolchainAssociateEntitiesInput = {
  associations: Array<ToolchainAssociateEntityInput>;
  cloudId: Scalars['ID']['input'];
  providerId: Scalars['ID']['input'];
  providerType?: InputMaybe<ToolchainProviderType>;
};

export type ToolchainAssociateEntityInput = {
  fromId: Scalars['ID']['input'];
  toEntityUrl: Scalars['URL']['input'];
};

export enum ToolchainCheckAuthErrorCode {
  /** An unexpected provider error occurred or authentication type is not implemented */
  ProviderError = 'PROVIDER_ERROR'
}

export enum ToolchainContainerConnectionErrorCode {
  ProviderActionForbidden = 'PROVIDER_ACTION_FORBIDDEN'
}

export enum ToolchainCreateContainerErrorCode {
  /** The container already exists */
  ProviderContainerAlreadyExists = 'PROVIDER_CONTAINER_ALREADY_EXISTS',
  /** You do not have permission to create the container */
  ProviderContainerCreateForbidden = 'PROVIDER_CONTAINER_CREATE_FORBIDDEN',
  /** An unexpected provider error occurred */
  ProviderError = 'PROVIDER_ERROR',
  /** The input provided is invalid */
  ProviderInputInvalid = 'PROVIDER_INPUT_INVALID',
  /** The given workspace doesn't exist */
  ProviderWorkspaceNotFound = 'PROVIDER_WORKSPACE_NOT_FOUND'
}

/** Either both `cloudId` and 'providerId', or 'workspaceId' must be specified. */
export type ToolchainCreateContainerInput = {
  cloudId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  providerId?: InputMaybe<Scalars['ID']['input']>;
  providerType?: InputMaybe<ToolchainProviderType>;
  type?: InputMaybe<Scalars['String']['input']>;
  workspaceId?: InputMaybe<Scalars['ID']['input']>;
};

export type ToolchainDisassociateContainerInput = {
  containerId: Scalars['ID']['input'];
  jiraProjectId: Scalars['ID']['input'];
};

export type ToolchainDisassociateContainersInput = {
  cloudId: Scalars['ID']['input'];
  disassociations: Array<ToolchainDisassociateContainerInput>;
  providerId: Scalars['ID']['input'];
  providerType?: InputMaybe<ToolchainProviderType>;
};

export enum ToolchainDisassociateEntitiesErrorCode {
  /** The association is unknown */
  UnknownAssociation = 'UNKNOWN_ASSOCIATION'
}

export type ToolchainDisassociateEntitiesInput = {
  cloudId: Scalars['ID']['input'];
  disassociations: Array<ToolchainDisassociateEntityInput>;
  providerId: Scalars['ID']['input'];
  providerType?: InputMaybe<ToolchainProviderType>;
};

export type ToolchainDisassociateEntityInput = {
  fromId: Scalars['ID']['input'];
  toEntityId: Scalars['ID']['input'];
};

/**
 * Type of a data-depot provider.
 * A provider may belongs to multiple types (e.g an connect-app can send both build and deployment info).
 */
export enum ToolchainProviderType {
  Build = 'BUILD',
  Deployment = 'DEPLOYMENT',
  Design = 'DESIGN',
  DevopsComponents = 'DEVOPS_COMPONENTS',
  DevInfo = 'DEV_INFO',
  Documentation = 'DOCUMENTATION',
  FeatureFlag = 'FEATURE_FLAG',
  Operations = 'OPERATIONS',
  RemoteLinks = 'REMOTE_LINKS',
  Security = 'SECURITY'
}

export enum ToolchainWorkspaceConnectionErrorCode {
  ProviderActionError = 'PROVIDER_ACTION_ERROR',
  ProviderNotSupported = 'PROVIDER_NOT_SUPPORTED'
}

export enum TownsquareAccessControlCapability {
  Access = 'ACCESS',
  Administer = 'ADMINISTER',
  Create = 'CREATE'
}

/** Input to link a project to a goal. */
export type TownsquareAddProjectLinkInput = {
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** ID of the project. */
  projectId: Scalars['ID']['input'];
};

export type TownsquareAddTagToEntityByIdInput = {
  nounId: Scalars['ID']['input'];
  tagIds: Array<Scalars['ID']['input']>;
};

export type TownsquareAddTagsByNameInput = {
  nounId: Scalars['ID']['input'];
  tagNames: Array<Scalars['String']['input']>;
};

export type TownsquareArchiveGoalInput = {
  id: Scalars['String']['input'];
};

/** Result of setting up a sync between a Jira Issue and a Project or a Goal. */
export enum TownsquareCanCreateFusionResult {
  CanCreate = 'CAN_CREATE',
  IntegrationNotInstalled = 'INTEGRATION_NOT_INSTALLED',
  IssueAlreadyLinked = 'ISSUE_ALREADY_LINKED',
  NotInSameOrg = 'NOT_IN_SAME_ORG',
  PermissionDenied = 'PERMISSION_DENIED',
  UnexpectedIssueType = 'UNEXPECTED_ISSUE_TYPE',
  UnknownError = 'UNKNOWN_ERROR'
}

export enum TownsquareCapabilityContainer {
  FocusAreasApp = 'FOCUS_AREAS_APP',
  GoalsApp = 'GOALS_APP',
  JiraAlignApp = 'JIRA_ALIGN_APP',
  ProjectsApp = 'PROJECTS_APP'
}

export type TownsquareCreateGoalHasJiraAlignProjectInput = {
  from: Scalars['String']['input'];
  to: Scalars['String']['input'];
};

export type TownsquareCreateGoalInput = {
  /**  Site ARI in the form of `ari:cloud:townsquare::site/{siteId}` */
  containerId: Scalars['String']['input'];
  goalTypeAri?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  owner?: InputMaybe<Scalars['String']['input']>;
  parentGoalAri?: InputMaybe<Scalars['String']['input']>;
  targetDate?: InputMaybe<TownsquareTargetDateInput>;
};

export type TownsquareCreateGoalTypeInput = {
  containerId: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  state?: InputMaybe<TownsquareGoalTypeState>;
};

export type TownsquareCreateGoalTypeInputV2 = {
  containerId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  namePlural?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<TownsquareGoalTypeState>;
};

export type TownsquareCreateOrEditSuccessMeasureInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<TownsquareGoalTypeState>;
};

export type TownsquareCreateRelationshipsInput = {
  relationships: Array<TownsquareRelationshipInput>;
};

export type TownsquareCreateTagInput = {
  containerId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

/** Outlines the entities that the custom field can be used on. */
export enum TownsquareCustomFieldEntity {
  Goal = 'GOAL',
  Project = 'PROJECT'
}

/** Represents how to sort the custom fields. */
export enum TownsquareCustomFieldSortEnum {
  CreationDateAsc = 'CREATION_DATE_ASC',
  CreationDateDesc = 'CREATION_DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC'
}

/** Denotes the data type of a custom field. */
export enum TownsquareCustomFieldType {
  Number = 'NUMBER',
  Text = 'TEXT',
  TextSelect = 'TEXT_SELECT',
  User = 'USER'
}

export type TownsquareDeleteGoalHasJiraAlignProjectInput = {
  from: Scalars['String']['input'];
  to: Scalars['String']['input'];
};

export type TownsquareDeleteRelationshipsInput = {
  relationships: Array<TownsquareRelationshipInput>;
};

export type TownsquareEditGoalInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  owner?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
  targetDate?: InputMaybe<TownsquareTargetDateInput>;
};

export type TownsquareEditGoalTypeInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  goalTypeAri: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<TownsquareGoalTypeState>;
};

export type TownsquareEditGoalTypeInputV2 = {
  description?: InputMaybe<Scalars['String']['input']>;
  goalTypeId: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<TownsquareGoalTypeState>;
};

export enum TownsquareGoalAccessRole {
  Editor = 'EDITOR',
  Viewer = 'VIEWER'
}

/** Input enum for goal access roles. */
export enum TownsquareGoalAccessRoleInput {
  Editor = 'EDITOR',
  Viewer = 'VIEWER'
}

/** The input to create a metric. */
export type TownsquareGoalCreateMetricInput = {
  /** ID of the external entity providing the metric data. External entities are non-Atlassian providers. */
  externalEntityId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** Name of the metric. */
  name: Scalars['String']['input'];
  /**
   * Provider name of the metric data. If the the data syncs from the Goals app, the source will be "MANUAL". If data syncs from external providers, the source will be the name of the provider.
   * For example: "AWS", "SNOWFLAKE", "DATABRICKS", etc.
   */
  source?: InputMaybe<Scalars['String']['input']>;
  /** The sub-type of the metric. Only applicable for metric type "CURRENCY". */
  subType?: InputMaybe<Scalars['String']['input']>;
  /** The type of the metric. */
  type: TownsquareMetricType;
  /** Past values that the metric has had. */
  value: Scalars['Float']['input'];
};

/** Input to grant access to a goal by assigning roles to users. */
export type TownsquareGoalGrantAccessInput = {
  /** Whether to add users as followers of the goal. */
  addAsFollower?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** Identity user ARIs: ari:cloud:identity::user/{userId} */
  principalIds: Array<Scalars['ID']['input']>;
  /** Role to assign to the users. */
  role: TownsquareGoalAccessRoleInput;
};

/**
 * Icon appearances specify how the goal icon will be displayed based on the current progress of the goal.
 * For example, the icon of a goal that is in on track will be green.
 */
export enum TownsquareGoalIconAppearance {
  AtRisk = 'AT_RISK',
  Default = 'DEFAULT',
  OffTrack = 'OFF_TRACK',
  OnTrack = 'ON_TRACK'
}

/** Icon keys specify which icon is displayed for a goal. */
export enum TownsquareGoalIconKey {
  Goal = 'GOAL',
  KeyResult = 'KEY_RESULT',
  Objective = 'OBJECTIVE'
}

/** Represents the method used to calculate the progress of a goal. */
export enum TownsquareGoalProgressType {
  AttachedMetric = 'ATTACHED_METRIC',
  AverageRollup = 'AVERAGE_ROLLUP',
  AverageSuccessMeasureRollup = 'AVERAGE_SUCCESS_MEASURE_ROLLUP',
  None = 'NONE'
}

/** Input to revoke access to a goal by removing user roles. */
export type TownsquareGoalRevokeAccessInput = {
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** Identity user ARIs: ari:cloud:identity::user/{userId} */
  principalIds: Array<Scalars['ID']['input']>;
};

/** Scoring mode of the goal. */
export enum TownsquareGoalScoringMode {
  Okr = 'OKR',
  Simple = 'SIMPLE'
}

export enum TownsquareGoalSortEnum {
  CreationDateAsc = 'CREATION_DATE_ASC',
  CreationDateDesc = 'CREATION_DATE_DESC',
  HierarchyAsc = 'HIERARCHY_ASC',
  HierarchyDesc = 'HIERARCHY_DESC',
  HierarchyLevelAsc = 'HIERARCHY_LEVEL_ASC',
  HierarchyLevelDesc = 'HIERARCHY_LEVEL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatestUpdateDateAsc = 'LATEST_UPDATE_DATE_ASC',
  LatestUpdateDateDesc = 'LATEST_UPDATE_DATE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  ProjectCountAsc = 'PROJECT_COUNT_ASC',
  ProjectCountDesc = 'PROJECT_COUNT_DESC',
  ScoreAsc = 'SCORE_ASC',
  ScoreDesc = 'SCORE_DESC',
  TargetDateAsc = 'TARGET_DATE_ASC',
  TargetDateDesc = 'TARGET_DATE_DESC',
  WatchingAsc = 'WATCHING_ASC',
  WatchingDesc = 'WATCHING_DESC'
}

/** Represents the possible states for a goal. */
export enum TownsquareGoalStateValue {
  /** The goal is archived and no longer active. */
  Archived = 'archived',
  /** The goal is at risk of not being achieved. */
  AtRisk = 'at_risk',
  /** The goal has been cancelled. */
  Cancelled = 'cancelled',
  /** The goal has been completed. */
  Done = 'done',
  /** The goal is not progressing as planned. */
  OffTrack = 'off_track',
  /** The goal is progressing as expected. */
  OnTrack = 'on_track',
  /** The goal is temporarily paused. */
  Paused = 'paused',
  /** The goal is awaiting action or start. */
  Pending = 'pending'
}

/**
 * Goal Types come in two varieties:
 *  - GOAL, these are regular goals
 *  - SUCCESS_MEASURE, these goals represent how their parent goal will be measured
 *
 * A SUCCESS_MEASURE goal always has to contribute to a parent GOAL.
 */
export enum TownsquareGoalTypeKind {
  Goal = 'GOAL',
  SuccessMeasure = 'SUCCESS_MEASURE'
}

/** Represents the possible states for a goal type. */
export enum TownsquareGoalTypeState {
  Disabled = 'DISABLED',
  Enabled = 'ENABLED'
}

/** The input for linking a team to a goal. */
export type TownsquareGoalsAddGoalTeamLinkInput = {
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** ID of the team. */
  teamId: Scalars['ID']['input'];
};

/** The input to archive a metric. */
export type TownsquareGoalsArchiveMetricInput = {
  /** ID of the metric to archive. */
  metricId: Scalars['ID']['input'];
};

export type TownsquareGoalsCloneInput = {
  addProjects?: InputMaybe<Scalars['Boolean']['input']>;
  addWatchers?: InputMaybe<Scalars['Boolean']['input']>;
  goalId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

/** The input to create then add a metric target to a goal. */
export type TownsquareGoalsCreateAddMetricTargetInput = {
  /** Information to create the metric. */
  createMetric?: InputMaybe<TownsquareGoalCreateMetricInput>;
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** ID of the metric. */
  metricId?: InputMaybe<Scalars['ID']['input']>;
  /** Starting value of the metric target. */
  startValue: Scalars['Float']['input'];
  /** Target value of the metric target. */
  targetValue: Scalars['Float']['input'];
};

/** Input to create a comment for a goal or a goal update. */
export type TownsquareGoalsCreateCommentInput = {
  /** Comment text in ADF format. */
  commentText: Scalars['String']['input'];
  /** ID of the goal or goal update that the comment is being created for. */
  entityId: Scalars['ID']['input'];
};

/** Input to create a decision for a goal */
export type TownsquareGoalsCreateDecisionInput = {
  /** Decision description text. */
  description: Scalars['String']['input'];
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** Decision summary text. */
  summary: Scalars['String']['input'];
};

export type TownsquareGoalsCreateGoalTypePairInput = {
  goalType: TownsquareCreateGoalTypeInputV2;
  successMeasureType?: InputMaybe<TownsquareCreateOrEditSuccessMeasureInput>;
};

/** Input type needed to create a goal. */
export type TownsquareGoalsCreateInput = {
  /** ID of the site to create the goal in. */
  containerId: Scalars['ID']['input'];
  /** ID of the goal type that the goal is. */
  goalTypeId: Scalars['ID']['input'];
  /** Name of the goal. */
  name: Scalars['String']['input'];
  /** Owner of the goal. If not specified, the owner will default to the current user. */
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  /** ID of the parent goal, if any. */
  parentGoalId?: InputMaybe<Scalars['ID']['input']>;
  /** Projected date that the goal will be achieved. */
  targetDate?: InputMaybe<TownsquareTargetDateInput>;
};

/** Input to create a learning for a goal */
export type TownsquareGoalsCreateLearningInput = {
  /** Learning description text. */
  description: Scalars['String']['input'];
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** Learning summary text. */
  summary: Scalars['String']['input'];
};

/** Input to create a risk for a goal */
export type TownsquareGoalsCreateRiskInput = {
  /** Risk description text. */
  description: Scalars['String']['input'];
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** Risk summary text. */
  summary: Scalars['String']['input'];
};

/** The input for creating an update to a goal. */
export type TownsquareGoalsCreateUpdateInput = {
  /** The ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** A list of highlights associated with the goal update. */
  highlights?: InputMaybe<Array<InputMaybe<TownsquareUpdateHighlightInput>>>;
  /** Whether we should store bundled updates on write. */
  isBundledUpdate?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of metric updates associated with the goal update. */
  metricUpdate?: InputMaybe<Array<InputMaybe<TownsquareMetricUpdateInput>>>;
  /** The score of the update. */
  score?: InputMaybe<Scalars['Int']['input']>;
  /** The status of the update. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** The summary of the update. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** The target date of the update. */
  targetDate?: InputMaybe<TownsquareTargetDateInput>;
  /** A list of notes associated with the goal update. */
  updateNotes?: InputMaybe<Array<InputMaybe<TownsquareUpdateNoteInput>>>;
};

/** Input to delete a comment from a goal update. */
export type TownsquareGoalsDeleteCommentInput = {
  /** ID of the comment. */
  commentId: Scalars['ID']['input'];
};

/** Input to delete a decision for a goal */
export type TownsquareGoalsDeleteDecisionInput = {
  /** ID of the decision. */
  decisionId: Scalars['ID']['input'];
};

/** The input to delete the latest update from a goal. */
export type TownsquareGoalsDeleteLatestUpdateInput = {
  /** ID of the latest goal update to delete. */
  updateId: Scalars['ID']['input'];
};

/** Input to delete a learning for a goal */
export type TownsquareGoalsDeleteLearningInput = {
  /** ID of the learning. */
  learningId: Scalars['ID']['input'];
};

export type TownsquareGoalsDeleteProjectLinkInput = {
  /** ID of the goal to to unlink a project from. */
  goalId: Scalars['ID']['input'];
  /** ID of the project to unlink from the goal. */
  projectId: Scalars['ID']['input'];
};

/** Input to delete a risk for a goal */
export type TownsquareGoalsDeleteRiskInput = {
  /** ID of the risk. */
  riskId: Scalars['ID']['input'];
};

/** Input to update a comment for a goal update */
export type TownsquareGoalsEditCommentInput = {
  /** ID of the comment. */
  commentId: Scalars['ID']['input'];
  /** Updated comment text in ADF format. */
  commentText: Scalars['String']['input'];
};

/** Input to edit a decision for a goal */
export type TownsquareGoalsEditDecisionInput = {
  /** ID of the decision. */
  decisionId: Scalars['ID']['input'];
  /** Decision description text. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Decision summary text. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** Input type needed to edit a dropdown custom field attached to a goal. */
export type TownsquareGoalsEditDropdownCustomFieldInput = {
  /** ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the goal the custom field is attached to. */
  goalId: Scalars['ID']['input'];
  /** ID of the dropdown value to be added to the custom field. */
  valueId: Scalars['ID']['input'];
};

export type TownsquareGoalsEditGoalTypePairInput = {
  goalType: TownsquareEditGoalTypeInputV2;
  successMeasureType?: InputMaybe<TownsquareCreateOrEditSuccessMeasureInput>;
};

/** Input type for editing a goal. */
export type TownsquareGoalsEditInput = {
  /** Whether to archive the goal. */
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  /** Goal description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the goal to be edited. */
  goalId: Scalars['ID']['input'];
  /** Goal name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Owner of the goal. */
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  /** Start date for the goal. */
  startDate?: InputMaybe<Scalars['Date']['input']>;
  /** Target date for the goal. */
  targetDate?: InputMaybe<TownsquareTargetDateInput>;
};

/** Input to edit a learning for a goal */
export type TownsquareGoalsEditLearningInput = {
  /** Learning description text. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the learning. */
  learningId: Scalars['ID']['input'];
  /** Learning summary text. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

export type TownsquareGoalsEditMetricInput = {
  /** ID of the external entity providing the metric data. External entities are non-Atlassian providers. */
  externalEntityId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the metric. */
  metricId: Scalars['ID']['input'];
  /** Name of the metric. */
  name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Provider name of the metric data. If the the data syncs from the Goals app, the source will be "MANUAL". If data syncs from external providers, the source will be the name of the provider.
   * For example: "AWS", "SNOWFLAKE", "DATABRICKS", etc.
   */
  source?: InputMaybe<Scalars['String']['input']>;
  /** The sub-type of the metric. Only applicable for metric type "CURRENCY". */
  subType?: InputMaybe<Scalars['String']['input']>;
  /** Past values that the metric has had. */
  value?: InputMaybe<Scalars['Float']['input']>;
};

/** The input to edit a metric target attached to a goal. */
export type TownsquareGoalsEditMetricTargetInput = {
  /** Current value to set the metric target to. */
  currentValue?: InputMaybe<Scalars['Float']['input']>;
  /** ID of the metric target. */
  metricTargetId: Scalars['ID']['input'];
  /** Starting value to set the metric target to. */
  startValue?: InputMaybe<Scalars['Float']['input']>;
  /** Target value to set the metric target to. */
  targetValue?: InputMaybe<Scalars['Float']['input']>;
};

/** Input type needed to edit a numeric custom field attached to a goal. */
export type TownsquareGoalsEditNumberCustomFieldInput = {
  /** ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the goal the custom field is attached to. */
  goalId: Scalars['ID']['input'];
  /** Value to be added to the custom field. */
  value: Scalars['Float']['input'];
};

/** Input to edit a risk for a goal */
export type TownsquareGoalsEditRiskInput = {
  /** Risk description text. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the risk. */
  riskId: Scalars['ID']['input'];
  /** Risk summary text. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** Input type needed to edit a text custom field attached to a goal. */
export type TownsquareGoalsEditTextCustomFieldInput = {
  /** ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the goal the custom field is attached to. */
  goalId: Scalars['ID']['input'];
  /** Value to be added to the custom field. */
  value: Scalars['String']['input'];
};

/** The input required to edit an update for a goal. */
export type TownsquareGoalsEditUpdateInput = {
  /** ID of the goal update to edit. */
  goalUpdateId: Scalars['ID']['input'];
  /** A list of highlights associated with the goal update. */
  highlights?: InputMaybe<Array<InputMaybe<TownsquareUpdateHighlightInput>>>;
  /** A list of metric updates associated with the goal update. */
  metricUpdate?: InputMaybe<Array<InputMaybe<TownsquareMetricUpdateEditInput>>>;
  /** The new score for the goal update. */
  score?: InputMaybe<Scalars['Int']['input']>;
  /** The new status for the goal update. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** The summary of the goal update. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** The target date for the goal update. */
  targetDate?: InputMaybe<TownsquareTargetDateInput>;
  /** A list of notes associated with the goal update. */
  updateNotes?: InputMaybe<Array<InputMaybe<TownsquareUpdateNoteInput>>>;
};

/** Input type needed to edit a user type custom field attached to a goal. */
export type TownsquareGoalsEditUserCustomFieldInput = {
  /** ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the goal the custom field is attached to. */
  goalId: Scalars['ID']['input'];
  /** ID of the user to be added to the custom field. */
  userId: Scalars['ID']['input'];
};

/** Input type for linking a goal to a Jira Align project. */
export type TownsquareGoalsLinkJiraAlignProjectInput = {
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** ID of the Jira Align project. */
  jiraAlignProjectId: Scalars['ID']['input'];
};

/** Input type to link a Jira Work Item to a Goal. */
export type TownsquareGoalsLinkWorkItemInput = {
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** ID of the Jira Work Item being linked to a goal. */
  workItemId: Scalars['ID']['input'];
};

/** Input type for removing a text value from a custom field on a goal. */
export type TownsquareGoalsRemoveDropdownCustomFieldValueInput = {
  /** The ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the goal that the custom field is attached to. */
  goalId: Scalars['ID']['input'];
  /** ID of the text value to be removed from the custom field. */
  valueId: Scalars['ID']['input'];
};

/** The input for unlinking a team from a goal. */
export type TownsquareGoalsRemoveGoalTeamLinkInput = {
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** ID of the team. */
  teamId: Scalars['ID']['input'];
};

/** The input to remove a metric target attached to a goal. */
export type TownsquareGoalsRemoveMetricTargetInput = {
  /** ID of the goal that the metric target should be removed from. */
  goalId: Scalars['ID']['input'];
  /** ID of the metric target. */
  metricTargetId: Scalars['ID']['input'];
};

/** Input type for removing a numeric value from a custom field on a goal. */
export type TownsquareGoalsRemoveNumericCustomFieldValueInput = {
  /** The ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the goal that the custom field is attached to. */
  goalId: Scalars['ID']['input'];
  /** ID of the numeric value to be removed from the custom field. */
  valueId: Scalars['ID']['input'];
};

/** Input type for removing a text value from a custom field on a goal. */
export type TownsquareGoalsRemoveTextCustomFieldValueInput = {
  /** The ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the goal that the custom field is attached to. */
  goalId: Scalars['ID']['input'];
  /** ID of the text value to be removed from the custom field. */
  valueId: Scalars['ID']['input'];
};

/** Input type for removing a user value from a custom field on a goal. */
export type TownsquareGoalsRemoveUserCustomFieldValueInput = {
  /** The ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the goal that the custom field is attached to. */
  goalId: Scalars['ID']['input'];
  /** ID of the user to be removed from the custom field. */
  userId: Scalars['ID']['input'];
};

/** Input to set rollup progress for a goal. */
export type TownsquareGoalsSetRollupProgressInput = {
  /** Whether rollup progress should be enabled for the goal. */
  enableRollupProgress: Scalars['Boolean']['input'];
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
};

/** The input to set whether a user is watching a team. */
export type TownsquareGoalsSetUserWatchingTeamInput = {
  /** The ID of the site that houses the team and the user */
  containerId: Scalars['ID']['input'];
  /** Used to set whether the user is watching or not watching the team. */
  isWatching: Scalars['Boolean']['input'];
  /** ID of the team. */
  teamId: Scalars['ID']['input'];
};

/** The input to set whether a user is watching a goal. */
export type TownsquareGoalsSetWatchingGoalInput = {
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** USed to set whether the user is watching or not watching the goal. */
  isWatching: Scalars['Boolean']['input'];
  /** Atlassian ID of the user. */
  userId: Scalars['ID']['input'];
};

/** The input to set whether a team is watching a goal. */
export type TownsquareGoalsSetWatchingTeamInput = {
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** Whether the team should be watching the goal or not */
  isWatching: Scalars['Boolean']['input'];
  /** ID of the team. */
  teamId: Scalars['ID']['input'];
};

/** Input to share a goal with users. */
export type TownsquareGoalsShareGoalInput = {
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** List of users to add to the goal. */
  users: Array<InputMaybe<TownsquareShareGoalUserInput>>;
};

/** Input to share a goal update */
export type TownsquareGoalsShareUpdateInput = {
  /** Account ID of the recipient. */
  recipientAccountId?: InputMaybe<Scalars['String']['input']>;
  /** Email address of the recipient. */
  recipientEmailAddress?: InputMaybe<Scalars['String']['input']>;
  /** ID of the goal update to share. */
  updateId: Scalars['ID']['input'];
};

/** Input type needed to unlink a Goal from a Jira Align Project */
export type TownsquareGoalsUnlinkJiraAlignProjectInput = {
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** ID of the Jira Align project. */
  jiraAlignProjectId: Scalars['ID']['input'];
};

/** Input to unlink a work item from a goal. */
export type TownsquareGoalsUnlinkWorkItemInput = {
  /** ID of the goal. */
  goalId: Scalars['ID']['input'];
  /** ID of the work item. */
  workItemId: Scalars['ID']['input'];
};

/** Represents the available sorting options for highlights. */
export enum TownsquareHighlightSortEnum {
  /** Sort highlights by creation date in ascending order. */
  CreationDateAsc = 'CREATION_DATE_ASC',
  /** Sort highlights by creation date in descending order. */
  CreationDateDesc = 'CREATION_DATE_DESC',
  /** Sort highlights by ID in ascending order. */
  IdAsc = 'ID_ASC',
  /** Sort highlights by ID in descending order. */
  IdDesc = 'ID_DESC',
  /** Sort highlights by summary in ascending (A-Z) order. */
  SummaryAsc = 'SUMMARY_ASC',
  /** Sort highlights by summary in descending (Z-A) order. */
  SummaryDesc = 'SUMMARY_DESC'
}

/** Represents the type of highlight, categorizing highlights as learnings, risks, or decisions. */
export enum TownsquareHighlightType {
  Decision = 'DECISION',
  Learning = 'LEARNING',
  Risk = 'RISK'
}

/** Input to update an icon attached to a goal or a project. */
export type TownsquareIconInput = {
  /** Background color of the icon. */
  color?: InputMaybe<Scalars['String']['input']>;
  /** ID of the selected emoji. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Shortname of the emoji. */
  shortName?: InputMaybe<Scalars['String']['input']>;
};

export enum TownsquareLinkType {
  Related = 'RELATED',
  WorkTracking = 'WORK_TRACKING'
}

/** Specifies the order in which to sort a list of metrics. */
export enum TownsquareMetricSortEnum {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC'
}

export enum TownsquareMetricType {
  Currency = 'CURRENCY',
  Numeric = 'NUMERIC',
  Percentage = 'PERCENTAGE'
}

/** Input defining the structure for a metric update when editing an update */
export type TownsquareMetricUpdateEditInput = {
  /** Metric ID */
  metricId: Scalars['ID']['input'];
  /** Updated metric value */
  newValue: Scalars['Float']['input'];
};

/** Input defining the structure for a metric update when creating an update */
export type TownsquareMetricUpdateInput = {
  /** Updated metric value */
  newValue: Scalars['Float']['input'];
  /** Metric target ID */
  targetId: Scalars['ID']['input'];
};

export enum TownsquareMetricValueSortEnum {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TimeAsc = 'TIME_ASC',
  TimeDesc = 'TIME_DESC'
}

export enum TownsquareProjectAccessRole {
  Editor = 'EDITOR',
  Viewer = 'VIEWER'
}

/** Input enum for project access roles. */
export enum TownsquareProjectAccessRoleInput {
  Editor = 'EDITOR',
  Viewer = 'VIEWER'
}

/** The type of a dependency relationship between two Projects. */
export enum TownsquareProjectDependencyRelationship {
  DependedBy = 'DEPENDED_BY',
  DependsOn = 'DEPENDS_ON',
  Related = 'RELATED'
}

/**
 * Input needed to update the description of a Project.
 * The description for a Project appears on the About tab on the Project page.
 */
export type TownsquareProjectDescriptionInput = {
  /** Content for the "How we'll know we're successful" field on the Project description. */
  measurement?: InputMaybe<Scalars['String']['input']>;
  /** Content for the "What we're doing" field on the Project description. */
  what?: InputMaybe<Scalars['String']['input']>;
  /** Content for the "Why we're doing it" field on the Project description. */
  why?: InputMaybe<Scalars['String']['input']>;
};

export enum TownsquareProjectFusionField {
  DueDate = 'DUE_DATE',
  Followers = 'FOLLOWERS',
  Labels = 'LABELS',
  StartDate = 'START_DATE',
  Status = 'STATUS',
  Summary = 'SUMMARY'
}

/** Input to grant access to a project by assigning roles to users. */
export type TownsquareProjectGrantAccessInput = {
  /** Whether to add users as followers of the project. */
  addAsFollower?: InputMaybe<Scalars['Boolean']['input']>;
  /** Identity user ARIs: ari:cloud:identity::user/{userId} */
  principalIds: Array<Scalars['ID']['input']>;
  /** ID of the project. */
  projectId: Scalars['ID']['input'];
  /** Role to assign to the users. */
  role: TownsquareProjectAccessRoleInput;
};

export enum TownsquareProjectPhase {
  Done = 'done',
  InProgress = 'in_progress',
  Paused = 'paused',
  Pending = 'pending'
}

/** Input to revoke access to a project by removing user roles. */
export type TownsquareProjectRevokeAccessInput = {
  /** Identity user ARIs: ari:cloud:identity::user/{userId} */
  principalIds: Array<Scalars['ID']['input']>;
  /** ID of the project. */
  projectId: Scalars['ID']['input'];
};

export enum TownsquareProjectSortEnum {
  CreationDateAsc = 'CREATION_DATE_ASC',
  CreationDateDesc = 'CREATION_DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatestUpdateDateAsc = 'LATEST_UPDATE_DATE_ASC',
  LatestUpdateDateDesc = 'LATEST_UPDATE_DATE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  StartDateAsc = 'START_DATE_ASC',
  StartDateDesc = 'START_DATE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TargetDateAsc = 'TARGET_DATE_ASC',
  TargetDateDesc = 'TARGET_DATE_DESC',
  WatchingAsc = 'WATCHING_ASC',
  WatchingDesc = 'WATCHING_DESC'
}

export enum TownsquareProjectStateValue {
  Archived = 'archived',
  AtRisk = 'at_risk',
  Cancelled = 'cancelled',
  Done = 'done',
  OffTrack = 'off_track',
  OnTrack = 'on_track',
  Paused = 'paused',
  Pending = 'pending'
}

/** Input type fro linking a Goal to a Project. */
export type TownsquareProjectsAddGoalLink = {
  /** ID of the Goal to link to the Project. */
  goalId: Scalars['ID']['input'];
  /** ID of the Project to link the Goal to. */
  projectId: Scalars['ID']['input'];
};

/** Input type for adding a Jira Work Item as a link to a Project. */
export type TownsquareProjectsAddJiraWorkItemLinkInput = {
  /** ID of the Project to link a Jira Work Item to. */
  projectId: Scalars['ID']['input'];
  /**
   * Optionally replaces echildren of the existing linked Jira Work Item.
   * This only applies to replacing the links of any child work items.
   */
  replaceChildWorkItemLinks?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Optionally replaces the existing linked Jira Work Item.
   * This only applies to replacing the link on the current work item we are trying to link.
   */
  replaceCurrentWorkItemLink?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID of the Jira Work item to link to a Project. */
  workItemId: Scalars['ID']['input'];
};

/** Input to add individual contributors to a Project. */
export type TownsquareProjectsAddMembersInput = {
  /** Whether to additionally add all the provided users a watchers of a Project. */
  addAsWatchers?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID of the Project to add new contributors to. */
  projectId: Scalars['ID']['input'];
  /** List of IDs of users to add as contributors to a Project. */
  users: Array<Scalars['ID']['input']>;
};

export type TownsquareProjectsAddTeamContributorsInput = {
  projectId: Scalars['ID']['input'];
  teamId: Scalars['ID']['input'];
  userIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Input type for setting up a sync between a Jira Issue and a Project. */
export type TownsquareProjectsCanCreateProjectFusionInput = {
  /** The ID of the Jira Issue to sync the Project with. */
  issueId: Scalars['ID']['input'];
  /** The ID of the Project to sync the Jira Issue with. */
  projectId: Scalars['ID']['input'];
};

/** Input to clone an existing Project as a new Project. */
export type TownsquareProjectsCloneInput = {
  /** Whether the cloned Project should include the existing links from the original Project. */
  addLinks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the cloned Project should include the existing watchers from the original Project. */
  addWatchers?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the cloned Project. */
  name: Scalars['String']['input'];
  /** ID of the Project being cloned. */
  projectId: Scalars['ID']['input'];
};

/** Input to create a comment for a project or a project update. */
export type TownsquareProjectsCreateCommentInput = {
  /** Comment text in ADF format. */
  commentText: Scalars['String']['input'];
  /** ID of the project or project update that the comment is being created for. */
  entityId: Scalars['ID']['input'];
};

/** Input to create a decision for a project */
export type TownsquareProjectsCreateDecisionInput = {
  /** Description of the decision. */
  description: Scalars['String']['input'];
  /** ID of the project. */
  projectId: Scalars['ID']['input'];
  /** Summary of the decision. */
  summary: Scalars['String']['input'];
};

/** Input to create a new Project. */
export type TownsquareProjectsCreateInput = {
  /** The ID of the site to create the new Project in. */
  containerId: Scalars['String']['input'];
  /** Icon of the new Project. */
  icon?: InputMaybe<TownsquareIconInput>;
  /** Name of the new Project. */
  name: Scalars['String']['input'];
  /**
   * Whether the new Project should be private or not.
   * Private Projects can only be viewed by contributors.
   */
  private?: InputMaybe<Scalars['Boolean']['input']>;
  /** Project date for the new Project to be finished. */
  targetDate?: InputMaybe<TownsquareTargetDateInput>;
};

/** Input to create a learning for a project */
export type TownsquareProjectsCreateLearningInput = {
  /** Description of the learning. */
  description: Scalars['String']['input'];
  /** ID of the project. */
  projectId: Scalars['ID']['input'];
  /** Summary of the learning. */
  summary: Scalars['String']['input'];
};

/** Input for creating a link on a Project. */
export type TownsquareProjectsCreateLinkInput = {
  /** Optional URL for an icon for the link. */
  iconUrl?: InputMaybe<Scalars['String']['input']>;
  /** Optional display name for the link. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** ID of the Project to create a link for. */
  projectId: Scalars['ID']['input'];
  /** Optional name for where the link comes from e.g. Jira, Confluence, etc. */
  provider?: InputMaybe<Scalars['String']['input']>;
  /** Type of the link. Can be either RELATED or WORK_TRACKING. */
  type?: InputMaybe<TownsquareLinkType>;
  /** URL of the link. */
  url: Scalars['String']['input'];
};

/** Input to create a risk for a project */
export type TownsquareProjectsCreateRiskInput = {
  /** Description of the risk. */
  description: Scalars['String']['input'];
  /** ID of the project. */
  projectId: Scalars['ID']['input'];
  /** Summary of the risk. */
  summary: Scalars['String']['input'];
};

/** Input type for creating a Project update. */
export type TownsquareProjectsCreateUpdateInput = {
  /** Any highlights such as Risks, Learnings, Decisions attached to the update. */
  highlights?: InputMaybe<Array<InputMaybe<TownsquareUpdateHighlightInput>>>;
  /** ID of the Project to create and update for. */
  projectId: Scalars['ID']['input'];
  /** The state of the Project, e.g. Off track, in progress, completed, etc. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Short description of the update. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** The new target date for Project, if any. */
  targetDate?: InputMaybe<TownsquareTargetDateInput>;
  /** Any update notes attached to the update for extra information, that may not fit into the `summary` field. */
  updateNotes?: InputMaybe<Array<InputMaybe<TownsquareUpdateNoteInput>>>;
};

/** Input to delete a comment from a project or a project update. */
export type TownsquareProjectsDeleteCommentInput = {
  /** ID of the comment. */
  commentId: Scalars['ID']['input'];
};

/** Input to delete a decision for a project */
export type TownsquareProjectsDeleteDecisionInput = {
  /** ID of the decision. */
  decisionId: Scalars['ID']['input'];
};

/** Input to delete an existing Project update. */
export type TownsquareProjectsDeleteLatestUpdateInput = {
  /** ID of the update to delete. */
  updateId: Scalars['ID']['input'];
};

/** Input to delete a learning for a project */
export type TownsquareProjectsDeleteLearningInput = {
  /** ID of the learning. */
  learningId: Scalars['ID']['input'];
};

/** Deletes a link attached to a Project. */
export type TownsquareProjectsDeleteLinkInput = {
  /** ID of the link to delete. */
  linkId: Scalars['ID']['input'];
};

/** Input to delete a risk for a project */
export type TownsquareProjectsDeleteRiskInput = {
  /** ID of the risk. */
  riskId: Scalars['ID']['input'];
};

/** Input to update a comment for a project or a project update. */
export type TownsquareProjectsEditCommentInput = {
  /** ID of the comment. */
  commentId: Scalars['ID']['input'];
  /** Updated comment text in ADF format. */
  commentText: Scalars['String']['input'];
};

/** Input to edit a decision for a project */
export type TownsquareProjectsEditDecisionInput = {
  /** ID of the decision. */
  decisionId: Scalars['ID']['input'];
  /** Decision description text. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Decision summary text. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** Input type needed to edit a dropdown custom field attached to a project. */
export type TownsquareProjectsEditDropdownCustomFieldInput = {
  /** ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the project the custom field is attached to. */
  projectId: Scalars['ID']['input'];
  /** ID of the dropdown value to be added to the custom field. */
  valueId: Scalars['ID']['input'];
};

/**
 * Input type for editing a Project.
 * Please only provide the fields you would like to update.
 */
export type TownsquareProjectsEditInput = {
  /** Whether the Project should be archived or not. */
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  /** The updated description for a Project. */
  description?: InputMaybe<TownsquareProjectDescriptionInput>;
  /** The icon to update the current Project icon to. */
  icon?: InputMaybe<TownsquareIconInput>;
  /** ID of the Project to edit. */
  id: Scalars['ID']['input'];
  /** The name to update the current Project name to. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the new owner of the Project. */
  owner?: InputMaybe<Scalars['ID']['input']>;
  /** The date to update the Project's start date to. */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Input to edit a learning for a project */
export type TownsquareProjectsEditLearningInput = {
  /** Learning description text. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the learning. */
  learningId: Scalars['ID']['input'];
  /** Learning summary text. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Input for editing a link attached to a Project.
 * Please only provide values for the fields you would like to edit.
 */
export type TownsquareProjectsEditLinkInput = {
  /** The new URL for the icon for the link. */
  iconUrl?: InputMaybe<Scalars['String']['input']>;
  /** ID of the link to edit. */
  linkId: Scalars['ID']['input'];
  /** The new name for the link. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The new provider for the link, e.g. Confluence, Jira, etc. */
  provider?: InputMaybe<Scalars['String']['input']>;
  /** The new URL for the link. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Input type needed to edit a numeric custom field attached to a project. */
export type TownsquareProjectsEditNumberCustomFieldInput = {
  /** ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the project the custom field is attached to. */
  projectId: Scalars['ID']['input'];
  /** Value to be added to the custom field. */
  value: Scalars['Float']['input'];
};

/** Input to edit a risk for a project */
export type TownsquareProjectsEditRiskInput = {
  /** Risk description text. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the risk. */
  riskId: Scalars['ID']['input'];
  /** Risk summary text. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** Input type needed to edit a text custom field attached to a project. */
export type TownsquareProjectsEditTextCustomFieldInput = {
  /** ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the project the custom field is attached to. */
  projectId: Scalars['ID']['input'];
  /** Value to be added to the custom field. */
  value: Scalars['String']['input'];
};

/**
 * Input type for editing an existing Project update.
 * Leave any fields you would not like to update empty.
 */
export type TownsquareProjectsEditUpdateInput = {
  /** Updated highlights (Risks, Learnings, Decisions) for the Project update. */
  highlights?: InputMaybe<Array<InputMaybe<TownsquareUpdateHighlightInput>>>;
  /** Updated status for the Project as set by the Project update. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Updated short summary of the Project update. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Updated target date for the Project as set by the Project update. */
  targetDate?: InputMaybe<TownsquareTargetDateInput>;
  /** ID of the project update to edit. */
  updateId: Scalars['ID']['input'];
  /** Updated notes attached to the Project update. */
  updateNotes?: InputMaybe<Array<InputMaybe<TownsquareUpdateNoteInput>>>;
};

/** Input type needed to edit a user type custom field attached to a project. */
export type TownsquareProjectsEditUserCustomFieldInput = {
  /** ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the project the custom field is attached to. */
  projectId: Scalars['ID']['input'];
  /** ID of the user to be added to the custom field. */
  userId: Scalars['ID']['input'];
};

/** Input type for deleting a dependency relationship between two Projects. */
export type TownsquareProjectsRemoveDependencyInput = {
  /** The ID of the Project that "owns" the relationship. */
  incomingProjectId: Scalars['ID']['input'];
  /** The ID of the Project linked to the owning Project. */
  outgoingProjectId: Scalars['ID']['input'];
};

/** Input type for removing a text value from a custom field on a project. */
export type TownsquareProjectsRemoveDropdownCustomFieldValueInput = {
  /** The ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the project that the custom field is attached to. */
  projectId: Scalars['ID']['input'];
  /** ID of the text value to be removed from the custom field. */
  valueId: Scalars['ID']['input'];
};

/** Input type for unlinking a Goal from a Project. */
export type TownsquareProjectsRemoveGoalLinkInput = {
  /** ID of the Goal to unlink from the Project. */
  goalId: Scalars['ID']['input'];
  /** ID of the Project to unlink the Goal from. */
  projectId: Scalars['ID']['input'];
};

/** Input for unlinking a Jira Work Item from a Project. */
export type TownsquareProjectsRemoveJiraWorkItemLinkInput = {
  /** ID of the Project to unlink the Jira Work Item from. */
  projectId: Scalars['ID']['input'];
  /** ID of the Work Item to unlink. */
  workItemId: Scalars['ID']['input'];
};

/** Input for removing an individual contributor from a Project. */
export type TownsquareProjectsRemoveMemberInput = {
  /** ID of the Project that the user to be removed is a contributor to. */
  projectId: Scalars['ID']['input'];
  /** ID of the user to be removed as a contributor from a Project. */
  userId: Scalars['ID']['input'];
};

/** Input type for removing a numeric value from a custom field on a project. */
export type TownsquareProjectsRemoveNumericCustomFieldValueInput = {
  /** The ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the project that the custom field is attached to. */
  projectId: Scalars['ID']['input'];
  /** ID of the numeric value to be removed from the custom field. */
  valueId: Scalars['ID']['input'];
};

/** Input type for removing a team as a contributor to a Project. */
export type TownsquareProjectsRemoveTeamContributorsInput = {
  /** ID of the Project to remove the team from. */
  projectId: Scalars['ID']['input'];
  /** Th team to remove as a contributor to the Project. */
  teamId: Scalars['ID']['input'];
};

/** Input type for removing a text value from a custom field on a project. */
export type TownsquareProjectsRemoveTextCustomFieldValueInput = {
  /** The ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the project that the custom field is attached to. */
  projectId: Scalars['ID']['input'];
  /** ID of the text value to be removed from the custom field. */
  valueId: Scalars['ID']['input'];
};

/** Input type for removing a user value from a custom field on a project. */
export type TownsquareProjectsRemoveUserCustomFieldValueInput = {
  /** The ID of the custom field definition attached to the custom field. */
  customFieldDefinitionId: Scalars['ID']['input'];
  /** ID of the project that the custom field is attached to. */
  projectId: Scalars['ID']['input'];
  /** ID of the user to be removed from the custom field. */
  userId: Scalars['ID']['input'];
};

/** Input type for adding  a Project as a dependency of another Project. */
export type TownsquareProjectsSetDependencyInput = {
  /** The Project to add another Project as a dependency to. */
  incomingProjectId: Scalars['ID']['input'];
  /** The Project to add as a dependency. */
  outgoingProjectId: Scalars['ID']['input'];
  /** Type of dependency relationship to create between Projects. */
  type: TownsquareProjectDependencyRelationship;
};

/** The input to set whether a user is watching a team. */
export type TownsquareProjectsSetUserWatchingTeamInput = {
  /** The ID of the container (workspace/site). */
  containerId: Scalars['ID']['input'];
  /** Whether the user is watching the team. */
  isWatching: Scalars['Boolean']['input'];
  /** The ID of the team. */
  teamId: Scalars['ID']['input'];
};

/** Input type for adding or removing a watcher to a Project. */
export type TownsquareProjectsSetWatchingProjectInput = {
  /** Whether the user should watch/unwatch the Project. */
  isWatching: Scalars['Boolean']['input'];
  /** ID of the Project to add the watcher to. */
  projectId: Scalars['ID']['input'];
  /** ID of the user to add as a watcher. */
  userId: Scalars['ID']['input'];
};

/** Input type for sharing a Project with users. */
export type TownsquareProjectsShareProjectInput = {
  /** ID of the Project to share. */
  projectId: Scalars['ID']['input'];
  /** A list of users to share the Project to. */
  users?: InputMaybe<Array<InputMaybe<TownsquareShareProjectUserInput>>>;
};

/** Input to share a project update */
export type TownsquareProjectsShareUpdateInput = {
  /** Account ID of the recipient. */
  recipientAccountId?: InputMaybe<Scalars['String']['input']>;
  /** Email address of the recipient. */
  recipientEmailAddress?: InputMaybe<Scalars['String']['input']>;
  /** ID of the projects update to share. */
  updateId: Scalars['ID']['input'];
};

/**
 * These are the currently supported relationships. The relationships are directional in the ARI Graph Store, so the order of "from" and "to" does matter.
 *
 *
 * | From           |   | To         |
 * |----------------|---|------------|
 * | Atlas Project  |  | Jira Issue |
 * | Jira Issue     |  | Atlas Goal |
 */
export type TownsquareRelationshipInput = {
  from: Scalars['String']['input'];
  to: Scalars['String']['input'];
};

export type TownsquareRemoveTagsInput = {
  nounId: Scalars['ID']['input'];
  tagIds: Array<Scalars['ID']['input']>;
};

/** This enum defines the available sorting options for risks. */
export enum TownsquareRiskSortEnum {
  CreationDateAsc = 'CREATION_DATE_ASC',
  CreationDateDesc = 'CREATION_DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC'
}

export type TownsquareSetParentGoalInput = {
  goalAri: Scalars['String']['input'];
  parentGoalAri?: InputMaybe<Scalars['String']['input']>;
};

/** The input to share a goal with a user. */
export type TownsquareShareGoalUserInput = {
  /** Atlassian account ID of the user. */
  accountId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Indicates whether to add the user as a watcher.
   * If set as true, the user becomes a follower of the goal and receives notifications about goal updates.
   */
  addAsWatcher?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The input type for specifying users to share a Project to. */
export type TownsquareShareProjectUserInput = {
  /** ID of the user to share the Project to. */
  accountId?: InputMaybe<Scalars['ID']['input']>;
  /** Option to also make the user a watcher of the shared Project. Defaults to false. */
  addAsWatcher?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum TownsquareTagSortEnum {
  EntityCountDesc = 'ENTITY_COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  UsageAsc = 'USAGE_ASC',
  UsageDesc = 'USAGE_DESC',
  WatcherAsc = 'WATCHER_ASC',
  WatcherDesc = 'WATCHER_DESC'
}

/** The input for specifying a projected target date and confidence level. */
export type TownsquareTargetDateInput = {
  /** The level of confidence in the projected target date. It indicates how precise the target date is. */
  confidence?: InputMaybe<TownsquareTargetDateType>;
  /** The projected target date. */
  date?: InputMaybe<Scalars['Date']['input']>;
};

/** Represents the confidence of a projected target date. */
export enum TownsquareTargetDateType {
  /** The target date is known to the exact day. */
  Day = 'DAY',
  /** The target date is known to the month, but not the specific day. */
  Month = 'MONTH',
  /** The target date is known to the quarter of the year, but not the specific month or day. */
  Quarter = 'QUARTER'
}

export enum TownsquareUnshardedAccessControlCapability {
  Access = 'ACCESS',
  Administer = 'ADMINISTER',
  Create = 'CREATE'
}

export enum TownsquareUnshardedCapabilityContainer {
  GoalsApp = 'GOALS_APP',
  ProjectsApp = 'PROJECTS_APP'
}

/** Input for creating a highlight attached to a Goal/Project. */
export type TownsquareUpdateHighlightInput = {
  /** Description for the update highlight. */
  description: Scalars['String']['input'];
  /** Summary of the update highlight. */
  summary: Scalars['String']['input'];
  /** Type of the highlight, e.g. Decision, Learning, Risk. */
  type: TownsquareHighlightType;
};

/** Input defining the structure for an update note. */
export type TownsquareUpdateNoteInput = {
  /** The archived status of the update note. */
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  /** Description of the update note. */
  description: Scalars['String']['input'];
  /** Summary of the update note. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Optional ARI ID field, to identify the existing update note that's being updated */
  updateNoteId?: InputMaybe<Scalars['ID']['input']>;
  /** UUID of the update note. */
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** Represents the type of update. */
export enum TownsquareUpdateType {
  /** An update that is automatically generated. */
  System = 'SYSTEM',
  /** An update created manually by a user. */
  User = 'USER'
}

export type TownsquareWatchGoalInput = {
  ari: Scalars['String']['input'];
};

export type TransitionFilter = {
  from: Scalars['String']['input'];
  to: Scalars['String']['input'];
};

/** Arguments passed into the acceptProposedEvents mutation. */
export type TrelloAcceptProposedEventsInput = {
  /** The planner calendar ID where the events should be created. */
  plannerCalendarId: Scalars['ID']['input'];
  /** The IDs of the proposed events to create calendar events for and delete from the proposed schedule. */
  proposedEventIds: Array<Scalars['ID']['input']>;
  /** The provider account ID to use for creating the calendar events. */
  providerAccountId: Scalars['ID']['input'];
};

/** Arguments passed into addBoardStar mutation */
export type TrelloAddBoardStarInput = {
  boardId: Scalars['ID']['input'];
  position: Scalars['Float']['input'];
  userId: Scalars['ID']['input'];
};

/** Arguments passed into addLabelsToCard mutation */
export type TrelloAddLabelsToCardInput = {
  cardId: Scalars['ID']['input'];
  labelIds: Array<Scalars['ID']['input']>;
};

/** Arguments passed into addMemberToCard mutation */
export type TrelloAddMemberInput = {
  cardId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};

/** Arguments passed into the add tag to board mutation */
export type TrelloAddWorkspaceTagToBoardInput = {
  boardId: Scalars['ID']['input'];
  tagId: Scalars['ID']['input'];
};

/** Arguments for creating an AI-generated board */
export type TrelloAiBoardUserInput = {
  newYearsResolutionInput?: InputMaybe<TrelloNewYearsResolutionAiBoardInput>;
};

/** Type options for an AI rule */
export enum TrelloAiRuleType {
  /** An AI rule for how to smart schedule cards */
  PlannerScheduling = 'PLANNER_SCHEDULING',
  /** An AI rule for how to select cards to be smart scheduled */
  PlannerSelection = 'PLANNER_SELECTION'
}

/** Arguments passed into the archiveCard mutation */
export type TrelloArchiveCardInput = {
  cardId: Scalars['ID']['input'];
};

/** Arguments passed into assignCardToPlannerCalendarEvent mutation */
export type TrelloAssignCardToPlannerCalendarEventInput = {
  cardId: Scalars['ID']['input'];
  plannerCalendarId: Scalars['ID']['input'];
  position?: InputMaybe<Scalars['Float']['input']>;
  providerAccountId: Scalars['ID']['input'];
  providerEventId: Scalars['ID']['input'];
};

/** Arguments passed into assignCardsToPlannerCalendarEvent mutation */
export type TrelloAssignCardsToPlannerCalendarEventInput = {
  /**
   * The IDs of the cards to assign to the event.
   *
   * An event can have at most 10 cards total (including any cards already assigned).
   */
  cardIds: Array<Scalars['ID']['input']>;
  plannerCalendarId: Scalars['ID']['input'];
  /** Optional starting position to assign cards at. If omitted, cards are appended. */
  position?: InputMaybe<Scalars['Float']['input']>;
  providerAccountId: Scalars['ID']['input'];
  providerEventId: Scalars['ID']['input'];
};

/** Input for selecting an attachment background. */
export type TrelloBoardBackgroundAttachmentInput = {
  /** The objectID of the custom uploaded background */
  objectId: Scalars['String']['input'];
};

/** Input for selecting a color background. */
export type TrelloBoardBackgroundColorInput = {
  /** The objectID of the color background */
  objectId: Scalars['String']['input'];
};

/**
 * Input type for setting board background.
 * Uses @oneOf to ensure only one background type can be specified at a time.
 */
export type TrelloBoardBackgroundInput = {
  /** Set an attachment background */
  attachment?: InputMaybe<TrelloBoardBackgroundAttachmentInput>;
  /** Set a color background */
  color?: InputMaybe<TrelloBoardBackgroundColorInput>;
  /** Set a photo background */
  photo?: InputMaybe<TrelloBoardBackgroundPhotoInput>;
};

/** Input for selecting a photo background. */
export type TrelloBoardBackgroundPhotoInput = {
  /** The objectID of the photo background */
  objectId: Scalars['String']['input'];
};

/** Filter input for TrelloBoard.members */
export type TrelloBoardMembershipFilterInput = {
  /** Returns the board membership that matches this member ID, if any. */
  memberId?: InputMaybe<Scalars['ID']['input']>;
  /** Returned board memberships will have only this type */
  type?: InputMaybe<TrelloBoardMembershipType>;
};

/** Membership types for a TrelloBoard */
export enum TrelloBoardMembershipType {
  /**
   * Privileged membership type. Can edit board settings,
   * and add/remove board members.
   */
  Admin = 'ADMIN',
  /** Standard membership type.  Can view as well as edit board content. */
  Normal = 'NORMAL',
  /**
   * This membership type is either view-only, or view + comment and react
   * depending on board settings.
   */
  Observer = 'OBSERVER'
}

/** Filters to apply when querying board powerUps. */
export type TrelloBoardPowerUpFilterInput = {
  /**
   * Only powerUps of the specified access visibility will be returned.
   * If not included, it'll return all powerUps.
   *
   * Use 'all' to return both private and shared powerUps.
   */
  access?: InputMaybe<Scalars['String']['input']>;
};

/** The permission level (visibility) of an Board */
export enum TrelloBoardPrefsPermissionLevel {
  /** Visible to Enterprise members */
  Enterprise = 'ENTERPRISE',
  /** Visible to Organization members */
  Org = 'ORG',
  /** Only visible to Board members */
  Private = 'PRIVATE',
  /** Visible to everyone */
  Public = 'PUBLIC'
}

/** Selectable action types for a card */
export enum TrelloCardActionType {
  AddAttachment = 'ADD_ATTACHMENT',
  AddChecklist = 'ADD_CHECKLIST',
  AddMember = 'ADD_MEMBER',
  Comment = 'COMMENT',
  CommentFromCopiedCard = 'COMMENT_FROM_COPIED_CARD',
  CopyCard = 'COPY_CARD',
  CopyInboxCard = 'COPY_INBOX_CARD',
  CreateCard = 'CREATE_CARD',
  CreateCardFromCheckItem = 'CREATE_CARD_FROM_CHECK_ITEM',
  CreateCardFromEmail = 'CREATE_CARD_FROM_EMAIL',
  CreateInboxCard = 'CREATE_INBOX_CARD',
  DeleteAttachment = 'DELETE_ATTACHMENT',
  MoveCard = 'MOVE_CARD',
  MoveCardToBoard = 'MOVE_CARD_TO_BOARD',
  MoveInboxCardToBoard = 'MOVE_INBOX_CARD_TO_BOARD',
  RemoveChecklist = 'REMOVE_CHECKLIST',
  RemoveMember = 'REMOVE_MEMBER',
  UpdateCardCheckItemState = 'UPDATE_CARD_CHECK_ITEM_STATE',
  UpdateCardClosed = 'UPDATE_CARD_CLOSED',
  UpdateCardComplete = 'UPDATE_CARD_COMPLETE',
  UpdateCardDue = 'UPDATE_CARD_DUE',
  UpdateCardRecurrenceRule = 'UPDATE_CARD_RECURRENCE_RULE',
  UpdateCustomFieldItem = 'UPDATE_CUSTOM_FIELD_ITEM'
}

/**
 * A TrelloCardBatchScript is a list of commands to apply sequentially to each card matched by the batch job selection.
 * Each command transforms the card in some way.
 * If an earlier command fails, later commands will not be run _for that card_.
 * However, other cards in the selection _will_ still have the script run against them.
 */
export type TrelloCardBatchScript = {
  /** A list of commands to apply to matched cards during execution. */
  commands?: InputMaybe<Array<TrelloCardCommand>>;
};

/**
 * A TrelloCardBatchSelection is a list of clauses treated as logically AND-ed together.
 * Each clause narrows the cards present on the parent board in some way.
 * Note that the default selection with zero clauses will select _every_ card on the board, including closed cards.
 */
export type TrelloCardBatchSelection = {
  /** A list of clauses used to filter cards on a board. */
  clauses?: InputMaybe<Array<TrelloCardClause>>;
};

/**
 * The TrelloCardBatchSpecificationInput defines a specification for a batch job run against a board.
 * A batch job will specify a selection of cards to operate on, and a script to apply to each card.
 * The batch job is run in the background, so the mutation that submits the specification will return immediately.
 * The status of the job can be queried via the TrelloCardBatch type.
 */
export type TrelloCardBatchSpecificationInput = {
  /** The ID of the board the batch is scoped to. */
  boardId: Scalars['ID']['input'];
  /** The operations to apply to the matched cards. */
  script?: InputMaybe<TrelloCardBatchScript>;
  /** The selection used to filter cards on the parent board. */
  selection?: InputMaybe<TrelloCardBatchSelection>;
};

/** Describes the allowed states of a batch job. */
export enum TrelloCardBatchStatus {
  /** The batch has completed execution successfully. */
  Completed = 'COMPLETED',
  /** The batch is currently executing. */
  Executing = 'EXECUTING',
  /** The batch has terminated due to a fatal error. */
  Failed = 'FAILED',
  /** The batch has been submitted, but has not yet begin executing. */
  Pending = 'PENDING'
}

/**
 * Describes the potential clause bodies that may be supplied.
 * Uses @oneOf to work around lack of union support, which requires that all fields be nullable here.
 */
export type TrelloCardClause = {
  closed?: InputMaybe<TrelloCardClosedClause>;
  completed?: InputMaybe<TrelloCardCompleteClause>;
  ids?: InputMaybe<TrelloCardIdsClause>;
  list?: InputMaybe<TrelloCardListClause>;
};

/** Describes an operation to close or open a matched card. */
export type TrelloCardCloseCommand = {
  /** If true, the matched card will be closed; if false, it will be opened. */
  close: Scalars['Boolean']['input'];
};

/**
 * Describes a filter for the closed property on cards.
 * Note that by default _all_ cards are matched in a selection.
 */
export type TrelloCardClosedClause = {
  /** True if only closed cards should be matched; false if only open cards should be matched. */
  closed: Scalars['Boolean']['input'];
};

/**
 * Describes the potential command bodies that may be supplied.
 * Uses @oneOf to work around lack of union support in inputs.
 */
export type TrelloCardCommand = {
  close?: InputMaybe<TrelloCardCloseCommand>;
  complete?: InputMaybe<TrelloCardCompleteCommand>;
};

/** Describes a filter for the complete flag on cards. */
export type TrelloCardCompleteClause = {
  /** True if only completed cards should be matched; false if only incomplete cards should be matched. */
  completed: Scalars['Boolean']['input'];
};

/** Describes an operation to mark a card complete or incomplete. */
export type TrelloCardCompleteCommand = {
  /** If true, the matched card will be marked complete; if false, it will be marked incomplete. */
  complete: Scalars['Boolean']['input'];
};

/** TrelloCardCover brightness */
export enum TrelloCardCoverBrightness {
  Dark = 'DARK',
  Light = 'LIGHT'
}

/** TrelloCardCover color */
export enum TrelloCardCoverColor {
  Black = 'BLACK',
  Blue = 'BLUE',
  Green = 'GREEN',
  Lime = 'LIME',
  Orange = 'ORANGE',
  Pink = 'PINK',
  Purple = 'PURPLE',
  Red = 'RED',
  Sky = 'SKY',
  Yellow = 'YELLOW'
}

/**
 * The cover of a card.
 * Includes a cover type and optional display properties.
 */
export type TrelloCardCoverInput = {
  brightness?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['String']['input']>;
  type: TrelloCardCoverTypeInput;
  yPosition?: InputMaybe<Scalars['Float']['input']>;
};

/** TrelloCardCover size */
export enum TrelloCardCoverSize {
  Full = 'FULL',
  Normal = 'NORMAL'
}

/** The type of card cover. Exactly one of these options must be provided. */
export type TrelloCardCoverTypeInput = {
  attachmentId?: InputMaybe<Scalars['String']['input']>;
  color?: InputMaybe<Scalars['String']['input']>;
  uploadedBackgroundId?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** TrelloCard external sources, from which cards can be generated */
export enum TrelloCardExternalSource {
  BrowserExtension = 'BROWSER_EXTENSION',
  Email = 'EMAIL',
  Loom = 'LOOM',
  Msteams = 'MSTEAMS',
  Siri = 'SIRI',
  Slack = 'SLACK'
}

/**
 * Describes a filter for specific identified cards, based on their ARI.
 * Note that this filter will still be combined with other clauses to narrow the selection.
 */
export type TrelloCardIdsClause = {
  /** The specific card IDs to process. */
  cards?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Describes a filter for the parent list of cards. */
export type TrelloCardListClause = {
  /** The parent list which contains matching cards. */
  listId: Scalars['ID']['input'];
};

/** Special TrelloCard roles */
export enum TrelloCardRole {
  Board = 'BOARD',
  Link = 'LINK',
  Mirror = 'MIRROR',
  Separator = 'SEPARATOR'
}

/** The state of a TrelloCheckItem */
export enum TrelloCheckItemState {
  Complete = 'COMPLETE',
  Incomplete = 'INCOMPLETE'
}

/** Specifies either an existing checklist ARI or a new checklist name to create. */
export type TrelloChecklistTarget = {
  /** The ARI of an existing checklist. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The name of the new checklist to create. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Input type for creating a Trello application (Power-Up / Integration) */
export type TrelloCreateApplicationInput = {
  /** Id of the developer agreement (which indicates the developer has read and agreed to terms and conditions) */
  agreementId: Scalars['ID']['input'];
  /** Name or company of the application developer */
  author: Scalars['String']['input'];
  /** Contact email if Trello needs to reach out to the application developer. */
  email: Scalars['String']['input'];
  /** The iFrame connector url location. Only used for Power-Ups and is called by Trello to load the Power-Up */
  iframeUrl?: InputMaybe<Scalars['URL']['input']>;
  /** The locale of the application name */
  locale?: InputMaybe<Scalars['String']['input']>;
  /** The name of the application */
  name: Scalars['String']['input'];
  /** The scopes to register for the OAuth2 Client */
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Email address or link for users to reach your support team. */
  supportContact: Scalars['String']['input'];
  /** The workspace that the application belongs to */
  workspaceId: Scalars['ID']['input'];
};

/** Arguments passed into createBoardWithAi mutation */
export type TrelloCreateBoardWithAiInput = {
  /** The user input to AI to help create a personalized board */
  userInput: TrelloAiBoardUserInput;
  /** The workspace to create the board in */
  workspaceId: Scalars['ID']['input'];
};

/** Argument passed into createCard mutation */
export type TrelloCreateCardInput = {
  /** The name of an agent to invoke, using the newly-created card as context */
  agentName?: InputMaybe<Scalars['String']['input']>;
  externalSource?: InputMaybe<TrelloCardExternalSource>;
  faviconUrl?: InputMaybe<Scalars['String']['input']>;
  listId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  position?: InputMaybe<Scalars['TrelloCardPosition']['input']>;
  urlSource?: InputMaybe<Scalars['String']['input']>;
  urlSourceText?: InputMaybe<Scalars['String']['input']>;
};

/** Arguments passed into the createMemberAiRule mutation. */
export type TrelloCreateMemberAiRuleInput = {
  /** The position the rule should occupy relative to other rules. */
  position: Scalars['Float']['input'];
  /** The free-form rule content provided by the member. */
  rule: Scalars['String']['input'];
  /** The type of AI rule to create. */
  type?: InputMaybe<TrelloAiRuleType>;
};

/** Arguments passed into createOrUpdatePlannerCalendar mutation */
export type TrelloCreateOrUpdatePlannerCalendarInput = {
  enabled: Scalars['Boolean']['input'];
  primaryCalendar?: InputMaybe<Scalars['Boolean']['input']>;
  /** The account ID from the underlying calendar provider */
  providerAccountId: Scalars['ID']['input'];
  providerCalendarId?: InputMaybe<Scalars['ID']['input']>;
  type: TrelloSupportedPlannerProviders;
  workspaceId: Scalars['ID']['input'];
};

/** Arguments passed into createPlannerCalendarEvent mutation */
export type TrelloCreatePlannerCalendarEventInput = {
  event: TrelloCreatePlannerCalendarEventOptions;
  plannerCalendarId: Scalars['ID']['input'];
  providerAccountId: Scalars['ID']['input'];
};

/**
 * Arguments passed into createPlannerCalendarEvent mutation
 * specific to the event being created
 */
export type TrelloCreatePlannerCalendarEventOptions = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  end: Scalars['DateTime']['input'];
  start: Scalars['DateTime']['input'];
  title: Scalars['String']['input'];
  visibility?: InputMaybe<TrelloPlannerCalendarEventVisibility>;
};

/** Arguments passed into the create tag in workspace mutation */
export type TrelloCreateWorkspaceTagInput = {
  name: Scalars['String']['input'];
  workspaceId: Scalars['ID']['input'];
};

/** Manages how the data is processed */
export enum TrelloDataSourceHandler {
  LinkingPlatform = 'LINKING_PLATFORM'
}

/** The TrelloDeleteAiRuleInput describes which AI rule to delete. */
export type TrelloDeleteAiRuleInput = {
  /** The ARI of the AI rule to delete. */
  aiRuleId: Scalars['ID']['input'];
};

/** Arguments passed into the delete board background mutation */
export type TrelloDeleteBoardBackgroundInput = {
  boardBackgroundId: Scalars['String']['input'];
};

/** Arguments passed into deletePlannerCalendarEvent mutation */
export type TrelloDeletePlannerCalendarEventInput = {
  /** The ID of the event to delete */
  plannerCalendarEventId: Scalars['ID']['input'];
  /** The ID of the planner calendar containing the event */
  plannerCalendarId: Scalars['ID']['input'];
  /** The ID of the provider account to use for the deletion */
  providerAccountId: Scalars['ID']['input'];
};

/** Arguments passed into the delete tag from workspace mutation */
export type TrelloDeleteWorkspaceTagInput = {
  tagId: Scalars['ID']['input'];
  workspaceId: Scalars['ID']['input'];
};

/** Arguments passed into editPlannerCalendarEvent mutation */
export type TrelloEditPlannerCalendarEventInput = {
  event: TrelloEditPlannerCalendarEventOptions;
  plannerCalendarId: Scalars['ID']['input'];
  providerAccountId: Scalars['ID']['input'];
};

/**
 * Arguments passed into editPlannerCalendarEvent mutation
 * specific to the event being created
 */
export type TrelloEditPlannerCalendarEventOptions = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  id: Scalars['ID']['input'];
  start?: InputMaybe<Scalars['DateTime']['input']>;
  targetPlannerCalendar?: InputMaybe<TrelloMovePlannerCalendarEventTargetOptions>;
  title?: InputMaybe<Scalars['String']['input']>;
  visibility?: InputMaybe<TrelloPlannerCalendarEventVisibility>;
};

/** Arguments passed into generateBoardBackgroundWithAi mutation */
export type TrelloGenerateBoardBackgroundWithAiInput = {
  /** The board to generate a background for */
  boardId: Scalars['ID']['input'];
  /** The theme to use for the board background */
  theme?: InputMaybe<Scalars['String']['input']>;
  /** The user input to AI to help create a personalized board */
  userInput: Scalars['String']['input'];
};

/** Arguments passed into the generateCheckItemsForCard mutation. */
export type TrelloGenerateCheckItemsForCardInput = {
  /** The ARI of the card to generate check items for. */
  cardId: Scalars['ID']['input'];
  /** Specifies either an existing checklist ARI or a new checklist name to create. */
  checklistTarget: TrelloChecklistTarget;
};

/** The feature of the labs preference. */
export enum TrelloLabsFeature {
  /** The generate checklist feature. */
  GenerateChecklist = 'GENERATE_CHECKLIST',
  /** The merge cards feature. */
  MergeCards = 'MERGE_CARDS',
  /** The smart schedule feature. */
  SmartSchedule = 'SMART_SCHEDULE'
}

/** The status of the labs preference. */
export enum TrelloLabsFeatureStatus {
  /** The not set status. */
  NotSet = 'NOT_SET',
  /** The opted in status. */
  OptedIn = 'OPTED_IN',
  /** The opted out status. */
  OptedOut = 'OPTED_OUT'
}

/** Specifies which cards to return in a list. */
export type TrelloListCardFilterInput = {
  /**
   * If true, returns only closed cards in the list.
   * If false , it'll return only open cards in the list.
   * If ommitted, it'll return all cards in the list.
   */
  closed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Sort options for list cards */
export enum TrelloListCardSortBy {
  CardName = 'CARD_NAME',
  DueDate = 'DUE_DATE',
  NewestFirst = 'NEWEST_FIRST',
  OldestFirst = 'OLDEST_FIRST',
  Votes = 'VOTES'
}

/** Filters to apply when querying lists. */
export type TrelloListFilterInput = {
  /** Only lists that have this closed property will be included */
  closed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** If a list has a datasource. */
export enum TrelloListType {
  Datasource = 'DATASOURCE'
}

/** Arguments passed into the mark card complete mutation */
export type TrelloMarkCardCompleteInput = {
  cardId: Scalars['ID']['input'];
};

/** Input for marking inbox notifications as read/unread */
export type TrelloMarkInboxNotificationsReadInput = {
  /** Comma-separated notification IDs to read/unread. If not provided, all inbox notifications are processed. */
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Whether to mark as read (true) or unread (false). Default is true. */
  read?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Filter to apply to a member's workspaces. */
export type TrelloMemberWorkspaceFilter = {
  /** The workspace membership type to filter by. */
  membershipType?: InputMaybe<TrelloWorkspaceMembershipType>;
  /** The workspace's tier to filter by. */
  tier?: InputMaybe<TrelloWorkspaceTier>;
};

/** Arguments required to merge cards */
export type TrelloMergeCardsInput = {
  cardIds: Array<Scalars['ID']['input']>;
  targetBoardId: Scalars['ID']['input'];
  targetListId: Scalars['ID']['input'];
};

/** Arguments passed into movePlannerCalendarEvent mutation */
export type TrelloMovePlannerCalendarEventInput = {
  sourceEvent: TrelloMovePlannerCalendarEventSourceOptions;
  targetPlannerCalendar: TrelloMovePlannerCalendarEventTargetOptions;
};

/**
 * Arguments passed into movePlannerCalendarEvent mutation
 * specific to the event being moved
 */
export type TrelloMovePlannerCalendarEventSourceOptions = {
  plannerCalendarEventId: Scalars['ID']['input'];
  plannerCalendarId: Scalars['ID']['input'];
  providerAccountId: Scalars['ID']['input'];
};

/**
 * Arguments passed into movePlannerCalendarEvent mutation
 * specific to the target planner calendar to move the event to
 */
export type TrelloMovePlannerCalendarEventTargetOptions = {
  plannerCalendarId: Scalars['ID']['input'];
  providerAccountId: Scalars['ID']['input'];
};

/** Arguments for creating an AI-generated New Year's Resolution board */
export type TrelloNewYearsResolutionAiBoardInput = {
  /** The New Year's Resolution you want to create a board for */
  resolution: Scalars['String']['input'];
};

/** Filter for notification queries */
export type TrelloNotificationFilter = {
  /**
   * Filter by notification read status.
   * Supported values: 'UNREAD', 'READ', 'ALL'
   * Default: 'UNREAD'
   */
  status?: InputMaybe<Scalars['String']['input']>;
  /**
   * Filter by notification type(s).
   * Pass an array of types to show multiple types.
   * Current supported type: QUICK_CAPTURE
   * Note: Additional types may be added in the future.
   * Unknown types will be ignored gracefully.
   * Example: ["QUICK_CAPTURE"]
   */
  types?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** ADS color options for planner calendars */
export enum TrelloPlannerCalendarColor {
  BlueSubtle = 'BLUE_SUBTLE',
  BlueSubtler = 'BLUE_SUBTLER',
  BlueSubtlest = 'BLUE_SUBTLEST',
  GraySubtle = 'GRAY_SUBTLE',
  GraySubtler = 'GRAY_SUBTLER',
  GraySubtlest = 'GRAY_SUBTLEST',
  GreenSubtle = 'GREEN_SUBTLE',
  GreenSubtler = 'GREEN_SUBTLER',
  GreenSubtlest = 'GREEN_SUBTLEST',
  LimeSubtler = 'LIME_SUBTLER',
  LimeSubtlest = 'LIME_SUBTLEST',
  MagentaSubtle = 'MAGENTA_SUBTLE',
  MagentaSubtler = 'MAGENTA_SUBTLER',
  MagentaSubtlest = 'MAGENTA_SUBTLEST',
  OrangeSubtle = 'ORANGE_SUBTLE',
  OrangeSubtler = 'ORANGE_SUBTLER',
  OrangeSubtlest = 'ORANGE_SUBTLEST',
  PurpleSubtle = 'PURPLE_SUBTLE',
  PurpleSubtler = 'PURPLE_SUBTLER',
  PurpleSubtlest = 'PURPLE_SUBTLEST',
  RedSubtle = 'RED_SUBTLE',
  RedSubtler = 'RED_SUBTLER',
  RedSubtlest = 'RED_SUBTLEST',
  TealSubtle = 'TEAL_SUBTLE',
  TealSubtler = 'TEAL_SUBTLER',
  TealSubtlest = 'TEAL_SUBTLEST',
  YellowBolder = 'YELLOW_BOLDER',
  YellowSubtle = 'YELLOW_SUBTLE',
  YellowSubtler = 'YELLOW_SUBTLER',
  YellowSubtlest = 'YELLOW_SUBTLEST'
}

/** The input filters for fetching enabled calendars */
export type TrelloPlannerCalendarEnabledCalendarsFilter = {
  updateCursor?: InputMaybe<Scalars['String']['input']>;
};

/** Status of the event (confirmed/tentative/declined) */
export enum TrelloPlannerCalendarEventStatus {
  Accepted = 'ACCEPTED',
  Declined = 'DECLINED',
  NeedsAction = 'NEEDS_ACTION',
  Tentative = 'TENTATIVE'
}

/** Event types (default/focusTime/outOfOffice) */
export enum TrelloPlannerCalendarEventType {
  Default = 'DEFAULT',
  OutOfOffice = 'OUT_OF_OFFICE',
  PlannerEvent = 'PLANNER_EVENT'
}

/** Event view type for planner calendar events */
export enum TrelloPlannerCalendarEventViewType {
  Default = 'DEFAULT',
  SingleScheduledTask = 'SINGLE_SCHEDULED_TASK'
}

/** Visibility of the event (public/private) */
export enum TrelloPlannerCalendarEventVisibility {
  Default = 'DEFAULT',
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

/** The input filters for fetching events */
export type TrelloPlannerCalendarEventsFilter = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  updateCursor?: InputMaybe<Scalars['String']['input']>;
};

/** The input filters for listening to planner updates */
export type TrelloPlannerCalendarEventsUpdatedFilter = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
};

/** The input filters for fetching provider calendars */
export type TrelloPlannerCalendarProviderCalendarsFilter = {
  updateCursor?: InputMaybe<Scalars['String']['input']>;
};

/** The input filters for fetching boards with cards that have due dates in a range. */
export type TrelloPlannerCardsWithDueDatesFilter = {
  dueEnd?: InputMaybe<Scalars['DateTime']['input']>;
  dueStart?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Time filter for event queries. */
export enum TrelloPlannerEventTimeFilter {
  /** Past and future events (only supported for single card queries). */
  All = 'ALL',
  /** Only upcoming events (default for badges and boards). */
  Future = 'FUTURE'
}

/** TrelloPowerUpData visibility */
export enum TrelloPowerUpDataAccess {
  Private = 'PRIVATE',
  Shared = 'SHARED'
}

/** Filters to apply when querying powerUpData. */
export type TrelloPowerUpDataFilterInput = {
  /**
   * Only powerUpData of the specified access visibility will be returned.
   * If not included, it'll return all powerUpData.
   *
   * Use 'all' to return both private and shared powerUpData.
   *
   * See TrelloPowerUpDataAccess for enumeration of valid values for access.
   */
  access?: InputMaybe<Scalars['String']['input']>;
  /**
   * Filter powerUpData on specified powerUps.
   *
   * - powerUpData will be excluded if they are from a powerUp not in the provided list.
   * - A missing list means powerUpData for all powerUps will be returned.
   */
  powerUps?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** TrelloPowerUpData scope */
export enum TrelloPowerUpDataScope {
  Board = 'BOARD',
  Card = 'CARD',
  Member = 'MEMBER',
  Organization = 'ORGANIZATION'
}

/** Input for smart scheduling cards to a member's planner. */
export type TrelloProposePlannerEventsInput = {
  /** The IDs of the cards to schedule. If not provided, we will select the cards to schedule from the user's inbox. */
  cardIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The timezone offset in hours from UTC. */
  timezoneOffsetHours: Scalars['Float']['input'];
};

/** Arguments passed into the rejectProposedEvents mutation. */
export type TrelloRejectProposedEventsInput = {
  /** The IDs of the proposed events to delete from the member's proposed schedule. */
  proposedEventIds: Array<Scalars['ID']['input']>;
};

/** Arguments passed into removeBoardStar mutation */
export type TrelloRemoveBoardStarInput = {
  boardStarId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};

/** Arguments passed into removeCardFromPlannerCalendarEvent mutation */
export type TrelloRemoveCardFromPlannerCalendarEventInput = {
  plannerCalendarEventCardId: Scalars['ID']['input'];
  plannerCalendarId: Scalars['ID']['input'];
  providerAccountId: Scalars['ID']['input'];
};

/** Arguments passed into removeLabelsFromCard mutation */
export type TrelloRemoveLabelsFromCardInput = {
  cardId: Scalars['ID']['input'];
  labelIds: Array<Scalars['ID']['input']>;
};

/** Arguments passed into removeMemberFromWorkspace mutation */
export type TrelloRemoveMemberFromWorkspaceInput = {
  userId: Scalars['ID']['input'];
  workspaceId: Scalars['ID']['input'];
};

/** Arguments passed into removeMemberFromCard mutation */
export type TrelloRemoveMemberInput = {
  cardId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};

/** Arguments passed into the remove tag from board mutation */
export type TrelloRemoveWorkspaceTagFromBoardInput = {
  boardId: Scalars['ID']['input'];
  tagId: Scalars['ID']['input'];
};

/** Arguments passed into the resetCardCover mutation. */
export type TrelloResetCardCoverInput = {
  /** The ID of the card to reset cover for. */
  cardId: Scalars['ID']['input'];
};

/** Arguments passed into retryAiOnBoard mutation */
export type TrelloRetryAiOnBoardInput = {
  /**
   * The ID of the board on which to retry AI. It must be a board that
   * was created with AI originally but had the AI fail (due to timeout, invalid input, etc.).
   */
  boardId: Scalars['ID']['input'];
  /** The user input to AI to help create a personalized board */
  userInput: TrelloAiBoardUserInput;
};

/** Input type for rotating the secret for the OAuth2 Client of a Trello application. */
export type TrelloRotateOAuth2ClientSecretInput = {
  /** The id of the Trello application whose OAuth2 Client secret is being rotated */
  id: Scalars['ID']['input'];
};

/** Arguments passed into the send board email key message mutation */
export type TrelloSendBoardEmailKeyInput = {
  boardId: Scalars['ID']['input'];
};

/** Arguments required to smart schedule cards to planner */
export type TrelloSmartScheduleCardsInput = {
  cardIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
  timezoneOffsetHours?: InputMaybe<Scalars['Float']['input']>;
};

/** Arguments required to smart schedule cards with smart selection */
export type TrelloSmartScheduleCardsWithSmartSelectionInput = {
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
  timezoneOffsetHours?: InputMaybe<Scalars['Float']['input']>;
};

/** The status of the proactive smart schedule for a user */
export enum TrelloSmartScheduleStatus {
  /** Proactive smart schedule for this user is active. */
  Active = 'ACTIVE',
  /** Proactive smart schedule for this user is dormant. */
  Dormant = 'DORMANT',
  /** Proactive smart schedule for this user is inactive. */
  Inactive = 'INACTIVE'
}

/** Arguments passed into the sortInboxCards mutation */
export type TrelloSortInboxCardsInput = {
  sortBy: TrelloListCardSortBy;
};

/** Arguments passed into the sortListCards mutation */
export type TrelloSortListCardsInput = {
  listId: Scalars['ID']['input'];
  sortBy: TrelloListCardSortBy;
};

/** The underlying Calendar providers that Planner supports */
export enum TrelloSupportedPlannerProviders {
  Google = 'GOOGLE',
  Outlook = 'OUTLOOK'
}

/** Filters to apply when querying the Template Gallery. */
export type TrelloTemplateGalleryFilterInput = {
  /**
   * Only templates of this category will be included. If not included, it'll
   * return all categories.
   *
   * See TrelloTemplateGalleryCategory.key for valid categories.
   */
  category?: InputMaybe<Scalars['String']['input']>;
  /**
   * Desired language of the Template Gallery.
   *
   * See TrelloTemplateGalleryLanguage.language for valid and enabled languages.
   */
  language: Scalars['String']['input'];
  /**
   * Filter templates based on supported Power-Ups.
   *
   * - Templates will be excluded if they use a Power-Up not in the provided list.
   * - A missing or empty list means include all templates.
   */
  supportedPowerUps?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Arguments passed into toggleLabsFeatureForMember mutation */
export type TrelloToggleLabsFeatureForMemberInput = {
  /** Whether the feature is enabled */
  enabled: Scalars['Boolean']['input'];
  /** The feature to toggle */
  feature: TrelloLabsFeature;
};

/** Arguments passed into the archiveCard mutation */
export type TrelloUnarchiveCardInput = {
  cardId: Scalars['ID']['input'];
};

/** Arguments passed into the updateAiRule mutation. */
export type TrelloUpdateAiRuleInput = {
  /** The ARI of the AI rule to update. */
  aiRuleId: Scalars['ID']['input'];
  /** The new free-form rule content provided by the member. */
  rule: Scalars['String']['input'];
};

/** Arguments passed into the update board background mutation */
export type TrelloUpdateBoardBackgroundInput = {
  background?: InputMaybe<TrelloBoardBackgroundInput>;
  id: Scalars['ID']['input'];
};

/** Arguments passed into the update board isTemplate mutation */
export type TrelloUpdateBoardIsTemplateInput = {
  boardId: Scalars['ID']['input'];
  value: Scalars['Boolean']['input'];
};

/** Arguments passed into the update board name mutation */
export type TrelloUpdateBoardNameInput = {
  boardId: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Arguments passed into updateBoardStarPosition mutation */
export type TrelloUpdateBoardStarPositionInput = {
  boardStarId: Scalars['ID']['input'];
  position: Scalars['Float']['input'];
  userId: Scalars['ID']['input'];
};

/** Arguments passed into the update board viewer AI Browser Extension mutation */
export type TrelloUpdateBoardViewerAiBrowserExtensionInput = {
  boardId: Scalars['ID']['input'];
  value: Scalars['Boolean']['input'];
};

/** Arguments passed into the update board viewer AI Email mutation */
export type TrelloUpdateBoardViewerAiEmailInput = {
  boardId: Scalars['ID']['input'];
  value: Scalars['Boolean']['input'];
};

/** Arguments passed into the update board viewer AI MSTeams mutation */
export type TrelloUpdateBoardViewerAimsTeamsInput = {
  boardId: Scalars['ID']['input'];
  value: Scalars['Boolean']['input'];
};

/** Arguments passed into the update board viewer AI Slack mutation */
export type TrelloUpdateBoardViewerAiSlackInput = {
  boardId: Scalars['ID']['input'];
  value: Scalars['Boolean']['input'];
};

/** Arguments passed into the update board viewer mirror card mutation */
export type TrelloUpdateBoardViewerShowCompactMirrorCardInput = {
  boardId: Scalars['ID']['input'];
  value: Scalars['Boolean']['input'];
};

/** Arguments passed into the update a board's visibility mutation */
export type TrelloUpdateBoardVisibilityInput = {
  boardId: Scalars['ID']['input'];
  visibility: TrelloBoardPrefsPermissionLevel;
};

/** Arguments passed into the update card cover mutation */
export type TrelloUpdateCardCoverInput = {
  cardId: Scalars['ID']['input'];
  cover: TrelloCardCoverInput;
};

/** Arguments passed into the update card name mutation */
export type TrelloUpdateCardNameInput = {
  cardId: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Arguments passed into updateCardPositionOnPlannerCalendarEvent mutation */
export type TrelloUpdateCardPositionOnPlannerCalendarEventInput = {
  plannerCalendarEventCardId: Scalars['ID']['input'];
  position: Scalars['Float']['input'];
};

/** Arguments passed into the updateCardRole mutation. */
export type TrelloUpdateCardRoleInput = {
  /** The ID of the card to update card role for. */
  cardId: Scalars['ID']['input'];
  /** The new card role to set to. */
  cardRole?: InputMaybe<TrelloCardRole>;
};

/** Arguments passed into the update inbox background mutation */
export type TrelloUpdateInboxBackgroundInput = {
  background?: InputMaybe<TrelloBoardBackgroundInput>;
  memberId: Scalars['ID']['input'];
};

/** Arguments passed into the updateKeyboardShortcutsPref mutation */
export type TrelloUpdateKeyboardShortcutsPrefInput = {
  userId: Scalars['ID']['input'];
  value: Scalars['Boolean']['input'];
};

/** Arguments passed into the updateMemberTimezone mutation */
export type TrelloUpdateMemberTimezoneInput = {
  value: Scalars['String']['input'];
};

/** Input type for updating the OAuth2 Client of a Trello application. */
export type TrelloUpdateOAuth2ClientInput = {
  /** The app contact link */
  appContactLink?: InputMaybe<Scalars['String']['input']>;
  /** The app description */
  appDescription?: InputMaybe<Scalars['String']['input']>;
  /** The app logo URL */
  appLogoUrl?: InputMaybe<Scalars['String']['input']>;
  /** The app vendor name or author */
  appVendorName?: InputMaybe<Scalars['String']['input']>;
  /** The callback URLs to update. The array can be empty, in which case all callback URLs will be removed. */
  callbackUrls?: InputMaybe<Array<Scalars['URL']['input']>>;
  /** The client type */
  clientType?: InputMaybe<Scalars['String']['input']>;
  /** The id of the Trello application whose OAuth2 Client is being updated */
  id: Scalars['ID']['input'];
  /** The new scopes to register for the OAuth2 Client */
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Arguments passed into updatePrimaryPlannerAccount mutation */
export type TrelloUpdatePrimaryPlannerAccountInput = {
  /**
   * The ID of the calendar to set as primary
   * Format should be TrelloPlannerCalendarAri
   */
  calendarId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The ID of the provider account to set as primary
   * Format should be GoogleAccountAri or MicrosoftAccountAri
   */
  providerAccountId: Scalars['ID']['input'];
};

/** Arguments passed into updateProactiveSmartScheduleStatus mutation */
export type TrelloUpdateProactiveSmartScheduleStatusInput = {
  /** The status to set for the smart schedule. */
  status: TrelloSmartScheduleStatus;
  /** The ID of the member to update the smart schedule status for. */
  userId: Scalars['ID']['input'];
};

/** Input for updating a proposed event. */
export type TrelloUpdateProposedEventInput = {
  /** The new end time for the proposed event in ISO 8601 format. */
  endTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** The ID of the proposed event to be updated. */
  proposedEventId: Scalars['ID']['input'];
  /** The new start time for the proposed event in ISO 8601 format. */
  startTime?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Arguments passed to update tag in workspace mutation */
export type TrelloUpdateWorkspaceTagInput = {
  name: Scalars['String']['input'];
  tagId: Scalars['ID']['input'];
  workspaceId: Scalars['ID']['input'];
};

/** Arguments passed into watchCard mutation */
export type TrelloWatchCardInput = {
  cardId: Scalars['ID']['input'];
};

/** Membership types for a TrelloWorkspace */
export enum TrelloWorkspaceMembershipType {
  /**
   * Privileged membership type. Can edit workspace settings,
   * add and remove members
   */
  Admin = 'ADMIN',
  /** Standard membership type */
  Normal = 'NORMAL'
}

/** Product tiers for a TrelloWorkspace */
export enum TrelloWorkspaceTier {
  /** Includes all non-free workspaces (i.e. Standard, Premium, Enterprise) */
  Paid = 'PAID'
}

export type TunnelDefinitionsInput = {
  customUI?: InputMaybe<Array<InputMaybe<CustomUiTunnelDefinitionInput>>>;
  /** The URL to tunnel FaaS calls to */
  faasTunnelUrl?: InputMaybe<Scalars['URL']['input']>;
};

export type UnarchiveSpaceInput = {
  /** The alias of the unarchived space */
  alias: Scalars['String']['input'];
};

export type UnassignIssueParentInput = {
  boardId: Scalars['ID']['input'];
  issueIds: Array<Scalars['ID']['input']>;
};

export enum UnifiedAiLikeTargetType {
  Post = 'POST',
  Response = 'RESPONSE'
}

export enum UnifiedAiPostSortField {
  CreatedAt = 'CREATED_AT',
  LastReplyAt = 'LAST_REPLY_AT',
  LikeCount = 'LIKE_COUNT',
  UpdatedAt = 'UPDATED_AT',
  ViewCount = 'VIEW_COUNT'
}

export type UnifiedAiPostSortOrder = {
  direction: UnifiedSortDirection;
  field: UnifiedAiPostSortField;
};

export enum UnifiedAiPostType {
  Article = 'ARTICLE',
  Question = 'QUESTION'
}

export type UnifiedAtlassianOneUserInput = {
  currentActiveAssociatedId?: InputMaybe<Scalars['String']['input']>;
};

export type UnifiedCacheFieldKey = {
  name?: InputMaybe<Scalars['String']['input']>;
  requiresHashing?: InputMaybe<Scalars['Boolean']['input']>;
  requiresSorting?: InputMaybe<Scalars['Boolean']['input']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type UnifiedConsentObjInput = {
  consentKey: Scalars['String']['input'];
  consentStatus: Scalars['String']['input'];
  displayedText?: InputMaybe<Scalars['String']['input']>;
};

export enum UnifiedLearningCertificationSortField {
  ActiveDate = 'ACTIVE_DATE',
  ExpireDate = 'EXPIRE_DATE',
  Id = 'ID',
  ImageUrl = 'IMAGE_URL',
  Name = 'NAME',
  NameAbbr = 'NAME_ABBR',
  PublicUrl = 'PUBLIC_URL',
  Status = 'STATUS',
  Type = 'TYPE'
}

export enum UnifiedLearningCertificationStatus {
  Active = 'ACTIVE',
  Expired = 'EXPIRED'
}

export enum UnifiedLearningCertificationType {
  Badge = 'BADGE',
  Certification = 'CERTIFICATION',
  Standing = 'STANDING'
}

export type UnifiedProfileInput = {
  aaid?: InputMaybe<Scalars['String']['input']>;
  accountInternalId?: InputMaybe<Scalars['String']['input']>;
  bio?: InputMaybe<Scalars['String']['input']>;
  company?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  internalId?: InputMaybe<Scalars['String']['input']>;
  isPrivate: Scalars['Boolean']['input'];
  linkedinUrl?: InputMaybe<Scalars['String']['input']>;
  location?: InputMaybe<Scalars['String']['input']>;
  products?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['String']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
  websiteUrl?: InputMaybe<Scalars['String']['input']>;
  xUrl?: InputMaybe<Scalars['String']['input']>;
  youtubeUrl?: InputMaybe<Scalars['String']['input']>;
};

export enum UnifiedSortDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type UnlicensedUserWithPermissionsInput = {
  operations: Array<InputMaybe<OperationCheckResultInput>>;
};

/** Handles detaching a dataManager from a Component */
export type UnlinkExternalSourceInput = {
  cloudId: Scalars['ID']['input'];
  /** The ID of the Forge App being uninstalled */
  ecosystemAppId: Scalars['ID']['input'];
  /** The external source name of any ExternalAliases to be removed */
  externalSource: Scalars['String']['input'];
};

export type UpdateAppContributorRoleInput = {
  appId: Scalars['ID']['input'];
  updates: Array<UpdateAppContributorRolePayload>;
};

export type UpdateAppContributorRolePayload = {
  accountId: Scalars['ID']['input'];
  add: Array<InputMaybe<AppContributorRole>>;
  remove: Array<InputMaybe<AppContributorRole>>;
};

export type UpdateAppDetailsInput = {
  appId: Scalars['ID']['input'];
  avatarFileId?: InputMaybe<Scalars['String']['input']>;
  contactLink?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  developerSpaceId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Distribution status determines the sharing status of the app.
   * If you stop sharing your app this may affect exising app users.
   * If not supplied defaults to DEVELOPMENT (not sharing).
   */
  distributionStatus?: InputMaybe<DistributionStatus>;
  hasPDReportingApiImplemented?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  privacyPolicy?: InputMaybe<Scalars['String']['input']>;
  storesPersonalData?: InputMaybe<Scalars['Boolean']['input']>;
  termsOfService?: InputMaybe<Scalars['String']['input']>;
  vendorName?: InputMaybe<Scalars['String']['input']>;
};

/** Input payload for enrolling scopes to an app environment */
export type UpdateAppHostServiceScopesInput = {
  /** A unique Id representing the app */
  appId: Scalars['ID']['input'];
  /** The key of the app's environment to enrol the scopes */
  environmentKey: Scalars['String']['input'];
  /** The scopes this app will be enrolled to after the request succeeds */
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The Id of the service for which the scopes belong to */
  serviceId: Scalars['ID']['input'];
};

export type UpdateAppOwnershipInput = {
  appAri: Scalars['String']['input'];
  newOwner: Scalars['String']['input'];
};

export type UpdateArchiveNotesInput = {
  archiveNote?: InputMaybe<Scalars['String']['input']>;
  areChildrenIncluded?: InputMaybe<Scalars['Boolean']['input']>;
  excludedBranchRootPageIDs?: InputMaybe<Array<InputMaybe<Scalars['Long']['input']>>>;
  isSelected?: InputMaybe<Scalars['Boolean']['input']>;
  pageID: Scalars['Long']['input'];
};

/** Input payload for updating an Atlassian OAuth Client mutation */
export type UpdateAtlassianOAuthClientInput = {
  callbacks?: InputMaybe<Array<Scalars['String']['input']>>;
  clientID: Scalars['ID']['input'];
  refreshToken?: InputMaybe<RefreshTokenInput>;
};

export type UpdateCommentInput = {
  commentBody: CommentBody;
  commentId: Scalars['ID']['input'];
  /** This field is being deprecated, you do not need to provide this value if the update.comment.mutations.optional.version FF is on */
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input for updating an existing component by reference. */
export type UpdateCompassComponentByReferenceInput = {
  /** The extended description details associated to the component. */
  componentDescriptionDetails?: InputMaybe<CompassComponentDescriptionDetailsInput>;
  /** A collection of custom fields for storing data about the component. */
  customFields?: InputMaybe<Array<CompassCustomFieldInput>>;
  /** The description of the component. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** A collection of fields for storing data about the component. */
  fields?: InputMaybe<Array<UpdateCompassFieldInput>>;
  /** The name of the component. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The unique identifier (ID) of the team that owns the component. */
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  /** The reference of the component being updated. */
  reference: ComponentReferenceInput;
  /** A unique identifier for the component. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** The state of the component. */
  state?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input to update a data manager on a component. */
export type UpdateCompassComponentDataManagerMetadataInput = {
  /** The ID of the component to update a data manager on. */
  componentId: Scalars['ID']['input'];
  /** A URL of the external source of the component's data. */
  externalSourceURL?: InputMaybe<Scalars['URL']['input']>;
  /** Details about the last sync event to this component. */
  lastSyncEvent?: InputMaybe<ComponentSyncEventInput>;
};

/** Accepts input for updating an existing component. */
export type UpdateCompassComponentInput = {
  /** The extended description details associated to the component. */
  componentDescriptionDetails?: InputMaybe<CompassComponentDescriptionDetailsInput>;
  /** A collection of custom fields for storing data about the component. */
  customFields?: InputMaybe<Array<CompassCustomFieldInput>>;
  /** The description of the component. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** A collection of fields for storing data about the component. */
  fields?: InputMaybe<Array<UpdateCompassFieldInput>>;
  /** The ID of the component being updated. */
  id: Scalars['ID']['input'];
  /** The name of the component. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The unique identifier (ID) of the team that owns the component. */
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the component. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** The state of the component. */
  state?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input for updating a component link. */
export type UpdateCompassComponentLinkInput = {
  /** The ID for the component to update the link. */
  componentId: Scalars['ID']['input'];
  /** The link to be updated for the component. */
  link: UpdateCompassLinkInput;
};

/** Accepts input for updating an existing component's type. */
export type UpdateCompassComponentTypeInput = {
  id: Scalars['ID']['input'];
  type?: InputMaybe<CompassComponentType>;
  typeId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input to update the metadata for a component type. */
export type UpdateCompassComponentTypeMetadataInput = {
  /** The description of the component type. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The icon key of the component type. */
  iconKey?: InputMaybe<Scalars['String']['input']>;
  /** The ID(ARI) of the component type being updated. */
  id: Scalars['ID']['input'];
  /** The name of the component type. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input to update a field. */
export type UpdateCompassFieldInput = {
  /** The ID of the field definition. */
  definition: Scalars['ID']['input'];
  /** The value of the field. */
  value: CompassFieldValueInput;
};

/** Accepts input to a update a scorecard criterion representing the presence of a description. */
export type UpdateCompassHasDescriptionScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to update a scorecard criterion representing the presence of a field, for example, 'Has Tier'. */
export type UpdateCompassHasFieldScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID for the field definition which is the target of a relationship. */
  fieldDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** ID of the scorecard criteria to update */
  id: Scalars['ID']['input'];
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to update a scorecard criterion representing the presence of a link, for example, 'Has Repository' or 'Has Documentation'. */
export type UpdateCompassHasLinkScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the scorecard criteria to update */
  id: Scalars['ID']['input'];
  /** The type of link, for example, 'Repository' if 'Has Repository'. */
  linkType?: InputMaybe<CompassLinkType>;
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The comparison operation to be performed. */
  textComparator?: InputMaybe<CompassCriteriaTextComparatorOptions>;
  /** The value that the field is compared to. */
  textComparatorValue?: InputMaybe<Scalars['String']['input']>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to update a scorecard criterion checking the value of a specified metric ID. */
export type UpdateCompassHasMetricValueCriteriaInput = {
  /** Automatically create metric sources for the custom metric definition associated with this criterion */
  automaticallyCreateMetricSources?: InputMaybe<Scalars['Boolean']['input']>;
  /** The comparison operation to be performed between the metric and comparator value. */
  comparator?: InputMaybe<CompassCriteriaNumberComparatorOptions>;
  /** The threshold value that the metric is compared to. */
  comparatorValue?: InputMaybe<Scalars['Float']['input']>;
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** A graduated series of comparators to score the criterion against */
  graduatedSeriesComparators?: InputMaybe<Array<CompassCriteriaGraduatedSeriesInput>>;
  /** ID of the scorecard criteria to update */
  id: Scalars['ID']['input'];
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The ID of the component metric to check the value of. */
  metricDefinitionId?: InputMaybe<Scalars['ID']['input']>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts input to a update a scorecard criterion representing the presence of an owner. */
export type UpdateCompassHasOwnerScorecardCriteriaInput = {
  /** The optional, user provided description of the scorecard criterion */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID']['input'];
  /** The optional, maturity group to assign the scorecard criterion to. Applies to Maturity-model based scorecards only */
  maturityGroup?: InputMaybe<CompassScorecardCriteriaMaturityGroupInput>;
  /** The optional, user provided name of the scorecard criterion */
  name?: InputMaybe<Scalars['String']['input']>;
  scoringStrategyRules?: InputMaybe<CompassUpdateScorecardCriteriaScoringStrategyRulesInput>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Accepts details of the link to be updated. */
export type UpdateCompassLinkInput = {
  /** The unique identifier (ID) of the link. */
  id: Scalars['ID']['input'];
  /** The name of the link. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The unique ID of the object the link points to. Generally, this is configured by integrations and does not need to be added to links manually. Eg the Repository ID for a Repository */
  objectId?: InputMaybe<Scalars['ID']['input']>;
  /** The type of the link. */
  type?: InputMaybe<CompassLinkType>;
  /** The URL of the link. */
  url?: InputMaybe<Scalars['URL']['input']>;
};

export type UpdateCompassScorecardCriteriaInput = {
  dynamic?: InputMaybe<CompassUpdateDynamicScorecardCriteriaInput>;
  hasCustomBooleanValue?: InputMaybe<CompassUpdateHasCustomBooleanFieldScorecardCriteriaInput>;
  hasCustomMultiSelectValue?: InputMaybe<CompassUpdateHasCustomMultiSelectFieldScorecardCriteriaInput>;
  hasCustomNumberValue?: InputMaybe<CompassUpdateHasCustomNumberFieldScorecardCriteriaInput>;
  hasCustomSingleSelectValue?: InputMaybe<CompassUpdateHasCustomSingleSelectFieldScorecardCriteriaInput>;
  hasCustomTextValue?: InputMaybe<CompassUpdateHasCustomTextFieldScorecardCriteriaInput>;
  hasDescription?: InputMaybe<UpdateCompassHasDescriptionScorecardCriteriaInput>;
  hasField?: InputMaybe<UpdateCompassHasFieldScorecardCriteriaInput>;
  hasLink?: InputMaybe<UpdateCompassHasLinkScorecardCriteriaInput>;
  hasMetricValue?: InputMaybe<UpdateCompassHasMetricValueCriteriaInput>;
  hasOwner?: InputMaybe<UpdateCompassHasOwnerScorecardCriteriaInput>;
  hasPackageDependency?: InputMaybe<CompassUpdateHasPackageDependencyScorecardCriteriaInput>;
};

export type UpdateCompassScorecardInput = {
  componentCreationTimeFilter?: InputMaybe<CompassComponentCreationTimeFilterInput>;
  componentCustomFieldFilters?: InputMaybe<Array<CompassCustomFieldFilterInput>>;
  componentLabelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  componentLifecycleStages?: InputMaybe<CompassLifecycleFilterInput>;
  componentOwnerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  componentTierValues?: InputMaybe<Array<Scalars['String']['input']>>;
  componentTypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  createCriteria?: InputMaybe<Array<CreateCompassScorecardCriteriaInput>>;
  deleteCriteria?: InputMaybe<Array<DeleteCompassScorecardCriteriaInput>>;
  description?: InputMaybe<Scalars['String']['input']>;
  importance?: InputMaybe<CompassScorecardImportance>;
  isDeactivationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  repositoryValues?: InputMaybe<CompassRepositoryValueInput>;
  scoringStrategyType?: InputMaybe<CompassScorecardScoringStrategyType>;
  state?: InputMaybe<Scalars['String']['input']>;
  statusConfig?: InputMaybe<CompassScorecardStatusConfigInput>;
  updateCriteria?: InputMaybe<Array<UpdateCompassScorecardCriteriaInput>>;
  verified?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * ###################################################################################################################
 *  COMPASS API SPEC
 * ###################################################################################################################
 */
export type UpdateComponentApiInput = {
  componentId: Scalars['String']['input'];
  defaultTag?: InputMaybe<Scalars['String']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  repo?: InputMaybe<CompassComponentApiRepoUpdate>;
  status?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateComponentApiUploadInput = {
  componentId: Scalars['ID']['input'];
  effectiveAt: Scalars['String']['input'];
  shouldDereference?: InputMaybe<Scalars['Boolean']['input']>;
  tags: Array<Scalars['String']['input']>;
  uploadId: Scalars['ID']['input'];
};

export type UpdateContentDataClassificationLevelInput = {
  classificationLevelId: Scalars['ID']['input'];
  contentStatus: ContentDataClassificationMutationContentStatus;
  id: Scalars['Long']['input'];
};

export type UpdateContentPermissionsInput = {
  confluencePrincipalType?: InputMaybe<ConfluencePrincipalType>;
  contentRole: ContentRole;
  principalId: Scalars['ID']['input'];
};

export type UpdateContentTemplateInput = {
  body: ContentTemplateBodyInput;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  labels?: InputMaybe<Array<InputMaybe<ContentTemplateLabelInput>>>;
  name: Scalars['String']['input'];
  space?: InputMaybe<ContentTemplateSpaceInput>;
  templateId: Scalars['ID']['input'];
  templateType: GraphQlContentTemplateType;
};

export type UpdateCoverPictureWidthInput = {
  contentId: Scalars['ID']['input'];
  /** Determines whether mutation updates CURRENT vs. DRAFT page entity. Defaults to CURRENT status. */
  contentStatus?: InputMaybe<ConfluenceMutationContentStatus>;
  coverPictureWidth: GraphQlCoverPictureWidth;
};

/**
 * Updates a custom filter with the given id in the board with the given boardId.
 * The update will update the entire filter (ie. not a partial update)
 */
export type UpdateCustomFilterInput = {
  boardId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  jql: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export type UpdateDefaultSpacePermissionsInput = {
  permissionsToAdd: Array<InputMaybe<SpacePermissionType>>;
  permissionsToRemove: Array<InputMaybe<SpacePermissionType>>;
  subjectKeyInput: UpdatePermissionSubjectKeyInput;
};

export type UpdateDefaultSpacePermissionsInputV2 = {
  subjectPermissionDeltasListV2: Array<SubjectPermissionDeltasV2>;
};

/** The request input for updating relationship properties */
export type UpdateDevOpsContainerRelationshipEntityPropertiesInput = {
  /** The ARI of the relationship entity */
  id: Scalars['ID']['input'];
  properties: Array<DevOpsContainerRelationshipEntityPropertyInput>;
};

/** The request input for updating a relationship between a DevOps Service and Jira Project */
export type UpdateDevOpsServiceAndJiraProjectRelationshipInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  /** The DevOps Graph Service_And_Jira_Project relationship ARI */
  id: Scalars['ID']['input'];
  /**
   * The revision that must be provided when updating a relationship between DevOps Service and Jira Project to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID']['input'];
};

/** The request input for updating a relationship between a DevOps Service and an Opsgenie Team */
export type UpdateDevOpsServiceAndOpsgenieTeamRelationshipInput = {
  /** The new description assigned to the relationship. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The DevOps Graph Service_And_Opsgenie_Team relationship ARI */
  id: Scalars['ID']['input'];
  /**
   * The revision that must be provided when updating a relationship between DevOps Service and Opsgenie Team to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID']['input'];
};

/** The request input for updating a relationship between a DevOps Service and a Repository */
export type UpdateDevOpsServiceAndRepositoryRelationshipInput = {
  /** The description of the relationship */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ARI of the relationship */
  id: Scalars['ID']['input'];
  /**
   * The revision that must be provided when updating a relationship between DevOps Service and a Repository to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID']['input'];
};

/** The request input for updating DevOps Service Entity Properties */
export type UpdateDevOpsServiceEntityPropertiesInput = {
  /** The ARI of the DevOps Service */
  id: Scalars['ID']['input'];
  properties: Array<DevOpsServiceEntityPropertyInput>;
};

/** The request input for updating a DevOps Service */
export type UpdateDevOpsServiceInput = {
  /** The ID of the DevOps Service in Compass */
  compassId?: InputMaybe<Scalars['ID']['input']>;
  /** The revision of the DevOps Service in Compass */
  compassRevision?: InputMaybe<Scalars['Int']['input']>;
  /** The new description assigned to the DevOps Service */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The DevOps Service ARI */
  id: Scalars['ID']['input'];
  /** The new name assigned to the DevOps Service */
  name: Scalars['String']['input'];
  /** The properties of the DevOps Service to be updated */
  properties?: InputMaybe<Array<DevOpsServiceEntityPropertyInput>>;
  /**
   * The revision that must be provided when updating a DevOps Service to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID']['input'];
  /** The id of the Tier assigned to the Service */
  serviceTier: Scalars['ID']['input'];
  /** The id of the Service Type assigned to the Service */
  serviceType?: InputMaybe<Scalars['ID']['input']>;
};

/** The request input for updating a DevOps Service Relationship */
export type UpdateDevOpsServiceRelationshipInput = {
  /** The description of the DevOps Service Relationship */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The DevOps Service Relationship ARI */
  id: Scalars['ID']['input'];
  /**
   * The revision that must be provided when updating a DevOps Service Relationship to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID']['input'];
};

export type UpdateDeveloperLogAccessInput = {
  /** AppId as ARI */
  appId: Scalars['ID']['input'];
  /** An array of context ARIs */
  contextIds: Array<Scalars['ID']['input']>;
  /** App environment */
  environmentType: AppEnvironmentType;
  /** Boolean representing whether access should be granted or not */
  shouldHaveAccess: Scalars['Boolean']['input'];
};

export type UpdateEmbedInput = {
  embedIconUrl?: InputMaybe<Scalars['String']['input']>;
  embedUrl?: InputMaybe<Scalars['String']['input']>;
  extensionKey?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  product?: InputMaybe<Scalars['String']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateExCoSpacePermissionsInput = {
  accountId: Scalars['String']['input'];
  spaceId: Scalars['Long']['input'];
};

export type UpdateExternalCollaboratorDefaultSpaceInput = {
  enabled: Scalars['Boolean']['input'];
  spaceId: Scalars['Long']['input'];
};

/** Update: Mutation (PUT) */
export type UpdateJiraPlaybookInput = {
  filters?: InputMaybe<Array<JiraPlaybookIssueFilterInput>>;
  id: Scalars['ID']['input'];
  jql?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** scopeId is projectId */
  scopeId?: InputMaybe<Scalars['String']['input']>;
  scopeType: JiraPlaybookScopeType;
  state?: InputMaybe<JiraPlaybookStateField>;
  steps: Array<UpdateJiraPlaybookStepInput>;
};

/** Input type for updating an existing label. */
export type UpdateJiraPlaybookLabelInput = {
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  property?: InputMaybe<JiraPlaybookLabelPropertyInput>;
  /** scopeId is projectId */
  scopeId?: InputMaybe<Scalars['String']['input']>;
  scopeType: JiraPlaybookScopeType;
};

/** Update: Mutation */
export type UpdateJiraPlaybookStateInput = {
  id: Scalars['ID']['input'];
  state: JiraPlaybookStateField;
};

export type UpdateJiraPlaybookStepInput = {
  description?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  ruleId?: InputMaybe<Scalars['String']['input']>;
  stepId?: InputMaybe<Scalars['ID']['input']>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
  type: JiraPlaybookStepType;
};

export type UpdateMetadataInput = {
  ari?: InputMaybe<Scalars['String']['input']>;
  extraProps?: InputMaybe<Array<PropInput>>;
  isPinned?: InputMaybe<Scalars['Boolean']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  productLink?: InputMaybe<Scalars['String']['input']>;
  thumbnailId?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateNoteInput = {
  backgroundColor?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  metadata?: InputMaybe<UpdateMetadataInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateOwnerInput = {
  contentId: Scalars['ID']['input'];
  ownerId: Scalars['String']['input'];
};

export type UpdatePageExtensionInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type UpdatePageInput = {
  extensions?: InputMaybe<Array<InputMaybe<UpdatePageExtensionInput>>>;
  pageId: Scalars['ID']['input'];
  restrictions?: InputMaybe<PageRestrictionsInput>;
};

export type UpdatePageOwnersInput = {
  ownerId: Scalars['ID']['input'];
  pageIDs: Array<InputMaybe<Scalars['Long']['input']>>;
};

export type UpdatePageStatusesInput = {
  pages: Array<InputMaybe<NestedPageInput>>;
  spaceKey: Scalars['String']['input'];
  targetContentState: ContentStateInput;
};

export type UpdatePermissionSubjectKeyInput = {
  permissionDisplayType: PermissionDisplayType;
  subjectId: Scalars['String']['input'];
};

export type UpdatePolarisCommentInput = {
  content?: InputMaybe<Scalars['JSON']['input']>;
  delete?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
};

export type UpdatePolarisIdeaInput = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  lastCommentsViewedTimestamp?: InputMaybe<Scalars['String']['input']>;
  lastInsightsViewedTimestamp?: InputMaybe<Scalars['String']['input']>;
};

export type UpdatePolarisIdeaTemplateInput = {
  color?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  emoji?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  project: Scalars['ID']['input'];
  /**
   * Template in ADF format.  See
   * https://developer.atlassian.com/platform/atlassian-document-format/
   */
  template?: InputMaybe<Scalars['JSON']['input']>;
  title: Scalars['String']['input'];
};

export type UpdatePolarisInsightInput = {
  description?: InputMaybe<Scalars['JSON']['input']>;
  snippets?: InputMaybe<Array<UpdatePolarisSnippetInput>>;
};

export type UpdatePolarisMatrixAxis = {
  dimension: Scalars['String']['input'];
  field: Scalars['ID']['input'];
  fieldOptions?: InputMaybe<Array<PolarisGroupValueInput>>;
  reversed?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UpdatePolarisMatrixConfig = {
  axes?: InputMaybe<Array<UpdatePolarisMatrixAxis>>;
};

export type UpdatePolarisPlayContribution = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  /**  the extent of the contribution (null=drop value) */
  comment?: InputMaybe<Scalars['ID']['input']>;
  /**  the comment (null=drop value, which is not permitted; delete the contribution if needed) */
  content?: InputMaybe<Scalars['JSON']['input']>;
};

export type UpdatePolarisPlayInput = {
  id: Scalars['ID']['input'];
  parameters?: InputMaybe<Scalars['JSON']['input']>;
};

export type UpdatePolarisSnippetInput = {
  /** Data in JSON format. It will be validated with JSON schema of Polaris Insights Data format. */
  data?: InputMaybe<Scalars['JSON']['input']>;
  deleteProperties?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * The client can specify either a specific snippet id, or an
   * oauthClientId.  In the latter case, we will create a snippet on
   * this data point (nee insight) if one doesn't exist already, and it
   * is an error for there to be more than one snippet with the same
   * oauthClientId.
   */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** OauthClientId of CaaS app */
  oauthClientId?: InputMaybe<Scalars['String']['input']>;
  setProperties?: InputMaybe<Scalars['JSON']['input']>;
  /** Snippet url that is source of data */
  url?: InputMaybe<Scalars['String']['input']>;
};

export type UpdatePolarisTimelineConfig = {
  dueDateField?: InputMaybe<Scalars['ID']['input']>;
  endTimestamp?: InputMaybe<Scalars['String']['input']>;
  mode?: InputMaybe<PolarisTimelineMode>;
  startDateField?: InputMaybe<Scalars['ID']['input']>;
  startTimestamp?: InputMaybe<Scalars['String']['input']>;
  summaryCardField?: InputMaybe<Scalars['ID']['input']>;
  todayMarker?: InputMaybe<PolarisTimelineTodayMarker>;
};

export type UpdatePolarisViewInput = {
  /**  how to apply color */
  boldColors?: InputMaybe<Scalars['Boolean']['input']>;
  colorBy?: InputMaybe<Scalars['ID']['input']>;
  /**  field to color by */
  colorStyle?: InputMaybe<PolarisColorStyle>;
  columnSize?: InputMaybe<PolarisColumnSize>;
  /**  groups filter configuration */
  connectionsFilter?: InputMaybe<Array<PolarisViewFilterInput>>;
  connectionsLayoutType?: InputMaybe<PolarisConnectionsLayout>;
  /**  view emoji */
  description?: InputMaybe<Scalars['JSON']['input']>;
  /**  the name of the view */
  emoji?: InputMaybe<Scalars['String']['input']>;
  enabledAutoSave?: InputMaybe<Scalars['Boolean']['input']>;
  /**  table column sizes per field */
  fieldRollups?: InputMaybe<Array<PolarisViewFieldRollupInput>>;
  /**  rollup type per field */
  fields?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**  a field to sort by */
  filter?: InputMaybe<Array<PolarisViewFilterInput>>;
  /**  columns filter configuration */
  filterGroups?: InputMaybe<Array<PolarisViewFilterGroupInput>>;
  /**  the table columns list of fields (table viz) or fields to show */
  groupBy?: InputMaybe<Scalars['ID']['input']>;
  /**  what field to group by (board viz) */
  groupValues?: InputMaybe<Array<PolarisGroupValueInput>>;
  /**  view filter congfiguration */
  groupsFilter?: InputMaybe<Array<PolarisViewFilterInput>>;
  /**  grouped filters configuration */
  hidden?: InputMaybe<Array<Scalars['ID']['input']>>;
  hideEmptyColumns?: InputMaybe<Scalars['Boolean']['input']>;
  hideEmptyGroups?: InputMaybe<Scalars['Boolean']['input']>;
  /**  description of the view */
  jql?: InputMaybe<Scalars['String']['input']>;
  /**  fields that are included in view but hidden */
  lastCommentsViewedTimestamp?: InputMaybe<Scalars['String']['input']>;
  layoutType?: InputMaybe<PolarisViewLayoutType>;
  matrixConfig?: InputMaybe<UpdatePolarisMatrixConfig>;
  /**  view to update, if this is an UPDATE operation */
  name?: InputMaybe<Scalars['String']['input']>;
  showConnectionsMatchingColumn?: InputMaybe<Scalars['Boolean']['input']>;
  showConnectionsMatchingGroup?: InputMaybe<Scalars['Boolean']['input']>;
  /**  what are the (ordered) vertical grouping values */
  sort?: InputMaybe<Array<PolarisSortFieldInput>>;
  sortMode?: InputMaybe<PolarisViewSortMode>;
  /**  just the user filtering part of the JQL */
  tableColumnSizes?: InputMaybe<Array<PolarisViewTableColumnSizeInput>>;
  timelineConfig?: InputMaybe<UpdatePolarisTimelineConfig>;
  /**  the JQL (sets filter and sorting) */
  userJql?: InputMaybe<Scalars['String']['input']>;
  /**  what are the (ordered) grouping values */
  verticalGroupBy?: InputMaybe<Scalars['ID']['input']>;
  /**  what field to vertical group by (board viz) */
  verticalGroupValues?: InputMaybe<Array<PolarisGroupValueInput>>;
  /**  connections filter configuration */
  verticalGroupsFilter?: InputMaybe<Array<PolarisViewFilterInput>>;
  view?: InputMaybe<Scalars['ID']['input']>;
  whiteboardConfig?: InputMaybe<UpdatePolarisWhiteboardConfig>;
};

export type UpdatePolarisViewRankInput = {
  container?: InputMaybe<Scalars['ID']['input']>;
  /**  new container if needed */
  rank: Scalars['Int']['input'];
};

export type UpdatePolarisViewSetInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  viewSet: Scalars['ID']['input'];
};

export type UpdatePolarisWhiteboardConfig = {
  id: Scalars['ID']['input'];
};

export type UpdateRelationInput = {
  relationName: RelationType;
  sourceKey: Scalars['String']['input'];
  sourceStatus?: InputMaybe<Scalars['String']['input']>;
  sourceType: RelationSourceType;
  sourceVersion?: InputMaybe<Scalars['Int']['input']>;
  targetKey: Scalars['String']['input'];
  targetStatus?: InputMaybe<Scalars['String']['input']>;
  targetType: RelationTargetType;
  targetVersion?: InputMaybe<Scalars['Int']['input']>;
};

export type UpdateSiteLookAndFeelInput = {
  backgroundColor?: InputMaybe<Scalars['String']['input']>;
  faviconFiles: Array<FaviconFileInput>;
  frontCoverState?: InputMaybe<GraphQlFrontCoverState>;
  highlightColor?: InputMaybe<Scalars['String']['input']>;
  resetFavicon?: InputMaybe<Scalars['Boolean']['input']>;
  resetSiteLogo?: InputMaybe<Scalars['Boolean']['input']>;
  showFrontCover?: InputMaybe<Scalars['Boolean']['input']>;
  showSiteName?: InputMaybe<Scalars['Boolean']['input']>;
  siteLogoFileStoreId?: InputMaybe<Scalars['ID']['input']>;
  siteName?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateSitePermissionInput = {
  anonymous?: InputMaybe<AnonymousWithPermissionsInput>;
  groups?: InputMaybe<Array<InputMaybe<GroupWithPermissionsInput>>>;
  unlicensedUser?: InputMaybe<UnlicensedUserWithPermissionsInput>;
  users?: InputMaybe<Array<InputMaybe<UserWithPermissionsInput>>>;
};

export type UpdateSpaceDefaultClassificationLevelInput = {
  classificationLevelId: Scalars['ID']['input'];
  id: Scalars['Long']['input'];
};

export type UpdateSpaceDetailsInput = {
  /** The new alias for the space. */
  alias?: InputMaybe<Scalars['String']['input']>;
  /** The full set of categories belonging to the space. */
  categories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** The new description as a string for the space. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The new content id as a string for the space's homepage. */
  homepagePageId?: InputMaybe<Scalars['Long']['input']>;
  /** The id of the target space to update. */
  id: Scalars['Long']['input'];
  /** The new name for the space. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The new owner for the space. Can be either a group or user. */
  owner?: InputMaybe<ConfluenceSpaceDetailsSpaceOwnerInput>;
  /** The new status as a string for the space. */
  status?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateSpacePermissionsInput = {
  spaceKey: Scalars['String']['input'];
  subjectPermissionDeltasList: Array<SubjectPermissionDeltas>;
};

export type UpdateSpacePermissionsInputV2 = {
  spaceId: Scalars['Long']['input'];
  subjectPermissionDeltasListV2: Array<SubjectPermissionDeltasV2>;
};

export type UpdateSpaceTypeSettingsInput = {
  spaceKey?: InputMaybe<Scalars['String']['input']>;
  spaceTypeSettings?: InputMaybe<SpaceTypeSettingsInput>;
};

export type UpdateTemplatePropertySetInput = {
  /** ID of template to create property for */
  templateId: Scalars['Long']['input'];
  /** Template properties */
  templatePropertySet: TemplatePropertySetInput;
};

export type UpdateUserInstallationRulesInput = {
  cloudId: Scalars['ID']['input'];
  rule: UserInstallationRuleValue;
};

export type UpdatedNestedPageOwnersInput = {
  ownerId: Scalars['ID']['input'];
  pages: Array<InputMaybe<NestedPageInput>>;
};

export type UserAuthTokenForExtensionInput = {
  /**
   * List of ARI's, this should be the same as passed to `InvokeExtensionInput`.
   * The most specific context is extracted and passed to outbound-auth to support
   * access narrowing (Tenant Isolation)
   *
   * *Important:* this should start with the most specific context as the
   * most specific extension will be the selected extension.
   */
  contextIds: Array<Scalars['ID']['input']>;
  extensionId: Scalars['ID']['input'];
};

/**  --------------------------------------------------------------------------------------------- */
export type UserInput = {
  booleanUserInput?: InputMaybe<BooleanUserInput>;
  numberUserInput?: InputMaybe<NumberUserInput>;
  stringUserInput?: InputMaybe<StringUserInput>;
};

export enum UserInstallationRuleValue {
  Allow = 'allow',
  Deny = 'deny'
}

export type UserPreferencesInput = {
  addUserSpaceNotifiedChangeBoardingOfExternalCollab?: InputMaybe<Scalars['String']['input']>;
  addUserSpaceNotifiedOfExternalCollab?: InputMaybe<Scalars['String']['input']>;
  confluenceEditorSettingsInput?: InputMaybe<ConfluenceEditorSettingsInput>;
  contextualEmojiOptOut?: InputMaybe<Scalars['Boolean']['input']>;
  endOfPageRecommendationsOptInStatus?: InputMaybe<Scalars['String']['input']>;
  feedRecommendedUserSettingsDismissTimestamp?: InputMaybe<Scalars['String']['input']>;
  feedTab?: InputMaybe<Scalars['String']['input']>;
  feedType?: InputMaybe<FeedType>;
  globalPageCardAppearancePreference?: InputMaybe<PagesDisplayPersistenceOption>;
  homePagesDisplayView?: InputMaybe<PagesDisplayPersistenceOption>;
  homeWidget?: InputMaybe<HomeWidgetInput>;
  isHomeOnboardingDismissed?: InputMaybe<Scalars['Boolean']['input']>;
  keyboardShortcutDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  missionControlFeatureDiscoverySuggestion?: InputMaybe<MissionControlFeatureDiscoverySuggestionInput>;
  missionControlMetricSuggestion?: InputMaybe<MissionControlMetricSuggestionInput>;
  missionControlOverview?: InputMaybe<MissionControlOverview>;
  nav4OptOut?: InputMaybe<Scalars['Boolean']['input']>;
  nextGenFeedOptInStatus?: InputMaybe<Scalars['String']['input']>;
  recentFilter?: InputMaybe<RecentFilter>;
  searchExperimentOptInStatus?: InputMaybe<Scalars['String']['input']>;
  shouldShowCardOnPageTreeHover?: InputMaybe<PageCardInPageTreeHoverPreference>;
  spacePagesDisplayView?: InputMaybe<SpacePagesDisplayView>;
  spacePagesSortView?: InputMaybe<SpacePagesSortView>;
  spaceViewsPersistence?: InputMaybe<SpaceViewsPersistence>;
  templateEntityFavouriteStatus?: InputMaybe<TemplateEntityFavouriteStatus>;
  theme?: InputMaybe<Scalars['String']['input']>;
  topNavigationOptedOut?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UserWithPermissionsInput = {
  accountId: Scalars['ID']['input'];
  operations: Array<InputMaybe<OperationCheckResultInput>>;
};

export enum UtsAlertRetriggerPolicy {
  /** Alert can be triggered multiple times */
  Always = 'ALWAYS',
  /** Alert triggers only once */
  Once = 'ONCE'
}

export enum UtsAlertState {
  /** Alert has been resolved or deactivated */
  Closed = 'CLOSED',
  /** Alert is currently active */
  Open = 'OPEN'
}

export type ValidateConvertPageToLiveEditInput = {
  adf: Scalars['String']['input'];
  contentId: Scalars['ID']['input'];
};

export type ValidatePageCopyInput = {
  /** ID of destination space */
  destinationSpaceId: Scalars['ID']['input'];
  /** ID of page being copied */
  pageId: Scalars['ID']['input'];
  /** Input params for validation of copying page restrictions */
  validatePageRestrictionsCopyInput?: InputMaybe<ValidatePageRestrictionsCopyInput>;
};

export type ValidatePageRestrictionsCopyInput = {
  includeChildren: Scalars['Boolean']['input'];
};

export enum VendorType {
  Internal = 'INTERNAL',
  ThirdParty = 'THIRD_PARTY'
}

export type VerifyComponentAutoPopulationField = {
  /** The ID of the component to verify the field for */
  componentId: Scalars['ID']['input'];
  /** The name of the field to verify */
  fieldId: Scalars['String']['input'];
  /** Verify as correct or incorrect */
  isCorrect: Scalars['Boolean']['input'];
  /** The value to verify */
  value: Scalars['String']['input'];
};

export type VirtualAgentAutoCloseConfigInput = {
  /** Message to show when User has abandoned the thread, and VA is pro-actively reaching out */
  autoCloseMessage?: InputMaybe<Scalars['String']['input']>;
};

export type VirtualAgentCsatConfigInput = {
  /** The message to show when the virtual agent is asking for CSAT */
  askForCSATMessage?: InputMaybe<Scalars['String']['input']>;
  /** Messages when the user has not provided feedback */
  noFeedbackProvidedMessage?: InputMaybe<Scalars['String']['input']>;
  /** The message to show when VA has received CSAT, and is asking for written feedback */
  requestAdditionalFeedbackMessage?: InputMaybe<Scalars['String']['input']>;
  /** Message when the user has provided feedback */
  thanksForFeedbackMessage?: InputMaybe<Scalars['String']['input']>;
};

export enum VirtualAgentConversationActionType {
  AiAnswered = 'AI_ANSWERED',
  Matched = 'MATCHED',
  Unhandled = 'UNHANDLED'
}

export enum VirtualAgentConversationChannel {
  HelpCenter = 'HELP_CENTER',
  JsmPortal = 'JSM_PORTAL',
  JsmWidget = 'JSM_WIDGET',
  MsTeams = 'MS_TEAMS',
  Slack = 'SLACK'
}

export enum VirtualAgentConversationCsatOptionType {
  CsatOption_1 = 'CSAT_OPTION_1',
  CsatOption_2 = 'CSAT_OPTION_2',
  CsatOption_3 = 'CSAT_OPTION_3',
  CsatOption_4 = 'CSAT_OPTION_4',
  CsatOption_5 = 'CSAT_OPTION_5'
}

export enum VirtualAgentConversationState {
  Closed = 'CLOSED',
  Escalated = 'ESCALATED',
  Open = 'OPEN',
  Resolved = 'RESOLVED'
}

export type VirtualAgentConversationsFilter = {
  /** Filter by action type(s) */
  actions?: InputMaybe<Array<VirtualAgentConversationActionType>>;
  /** Filter by channel */
  channels?: InputMaybe<Array<VirtualAgentConversationChannel>>;
  /** Filter by csat score(s) */
  csatOptions?: InputMaybe<Array<VirtualAgentConversationCsatOptionType>>;
  /** The end date of a period to filter conversations */
  endDate: Scalars['DateTime']['input'];
  /** The start date of a period to filter conversations */
  startDate: Scalars['DateTime']['input'];
  /** Filter by state(s) */
  states?: InputMaybe<Array<VirtualAgentConversationState>>;
};

export type VirtualAgentCreateChatChannelInput = {
  /** Specify whether the channel is triage channel or not */
  isTriageChannel: Scalars['Boolean']['input'];
  /** Specify whether the channel is virtual agent test channel or not */
  isVirtualAgentTestChannel: Scalars['Boolean']['input'];
};

/** Accepts input for creating a VirtualAgent Configuration. */
export type VirtualAgentCreateConfigurationInput = {
  /** Get the Virtual Agent's default request type id. */
  defaultJiraRequestTypeId?: InputMaybe<Scalars['String']['input']>;
  /** Whether AI answers is enabled */
  isAiResponsesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Configuration for escalation options offered to the user. */
  offerEscalationConfig?: InputMaybe<VirtualAgentOfferEscalationOptionsInput>;
  /** A configuration on the Virtual Agent which indicates if the Bot will reply to help seeker messages or not. */
  respondToQueries?: InputMaybe<Scalars['Boolean']['input']>;
};

export type VirtualAgentCreateIntentRuleProjectionInput = {
  /** Message that helpseekers use to confirm that this intent rule should be executed */
  confirmationMessage?: InputMaybe<Scalars['String']['input']>;
  /** The description of the intent */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the intent */
  name: Scalars['String']['input'];
  /** A list of question text to be created along with the intent */
  questions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Short message used by helpseekers to select this intent rule from a list of other intent rules */
  suggestionButtonText?: InputMaybe<Scalars['String']['input']>;
  /** Intent template id from which this intent is based on */
  templateId?: InputMaybe<Scalars['String']['input']>;
  /** The type of intent template from which this intent is based on */
  templateType?: InputMaybe<VirtualAgentIntentTemplateType>;
};

export type VirtualAgentFlowEditorAction = {
  /** type of the action */
  actionType: Scalars['String']['input'];
  /** payload of the action */
  payload: Scalars['JSON']['input'];
};

export type VirtualAgentFlowEditorActionInput = {
  /** stream of actions that need to performed on the flow editor */
  actions: Array<VirtualAgentFlowEditorAction>;
  /** Json representation of the flow editor */
  jsonRepresentation: Scalars['String']['input'];
};

export type VirtualAgentFlowEditorInput = {
  /** The group that the flow belongs to */
  group?: InputMaybe<Scalars['String']['input']>;
  /** Json representation of the flow editor */
  jsonRepresentation: Scalars['String']['input'];
  /** Display name of the flow editor */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Mutation schema/types for standard/common configs */
export type VirtualAgentGreetingConfigInput = {
  /** The greeting message to be displayed to the user. */
  greetingMessage?: InputMaybe<Scalars['String']['input']>;
};

/** Accepts input query to fetch Intent Rules */
export type VirtualAgentIntentRuleProjectionsFilter = {
  /** The Virtual Agent Configuration that should be used to filter Intent Rules */
  virtualAgentConfigurationId: Scalars['ID']['input'];
};

/** Statuses that an intent can be configured to have, affecting where it is surfaced to help-seekers */
export enum VirtualAgentIntentStatus {
  /** Surfaced to help-seekers in conversation channels, as well as visible to virtual agent admins in test mode */
  Live = 'LIVE',
  /** Not visible to help-seekers, but visible to virtual agent admins using test mode */
  TestOnly = 'TEST_ONLY'
}

export enum VirtualAgentIntentTemplateType {
  Discovered = 'DISCOVERED',
  Shared = 'SHARED',
  Standard = 'STANDARD'
}

export type VirtualAgentMatchIntentConfigInput = {
  /** Used in-case, the first rephrase try failed */
  askToRephraseAgainMessage?: InputMaybe<Scalars['String']['input']>;
  /** The message to show when the virtual agent is not able to find an intent */
  rephraseMessage?: InputMaybe<Scalars['String']['input']>;
  /** When there are multiple Intent matches found for a query */
  suggestMultipleIntentsMessage?: InputMaybe<Scalars['String']['input']>;
};

export type VirtualAgentOfferEscalationOptionsInput = {
  /** Whether 'raise a request' option is enabled while offering escalation. */
  isRaiseARequestEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether 'see related search results' option is enabled while offering escalation. */
  isSeeSearchResultsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether 'try asking another way' option is enabled while offering escalation. */
  isTryAskingAnotherWayEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type VirtualAgentUpdateAiAnswerForSlackChannelInput = {
  /** Specify whether ai answers is enabled on the channel */
  isAiResponsesChannel: Scalars['Boolean']['input'];
  /** Halp Id of the channel document */
  slackChannelId: Scalars['String']['input'];
};

export type VirtualAgentUpdateChatChannelInput = {
  /** Halp Id of the channel document */
  halpChannelId: Scalars['String']['input'];
  /** Specify whether smart answer is enabled on the channel */
  isAiResponsesChannel?: InputMaybe<Scalars['Boolean']['input']>;
  /** Specify whether the channel is connected to virtual agent or not */
  isVirtualAgentChannel: Scalars['Boolean']['input'];
};

/** Accepts input for updating an existing VirtualAgent Configuration. */
export type VirtualAgentUpdateConfigurationInput = {
  /** The ID of the default request type used when the virtual agent escalates and creates a Jira Service Management request */
  defaultJiraRequestTypeId?: InputMaybe<Scalars['String']['input']>;
  /** Whether AI answers is enabled */
  isAiResponsesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Configuration for escalation options offered to the user. */
  offerEscalationConfig?: InputMaybe<VirtualAgentOfferEscalationOptionsInput>;
  /** The configuration which determines if Virtual Agent will respond to Help Seeker queries. */
  respondToQueries?: InputMaybe<Scalars['Boolean']['input']>;
};

export type VirtualAgentUpdateIntentRuleProjectionInput = {
  /** Message that helpseekers use to confirm that this intent rule should be executed */
  confirmationMessage?: InputMaybe<Scalars['String']['input']>;
  /** A new description for the intent */
  description?: InputMaybe<Scalars['String']['input']>;
  /** A boolean flag which defines if an underlying Intent is enabled for this VirtualAgent or not */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the intent */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Short message used to represent this intent rule to helpseekers among a list of other intent rules */
  suggestionButtonText?: InputMaybe<Scalars['String']['input']>;
};

export type VirtualAgentUpdateIntentRuleProjectionQuestionsInput = {
  /** Questions to be added to the intent rule */
  addedQuestions?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Message that helpseekers use to confirm that this intent rule should be executed */
  confirmationMessage?: InputMaybe<Scalars['String']['input']>;
  /** Questions to be deleted */
  deletedQuestions?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The description for an intent */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the intent */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Short message used by helpseekers to select this intent rule from a list of other intent rules */
  suggestionButtonText?: InputMaybe<Scalars['String']['input']>;
  /** Questions to be updated */
  updatedQuestions?: InputMaybe<Array<VirtualAgentUpdatedQuestionInput>>;
};

export type VirtualAgentUpdatedQuestionInput = {
  /** Id of the question to be updated */
  id: Scalars['ID']['input'];
  /** Text of the question to be updated */
  question: Scalars['String']['input'];
};

export type WatchContentInput = {
  accountId?: InputMaybe<Scalars['String']['input']>;
  contentId: Scalars['ID']['input'];
  currentUser?: InputMaybe<Scalars['Boolean']['input']>;
  includeChildren?: InputMaybe<Scalars['Boolean']['input']>;
  shouldUnwatchAncestorWatchingChildren?: InputMaybe<Scalars['Boolean']['input']>;
};

export type WatchSpaceInput = {
  accountId?: InputMaybe<Scalars['String']['input']>;
  currentUser?: InputMaybe<Scalars['Boolean']['input']>;
  spaceId?: InputMaybe<Scalars['ID']['input']>;
  spaceKey?: InputMaybe<Scalars['String']['input']>;
};

export type WebTriggerUrlInput = {
  /** Id of the application */
  appId: Scalars['ID']['input'];
  /**
   * context in which function should run, usually a site context.
   * E.g.: ari:cloud:jira::site/{siteId}
   */
  contextId: Scalars['ID']['input'];
  /** Environment id of the application */
  envId: Scalars['ID']['input'];
  /** Web trigger module key */
  triggerKey: Scalars['String']['input'];
};

export enum WorkSuggestionsAction {
  Remove = 'REMOVE',
  Snooze = 'SNOOZE'
}

/** Input for the mutation operations (snooze and remove). */
export type WorkSuggestionsActionInput = {
  /** Cloud id */
  cloudId: Scalars['ID']['input'];
  /** Work Suggestion id */
  taskId: Scalars['String']['input'];
};

export enum WorkSuggestionsApprovalStatus {
  Approved = 'APPROVED',
  Needswork = 'NEEDSWORK',
  Unapproved = 'UNAPPROVED',
  Unknown = 'UNKNOWN'
}

export enum WorkSuggestionsAutoDevJobState {
  Cancelled = 'CANCELLED',
  CodeGenerating = 'CODE_GENERATING',
  CodeGenerationFail = 'CODE_GENERATION_FAIL',
  CodeGenerationReady = 'CODE_GENERATION_READY',
  CodeGenerationSuccess = 'CODE_GENERATION_SUCCESS',
  Created = 'CREATED',
  PlanGenerating = 'PLAN_GENERATING',
  PlanGenerationFail = 'PLAN_GENERATION_FAIL',
  PlanGenerationSuccess = 'PLAN_GENERATION_SUCCESS',
  PullrequestCreating = 'PULLREQUEST_CREATING',
  PullrequestCreationFail = 'PULLREQUEST_CREATION_FAIL',
  PullrequestCreationSuccess = 'PULLREQUEST_CREATION_SUCCESS',
  Unknown = 'UNKNOWN'
}

/** projectAri is always required, but sprintAri can also be specified */
export type WorkSuggestionsContextAri = {
  projectAri: Scalars['ID']['input'];
  sprintAri?: InputMaybe<Scalars['ID']['input']>;
};

export enum WorkSuggestionsEnvironmentType {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Staging = 'STAGING',
  Testing = 'TESTING',
  Unmapped = 'UNMAPPED'
}

export type WorkSuggestionsInput = {
  /** Limit to return the first X suggestions */
  first?: InputMaybe<Scalars['Int']['input']>;
  /** The target audience for the suggestions */
  targetAudience?: InputMaybe<WorkSuggestionsTargetAudience>;
};

/** Input for the mutation operation mergePullRequest. */
export type WorkSuggestionsMergePrActionInput = {
  /** Cloud id */
  cloudId: Scalars['ID']['input'];
  /** work suggestions id */
  taskId: Scalars['String']['input'];
};

/** Input for the mutation operation nudgePullRequestReviewers. */
export type WorkSuggestionsNudgePrActionInput = {
  /** Cloud id */
  cloudId: Scalars['ID']['input'];
  /** work suggestions id */
  taskId: Scalars['String']['input'];
};

/** Input for the mutation operations (save user profile). */
export type WorkSuggestionsSaveUserProfileInput = {
  /** Cloud id */
  cloudId: Scalars['ID']['input'];
  /** Persona */
  persona?: InputMaybe<WorkSuggestionsUserPersona>;
  /** Project ARIs */
  projectAris: Array<Scalars['ID']['input']>;
};

export enum WorkSuggestionsTargetAudience {
  /** The target audience for individual suggestions */
  Me = 'ME',
  /** The target audience for team suggestions */
  Team = 'TEAM'
}

/**
 * Persona for the user profile.
 * For example: DEVELOPER
 */
export enum WorkSuggestionsUserPersona {
  Developer = 'DEVELOPER'
}

/** The reason why an issue is included as a version candidate */
export enum WorkSuggestionsVersionCandidateIncludeReason {
  /** Issue is blocked by other issues in the version */
  IssueIsBlocked = 'ISSUE_IS_BLOCKED',
  /** Issue is blocking other issues in the version */
  IssueIsBlocking = 'ISSUE_IS_BLOCKING',
  /** Issue is a sibling to other issues in the version */
  IssueIsSibling = 'ISSUE_IS_SIBLING',
  /** Unknown reason for inclusion */
  Unknown = 'UNKNOWN'
}

export enum WorkSuggestionsVulnerabilityStatus {
  Closed = 'CLOSED',
  Ignored = 'IGNORED',
  Open = 'OPEN',
  Unknown = 'UNKNOWN'
}

export enum SourceBillingType {
  Ccp = 'CCP',
  Hams = 'HAMS'
}

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = { me: { user?:
      | { accountId: string, name: string, picture: any }
      | { accountId: string, name: string, picture: any }
      | { accountId: string, name: string, picture: any }
     | null } };

export type MarkAsReadMutationVariables = Exact<{
  notificationIDs: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type MarkAsReadMutation = { notifications?: { markNotificationsByIdsAsRead?: string | null } | null };

export type MarkAsUnreadMutationVariables = Exact<{
  notificationIDs: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type MarkAsUnreadMutation = { notifications?: { markNotificationsByIdsAsUnread?: string | null } | null };

export type RetrieveNotificationsByGroupIdQueryVariables = Exact<{
  groupId: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  readState?: InputMaybe<InfluentsNotificationReadState>;
}>;


export type RetrieveNotificationsByGroupIdQuery = { notifications?: { notificationGroup: { nodes: Array<{ notificationId: string, readState: InfluentsNotificationReadState }> } } | null };

export type GroupNotificationDetailsFragment = { notificationId: string, readState: InfluentsNotificationReadState };

export type MyNotificationsQueryVariables = Exact<{
  readState?: InputMaybe<InfluentsNotificationReadState>;
  flat?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
}>;


export type MyNotificationsQuery = { notifications?: { unseenNotificationCount: number, notificationFeed: { pageInfo: { hasNextPage: boolean }, nodes: Array<{ groupId: string, groupSize: number, additionalActors: Array<{ displayName?: string | null, avatarURL?: string | null }>, headNotification: { notificationId: string, timestamp: any, readState: InfluentsNotificationReadState, category: InfluentsNotificationCategory, content: { type: string, message: string, url?: string | null, entity?: { title?: string | null, iconUrl?: string | null, url?: string | null } | null, path?: Array<{ title?: string | null, iconUrl?: string | null, url?: string | null }> | null, actor: { displayName?: string | null, avatarURL?: string | null } }, analyticsAttributes?: Array<{ key?: string | null, value?: string | null }> | null } }> } } | null };

export type AtlassianNotificationFragment = { groupId: string, groupSize: number, additionalActors: Array<{ displayName?: string | null, avatarURL?: string | null }>, headNotification: { notificationId: string, timestamp: any, readState: InfluentsNotificationReadState, category: InfluentsNotificationCategory, content: { type: string, message: string, url?: string | null, entity?: { title?: string | null, iconUrl?: string | null, url?: string | null } | null, path?: Array<{ title?: string | null, iconUrl?: string | null, url?: string | null }> | null, actor: { displayName?: string | null, avatarURL?: string | null } }, analyticsAttributes?: Array<{ key?: string | null, value?: string | null }> | null } };

export type AtlassianHeadNotificationFragment = { notificationId: string, timestamp: any, readState: InfluentsNotificationReadState, category: InfluentsNotificationCategory, content: { type: string, message: string, url?: string | null, entity?: { title?: string | null, iconUrl?: string | null, url?: string | null } | null, path?: Array<{ title?: string | null, iconUrl?: string | null, url?: string | null }> | null, actor: { displayName?: string | null, avatarURL?: string | null } }, analyticsAttributes?: Array<{ key?: string | null, value?: string | null }> | null };

export type RetrieveCloudIDsForHostnamesQueryVariables = Exact<{
  hostNames: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type RetrieveCloudIDsForHostnamesQuery = { tenantContexts?: Array<{ cloudId?: string | null, hostName?: string | null } | null> | null };

export type MarkGroupAsReadMutationVariables = Exact<{
  groupId: Scalars['String']['input'];
}>;


export type MarkGroupAsReadMutation = { notifications?: { markNotificationsByGroupIdAsRead?: string | null } | null };

export type MarkGroupAsUnreadMutationVariables = Exact<{
  groupId: Scalars['String']['input'];
}>;


export type MarkGroupAsUnreadMutation = { notifications?: { markNotificationsByGroupIdAsUnread?: string | null } | null };

export type RetrieveJiraProjectTypesQueryVariables = Exact<{
  cloudId: Scalars['ID']['input'];
  keys: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type RetrieveJiraProjectTypesQuery = { jira?: { issuesByKey?: Array<{ key: string, summary?: string | null, projectField?: { project?: { name: string, projectTypeName?: string | null, projectType?: JiraProjectType | null } | null } | null } | null> | null } | null };

export class TypedDocumentString<TResult, TVariables>
  extends String
  implements DocumentTypeDecoration<TResult, TVariables>
{
  __apiType?: NonNullable<DocumentTypeDecoration<TResult, TVariables>['__apiType']>;
  private value: string;
  public __meta__?: Record<string, any> | undefined;

  constructor(value: string, __meta__?: Record<string, any> | undefined) {
    super(value);
    this.value = value;
    this.__meta__ = __meta__;
  }

  override toString(): string & DocumentTypeDecoration<TResult, TVariables> {
    return this.value;
  }
}
export const GroupNotificationDetailsFragmentDoc = new TypedDocumentString(`
    fragment GroupNotificationDetails on InfluentsNotificationItem {
  notificationId
  readState
}
    `, {"fragmentName":"GroupNotificationDetails"}) as unknown as TypedDocumentString<GroupNotificationDetailsFragment, unknown>;
export const AtlassianHeadNotificationFragmentDoc = new TypedDocumentString(`
    fragment AtlassianHeadNotification on InfluentsNotificationItem {
  notificationId
  timestamp
  readState
  category
  content {
    type
    message
    url
    entity {
      title
      iconUrl
      url
    }
    path {
      title
      iconUrl
      url
    }
    actor {
      displayName
      avatarURL
    }
  }
  analyticsAttributes {
    key
    value
  }
}
    `, {"fragmentName":"AtlassianHeadNotification"}) as unknown as TypedDocumentString<AtlassianHeadNotificationFragment, unknown>;
export const AtlassianNotificationFragmentDoc = new TypedDocumentString(`
    fragment AtlassianNotification on InfluentsNotificationHeadItem {
  groupId
  groupSize
  additionalActors {
    displayName
    avatarURL
  }
  headNotification {
    ...AtlassianHeadNotification
  }
}
    fragment AtlassianHeadNotification on InfluentsNotificationItem {
  notificationId
  timestamp
  readState
  category
  content {
    type
    message
    url
    entity {
      title
      iconUrl
      url
    }
    path {
      title
      iconUrl
      url
    }
    actor {
      displayName
      avatarURL
    }
  }
  analyticsAttributes {
    key
    value
  }
}`, {"fragmentName":"AtlassianNotification"}) as unknown as TypedDocumentString<AtlassianNotificationFragment, unknown>;
export const MeDocument = new TypedDocumentString(`
    query Me {
  me {
    user {
      accountId
      name
      picture
    }
  }
}
    `) as unknown as TypedDocumentString<MeQuery, MeQueryVariables>;
export const MarkAsReadDocument = new TypedDocumentString(`
    mutation MarkAsRead($notificationIDs: [String!]!) {
  notifications {
    markNotificationsByIdsAsRead(ids: $notificationIDs)
  }
}
    `) as unknown as TypedDocumentString<MarkAsReadMutation, MarkAsReadMutationVariables>;
export const MarkAsUnreadDocument = new TypedDocumentString(`
    mutation MarkAsUnread($notificationIDs: [String!]!) {
  notifications {
    markNotificationsByIdsAsUnread(ids: $notificationIDs)
  }
}
    `) as unknown as TypedDocumentString<MarkAsUnreadMutation, MarkAsUnreadMutationVariables>;
export const RetrieveNotificationsByGroupIdDocument = new TypedDocumentString(`
    query RetrieveNotificationsByGroupId($groupId: String!, $first: Int, $readState: InfluentsNotificationReadState) {
  notifications {
    notificationGroup(
      groupId: $groupId
      first: $first
      filter: {readStateFilter: $readState}
    ) {
      nodes {
        ...GroupNotificationDetails
      }
    }
  }
}
    fragment GroupNotificationDetails on InfluentsNotificationItem {
  notificationId
  readState
}`) as unknown as TypedDocumentString<RetrieveNotificationsByGroupIdQuery, RetrieveNotificationsByGroupIdQueryVariables>;
export const MyNotificationsDocument = new TypedDocumentString(`
    query MyNotifications($readState: InfluentsNotificationReadState, $flat: Boolean = true, $first: Int) {
  notifications {
    unseenNotificationCount
    notificationFeed(
      flat: $flat
      first: $first
      filter: {readStateFilter: $readState}
    ) {
      pageInfo {
        hasNextPage
      }
      nodes {
        ...AtlassianNotification
      }
    }
  }
}
    fragment AtlassianNotification on InfluentsNotificationHeadItem {
  groupId
  groupSize
  additionalActors {
    displayName
    avatarURL
  }
  headNotification {
    ...AtlassianHeadNotification
  }
}
fragment AtlassianHeadNotification on InfluentsNotificationItem {
  notificationId
  timestamp
  readState
  category
  content {
    type
    message
    url
    entity {
      title
      iconUrl
      url
    }
    path {
      title
      iconUrl
      url
    }
    actor {
      displayName
      avatarURL
    }
  }
  analyticsAttributes {
    key
    value
  }
}`) as unknown as TypedDocumentString<MyNotificationsQuery, MyNotificationsQueryVariables>;
export const RetrieveCloudIDsForHostnamesDocument = new TypedDocumentString(`
    query RetrieveCloudIDsForHostnames($hostNames: [String!]!) {
  tenantContexts(hostNames: $hostNames) {
    cloudId
    hostName
  }
}
    `) as unknown as TypedDocumentString<RetrieveCloudIDsForHostnamesQuery, RetrieveCloudIDsForHostnamesQueryVariables>;
export const MarkGroupAsReadDocument = new TypedDocumentString(`
    mutation MarkGroupAsRead($groupId: String!) {
  notifications {
    markNotificationsByGroupIdAsRead(groupId: $groupId)
  }
}
    `) as unknown as TypedDocumentString<MarkGroupAsReadMutation, MarkGroupAsReadMutationVariables>;
export const MarkGroupAsUnreadDocument = new TypedDocumentString(`
    mutation MarkGroupAsUnread($groupId: String!) {
  notifications {
    markNotificationsByGroupIdAsUnread(groupId: $groupId)
  }
}
    `) as unknown as TypedDocumentString<MarkGroupAsUnreadMutation, MarkGroupAsUnreadMutationVariables>;
export const RetrieveJiraProjectTypesDocument = new TypedDocumentString(`
    query RetrieveJiraProjectTypes($cloudId: ID!, $keys: [String!]!) {
  jira {
    issuesByKey(cloudId: $cloudId, keys: $keys) {
      key
      summary
      projectField {
        project {
          name
          projectTypeName
          projectType
        }
      }
    }
  }
}
    `) as unknown as TypedDocumentString<RetrieveJiraProjectTypesQuery, RetrieveJiraProjectTypesQueryVariables>;